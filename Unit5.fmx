object Form5: TForm5
  Left = 0
  Top = 0
  Caption = 'Form5'
  ClientHeight = 480
  ClientWidth = 640
  Fill.Color = xFF262626
  Fill.Kind = Solid
  StyleBook = StyleBook
  FormFactor.Width = 320
  FormFactor.Height = 480
  FormFactor.Devices = [Desktop]
  OnCreate = FormCreate
  OnDestroy = FormDestroy
  DesignerMasterStyle = 0
  object Memo1: TMemo
    Touch.InteractiveGestures = [Pan, LongTap, DoubleTap]
    DataDetectorTypes = []
    Lines.Strings = (
      '{*******************************************************}'
      '{                                                       }'
      '{           CodeGear Delphi Runtime Library             }'
      '{                                                       }'
      '{ Copyright(c) 1995-2023 Embarcadero Technologies, Inc. }'
      '{              All rights reserved                      }'
      '{                                                       }'
      '{   Copyright and license exceptions noted in source    }'
      '{                                                       }'
      '{*******************************************************}'
      ''
      'unit System; { Predefined constants, types, procedures, }'
      '             { and functions (such as True, Integer, or }'
      '             { Writeln) do not have actual declarations.}'
      '             { Instead they are built into the compiler }'
      '             { and are treated as if they were declared }'
      '             { at the beginning of the System unit.     }'
      ''
      '{$H+,I-,R-,O+,W-}'
      '{$WARN SYMBOL_PLATFORM OFF}'
      '{$WARN SYMBOL_DEPRECATED OFF}'
      '{$WARN UNSAFE_TYPE OFF}'
      '{$WARN IMMUTABLE_STRINGS OFF}'
      '{$WARN UNSAFE_VOID_POINTER OFF}'
      ''
      ''
      '{ L- should never be specified.'
      ''
      '  The IDE needs to find DebugHook (through the C++'
      '  compiler sometimes) for integrated debugging to'
      '  function properly.'
      ''
      '  ILINK will generate debug info for DebugHook if'
      '  the object module has not been compiled with debug info.'
      ''
      '  ILINK will not generate debug info for DebugHook if'
      '  the object module has been compiled with debug info.'
      ''
      '  Thus, the Pascal compiler must be responsible for'
      '  generating the debug information for that symbol'
      '  when a debug-enabled object file is produced.'
      '}'
      ''
      'interface'
      ''
      '// PUREPASCAL'
      '// X86ASMRTL'
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      '  {$DEFINE X86ASMRTL}'
      '{$ELSE}'
      '  {$DEFINE PUREPASCAL}'
      '{$ENDIF}'
      ''
      '// STACK_BASED_EXCEPTIONS'
      '// PC_MAPPED_EXCEPTIONS'
      '// TABLE_BASED_EXCEPTIONS'
      '// SJLJ_BASED_EXCEPTIONS'
      '// ZCX_BASED_EXCEPTIONS'
      '// ZCX_BASED_EXCEPTIONS_MACOS'
      '{$IFNDEF PC_MAPPED_EXCEPTIONS}'
      '  {$IF defined(ANDROID)}'
      '    {$DEFINE ZCX_BASED_EXCEPTIONS}'
      '  {$ELSEIF defined(MACOS)}'
      '    {$IF defined(CPUARM32)}'
      '      {$DEFINE SJLJ_BASED_EXCEPTIONS}'
      '    {$ELSEIF defined(CPUARM64)}'
      '      {$DEFINE ZCX_BASED_EXCEPTIONS_MACOS}'
      '    {$ELSEIF defined(CPUX64)}'
      '      {$DEFINE ZCX_BASED_EXCEPTIONS_MACOS}'
      '    {$ENDIF}'
      '  {$ELSEIF defined(MSWINDOWS)}'
      '    {$IFDEF EXTERNALLINKER}'
      '      {$DEFINE ZCX_BASED_EXCEPTIONS}'
      '    {$ELSE}'
      '      {$IF defined(CPUX86)}'
      '        {$DEFINE STACK_BASED_EXCEPTIONS}'
      '      {$ELSEIF defined(CPUX64)}'
      '        {$DEFINE TABLE_BASED_EXCEPTIONS}'
      '      {$ELSE}'
      '        {$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '      {$ENDIF}'
      '    {$ENDIF !EXTERNALLINKER}'
      '  {$ELSEIF defined(LINUX)}'
      '    {$IFDEF EXTERNALLINKER}'
      '      {$DEFINE ZCX_BASED_EXCEPTIONS}'
      '    {$ELSE}'
      '      {$DEFINE PC_MAPPED_EXCEPTIONS}'
      '    {$ENDIF}'
      '  {$ELSE}'
      '    {$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '  {$ENDIF}'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      ''
      '// USE_LIBICU'
      '{$IFDEF ANDROID}'
      '  {$DEFINE USE_LIBICU}'
      '{$ENDIF ANDROID}'
      '{$IFDEF LINUX}'
      '  {$DEFINE USE_LIBICU}'
      '{$ENDIF LINUX}'
      ''
      ''
      '// EXTENDEDHAS10BYTES'
      '// EXTENDEDIS16BYTES'
      '// EXTENDEDIS12BYTES'
      '// EXTENDEDIS10BYTES'
      '// EXTENDEDIS8BYTES'
      '{$IF SizeOf(Extended) >= 10} // 10,12,16'
      '  {$DEFINE  EXTENDEDHAS10BYTES}'
      '{$ENDIF}'
      '{$IF SizeOf(Extended) = 16}'
      '  {$DEFINE EXTENDEDIS16BYTES}'
      '{$ELSEIF SizeOf(Extended) = 12}'
      '  {$DEFINE EXTENDEDIS12BYTES}'
      '{$ELSEIF SizeOf(Extended) = 10}'
      '  {$DEFINE EXTENDEDIS10BYTES}'
      '{$ELSEIF SizeOf(Extended) = 8}'
      '  {$DEFINE EXTENDEDIS8BYTES}'
      '{$ELSE}'
      '  {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '{$ENDIF}'
      ''
      '{$IFDEF ARITH_PUREPASCAL}'
      '  {$IFDEF CPUX86}'
      '        {$DEFINE ARITH_PUREPASCAL_EXT80}'
      '  {$ENDIF CPUX86}'
      '  {$IFDEF CPUX64}'
      '    {$IFDEF MSWINDOWS}'
      '        {$DEFINE ARITH_PUREPASCAL_EXT64}'
      '    {$ENDIF MSWINDOWS}'
      '    {$IFDEF LINUX}'
      '        {$DEFINE ARITH_USE_LIBM}'
      '    {$ENDIF LINUX}'
      '  {$ENDIF CPUX64}'
      '  {$IFDEF CPUARM}'
      '        {$DEFINE ARITH_USE_LIBM}'
      '  {$ENDIF CPUARM}'
      '{$ELSE !ARITH_PUREPASCAL}'
      '  {$IFDEF CPUX86}'
      '    {$IFDEF ASSEMBLER}'
      '        {$DEFINE ARITH_X32_FPU}'
      '    {$ELSE !ASSEMBLER}'
      '      {$IFDEF EXTENDEDHAS10BYTES}'
      '        {$DEFINE ARITH_PUREPASCAL_EXT80}'
      '      {$ELSE !EXTENDEDHAS10BYTES}'
      '        {$DEFINE ARITH_USE_LIBM}'
      '      {$ENDIF !EXTENDEDHAS10BYTES}'
      '    {$ENDIF !ASSEMBLER}'
      '  {$ENDIF CPUX86}'
      '  {$IFDEF CPUX64}'
      '    {$IF defined(ASSEMBLER) and defined(MSWINDOWS)}'
      '      {$DEFINE ARITH_X64_SSE}'
      '    {$ELSEIF defined(OSX) or defined(IOSSIMULATOR)}'
      '      {$DEFINE ARITH_PUREPASCAL_EXT80}'
      '      {$DEFINE ARITH_USE_LIBM}'
      '    {$ELSE}'
      '      {$IFDEF EXTENDEDHAS10BYTES}'
      '        {$DEFINE ARITH_PUREPASCAL_EXT80}'
      '      {$ELSE !EXTENDEDHAS10BYTES}'
      '        {$DEFINE ARITH_PUREPASCAL_EXT64}'
      '      {$ENDIF !EXTENDEDHAS10BYTES}'
      '    {$ENDIF}'
      '    {$IF     defined(LINUX)}'
      '        {$DEFINE ARITH_USE_LIBM}'
      '    {$ELSEIF defined(MACOS)}'
      '        {$DEFINE ARITH_USE_LIBM}'
      '    {$ENDIF}'
      '  {$ENDIF CPUX64}'
      '  {$IFDEF CPUARM}'
      
        '    {$IF defined(IOS) or defined(OSX) or defined(ANDROID) or def' +
        'ined(LINUX)}'
      '      {$DEFINE ARITH_USE_LIBM}'
      '    {$ELSE}'
      '      {$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '    {$ENDIF}'
      '  {$ENDIF CPUARM}'
      '{$ENDIF !ARITH_PUREPASCAL}'
      ''
      ''
      ''
      
        '(* You can use RTLVersion in $IF expressions to test the runtime' +
        ' library'
      '  version level independently of the compiler version level.'
      
        '  Example:  {$IF RTLVersion >= 16.2} ... {$ENDIF}               ' +
        '   *)'
      ''
      'const'
      '  RTLVersion = 35.00;'
      '  RTLVersion111 = True;'
      '  RTLVersion112 = True;'
      '  RTLVersion113 = True;'
      ' {$HPPEMIT '#39'#define RTLVersionC 3500'#39'}'
      ' {$HPPEMIT '#39'#define RTLVersion111C'#39'}'
      ' {$HPPEMIT '#39'#define RTLVersion112C'#39'}'
      ' {$HPPEMIT '#39'#define RTLVersion113C'#39'}'
      ''
      
        '{$IF (Defined(NEXTGEN) or defined(ANDROID)) and Defined(EMBEDDED' +
        ')}'
      '  Embedded = True;'
      '{$ENDIF}'
      ''
      '{$EXTERNALSYM CompilerVersion}'
      ''
      '(*'
      'const'
      '  CompilerVersion = 0.0;'
      ''
      '  CompilerVersion is assigned a value by the compiler when'
      
        '  the system unit is compiled.  It indicates the revision level ' +
        'of the'
      
        '  compiler features / language syntax, which may advance indepen' +
        'dently of'
      
        '  the RTLVersion.  CompilerVersion can be tested in $IF expressi' +
        'ons and'
      
        '  should be used instead of testing for the VERxxx conditional d' +
        'efine.'
      
        '  Always test for greater than or less than a known revision lev' +
        'el.'
      '  It'#39's a bad idea to test for a specific revision level.'
      '*)'
      ''
      '{$IFDEF DECLARE_GPL}'
      
        '(* The existence of the GPL symbol indicates that the System uni' +
        't'
      
        '  and the rest of the Delphi runtime library were compiled for u' +
        'se'
      
        '  and distribution under the terms of the GNU General Public Lic' +
        'ense (GPL).'
      '  Under the terms of the GPL, all applications compiled with the'
      
        '  GPL version of the Delphi runtime library must also be distrib' +
        'uted'
      '  under the terms of the GPL.'
      '  For more information about the GNU GPL, see'
      '  http://www.gnu.org/copyleft/gpl.html'
      ''
      '  The GPL symbol does not exist in the Delphi runtime library'
      '  purchased for commercial/proprietary software development.'
      ''
      
        '  If your source code needs to know which licensing model it is ' +
        'being'
      '  compiled into, you can use {$IF DECLARED(GPL)}...{$ENDIF} to'
      '  test for the existence of the GPL symbol.  The value of the'
      '  symbol itself is not significant.   *)'
      ''
      'const'
      '  GPL = True;'
      '{$ENDIF}'
      ''
      '//{$IF (DEFINED(WIN32) or DEFINED(MACOS32)) and DEFINED(CPUX86)}'
      '{$IF NOT (DEFINED(WIN64) or DEFINED(EXTERNALLINKER))}'
      '{$DEFINE MANGLE_BCC32}'
      '{$ENDIF}'
      ''
      
        '//{$IF not ((DEFINED(WIN32) or DEFINED(MACOS32) or DEFINED(ANDRO' +
        'ID)))}'
      '{$IF DEFINED(WIN64) or DEFINED(EXTERNALLINKER)}'
      '{'
      ' C++ ABI support a'#39'la the Itanium C++ ABI.'
      '}'
      '{$DEFINE CPP_ABI_SUPPORT}'
      '{$ENDIF}'
      ''
      '{$IF SizeOf(LongInt) = 8}'
      '  {$DEFINE LONGINT64}'
      '  {$DEFINE LONGINTISCPPLONG}'
      '{$ENDIF}'
      ''
      '{.$DEFINE MANAGED_RECORD}'
      ''
      '{ Delphi built-in types for .hpp/.obj support }'
      '{   Most of built-in types are defined in sysmac.h }'
      
        '{   Pointer types should be mangled by the compiler for constnes' +
        's}'
      
        '{$EXTERNALSYM Boolean     '#39'bool'#39'             } {$OBJTYPENAME Boo' +
        'lean    '#39'Bo'#39'  '#39'Gb'#39'}'
      
        '{$NODEFINE    ShortInt    '#39'Int8'#39'             } {$OBJTYPENAME Sho' +
        'rtInt   '#39'Bzc'#39' '#39'Ga'#39'} { signed char }'
      
        '{-EXTERNALSYM ShortInt    '#39'signed char'#39'      } {-OBJTYPENAME Sho' +
        'rtInt   '#39'Bzc'#39' '#39'Ga'#39'}'
      
        '{$EXTERNALSYM SmallInt    '#39'short'#39'            } {$OBJTYPENAME Sma' +
        'llInt   '#39'Bs'#39'  '#39'Gs'#39'}'
      
        '{$EXTERNALSYM Integer     '#39'int'#39'              } {$OBJTYPENAME Int' +
        'eger    '#39'Bi'#39'  '#39'Gi'#39'}'
      
        '{$NODEFINE    Byte        '#39'Byte'#39'             } {$OBJTYPENAME Byt' +
        'e       '#39'Buc'#39' '#39'Gh'#39'} { unsigned char }'
      
        '{$NODEFINE    Word        '#39'Word'#39'             } {$OBJTYPENAME Wor' +
        'd       '#39'Bus'#39' '#39'Gt'#39'} { unsigned short }'
      
        '{$EXTERNALSYM Cardinal    '#39'unsigned'#39'         } {$OBJTYPENAME Car' +
        'dinal   '#39'Bui'#39' '#39'Gj'#39'}'
      
        '{$EXTERNALSYM Int64       '#39'__int64'#39'          } {$OBJTYPENAME Int' +
        '64      '#39'Bj'#39'  '#39'Gx'#39'}'
      
        '{$EXTERNALSYM UInt64      '#39'unsigned __int64'#39' } {$OBJTYPENAME UIn' +
        't64     '#39'Buj'#39' '#39'Gy'#39'}'
      '{$IF defined(WEAK_NATIVEINT)}'
      '{$EXTERNALSYM NativeInt   '#39'NativeInt'#39'        }'
      '{$EXTERNALSYM NativeUInt  '#39'NativeUInt'#39'       }'
      '{$ELSE not WEAK_NATIVEINT}'
      '{$IF defined(EXTERNALLINKER)}'
      '{$EXTERNALSYM NativeInt   '#39'NativeInt'#39'        }'
      '{$EXTERNALSYM NativeUInt  '#39'NativeUInt'#39'       }'
      '{$ELSE}'
      '{$IFDEF WIN64}'
      
        '{$EXTERNALSYM NativeInt   '#39'NativeInt'#39'        } {$OBJTYPENAME Nat' +
        'iveInt  '#39'Bj'#39'  '#39'Gx'#39'}'
      
        '{$EXTERNALSYM NativeUInt  '#39'NativeUInt'#39'       } {$OBJTYPENAME Nat' +
        'iveUInt '#39'Buj'#39' '#39'Gy'#39'}'
      '{$ELSE}'
      
        '{$EXTERNALSYM NativeInt   '#39'NativeInt'#39'        } {$OBJTYPENAME Nat' +
        'iveInt  '#39'Bi'#39'  '#39'Gi'#39'}'
      
        '{$EXTERNALSYM NativeUInt  '#39'NativeUInt'#39'       } {$OBJTYPENAME Nat' +
        'iveUInt '#39'Bui'#39' '#39'Gj'#39'}'
      '{$ENDIF}'
      '{$ENDIF}'
      '{$ENDIF not WEAK_NATIVEINT}'
      
        '{$EXTERNALSYM Single      '#39'float'#39'            } {$OBJTYPENAME Sin' +
        'gle     '#39'Bf'#39'  '#39'Gf'#39'}'
      
        '{$EXTERNALSYM Double      '#39'double'#39'           } {$OBJTYPENAME Dou' +
        'ble     '#39'Bd'#39'  '#39'Gd'#39'}'
      
        '{$NODEFINE    Extended    '#39'Extended'#39'         } {$OBJTYPENAME Ext' +
        'ended   '#39'Bg'#39'  '#39'Ge'#39'} { long double }'
      
        '{$NODEFINE    Currency    '#39'Currency'#39'    '#39'CurrencyBase'#39'    } {$OB' +
        'JTYPENAME Currency    '#39'NCurrency'#39'}'
      
        '{$NODEFINE    Comp        '#39'Comp'#39'        '#39'CompBase'#39'        } {$OB' +
        'JTYPENAME Comp        '#39'NComp'#39'}'
      
        '{$EXTERNALSYM Real        '#39'double'#39'                        } {$OB' +
        'JTYPENAME Real        '#39'Bd'#39' '#39'Gd'#39'}'
      '{$IFDEF NEXTGEN}'
      '{$NODEFINE    _ShortString '#39'ShortString'#39' '#39'ShortStringBase'#39' }'
      '{$NODEFINE    _OpenString}'
      '{$ELSE}'
      
        '{$NODEFINE    ShortString '#39'ShortString'#39' '#39'ShortStringBase'#39' } {$IF' +
        'DEF MANGLE_BCC32}{$OBJTYPENAME ShortString '#39'N%SmallString$uc$i25' +
        '5$%'#39'}{$ELSE}{$OBJTYPENAME ShortString '#39'NSmallString:GILh255EE'#39'}{' +
        '$ENDIF}'
      
        '{$NODEFINE    OpenString  '#39'OpenString'#39'       } {$OBJTYPENAME Ope' +
        'nString '#39'Bxpc'#39' '#39'GPc'#39'} { char * const }'
      '{$ENDIF}'
      
        '{$NODEFINE    File        '#39'file'#39'             } {$OBJTYPENAME Fil' +
        'e       '#39'Nfile'#39'}'
      
        '{$NODEFINE    Text        '#39'TextFile'#39'         } {$OBJTYPENAME Tex' +
        't       '#39'NTextfile'#39'}'
      
        '{$NODEFINE    ByteBool    '#39'ByteBool'#39'         } {$OBJTYPENAME Byt' +
        'eBool   '#39'Buc'#39' '#39'Gh'#39'} { unsigned char }'
      
        '{$NODEFINE    WordBool    '#39'WordBool'#39'         } {$OBJTYPENAME Wor' +
        'dBool   '#39'Bus'#39' '#39'Gt'#39'} { unsigned short }'
      
        '{$NODEFINE    LongBool    '#39'LongBool'#39'         } {$OBJTYPENAME Lon' +
        'gBool   '#39'Bi'#39'  '#39'Gi'#39'} { int } { from windef.h }'
      '{$NODEFINE    Real48      } { not supported in C++ }'
      '{$NODEFINE    Extended80  } { not supported in C++ }'
      '{$EXTERNALSYM Pointer     '#39'void *'#39'    }'
      '{$NODEFINE    PWideChar   '#39'WideChar *'#39'}'
      '{$IFDEF NEXTGEN}'
      '{$EXTERNALSYM _PAnsiChar  '#39'char *'#39'    }'
      '{$ELSE}'
      '{$EXTERNALSYM PAnsiChar   '#39'char *'#39'    }'
      '{$ENDIF}'
      '{$NODEFINE    Variant     } { defined in sysvari.h }'
      '{$NODEFINE    OleVariant  } { defined in sysvari.h }'
      '{$IFDEF LONGINTISCPPLONG}'
      
        '{$EXTERNALSYM LongInt     '#39'long'#39'             } {$OBJTYPENAME Lon' +
        'gInt    '#39'Bl'#39'  '#39'Gl'#39'}'
      
        '{$EXTERNALSYM LongWord    '#39'unsigned long'#39'    } {$OBJTYPENAME Lon' +
        'gWord   '#39'Bul'#39' '#39'Gm'#39'}'
      '{$ELSE}'
      
        '{$NODEFINE    LongInt     } { alias of Integer if 32-bit or LP64' +
        '  }'
      
        '{$NODEFINE    LongWord    } { alias of Cardinal if 32-bit or LP6' +
        '4 }'
      '{$ENDIF}'
      '{$NODEFINE    TextFile    } { alias of Text        }'
      '{$IFDEF NEXTGEN}'
      
        '{$EXTERNALSYM _AnsiChar    '#39'char'#39'          } {$OBJTYPENAME _Ansi' +
        'Char '#39'Bc'#39'  '#39'Gc'#39'}'
      '{$ELSE}'
      
        '{$EXTERNALSYM AnsiChar     '#39'char'#39'          } {$OBJTYPENAME AnsiC' +
        'har '#39'Bc'#39'  '#39'Gc'#39'}'
      '{$ENDIF}'
      '{$IFDEF MSWINDOWS}'
      
        '  {$NODEFINE  Char         '#39'WideChar'#39'      } {$OBJTYPENAME Char ' +
        '    '#39'Bb'#39'  '#39'Gw'#39'}  { wchar_t }'
      '{$ELSE}'
      
        '  {$NODEFINE  Char         '#39'WideChar'#39'      } {$OBJTYPENAME Char ' +
        '    '#39'BCs'#39' '#39'Ds'#39'} { char16_t }'
      '{$ENDIF}'
      
        '{$NODEFINE    string       '#39'UnicodeString'#39' } {$OBJTYPENAME strin' +
        'g   '#39'NUnicodeString'#39'} { defined in ustring.h }'
      
        '{-NODEFINE    string       '#39'String'#39'        } {$OBJTYPENAME strin' +
        'g   '#39'NUnicodeString'#39'} { defined in ustring.h }'
      '{$IFDEF NEXTGEN}'
      
        '{$NODEFINE    _AnsiString '#39'_AnsiString'#39'  } { defined in dstring.' +
        'h }'
      
        '{$NODEFINE    _WideString '#39'_WideString'#39'  } { defined in wstring.' +
        'h }'
      '{$ELSE}'
      '{$NODEFINE    AnsiString   } { defined in dstring.h }'
      
        '{$NODEFINE    WideString   } {$OBJTYPENAME WideString '#39'NWideStri' +
        'ng'#39'} { defined in wstring.h }'
      '{$ENDIF}'
      '{$NODEFINE    PChar        } { alias of PWideChar  }'
      '{$NODEFINE    WideChar     } { alias of Char       }'
      '{$NODEFINE    UnicodeString} { alias of string     }'
      ''
      '(*$HPPEMIT '#39'namespace System'#39' *)'
      '(*$HPPEMIT '#39'{'#39' *)'
      '(*$HPPEMIT '#39'  // Shortint is a source of confusion in C++'#39' *)'
      '(*$HPPEMIT '#39'  // typedef Shortint ShortInt;'#39' *)'
      '(*$HPPEMIT '#39'  typedef Smallint SmallInt;'#39' *)'
      '(*$HPPEMIT '#39'  typedef Longint LongInt;'#39' *)'
      '(*$HPPEMIT '#39'}'#39' *)'
      ''
      'type'
      
        '  CppLongInt  = type LongInt;  {$EXTERNALSYM CppLongInt  '#39'long'#39' ' +
        '        } {$OBJTYPENAME CppLongInt  '#39'Bl'#39'  '#39'Gl'#39'}'
      
        '  CppULongInt = type LongWord; {$EXTERNALSYM CppULongInt '#39'unsign' +
        'ed long'#39'} {$OBJTYPENAME CppULongInt '#39'Bul'#39' '#39'Gm'#39'}'
      '{$IFDEF MSWINDOWS}'
      '  FixedInt = LongInt;'
      '  FixedUInt = LongWord;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      '  FixedInt = Integer;'
      '  FixedUInt = Cardinal;'
      '{$ENDIF}'
      '  PFixedInt = ^FixedInt;'
      '  PFixedUInt = ^FixedUInt;'
      '  {$EXTERNALSYM FixedInt}'
      '  {$EXTERNALSYM FixedUInt}'
      ''
      '{ Useful alias types }'
      'type'
      '  {$NODEFINE Int8} // We map '#39'Shortint'#39' to '#39'Int8'#39' for C++ above'
      '  Int8    = ShortInt;'
      '  Int16   = SmallInt;'
      '  Int32   = Integer;'
      '  IntPtr  = NativeInt;'
      '  UInt8   = Byte;'
      '  UInt16  = Word;'
      '  UInt32  = Cardinal;'
      '  UIntPtr = NativeUInt;'
      '{$IFDEF MACOS} {mactypes.h}'
      '  {$EXTERNALSYM UInt8}'
      '  {$EXTERNALSYM UInt16}'
      '  {$EXTERNALSYM UInt32}'
      '{$ENDIF}'
      '  Float32 = Single;'
      '  Float64 = Double;'
      ''
      '  { Internal Aliases }'
      '  {$IFDEF NEXTGEN}'
      '  _ShortStr = _ShortString;'
      '  _AnsiStr = _AnsiString;'
      '  _AnsiChr = _AnsiChar;'
      '  _WideStr = _WideString;'
      '  _PAnsiChr = _PAnsiChar;'
      '  UTF8Char = _AnsiChar;'
      '  PUTF8Char = _PAnsiChar;'
      '  {$ELSE}'
      '  _ShortStr = ShortString;'
      '  _AnsiStr = AnsiString;'
      '  _AnsiChr = AnsiChar;'
      '  _WideStr = WideString;'
      '  _PAnsiChr = PAnsiChar;'
      '  UTF8Char = AnsiChar;'
      '  PUTF8Char = PAnsiChar;'
      '  {$ENDIF}'
      '  MarshaledString = PWideChar;'
      '  MarshaledAString = _PAnsiChr;'
      '{$IF defined(WEAK_NATIVEINT)}'
      '{$NODEFINE    MarshaledString  '#39'PWideChar'#39'   }'
      '{$NODEFINE    MarshaledAString '#39'PAnsiChar'#39'   }'
      '{$NODEFINE    _ShortStr        '#39'ShortString'#39' }'
      '{$NODEFINE    _WideStr         '#39'WideString'#39'  }'
      '{$NODEFINE    _AnsiStr         '#39'AnsiString'#39'  }'
      '{$NODEFINE    _AnsiChr         '#39'AnsiChar'#39'    }'
      '{$NODEFINE    _PAnsiChr        '#39'PAnsiChar'#39'   }'
      '{$ELSE}'
      '{$NODEFINE    MarshaledString  }'
      '{$NODEFINE    MarshaledAString }'
      '{$NODEFINE    _ShortStr    }'
      '{$NODEFINE    _WideStr     }'
      '{$NODEFINE    _AnsiStr     }'
      '{$NODEFINE    _AnsiChr     }'
      '{$NODEFINE    _PAnsiChr    }'
      '{$ENDIF}'
      ''
      'const'
      '{ Variant type codes (wtypes.h) }'
      ''
      '  varEmpty    = $0000; { vt_empty        0 }'
      '  varNull     = $0001; { vt_null         1 }'
      '  varSmallint = $0002; { vt_i2           2 }'
      '  varInteger  = $0003; { vt_i4           3 }'
      '  varSingle   = $0004; { vt_r4           4 }'
      '  varDouble   = $0005; { vt_r8           5 }'
      '  varCurrency = $0006; { vt_cy           6 }'
      '  varDate     = $0007; { vt_date         7 }'
      '  varOleStr   = $0008; { vt_bstr         8 }'
      '  varDispatch = $0009; { vt_dispatch     9 }'
      '  varError    = $000A; { vt_error       10 }'
      '  varBoolean  = $000B; { vt_bool        11 }'
      '  varVariant  = $000C; { vt_variant     12 }'
      '  varUnknown  = $000D; { vt_unknown     13 }'
      
        '//varDecimal  = $000E; { vt_decimal     14 } {UNSUPPORTED as of ' +
        'v6.x code base}'
      
        '//varUndef0F  = $000F; { undefined      15 } {UNSUPPORTED per Mi' +
        'crosoft}'
      '  varShortInt = $0010; { vt_i1          16 }'
      '  varByte     = $0011; { vt_ui1         17 }'
      '  varWord     = $0012; { vt_ui2         18 }'
      
        '  varLongWord = $0013  { vt_ui4         19 } {deprecated '#39'use va' +
        'rUInt32'#39'} ;'
      '  varUInt32   = $0013; { vt_ui4         19 }'
      '  varInt64    = $0014; { vt_i8          20 }'
      '  varUInt64   = $0015; { vt_ui8         21 }'
      '  varRecord   = $0024; { VT_RECORD      36 }'
      
        '{  if adding new items, update Variants'#39' varLast, BaseTypeMap an' +
        'd OpTypeMap }'
      ''
      '  varStrArg   = $0048; { vt_clsid        72 }'
      '  varObject   = $0049; {                 73 }'
      '  varUStrArg  = $004A; {                 74 }'
      
        '  varString   = $0100; { Pascal string  256 } {not OLE compatibl' +
        'e }'
      
        '  varAny      = $0101; { Corba any      257 } {not OLE compatibl' +
        'e }'
      
        '  varUString  = $0102; { Unicode string 258 } {not OLE compatibl' +
        'e }'
      '  // custom types range from $110 (272) to $7FF (2047)'
      ''
      '  varTypeMask = $0FFF;'
      '  varArray    = $2000;'
      '  varByRef    = $4000;'
      ''
      '{ TVarRec.VType values }'
      ''
      '  vtInteger       = 0;'
      '  vtBoolean       = 1;'
      '  vtChar          = 2;'
      '  vtExtended      = 3;'
      
        '  vtString        = 4{$IFDEF NEXTGEN} deprecated '#39'Type not suppo' +
        'rted'#39' {$ENDIF NEXTGEN};'
      '  vtPointer       = 5;'
      '  vtPChar         = 6;'
      '  vtObject        = 7;'
      '  vtClass         = 8;'
      '  vtWideChar      = 9;'
      '  vtPWideChar     = 10;'
      '  vtAnsiString    = 11;'
      '  vtCurrency      = 12;'
      '  vtVariant       = 13;'
      '  vtInterface     = 14;'
      '  vtWideString    = 15;'
      '  vtInt64         = 16;'
      '  vtUnicodeString = 17;'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      '  vmtArcOffset    = 2 * SizeOf(Pointer);'
      '{$ELSE}'
      '  vmtArcOffset    = 0;'
      '{$ENDIF}'
      ''
      '{$IFDEF CPP_ABI_SUPPORT}'
      '  CPP_ABI_ADJUST = 3 * SizeOf(Pointer);'
      '{$ELSE !CPP_ABI_SUPPORT}'
      '  CPP_ABI_ADJUST = 0;'
      '{$ENDIF !CPP_ABI_SUPPORT}'
      ''
      '{ Virtual method table entries }'
      '{$IF defined(CPU64BITS)}'
      '  vmtSelfPtr           = -176 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtIntfTable         = -168 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtAutoTable         = -160 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtInitTable         = -152 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtTypeInfo          = -144 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtFieldTable        = -136 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtMethodTable       = -128 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtDynamicTable      = -120 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtClassName         = -112 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtInstanceSize      = -104 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtParent            = -96 - vmtArcOffset - CPP_ABI_ADJUST;'
      '{$IFDEF AUTOREFCOUNT}'
      
        '  vmtObjAddRef         = -104 - CPP_ABI_ADJUST deprecated '#39'Use V' +
        'MTOFFSET in asm code'#39';'
      
        '  vmtObjRelease        = -96 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      '{$ENDIF}'
      
        '  vmtEquals            = -88 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtGetHashCode       = -80 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtToString          = -72 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtSafeCallException = -64 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtAfterConstruction = -56 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtBeforeDestruction = -48 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtDispatch          = -40 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtDefaultHandler    = -32 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtNewInstance       = -24 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtFreeInstance      = -16 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtDestroy           =  -8 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtQueryInterface    =  0 deprecated '#39'Use VMTOFFSET in asm cod' +
        'e'#39';'
      
        '  vmtAddRef            =  8 deprecated '#39'Use VMTOFFSET in asm cod' +
        'e'#39';'
      
        '  vmtRelease           = 16 deprecated '#39'Use VMTOFFSET in asm cod' +
        'e'#39';'
      
        '  vmtCreateObject      = 24 deprecated '#39'Use VMTOFFSET in asm cod' +
        'e'#39';'
      '{$ELSE !CPU64BITS}'
      '  vmtSelfPtr           = -88 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtIntfTable         = -84 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtAutoTable         = -80 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtInitTable         = -76 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtTypeInfo          = -72 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtFieldTable        = -68 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtMethodTable       = -64 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtDynamicTable      = -60 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtClassName         = -56 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtInstanceSize      = -52 - vmtArcOffset - CPP_ABI_ADJUST;'
      '  vmtParent            = -48 - vmtArcOffset - CPP_ABI_ADJUST;'
      '{$IFDEF AUTOREFCOUNT}'
      
        '  vmtObjAddRef         = -52 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtObjRelease        = -48 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      '{$ENDIF}'
      
        '  vmtEquals            = -44 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtGetHashCode       = -40 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtToString          = -36 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtSafeCallException = -32 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtAfterConstruction = -28 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtBeforeDestruction = -24 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtDispatch          = -20 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtDefaultHandler    = -16 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtNewInstance       = -12 - CPP_ABI_ADJUST deprecated '#39'Use VM' +
        'TOFFSET in asm code'#39';'
      
        '  vmtFreeInstance      = -8 - CPP_ABI_ADJUST deprecated '#39'Use VMT' +
        'OFFSET in asm code'#39';'
      
        '  vmtDestroy           = -4 - CPP_ABI_ADJUST deprecated '#39'Use VMT' +
        'OFFSET in asm code'#39';'
      ''
      
        '  vmtQueryInterface    = 0 deprecated '#39'Use VMTOFFSET in asm code' +
        #39';'
      
        '  vmtAddRef            = 4 deprecated '#39'Use VMTOFFSET in asm code' +
        #39';'
      
        '  vmtRelease           = 8 deprecated '#39'Use VMTOFFSET in asm code' +
        #39';'
      
        '  vmtCreateObject      = 12 deprecated '#39'Use VMTOFFSET in asm cod' +
        'e'#39';'
      '{$ENDIF !CPU64BITS}'
      ''
      '  { Hidden TObject field info }'
      '  hfFieldSize          = SizeOf(Pointer);'
      '  hfMonitorOffset      = 0;'
      ''
      '{ RTTI Visibility }'
      'type'
      
        '  TVisibilityClasses = set of (vcPrivate, vcProtected, vcPublic,' +
        ' vcPublished);'
      ''
      'const'
      
        '  { These constants represent the default settings built into th' +
        'e compiler.'
      
        '    For classes, these settings are normally inherited from TObj' +
        'ect. }'
      '  DefaultMethodRttiVisibility = [vcPublic, vcPublished];'
      '  DefaultFieldRttiVisibility = [vcPrivate..vcPublished];'
      '  DefaultPropertyRttiVisibility = [vcPublic, vcPublished];'
      ''
      'type'
      '  { Default RTTI settings }'
      '  {$RTTI INHERIT'
      '      METHODS(DefaultMethodRttiVisibility)'
      '      FIELDS(DefaultFieldRttiVisibility)'
      '      PROPERTIES(DefaultPropertyRttiVisibility)}'
      ''
      '  { Minimal RTTI generation henceforth in this file }'
      '  {.$RTTI EXPLICIT METHODS([]) FIELDS([]) PROPERTIES([])}'
      ''
      '  TArray<T> = array of T;'
      ''
      '  {.$DEFINE SYSTEM_HPP_DEFINES_OBJECTS}'
      ''
      '  TObject = class;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE TObject}   { defined in systobj.h }'
      '  {$ENDIF}'
      ''
      '  TClass = class of TObject;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE TClass}    { defined in systobj.h }'
      '  {$ENDIF}'
      ''
      '  {$IFDEF LONGINT64}'
      '  HRESULT = type Int32;'
      '  {$EXTERNALSYM HRESULT}'
      '  {$ELSEIF defined(EXTERNALLINKER)}'
      '  HRESULT = type CppLongInt;'
      '  {$EXTERNALSYM HRESULT} { long }'
      '  {$ELSE}'
      '  HRESULT = type LongInt;  { from wtypes.h }'
      
        '  {$EXTERNALSYM HRESULT} {$OBJTYPENAME HRESULT '#39'Bl'#39' '#39'Gl'#39'} { long' +
        ' }'
      '  {$ENDIF}'
      ''
      '  PGUID = ^TGUID;'
      '  TGUID = record'
      '    D1: Cardinal;'
      '    D2: Word;'
      '    D3: Word;'
      '    D4: array[0..7] of Byte;'
      
        '    class operator Equal(const Left, Right: TGUID): Boolean; {$I' +
        'FDEF WIN64} inline; {$ENDIF}'
      
        '    class operator NotEqual(const Left, Right: TGUID): Boolean; ' +
        'inline;'
      '    class function Empty: TGUID; static;'
      
        '    class function Create(const Data; BigEndian: Boolean = False' +
        '): TGUID; overload; static;'
      
        '    class function Create(const Data: array of Byte; AStartIndex' +
        ': Cardinal; BigEndian: Boolean = False): TGUID; overload; static' +
        ';'
      '    function IsEmpty: Boolean;'
      '  end;'
      '  {$NODEFINE PGUID}             { defined in sysmac.h }'
      '  {$EXTERNALSYM TGUID '#39'GUID'#39' }  { defined in sysmac.h }'
      '  {$OBJTYPENAME TGUID '#39'N_GUID'#39'}'
      
        '  { Type '#39'GUID'#39' in C++ is alias of '#39'_GUID'#39' and defined in guidde' +
        'f.h (wtypes.h) }'
      ''
      '  PInterfaceEntry = ^TInterfaceEntry;'
      '  TInterfaceEntry = packed record'
      '    IID: TGUID;'
      '    VTable: Pointer;'
      '    IOffset: Integer;'
      '    {$IF defined(CPU64BITS)}'
      '    _Filler: UInt32;'
      '    {$ENDIF}'
      '    ImplGetter: NativeUInt;'
      '  end;'
      ''
      '  PInterfaceTable = ^TInterfaceTable;'
      '  TInterfaceTable = packed record'
      '    EntryCount: Integer;'
      '    {$IF defined(CPU64BITS)}'
      '    _Filler: UInt32;'
      '    {$ENDIF}'
      '    Entries: array[0..9999{EntryCount - 1}] of TInterfaceEntry;'
      '   {Intfs: array[0..EntryCount - 1] of PPTypeInfo;}'
      '  end;'
      ''
      '  PMethod = ^TMethod;'
      '  TMethod = record'
      '    Code, Data: Pointer;'
      '  public'
      
        '    class operator Equal(const Left, Right: TMethod): Boolean; i' +
        'nline;'
      
        '    class operator NotEqual(const Left, Right: TMethod): Boolean' +
        '; inline;'
      
        '    class operator GreaterThan(const Left, Right: TMethod): Bool' +
        'ean; inline;'
      
        '    class operator GreaterThanOrEqual(const Left, Right: TMethod' +
        '): Boolean; inline;'
      
        '    class operator LessThan(const Left, Right: TMethod): Boolean' +
        '; inline;'
      
        '    class operator LessThanOrEqual(const Left, Right: TMethod): ' +
        'Boolean; inline;'
      '  end;'
      ''
      
        '{ TObject.Dispatch accepts any data type as its Message paramete' +
        'r.  The'
      
        '  first 2 bytes of the data are taken as the message id to searc' +
        'h for'
      
        '  in the object'#39's message methods.  TDispatchMessage is an examp' +
        'le of'
      '  such a structure with a word field for the message id.'
      '}'
      '  TDispatchMessage = record'
      '    MsgID: Word;'
      '  end;'
      ''
      '  TObject = class'
      '  public'
      '    constructor Create;'
      '    procedure Free;'
      '    procedure DisposeOf; {$IFNDEF AUTOREFCOUNT} inline; {$ENDIF}'
      
        '    class function InitInstance(Instance: Pointer): TObject {$IF' +
        'DEF AUTOREFCOUNT} unsafe {$ENDIF};'
      '    procedure CleanupInstance;'
      '    function ClassType: TClass; inline;'
      '    class function ClassName: string;'
      '    class function ClassNameIs(const Name: string): Boolean;'
      '    class function ClassParent: TClass; inline;'
      '    class function ClassInfo: Pointer; inline;'
      '    class function InstanceSize: Integer; inline;'
      '    class function InheritsFrom(AClass: TClass): Boolean;'
      
        '    class function MethodAddress(const Name: _ShortStr): Pointer' +
        '; overload;'
      
        '    class function MethodAddress(const Name: string): Pointer; o' +
        'verload;'
      '    class function MethodName(Address: Pointer): string;'
      '    class function QualifiedClassName: string;'
      
        '    function FieldAddress(const Name: _ShortStr): Pointer; overl' +
        'oad;'
      
        '    function FieldAddress(const Name: string): Pointer; overload' +
        ';'
      '    function GetInterface(const IID: TGUID; out Obj): Boolean;'
      
        '    class function GetInterfaceEntry(const IID: TGUID): PInterfa' +
        'ceEntry;'
      '    class function GetInterfaceTable: PInterfaceTable; inline;'
      '    class function UnitName: string;'
      '    class function UnitScope: string;'
      '{$IFDEF AUTOREFCOUNT}'
      '    function __ObjAddRef: Integer; virtual;'
      '    function __ObjRelease: Integer; virtual;'
      '{$ENDIF}'
      '    function Equals(Obj: TObject): Boolean; virtual;'
      '    function GetHashCode: Integer; virtual;'
      '    function ToString: string; virtual;'
      '    function SafeCallException(ExceptObject: TObject;'
      '      ExceptAddr: Pointer): HResult; virtual;'
      '    procedure AfterConstruction; virtual;'
      '    procedure BeforeDestruction; virtual;'
      '    procedure Dispatch(var Message); virtual;'
      '    procedure DefaultHandler(var Message); virtual;'
      
        '    class function NewInstance: TObject {$IFDEF AUTOREFCOUNT} un' +
        'safe {$ENDIF}; virtual;'
      '    procedure FreeInstance; virtual;'
      '{$IFDEF AUTOREFCOUNT}'
      '  protected'
      '{$ENDIF}'
      '    destructor Destroy; virtual;'
      ''
      '{$IFDEF CPP_ABI_SUPPORT}'
      '    procedure CPP_ABI_1; virtual;'
      '    procedure CPP_ABI_2; virtual;'
      '    procedure CPP_ABI_3; virtual;'
      '{$ENDIF !CPP_ABI_SUPPORT}'
      ''
      '  protected'
      '    function GetDisposed: Boolean; inline;'
      
        '    procedure CheckDisposed; {$IFNDEF AUTOREFCOUNT} inline; {$EN' +
        'DIF}'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      '  private const'
      '    objDestroyingFlag = Integer($80000000);'
      '    objDisposedFlag = Integer($40000000);'
      '  protected'
      '                                                               '
      '    [Volatile] FRefCount: Integer;'
      '    class procedure __MarkDestroying(const Obj); static; inline;'
      
        '    class function __SetDisposed(const Obj): Boolean; static; in' +
        'line;'
      '  public'
      '    property RefCount: Integer read FRefCount;'
      '{$ENDIF AUTOREFCOUNT}'
      '    property Disposed: Boolean read GetDisposed;'
      '  end;'
      ''
      '  { The base class for all custom attributes. Attribute'
      '    instances created by the RTTI unit are owned by those'
      '    members to which they apply. }'
      '  TCustomAttribute = class(TObject)'
      '  end;'
      '  TCustomAttributeClass = class of TCustomAttribute;'
      '  WeakAttribute = class(TCustomAttribute);'
      '  UnsafeAttribute = class(TCustomAttribute);'
      '  RefAttribute = class(TCustomAttribute);'
      '  VolatileAttribute = class(TCustomAttribute);'
      '  StoredAttribute = class(TCustomAttribute)'
      '  strict protected'
      '    FFlag: Boolean;'
      '    _FName: String;'
      '  public'
      '    constructor Create; overload;'
      
        '    constructor Create(const StorageHandlerFlag: Boolean); overl' +
        'oad;'
      
        '    constructor Create(const StorageHandlerName: string); overlo' +
        'ad;'
      '    property Flag: Boolean read FFlag;'
      '    property Name: String read _FName;'
      '  end;'
      '  HPPGENAttribute = class(TCustomAttribute)'
      '  const'
      '    mkNoDefine   = 1;'
      '    mkAccessible = 2;'
      '    mkFriend     = 4;'
      '    mkNonPackage = 8;'
      '    mkNoOperator = 16;'
      '  public'
      '    constructor Create(const AData: string); overload;'
      
        '    constructor Create(const AFlag: Integer; const AData: string' +
        ' = '#39#39'); overload;'
      '  end;'
      '  /// <summary>For internal use only.</summary>'
      '  HFAAttribute = class(TCustomAttribute)'
      '  strict protected'
      '    /// <summary>Internal use only</summary>'
      '    FElementType: Pointer;'
      '    /// <summary>Internal use only</summary>'
      '    FElementCount: Integer;'
      '  public'
      
        '    constructor Create(const ElementType: Pointer; const Element' +
        'Count: Integer); overload;'
      '    /// <summary>TypeInfo of element type</summary>'
      '    property ElementType: Pointer read FElementType;'
      '    /// <summary>Number of element type </summary>'
      '    property ElementCount: Integer read FElementCount;'
      '  end;'
      '  /// <summary>Internal use only.</summary>'
      '  AlignAttribute = class(TCustomAttribute)'
      '  strict protected'
      '    /// <summary>Internal use only</summary>'
      '    FAlign: Integer;'
      '  public'
      '    constructor Create(Align: Integer);'
      '    /// <summary>Alignment in bytes</summary>'
      '    property Align: Integer read FAlign;'
      '  end;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE TCustomAttribute}'
      '  {$NODEFINE WeakAttribute}'
      '  {$NODEFINE UnsafeAttribute}'
      '  {$NODEFINE RefAttribute}'
      '  {$NODEFINE VolatileAttribute}'
      '  {$NODEFINE StoredAttribute}'
      '  {$NODEFINE HPPGENAttribute}'
      '  {$NODEFINE HFAAttribute}'
      '  {$NODEFINE AlignAttribute}'
      '  {$ENDIF}'
      ''
      ''
      '{$IFDEF NEXTGEN}'
      '  CheckForCyclesProc = procedure (const Obj: TObject);'
      '{$ENDIF NEXTGEN}'
      ''
      '{$IF Defined(MSWINDOWS)}'
      '  TThreadID = LongWord;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      '  TThreadID = NativeUInt;'
      '{$ENDIF}'
      
        '  { TMonitor is an implementation of the concept invented by C.A' +
        '.R Hoare and Per Brinch Hansen.'
      
        '    See http://en.wikipedia.org/wiki/Monitor_%28synchronization%' +
        '29 for more information.'
      ''
      
        '    Every TObject derived instance can be used as a monitor. How' +
        'ever, it is recommended that privately'
      
        '    constructed objects be used rather than the publicly availab' +
        'le instance itself. This will allow the'
      
        '    developer to better control access to the lock and to ensure' +
        ' that the locking rules are adhered to.'
      
        '    If a publicly available instance were to be used a the lock,' +
        ' such as a TComponent derivative, then'
      
        '    deadlocks are more likely when external code is locking and ' +
        'unlocking the monitor in addition to'
      
        '    the code internal to the class. In many cases, a mutex/criti' +
        'cal section/condition variable can be'
      
        '    created by simply constructing a variable of type TObject an' +
        'd calling the TMonitor.XXXX(ObjInstance)'
      '    methods. }'
      ''
      '  PPMonitor = ^PMonitor;'
      '  PMonitor = ^TMonitor;'
      '  TMonitor = record'
      '  strict private'
      '    type'
      '      PWaitingThread = ^TWaitingThread;'
      '      TWaitingThread = record'
      '        Next: PWaitingThread;'
      '        Thread: TThreadID;'
      '        WaitEvent: Pointer;'
      '      end;'
      
        '      { TSpinWait implements an exponential backoff algorithm fo' +
        'r TSpinLock. The algorithm is as follows:'
      
        '        If the CPUCount > 1, then the first 10 (YieldThreshold) ' +
        'spin cycles (calls to SpinCycle) will use a base 2'
      
        '        exponentially increasing spin count starting at 4. After' +
        ' 10 cycles, then the behavior reverts to the same'
      '        behavior as when CPUCount = 1.'
      
        '        If the CPUCount = 1, then it will sleep 1ms every modulu' +
        's 20 cycles and sleep 0ms every modulus 5 cycles.'
      
        '        All other cycles simply yield (SwitchToThread - Windows,' +
        ' sched_yield - POSIX). }'
      '      TSpinWait = record'
      '      private const'
      '        YieldThreshold = 10;'
      '        Sleep1Threshold = 20;'
      '        Sleep0Threshold = 5;'
      '      private'
      '        FCount: Integer;'
      '      public'
      '        procedure Reset; inline;'
      '        procedure SpinCycle;'
      '      end;'
      
        '      { TSpinLock implements a very simple non-reentrant lock. T' +
        'his lock does not block the calling thread using a'
      
        '        synchronization object. Instead it opts to burn a few ex' +
        'tra CPU cycles using the above TSpinWait type. This'
      
        '        is typically far faster than fully blocking since the le' +
        'ngth of time the lock is held is relatively few'
      
        '        cycles and the thread switching overhead will usually fa' +
        'r outpace the few cycles burned by simply spin'
      '        waiting. }'
      '      TSpinLock = record'
      '      private'
      '        FLock: Integer;'
      '      public'
      '        procedure Enter;'
      '        procedure Exit;'
      '      end;'
      '    var'
      '      [Volatile] FLockCount: Integer;'
      '      FRecursionCount: Integer;'
      '      FOwningThread: TThreadID;'
      '      FLockEvent: Pointer;'
      '      FSpinCount: Integer;'
      '      FWaitQueue: PWaitingThread;'
      '      FQueueLock: TSpinLock;'
      '    class var CacheLineSize: Integer;'
      '    class var FDefaultSpinCount: Integer;'
      '    class procedure Spin(Iterations: Integer); static;'
      '    class function GetCacheLineSize: Integer; static;'
      '    procedure QueueWaiter(var WaitingThread: TWaitingThread);'
      '    procedure RemoveWaiter(var WaitingThread: TWaitingThread);'
      '    function DequeueWaiter: PWaitingThread;'
      '    function GetEvent: Pointer;'
      '    function CheckOwningThread: TThreadID;'
      '    class procedure CheckMonitorSupport; static; inline;'
      '  private'
      '    class function Create: PMonitor; static;'
      '    // Make sure the following Destroy overload is always'
      '    // listed first since it is called from an asm block'
      '    // and there is no overload-resolution done from a'
      '    // basm symbol reference'
      
        '    class procedure Destroy(const AObject: TObject); overload; s' +
        'tatic;'
      '    procedure Destroy; overload;'
      '  strict private'
      
        '    class function GetFieldAddress(const AObject: TObject): PPMo' +
        'nitor; inline; static;'
      
        '    class function GetMonitor(const AObject: TObject): PMonitor;' +
        ' static;'
      
        '    class procedure SetDefaultSpinCount(AValue: Integer); static' +
        ';'
      '    function TryEnter: Boolean; overload;'
      
        '    function Wait(ALock: PMonitor; Timeout: Cardinal): Boolean; ' +
        'overload;'
      '    procedure Pulse; overload;'
      '    procedure PulseAll; overload;'
      '  private'
      '    function Enter(Timeout: Cardinal): Boolean; overload;'
      '    procedure Exit; overload;'
      '  public'
      
        '    { In multi-core/multi-processor systems, it is sometimes des' +
        'irable to spin for a few cycles instead of blocking'
      
        '      the current thread when attempting to Enter the monitor. U' +
        'se SetSpinCount to set a reasonable number of times to'
      
        '      spin before fully blocking the thread. This value usually ' +
        'obtained through empirical study of the particular'
      '      situation.  }'
      
        '    class procedure SetSpinCount(const AObject: TObject; ASpinCo' +
        'unt: Integer); static;'
      
        '    { Enter locks the monitor object with an optional timeout (i' +
        'n ms) value. Enter without a timeout will wait until'
      
        '      the lock is obtained. If the procedure returns it can be a' +
        'ssumed that the lock was acquired. Enter with a'
      
        '      timeout will return a boolean status indicating whether or' +
        ' not the lock was obtained (True) or the attempt timed'
      
        '      out prior to acquire the lock (False). Calling Enter with ' +
        'an INFINITE timeout is the same as calling Enter'
      '      without a timeout.'
      
        '      TryEnter will simply attempt to obtain the lock and return' +
        ' immediately whether or not the lock was acuired.'
      
        '      Enter with a 0ms timeout is functionally equivalent to Try' +
        'Enter.'
      
        '      Exit will potentially release the lock acquired by a call ' +
        'to Enter or TryEnter. Since Enter/TryEnter are'
      
        '      rentrant, you must balance each of those calls with a corr' +
        'esponding call to Exit. Only the last call to Exit will'
      
        '      release the lock and allow other threads to obtain it. Run' +
        'time error, reMonitorNotLocked, is generated if Exit is'
      '      called and the calling thread does not own the lock. }'
      
        '    class procedure Enter(const AObject: TObject); overload; sta' +
        'tic; inline;'
      
        '    class function Enter(const AObject: TObject; Timeout: Cardin' +
        'al): Boolean; overload; static;'
      
        '    class procedure Exit(const AObject: TObject); overload; stat' +
        'ic;'
      
        '    class function TryEnter(const AObject: TObject): Boolean; ov' +
        'erload; static;'
      
        '    { Wait will atomically fully release the lock (regardless of' +
        ' the recursion count) and block the calling thread'
      
        '      until another thread calls Pulse or PulseAll. The first ov' +
        'erloaded Wait function will assume the locked object'
      
        '      and wait object are the same and thus the calling thread m' +
        'ust own the lock. The second Wait allows the given'
      
        '      monitor to atomically unlock the separate monitor lock obj' +
        'ect and block with the calling thread on the first'
      
        '      given wait object. Wait will not return (even if it times ' +
        'out) until the monitor lock can be acquired again. It'
      
        '      is possible for wait to return False (the timeout expired)' +
        ' after a much longer period of time has elapsed if'
      
        '      the locking object was being held by another thread for an' +
        ' extended period. When Wait returns the recursion'
      '      level of the lock has been restored.'
      
        '      Pulse must be called on the exact same instance passed to ' +
        'Wait in order to properly release one waiting thread.'
      
        '      PulseAll works the same as Pulse except that it will relea' +
        'se all currently waiting threads.'
      
        '      Wait/Pulse/PulseAll are the same as a traditional conditio' +
        'n variable.'
      '    }'
      
        '    class function Wait(const AObject: TObject; Timeout: Cardina' +
        'l): Boolean; overload; static;'
      
        '    class function Wait(const AObject, ALock: TObject; Timeout: ' +
        'Cardinal): Boolean; overload; static;'
      
        '    class procedure Pulse(const AObject: TObject); overload; sta' +
        'tic;'
      
        '    class procedure PulseAll(const AObject: TObject); overload; ' +
        'static;'
      
        '    class property DefaultSpinCount: Integer read FDefaultSpinCo' +
        'unt write SetDefaultSpinCount;'
      '  end;'
      ''
      'const'
      '  INFINITE = Cardinal($FFFFFFFF);       {$EXTERNALSYM INFINITE}'
      ''
      
        'function MonitorEnter(const AObject: TObject; Timeout: Cardinal ' +
        '= INFINITE): Boolean; inline;'
      
        'function MonitorTryEnter(const AObject: TObject): Boolean; inlin' +
        'e;'
      'procedure MonitorExit(const AObject: TObject); inline;'
      
        'function MonitorWait(const AObject: TObject; Timeout: Cardinal):' +
        ' Boolean; inline; overload;'
      
        'function MonitorWait(const AObject, ALock: TObject; Timeout: Car' +
        'dinal): Boolean; inline; overload;'
      'procedure MonitorPulse(const AObject: TObject); inline;'
      'procedure MonitorPulseAll(const AObject: TObject); inline;'
      '// Note: MemoryBarrier is now standard function.'
      '//procedure MemoryBarrier;'
      ''
      'procedure YieldProcessor; {$EXTERNALSYM YieldProcessor }'
      ''
      'const'
      '  S_OK = 0;'
      '  {$EXTERNALSYM S_OK}'
      '  S_FALSE = $00000001;'
      '  {$EXTERNALSYM S_FALSE}'
      '  E_NOINTERFACE = HRESULT($80004002);'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM E_NOINTERFACE}'
      '{$ENDIF}'
      '  E_UNEXPECTED = HRESULT($8000FFFF);'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM E_UNEXPECTED}'
      '{$ENDIF}'
      '  E_NOTIMPL = HRESULT($80004001);'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM E_NOTIMPL}'
      '{$ENDIF}'
      ''
      'type'
      '  IInterface = interface'
      '    ['#39'{00000000-0000-0000-C000-000000000046}'#39']'
      
        '    function QueryInterface(const IID: TGUID; out Obj): HResult;' +
        ' stdcall;'
      '    function _AddRef: Integer; stdcall;'
      '    function _Release: Integer; stdcall;'
      '  end;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE IInterface}        { defined in sysmac.h }'
      '  {$ENDIF}'
      ''
      '  IUnknown = IInterface;'
      '  {$EXTERNALSYM IUnknown}       { from unknwn.h or sysmac.h }'
      '{$M+}'
      '  IInvokable = interface(IInterface)'
      '  end;'
      '{$M-}'
      '  {$NODEFINE IInvokable}        { defined in sysmac.h }'
      ''
      '  IEnumerator = interface(IInterface)'
      '    function GetCurrent: TObject;'
      '    function MoveNext: Boolean;'
      '    procedure Reset;'
      '    property Current: TObject read GetCurrent;'
      '  end;'
      ''
      '  IEnumerable = interface(IInterface)'
      '    function GetEnumerator: IEnumerator;'
      '  end;'
      ''
      '  IEnumerator<T> = interface(IEnumerator)'
      '    [HPPGEN('#39'virtual T __fastcall GetCurrentT(void) = 0'#39')]'
      '    function GetCurrent: T;'
      '    [HPPGEN('#39'__property T Current = {read=GetCurrentT}'#39')]'
      '    property Current: T read GetCurrent;'
      '  end;'
      ''
      '  IEnumerable<T> = interface(IEnumerable)'
      
        '    [HPPGEN('#39'virtual System::DelphiInterface<IEnumerator__1<T> >' +
        ' __fastcall GetEnumeratorT(void) = 0'#39')]'
      '    function GetEnumerator: IEnumerator<T>;'
      '  end;'
      ''
      '  IComparable = interface(IInterface)'
      '    function CompareTo(Obj: TObject): Integer;'
      '  end;'
      ''
      '  IComparable<T> = interface(IComparable)'
      '    function CompareTo(Value: T): Integer;'
      '  end;'
      ''
      '  IEquatable<T> = interface(IInterface)'
      '    function Equals(Value: T): Boolean;'
      '  end;'
      ''
      '  IDispatch = interface(IUnknown)'
      '    ['#39'{00020400-0000-0000-C000-000000000046}'#39']'
      
        '    function GetTypeInfoCount(out Count: Integer): HResult; stdc' +
        'all;'
      
        '    function GetTypeInfo(Index, LocaleID: Integer; out TypeInfo)' +
        ': HResult; stdcall;'
      '    function GetIDsOfNames(const IID: TGUID; Names: Pointer;'
      
        '      NameCount, LocaleID: Integer; DispIDs: Pointer): HResult; ' +
        'stdcall;'
      
        '    function Invoke(DispID: Integer; const IID: TGUID; LocaleID:' +
        ' Integer;'
      
        '      Flags: Word; var Params; VarResult, ExcepInfo, ArgErr: Poi' +
        'nter): HResult; stdcall;'
      '  end;'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM IDispatch}      { from oaidl.h (oleauto.h) }'
      '{$ENDIF}'
      ''
      '{ TInterfacedObject provides a threadsafe default implementation'
      
        '  of IInterface.  You should use TInterfaceObject as the base cl' +
        'ass'
      '  of objects implementing interfaces.  }'
      ''
      '  TInterfacedObject = class(TObject, IInterface)'
      '{$IFNDEF AUTOREFCOUNT}'
      '  private const'
      '    objDestroyingFlag = Integer($80000000);'
      '    function GetRefCount: Integer; inline;'
      '{$ENDIF}'
      '  protected'
      '{$IFNDEF AUTOREFCOUNT}'
      '    [Volatile] FRefCount: Integer;'
      '    class procedure __MarkDestroying(const Obj); static; inline;'
      '{$ENDIF}'
      
        '    function QueryInterface(const IID: TGUID; out Obj): HResult;' +
        ' stdcall;'
      '    function _AddRef: Integer; stdcall;'
      '    function _Release: Integer; stdcall;'
      '  public'
      '{$IFNDEF AUTOREFCOUNT}'
      '    procedure AfterConstruction; override;'
      '    procedure BeforeDestruction; override;'
      '    class function NewInstance: TObject; override;'
      '    property RefCount: Integer read GetRefCount;'
      '{$ENDIF}'
      '  end;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE TInterfacedObject}         { defined in systobj.h }'
      '  {$ENDIF}'
      ''
      '  TInterfacedClass = class of TInterfacedObject;'
      ''
      '{ TAggregatedObject and TContainedObject are suitable base'
      '  classes for interfaced objects intended to be aggregated'
      '  or contained in an outer controlling object.  When using'
      '  the "implements" syntax on an interface property in'
      '  an outer object class declaration, use these types'
      '  to implement the inner object.'
      ''
      '  Interfaces implemented by aggregated objects on behalf of'
      '  the controller should not be distinguishable from other'
      '  interfaces provided by the controller.  Aggregated objects'
      '  must not maintain their own reference count - they must'
      '  have the same lifetime as their controller.  To achieve this,'
      '  aggregated objects reflect the reference count methods'
      '  to the controller.'
      ''
      '  TAggregatedObject simply reflects QueryInterface calls to'
      '  its controller.  From such an aggregated object, one can'
      '  obtain any interface that the controller supports, and'
      '  only interfaces that the controller supports.  This is'
      '  useful for implementing a controller class that uses one'
      '  or more internal objects to implement the interfaces declared'
      '  on the controller class.  Aggregation promotes implementation'
      '  sharing across the object hierarchy.'
      ''
      '  TAggregatedObject is what most aggregate objects should'
      '  inherit from, especially when used in conjunction with'
      '  the "implements" syntax.  }'
      ''
      '  TAggregatedObject = class(TObject)'
      '  private'
      
        '    [Unsafe] FController: IInterface;  // unsafe/weak reference ' +
        'to controller'
      '  protected'
      '    { IInterface }'
      
        '    function QueryInterface(const IID: TGUID; out Obj): HResult;' +
        ' stdcall;'
      '    function _AddRef: Integer; stdcall;'
      '    function _Release: Integer; stdcall;'
      '  public'
      '    constructor Create(const Controller: IInterface);'
      '    property Controller: IInterface read FController;'
      '  end;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE TAggregatedObject} { defined in systobj.h }'
      '  {$ENDIF}'
      ''
      '  { TContainedObject is an aggregated object that isolates'
      '    QueryInterface on the aggregate from the controller.'
      '    TContainedObject will return only interfaces that the'
      '    contained object itself implements, not interfaces'
      '    that the controller implements.  This is useful for'
      '    implementing nodes that are attached to a controller and'
      '    have the same lifetime as the controller, but whose'
      '    interface identity is separate from the controller.'
      '    You might do this if you don'#39't want the consumers of'
      '    an aggregated interface to have access to other interfaces'
      '    implemented by the controller - forced encapsulation.'
      '    This is a less common case than TAggregatedObject.  }'
      ''
      '  TContainedObject = class(TAggregatedObject, IInterface)'
      '  protected'
      '    { IInterface }'
      
        '    function QueryInterface(const IID: TGUID; out Obj): HResult;' +
        ' virtual; stdcall;'
      '  end;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE TContainedObject}  { defined in systobj.h }'
      '  {$ENDIF}'
      ''
      '  TClassHelperBase = class(TInterfacedObject, IInterface)'
      '  protected'
      '    FInstance: TObject;'
      '    constructor _Create(Instance: TObject);'
      '  end;'
      ''
      '  TClassHelperBaseClass = class of TClassHelperBase;'
      '  {$NODEFINE TClassHelperBaseClass}'
      '  {$NODEFINE TClassHelperBase}'
      ''
      '  { A non-reference-counted IInterface implementation. }'
      '  TNoRefCountObject = class(TObject, IInterface)'
      '  protected'
      
        '    function QueryInterface(const IID: TGUID; out Obj): HResult;' +
        ' stdcall;'
      '    function _AddRef: Integer; stdcall;'
      '    function _Release: Integer; stdcall;'
      '  end;'
      '  {$IFNDEF SYSTEM_HPP_DEFINES_OBJECTS}'
      '  {$NODEFINE TNoRefCountObject}  { defined in systobj.h }'
      '  {$ENDIF}'
      ''
      '{$IFDEF NEXTGEN}'
      '  _PShortString = ^_ShortString;'
      '  _PAnsiString = ^_AnsiString;'
      '  _PWideString = ^_WideString;'
      '  PUnicodeString = ^UnicodeString;'
      '  PString = PUnicodeString;'
      '  _PShortStr = _PShortString;'
      '  _PAnsiStr = _PAnsiString;'
      '  _PWideStr = _PWideString;'
      '  {$NODEFINE _PShortString}'
      '  {$NODEFINE _PAnsiString '#39'PAnsiString'#39'}'
      '  {$NODEFINE _PWideString}'
      '  {$NODEFINE PUnicodeString}'
      '  {$NODEFINE PString}'
      '  {$NODEFINE _PShortStr}'
      '  {$NODEFINE _PAnsiStr}'
      '  {$NODEFINE _PWideStr}'
      '{$ELSE}'
      '  PShortString = ^ShortString;'
      '  PAnsiString = ^AnsiString;'
      '  PWideString = ^WideString;'
      '  PUnicodeString = ^UnicodeString;'
      '  PString = PUnicodeString;'
      '  _PShortStr = PShortString;'
      '  _PAnsiStr = PAnsiString;'
      '  _PWideStr = PWideString;'
      '  {$NODEFINE PShortString}      { defined in sysmac.h }'
      '  {$NODEFINE PAnsiString}       { defined in sysmac.h }'
      '  {$NODEFINE PWideString}       { defined in sysmac.h }'
      '  {$NODEFINE PUnicodeString}    { defined in sysmac.h }'
      '  {$NODEFINE PString}           { defined in sysmac.h }'
      '{$ENDIF}'
      '  {$NODEFINE _PShortStr }       { defined in sysmac.h }'
      '  {$NODEFINE _PAnsiStr  }       { defined in sysmac.h }'
      '  {$NODEFINE _PWideStr  }       { defined in sysmac.h }'
      ''
      '  UCS2Char = WideChar;'
      '  PUCS2Char = PWideChar;'
      '  UCS4Char = Cardinal;'
      '  {$NODEFINE UCS4Char}          { defined in sysmac.h }'
      '  PUCS4Char = ^UCS4Char;'
      '  {$NODEFINE PUCS4Char}         { defined in sysmac.h }'
      ''
      '  TUCS4CharArray = array [0..$effffff] of UCS4Char;'
      '  PUCS4CharArray = ^TUCS4CharArray;'
      '  {$NODEFINE TUCS4CharArray}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  (*$HPPEMIT '#39'  typedef UCS4Char* TUCS4CharArray;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      ''
      '  UCS4String = array of UCS4Char;'
      '  {$NODEFINE UCS4String}        { defined in sysmac.h }'
      ''
      '{$IFDEF NEXTGEN}'
      '  UTF8String = type _AnsiString(65001);'
      '  RawByteString = type _AnsiString($ffff);'
      '{$ELSE}'
      '  UTF8String = type AnsiString(65001);'
      '  RawByteString = type AnsiString($ffff);'
      '{$ENDIF}'
      '  PUTF8String = ^UTF8String;'
      '  PRawByteString = ^RawByteString;'
      
        '{$IF Defined(NEXTGEN) or Defined(LINUX64) or Defined(OSX64) or D' +
        'efined(ANDROID) or Defined(IOS)}'
      '  {$NODEFINE UTF8String}'
      '  {$NODEFINE RawByteString}'
      '  {$NODEFINE PUTF8String}'
      '  {$NODEFINE PRawByteString}'
      '{$ENDIF (NEXTGEN or EXTERNALLINKER) and not MSWINDOWS}'
      '  _RawByteStr = RawByteString;'
      '  {$NODEFINE _RawByteStr}'
      '  _PRawByteStr = PRawByteString;'
      '  {$NODEFINE _PRawByteStr}'
      '  _UTF8Str = UTF8String;'
      '  {$NODEFINE _UTF8Str}'
      '  _PUTF8Str = PUTF8String;'
      '  {$NODEFINE _PUTF8Str}'
      ''
      '  IntegerArray  = array[0..$effffff] of Integer;'
      '  PIntegerArray = ^IntegerArray;'
      '  {$NODEFINE IntegerArray}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  (*$HPPEMIT '#39'  typedef int* IntegerArray;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      ''
      '  Int64Array  = array[0..$0ffffffe] of Int64;'
      '  PInt64Array = ^Int64Array;'
      '  {$NODEFINE Int64Array}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  (*$HPPEMIT '#39'  typedef __int64* Int64Array;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      ''
      '  {$IFDEF CPU64BITS}'
      '  PointerArray = array [0..256*1024*1024 - 2] of Pointer;'
      '  {$ELSE !CPU64BITS}'
      '  PointerArray = array [0..512*1024*1024 - 2] of Pointer;'
      '  {$ENDIF !CPU64BITS}'
      '  PPointerArray = ^PointerArray;'
      '  {$NODEFINE PointerArray}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  (*$HPPEMIT '#39'  typedef void *PointerArray;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      ''
      '  TBoundArray = array of NativeInt;'
      ''
      
        '  TPCharArray = packed array[0..(High(Integer) div SizeOf(PChar)' +
        ')-1] of PChar;'
      ''
      '  PPCharArray = ^TPCharArray;'
      '  {$NODEFINE TPCharArray}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  (*$HPPEMIT '#39'  typedef PChar TPCharArray;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      ''
      '  PLongInt      = ^LongInt;'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  {$IFDEF LONGINTISCPPLONG}'
      '  (*$HPPEMIT '#39'  typedef long *PLongInt;'#39' *)'
      '  {$ELSE}'
      '  (*$HPPEMIT '#39'  typedef int *PLongInt;'#39' *)'
      '  {$ENDIF}'
      '  (*$HPPEMIT '#39'  typedef PLongInt PLongint;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      '  {$NODEFINE PLongInt}'
      ''
      
        '  PInteger      = ^Integer;     {$NODEFINE PInteger}    { define' +
        'd in sysmac.h }'
      '  PCardinal     = ^Cardinal;'
      '  PWord         = ^Word;'
      
        '  PSmallInt     = ^SmallInt;    {$NODEFINE PSmallInt}   { define' +
        'd in sysmac.h }'
      '  {$POINTERMATH ON}'
      
        '  PByte         = ^Byte;        {$NODEFINE PByte}       { define' +
        'd in sysmac.h }'
      '  {$POINTERMATH OFF}'
      
        '  PShortInt     = ^ShortInt;    {$NODEFINE PShortInt}   { define' +
        'd in sysmac.h }'
      '  PUint32       = ^Uint32;'
      
        '  PInt64        = ^Int64;       {$NODEFINE PInt64}      { define' +
        'd in sysmac.h }'
      '  PUInt64       = ^UInt64;'
      
        '  PLongWord     = ^LongWord;    {$NODEFINE PLongWord}   { define' +
        'd in sysmac.h }'
      
        '  PSingle       = ^Single;      {$NODEFINE PSingle}     { define' +
        'd in sysmac.h }'
      
        '  PDouble       = ^Double;      {$NODEFINE PDouble}     { define' +
        'd in sysmac.h }'
      '  PDate         = ^Double;'
      '  PDispatch     = ^IDispatch;'
      '  PPDispatch    = ^PDispatch;'
      '  {$NODEFINE PDispatch}  // due to avoid compile error'
      '  {$NODEFINE PPDispatch} // due to avoid compile error'
      '  PError        = ^LongWord;'
      '  PWordBool     = ^WordBool;'
      '  PUnknown      = ^IUnknown;'
      '  PPUnknown     = ^PUnknown;'
      '  PPWideChar    = ^PWideChar;'
      '{$IFDEF NEXTGEN}'
      '  _PPAnsiChar   = ^_PAnsiChar;'
      '  _PPAnsiChr    = _PPAnsiChar;'
      '  {$NODEFINE _PPAnsiChar}'
      '{$ELSE}'
      '  PPAnsiChar    = ^PAnsiChar;'
      '  _PPAnsiChr    = PPAnsiChar;'
      '{$ENDIF}'
      '  {$NODEFINE    _PPAnsiChr}'
      
        '  PPChar        = PPWideChar;   {$NODEFINE PPChar}      { define' +
        'd in sysmac.h }'
      
        '  PExtended     = ^Extended;    {$NODEFINE PExtended}   { define' +
        'd in sysmac.h }'
      '  PComp         = ^Comp;'
      
        '  PCurrency     = ^Currency;    {$NODEFINE PCurrency}   { define' +
        'd in sysmac.h }'
      
        '  PVariant      = ^Variant;     {$NODEFINE PVariant}    { define' +
        'd in sysmac.h }'
      
        '  POleVariant   = ^OleVariant;  {$NODEFINE POleVariant} { define' +
        'd in sysmac.h }'
      
        '  PPointer      = ^Pointer;     {$NODEFINE PPointer}    { define' +
        'd in sysmac.h }'
      
        '  PBoolean      = ^Boolean;     {$NODEFINE PBoolean}    { define' +
        'd in sysmac.h }'
      '  PNativeInt    = ^NativeInt;'
      '  PNativeUInt   = ^NativeUInt;'
      '  PMarshaledString = PPWideChar;  {$NODEFINE PMarshaledString}'
      '  PMarshaledAString = _PPAnsiChr; {$NODEFINE PMarshaledAString}'
      ''
      '  TDateTime = type Double;'
      '  PDateTime = ^TDateTime;'
      
        '  {$NODEFINE TDateTime '#39'TDateTime'#39' '#39'TDateTimeBase'#39'}     { define' +
        'd in systdate.h }'
      '  {$OBJTYPENAME TDateTime '#39'NTDateTime'#39' }'
      ''
      '  TDate = type TDateTime;'
      '  TTime = type TDateTime;'
      '  {$NODEFINE TDate '#39'TDate'#39' '#39'TDateTimeBase'#39'}'
      '  {$NODEFINE TTime '#39'TTime'#39' '#39'TDateTimeBase'#39'}'
      '{$IF defined(EXTERNALLINKER)}'
      '  {$OBJTYPENAME TDate '#39'NTDate'#39' }'
      '  {$OBJTYPENAME TTime '#39'NTTime'#39' }'
      '{$ELSE}'
      '  {$OBJTYPENAME TDate '#39'NTDateTime'#39' }'
      '  {$OBJTYPENAME TTime '#39'NTDateTime'#39' }'
      '{$ENDIF}'
      '{$IF not defined(EXTERNALLINKER) or defined(MSWINDOWS)}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  (*$HPPEMIT '#39'    typedef System::TDateTime TDate;'#39' *)'
      '  (*$HPPEMIT '#39'    typedef System::TDateTime TTime;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      '{$ENDIF}'
      ''
      '  THandle = NativeUInt;'
      '  {$IF defined(WEAK_NATIVEINT)}'
      '  {$NODEFINE THandle '#39'NativeUInt'#39'}'
      '  {$ELSE}'
      '  {$NODEFINE THandle}'
      '  {$ENDIF}'
      ''
      '  PVarArrayBound = ^TVarArrayBound;'
      '  TVarArrayBound = record'
      '    ElementCount: Integer;'
      '    LowBound: Integer;'
      '  end;'
      '  TVarArrayBoundArray = array [0..0] of TVarArrayBound;'
      '  PVarArrayBoundArray = ^TVarArrayBoundArray;'
      '  TVarArrayCoorArray = array [0..0] of Integer;'
      '  PVarArrayCoorArray = ^TVarArrayCoorArray;'
      ''
      '  PVarArray = ^TVarArray;'
      '  TVarArray = record'
      '    DimCount: Word;'
      '    Flags: Word;'
      '    ElementSize: Integer;'
      '    LockCount: Integer;'
      '    Data: Pointer;'
      '    Bounds: TVarArrayBoundArray;'
      '  end;'
      ''
      '  PVarRecord = ^TVarRecord;'
      '  TVarRecord = record'
      '    PRecord: Pointer;'
      '    RecInfo: Pointer;'
      '  end;'
      ''
      '  TLargestVarData = record'
      '    _Reserved1: Pointer;'
      '    _Reserved2: Pointer;'
      '  end;'
      ''
      '  TVarType = Word;'
      '  PVarData = ^TVarData;'
      '  TVarData = packed record'
      '    case Integer of'
      '      0: (VType: TVarType;'
      '          case Integer of'
      '            0: (Reserved1: Word;'
      '                case Integer of'
      '                  0: (Reserved2, Reserved3: Word;'
      '                      case Integer of'
      '                        varSmallInt: (VSmallInt: SmallInt);'
      '                        varInteger:  (VInteger: Integer);'
      '                        varSingle:   (VSingle: Single);'
      '                        varDouble:   (VDouble: Double);'
      '                        varCurrency: (VCurrency: Currency);'
      '                        varDate:     (VDate: TDateTime);'
      '                        varOleStr:   (VOleStr: PWideChar);'
      '                        varDispatch: (VDispatch: Pointer);'
      '                        varError:    (VError: HRESULT);'
      '                        varBoolean:  (VBoolean: WordBool);'
      '                        varUnknown:  (VUnknown: Pointer);'
      '                        varShortInt: (VShortInt: ShortInt);'
      '                        varByte:     (VByte: Byte);'
      '                        varWord:     (VWord: Word);'
      
        '                        -1:          (VLongWord: Cardinal {depre' +
        'cated '#39'use VUInt32'#39'});'
      '                        varUInt32:   (VUInt32: UInt32);'
      '                        varInt64:    (VInt64: Int64);'
      '                        varUInt64:   (VUInt64: UInt64);'
      '                        varString:   (VString: Pointer);'
      '                        varAny:      (VAny: Pointer);'
      '                        varArray:    (VArray: PVarArray);'
      '                        varByRef:    (VPointer: Pointer);'
      '                        varUString:  (VUString: Pointer);'
      '                        varRecord:   (VRecord: TVarRecord);'
      
        '                        //$ffff:     (VLargest: TLargestVarData)' +
        ';'
      '                     );'
      
        '                  1: (VLongs: array[0..{$IFDEF CPU64BITS}4{$ELSE' +
        '}2{$ENDIF}] of Integer);'
      '               );'
      
        '            2: (VWords: array [0..{$IFDEF CPU64BITS}10{$ELSE}6{$' +
        'ENDIF}] of Word);'
      
        '            3: (VBytes: array [0..{$IFDEF CPU64BITS}21{$ELSE}13{' +
        '$ENDIF}] of Byte);'
      '          );'
      
        '      1: (RawData: array [0..{$IFDEF CPU64BITS}5{$ELSE}3{$ENDIF}' +
        '] of Integer);'
      '  end;'
      '  {$EXTERNALSYM TVarData}'
      '  {$EXTERNALSYM PVarData}'
      ''
      '  // Sync with compiler internals'
      
        '  TTypeKind = (tkUnknown, tkInteger, tkChar, tkEnumeration, tkFl' +
        'oat,'
      
        '    tkString, tkSet, tkClass, tkMethod, tkWChar, tkLString, tkWS' +
        'tring,'
      
        '    tkVariant, tkArray, tkRecord, tkInterface, tkInt64, tkDynArr' +
        'ay, tkUString,'
      '    tkClassRef, tkPointer, tkProcedure, tkMRecord);'
      ''
      'type'
      '  TVarOp = Integer;'
      ''
      'const'
      '  opAdd =        0;'
      '  opSubtract =   1;'
      '  opMultiply =   2;'
      '  opDivide =     3;'
      '  opIntDivide =  4;'
      '  opModulus =    5;'
      '  opShiftLeft =  6;'
      '  opShiftRight = 7;'
      '  opAnd =        8;'
      '  opOr =         9;'
      '  opXor =        10;'
      '  opCompare =    11;'
      '  opNegate =     12;'
      '  opNot =        13;'
      ''
      '  opCmpEQ =      14;'
      '  opCmpNE =      15;'
      '  opCmpLT =      16;'
      '  opCmpLE =      17;'
      '  opCmpGT =      18;'
      '  opCmpGE =      19;'
      ''
      '  tkAnsiChar =   TTypeKind.tkChar;'
      '  tkWideChar =   TTypeKind.tkWChar;'
      '  tkUnicodeString = TTypeKind.tkUString;'
      '  tkAnsiString = TTypeKind.tkLString;'
      '  tkWideString = TTypeKind.tkWString;'
      '  tkShortString = TTypeKind.tkString;'
      ''
      
        '  {The number of small block types employed by the default memor' +
        'y manager}'
      '{$ifdef CPU386}'
      '   NumSmallBlockTypes = 55;'
      '{$else}'
      '   NumSmallBlockTypes = 46;'
      '{$endif}'
      ''
      'type'
      '  { Dispatch call descriptor }'
      '  PCallDesc = ^TCallDesc;'
      '  TCallDesc = packed record'
      '    CallType: Byte;'
      '    ArgCount: Byte;'
      '    NamedArgCount: Byte;'
      '    ArgTypes: array[0..255] of Byte;'
      '  end;'
      ''
      '  PDispDesc = ^TDispDesc;'
      '  TDispDesc = packed record'
      '    DispID: Integer;'
      '    ResType: Byte;'
      '    CallDesc: TCallDesc;'
      '  end;'
      ''
      '  PVariantManager = ^TVariantManager;'
      '  TVariantManager = record'
      '    VarClear: procedure(var V : Variant);'
      
        '    VarCopy: procedure(var Dest: Variant; const Source: Variant)' +
        ';'
      '    VarCopyNoInd: procedure; // ARGS PLEASE!'
      
        '    VarCast: procedure(var Dest: Variant; const Source: Variant;' +
        ' VarType: Integer);'
      
        '    VarCastOle: procedure(var Dest: Variant; const Source: Varia' +
        'nt; VarType: Integer);'
      ''
      '    VarToInt: function(const V: Variant): Integer;'
      '    VarToInt64: function(const V: Variant): Int64;'
      '    VarToBool: function(const V: Variant): Boolean;'
      '    VarToReal: function(const V: Variant): Extended;'
      '    VarToCurr: function(const V: Variant): Currency;'
      '    VarToPStr: procedure(var S; const V: Variant);'
      '    VarToLStr: procedure(var S: string; const V: Variant);'
      '    VarToWStr: procedure(var S: _WideStr; const V: Variant);'
      
        '    VarToIntf: procedure(var Unknown: IInterface; const V: Varia' +
        'nt);'
      
        '    VarToDisp: procedure(var Dispatch: IDispatch; const V: Varia' +
        'nt);'
      
        '    VarToDynArray: procedure(var DynArray: Pointer; const V: Var' +
        'iant; TypeInfo: Pointer);'
      ''
      
        '    VarFromInt: procedure(var V: Variant; const Value: Integer; ' +
        'const Range: ShortInt);'
      '    VarFromInt64: procedure(var V: Variant; const Value: Int64);'
      
        '    VarFromBool: procedure(var V: Variant; const Value: Boolean)' +
        ';'
      '    VarFromReal: procedure; // var V: Variant; const Value: Real'
      
        '    VarFromTDateTime: procedure; // var V: Variant; const Value:' +
        ' TDateTime'
      
        '    VarFromCurr: procedure; // var V: Variant; const Value: Curr' +
        'ency'
      
        '    VarFromPStr: procedure(var V: Variant; const Value: _ShortSt' +
        'r);'
      '    VarFromLStr: procedure(var V: Variant; const Value: string);'
      
        '    VarFromWStr: procedure(var V: Variant; const Value: _WideStr' +
        ');'
      
        '    VarFromIntf: procedure(var V: Variant; const Value: IInterfa' +
        'ce);'
      
        '    VarFromDisp: procedure(var V: Variant; const Value: IDispatc' +
        'h);'
      
        '    VarFromDynArray: procedure(var V: Variant; const DynArray: P' +
        'ointer; TypeInfo: Pointer);'
      
        '    OleVarFromPStr: procedure(var V: OleVariant; const Value: _S' +
        'hortStr);'
      
        '    OleVarFromLStr: procedure(var V: OleVariant; const Value: st' +
        'ring);'
      
        '    OleVarFromVar: procedure(var V: OleVariant; const Value: Var' +
        'iant);'
      
        '    OleVarFromInt: procedure(var V: OleVariant; const Value: Int' +
        'eger; const Range: ShortInt);'
      
        '    OleVarFromInt64: procedure(var V: OleVariant; const Value: I' +
        'nt64);'
      ''
      
        '    VarOp: procedure(var Left: Variant; const Right: Variant; Op' +
        'Code: TVarOp);'
      
        '    VarCmp: procedure(const Left, Right: TVarData; const OpCode:' +
        ' TVarOp); { result is set in the flags }'
      '    VarNeg: procedure(var V: Variant);'
      '    VarNot: procedure(var V: Variant);'
      ''
      
        '    DispInvoke: procedure(Dest: PVarData; const Source: TVarData' +
        ';'
      '      CallDesc: PCallDesc; Params: Pointer); cdecl;'
      '    VarAddRef: procedure(var V: Variant);'
      ''
      
        '    VarArrayRedim: procedure(var A : Variant; HighBound: Integer' +
        ');'
      '    VarArrayGet: function(var A: Variant; IndexCount: Integer;'
      '      Indices: Integer): Variant; cdecl;'
      '    VarArrayPut: procedure(var A: Variant; const Value: Variant;'
      '      IndexCount: Integer; Indices: Integer); cdecl;'
      ''
      
        '    WriteVariant: function(var T: Text; const V: Variant; Width:' +
        ' Integer): Pointer;'
      
        '    Write0Variant: function(var T: Text; const V: Variant): Poin' +
        'ter;'
      '  end deprecated;'
      ''
      '  { Dynamic array support }'
      '  PDynArrayTypeInfo = ^TDynArrayTypeInfo;'
      '  {$EXTERNALSYM PDynArrayTypeInfo}'
      '  TDynArrayTypeInfo = packed record'
      '    kind: TTypeKind;'
      '    name: Byte; {string[0];}'
      '    elSize: Integer;'
      '    elType: ^PDynArrayTypeInfo;'
      '    varType: Integer;'
      '  end;'
      '  {$EXTERNALSYM TDynArrayTypeInfo}'
      ''
      '  PVarRec = ^TVarRec;'
      
        '  TVarRec = record { do not pack this record; it is compiler-gen' +
        'erated }'
      '    case Integer of'
      '      0: (case Byte of'
      '            vtInteger:       (VInteger: Integer);'
      '            vtBoolean:       (VBoolean: Boolean);'
      '            vtChar:          (VChar: _AnsiChr);'
      '            vtExtended:      (VExtended: PExtended);'
      '{$IFNDEF NEXTGEN}'
      '            vtString:        (VString: _PShortStr);'
      '{$ENDIF !NEXTGEN}'
      '            vtPointer:       (VPointer: Pointer);'
      '            vtPChar:         (VPChar: _PAnsiChr);'
      '{$IFDEF AUTOREFCOUNT}'
      '            vtObject:        (VObject: Pointer);'
      '{$ELSE}'
      '            vtObject:        (VObject: TObject);'
      '{$ENDIF}'
      '            vtClass:         (VClass: TClass);'
      '            vtWideChar:      (VWideChar: WideChar);'
      '            vtPWideChar:     (VPWideChar: PWideChar);'
      '            vtAnsiString:    (VAnsiString: Pointer);'
      '            vtCurrency:      (VCurrency: PCurrency);'
      '            vtVariant:       (VVariant: PVariant);'
      '            vtInterface:     (VInterface: Pointer);'
      '            vtWideString:    (VWideString: Pointer);'
      '            vtInt64:         (VInt64: PInt64);'
      '            vtUnicodeString: (VUnicodeString: Pointer);'
      '         );'
      '      1: (_Reserved1: NativeInt;'
      '          VType:      Byte;'
      '         );'
      '  end;'
      '  {$NODEFINE PVarRec}   { defined in systvar.h }'
      '  {$NODEFINE TVarRec}   { defined in systvar.h }'
      ''
      '  {$IF defined(PUREPASCAL)}'
      '  {$IF defined(CPUX64) and not defined(MSWINDOWS)}'
      '                                         '
      '  /// <summary>Used to get values of varargs argument.</summary>'
      '  TVarArgList = record'
      '    /// <summary>Internal use only</summary>'
      '    __F1: Int32;'
      '    /// <summary>Internal use only</summary>'
      '    __F2: Int32;'
      '    /// <summary>Internal use only</summary>'
      '    __F3: Pointer;'
      '    /// <summary>Internal use only</summary>'
      '    __F4: Pointer;'
      '  end;'
      '  {$DEFINE RECORD_TVARARGLIST}'
      
        '  {$ELSEIF defined(CPUARM64) and not (defined(IOS) or defined(OS' +
        'X))}'
      '  /// <summary>Used to get values of varargs argument.</summary>'
      '  TVarArgList = record'
      '    /// <summary>Internal use only</summary>'
      '    __Stack: Pointer;'
      '    /// <summary>Internal use only</summary>'
      '    __GR_Top: Pointer;'
      '    /// <summary>Internal use only</summary>'
      '    __VR_Top: Pointer;'
      '    /// <summary>Internal use only</summary>'
      '    __GR_Offs: Integer;'
      '    /// <summary>Internal use only</summary>'
      '    __VR_Offs: Integer;'
      '  end;'
      '  {$DEFINE RECORD_TVARARGLIST}'
      '  {$ELSE CPUX86 or CPUARM or (CPUX64 and MSWINDOWS)}'
      '  /// <summary>Used to get values of varargs argument.</summary>'
      '  TVarArgList = Pointer;'
      '  {$ENDIF}'
      '  // procedure VarArgStart(var ArgList: TVarArgList);'
      
        '  // function  VarArgGetValue(var ArgList: TVarArgList; ArgType:' +
        ' Type): ArgType;'
      
        '  // procedure VarArgCopy(var DestArgList, SrcArgList: TVarArgLi' +
        'st);'
      '  // procedure VarArgEnd(var ArgList: TVarArgList);'
      '  {$ENDIF}'
      ''
      
        '  {The old memory manager structure (for backward compatibility)' +
        '}'
      '  PMemoryManager = ^TMemoryManager;'
      '  TMemoryManager = record'
      '    GetMem: function(Size: NativeInt): Pointer;'
      '    FreeMem: function(P: Pointer): Integer;'
      '    ReallocMem: function(P: Pointer; Size: NativeInt): Pointer;'
      '  end deprecated '#39'Use TMemoryManagerEx'#39';'
      ''
      '  {The new memory manager structure with expanded functionality}'
      '  PMemoryManagerEx = ^TMemoryManagerEx;'
      '  TMemoryManagerEx = record'
      '    {The basic (required) memory manager functionality}'
      '    GetMem: function(Size: NativeInt): Pointer;'
      '    FreeMem: function(P: Pointer): Integer;'
      '    ReallocMem: function(P: Pointer; Size: NativeInt): Pointer;'
      '    {Extended (optional) functionality.}'
      '    AllocMem: function(Size: NativeInt): Pointer;'
      '    RegisterExpectedMemoryLeak: function(P: Pointer): Boolean;'
      '    UnregisterExpectedMemoryLeak: function(P: Pointer): Boolean;'
      '  end;'
      ''
      '  THeapStatus = record'
      '    TotalAddrSpace: NativeUInt;'
      '    TotalUncommitted: NativeUInt;'
      '    TotalCommitted: NativeUInt;'
      '    TotalAllocated: NativeUInt;'
      '    TotalFree: NativeUInt;'
      '    FreeSmall: NativeUInt;'
      '    FreeBig: NativeUInt;'
      '    Unused: NativeUInt;'
      '    Overhead: NativeUInt;'
      '    HeapErrorCode: Cardinal;'
      '  end deprecated;'
      ''
      '  TSmallBlockTypeState = packed record'
      '    {The internal size of the block type}'
      '    InternalBlockSize: Cardinal;'
      
        '    {Useable block size: The number of non-reserved bytes inside' +
        ' the block.}'
      '    UseableBlockSize: Cardinal;'
      '    {The number of allocated blocks}'
      '    AllocatedBlockCount: NativeUInt;'
      
        '    {The total address space reserved for this block type (both ' +
        'allocated and'
      '     free blocks)}'
      '    ReservedAddressSpace: NativeUInt;'
      '  end;'
      
        '  TSmallBlockTypeStates = array[0..NumSmallBlockTypes - 1] of TS' +
        'mallBlockTypeState;'
      ''
      '  TMemoryManagerState = packed record'
      '    {Small block type states}'
      '    SmallBlockTypeStates: TSmallBlockTypeStates;'
      '    {Medium block stats}'
      '    AllocatedMediumBlockCount: Cardinal;'
      '    TotalAllocatedMediumBlockSize: NativeUInt;'
      '    ReservedMediumBlockAddressSpace: NativeUInt;'
      '    {Large block stats}'
      '    AllocatedLargeBlockCount: Cardinal;'
      '    TotalAllocatedLargeBlockSize: NativeUInt;'
      '    ReservedLargeBlockAddressSpace: NativeUInt;'
      '  end;'
      ''
      '  PMonitorSupport = ^TMonitorSupport;'
      '  TMonitorSupport = record'
      
        '    // Obtain a synchronization object - usually an auto-reset e' +
        'vent or semaphore'
      '    NewSyncObject: function: Pointer;'
      
        '    // Free the synchronization object obtained from NewSyncObje' +
        'ct'
      '    FreeSyncObject: procedure (SyncObject: Pointer);'
      
        '    // Obtain a wait object - usually an auto-reset event or sem' +
        'aphore - these should be cached'
      '    NewWaitObject: function: Pointer;'
      
        '    // Return the wait object from NewWaitObject back to the cac' +
        'he'
      '    FreeWaitObject: procedure (WaitObject: Pointer);'
      
        '    // Wait for either a SyncObject or WaitObject or signal an o' +
        'bject'
      
        '    // o WaitOrSignalObject(nil, Obj, Timeout); - Wait for <Time' +
        'out> time or until <Obj> is signaled'
      
        '    // o WaitOrSignalObject(Obj, nil, 0); - Signal <Obj> and ret' +
        'urn. Timeout and WaitObject params ignored.'
      
        '    WaitOrSignalObject: function (SignalObject, WaitObject: Poin' +
        'ter; Timeout: Cardinal): Cardinal;'
      '  end;'
      ''
      '  { Opaque pointer wrapper }'
      '  TPtrWrapper = record'
      '  private'
      '    Value: PByte;'
      '    class function GetNilValue: TPtrWrapper; inline; static;'
      '  public'
      '    constructor Create(AValue: NativeInt); overload;'
      '    constructor Create(AValue: Pointer); overload;'
      ''
      '    function ToPointer: Pointer; inline;'
      '    function ToInteger: NativeInt; inline;'
      ''
      '    class property NilValue: TPtrWrapper read GetNilValue;'
      ''
      
        '    class operator Equal(Left, Right: TPtrWrapper): Boolean; inl' +
        'ine;'
      
        '    class operator NotEqual(Left, Right: TPtrWrapper): Boolean; ' +
        'inline;'
      '  end;'
      ''
      '  { Low level marshalling }'
      '  TMarshal = class(TObject)'
      '    constructor Create;'
      ''
      
        '    // Internal legacy: uses should probably be rewritten using ' +
        'TMarshaller.'
      
        '    class function InString(const S: string): MarshaledString; o' +
        'verload; inline; static;'
      
        '    class function OutString(const S: string): MarshaledString; ' +
        'overload; inline; static;'
      
        '    class function InOutString(const S: string): MarshaledString' +
        '; overload; inline; static;'
      
        '    class function AsAnsi(const S: string): _AnsiStr; overload; ' +
        'inline; static;'
      
        '    class function AsAnsi(S: PWideChar): _AnsiStr; overload; inl' +
        'ine; static;'
      ''
      '    // Memory allocation'
      '    class function AllocMem(Size: NativeInt): TPtrWrapper;'
      
        '    class function ReallocMem(OldPtr: TPtrWrapper; NewSize: Nati' +
        'veInt): TPtrWrapper;'
      '    class procedure FreeMem(Ptr: TPtrWrapper);'
      ''
      '    // Plain data in and out, via arrays'
      
        '    class procedure Copy(const Src: TArray<Byte>; StartIndex: In' +
        'teger; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; var Dest: TArra' +
        'y<Byte>; StartIndex: Integer; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TArray<Char>; StartIndex: In' +
        'teger; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; var Dest: TArra' +
        'y<Char>; StartIndex: Integer; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TArray<Word>; StartIndex: In' +
        'teger; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; var Dest: TArra' +
        'y<Word>; StartIndex: Integer; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TArray<Shortint>; StartIndex' +
        ': Integer; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; var Dest: TArra' +
        'y<Shortint>; StartIndex: Integer; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TArray<Smallint>; StartIndex' +
        ': Integer; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; var Dest: TArra' +
        'y<Smallint>; StartIndex: Integer; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TArray<Integer>; StartIndex:' +
        ' Integer; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; var Dest: TArra' +
        'y<Integer>; StartIndex: Integer; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TArray<Int64>; StartIndex: I' +
        'nteger; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; var Dest: TArra' +
        'y<Int64>; StartIndex: Integer; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TArray<TPtrWrapper>; StartIn' +
        'dex: Integer; Dest: TPtrWrapper; Count: Integer); overload;'
      
        '    class procedure Copy(const Src: TPtrWrapper; Dest: TArray<TP' +
        'trWrapper>; StartIndex: Integer; Count: Integer); overload;'
      ''
      
        '    // Plain data in and out, via singular elements, to avoid ne' +
        'eding arrays'
      
        '    class function ReadByte(const Ptr: TPtrWrapper; Ofs: NativeI' +
        'nt = 0): Byte;'
      
        '    class function ReadInt16(const Ptr: TPtrWrapper; Ofs: Native' +
        'Int = 0): Smallint;'
      
        '    class function ReadInt32(const Ptr: TPtrWrapper; Ofs: Native' +
        'Int = 0): Integer;'
      
        '    class function ReadInt64(const Ptr: TPtrWrapper; Ofs: Native' +
        'Int = 0): Int64;'
      
        '    class function ReadPtr(const Ptr: TPtrWrapper; Ofs: NativeIn' +
        't = 0): TPtrWrapper;'
      ''
      
        '    class procedure WriteByte(const Ptr: TPtrWrapper; Ofs: Nativ' +
        'eInt; Value: Byte); overload;'
      
        '    class procedure WriteInt16(const Ptr: TPtrWrapper; Ofs: Nati' +
        'veInt; Value: Smallint); overload;'
      
        '    class procedure WriteInt32(const Ptr: TPtrWrapper; Ofs: Nati' +
        'veInt; Value: Integer); overload;'
      
        '    class procedure WriteInt64(const Ptr: TPtrWrapper; Ofs: Nati' +
        'veInt; Value: Int64); overload;'
      
        '    class procedure WritePtr(const Ptr: TPtrWrapper; Ofs: Native' +
        'Int; const Value: TPtrWrapper); overload;'
      ''
      
        '    class procedure WriteByte(const Ptr: TPtrWrapper; Value: Byt' +
        'e); overload;'
      
        '    class procedure WriteInt16(const Ptr: TPtrWrapper; Value: Sm' +
        'allint); overload;'
      
        '    class procedure WriteInt32(const Ptr: TPtrWrapper; Value: In' +
        'teger); overload;'
      
        '    class procedure WriteInt64(const Ptr: TPtrWrapper; Value: In' +
        't64); overload;'
      
        '    class procedure WritePtr(const Ptr, Value: TPtrWrapper); ove' +
        'rload;'
      ''
      
        '    // A moderately wrapped version of System.Move, to discourag' +
        'e use.'
      
        '    class procedure Move(const Src, Dest: TPtrWrapper; Count: Na' +
        'tiveInt); inline;'
      ''
      '    // Direct referencing of array data'
      
        '    class function FixArray<T>(const Arr: TArray<T>): TPtrWrappe' +
        'r; overload;'
      
        '    class procedure UnfixArray<T>(ArrPtr: TPtrWrapper); overload' +
        ';'
      ''
      '    // Direct referencing of Unicode string data'
      
        '    class function FixString(var Str: string): TPtrWrapper; over' +
        'load;'
      '    class procedure UnfixString(Ptr: TPtrWrapper); overload;'
      
        '    // Direct reference to string that may be shared; returned v' +
        'alue still needs disposal with UnfixString.'
      
        '    class function UnsafeFixString(const Str: string): TPtrWrapp' +
        'er; overload;'
      ''
      '    // Direct and unsafe referencing of random data.'
      '    class function UnsafeAddrOf(var Value): TPtrWrapper; inline;'
      ''
      
        '    // Copy string to newly allocated buffer (needs to be freed ' +
        'with .FreeMem)'
      
        '    class function AllocStringAsAnsi(const Str: string): TPtrWra' +
        'pper; overload;'
      
        '    class function AllocStringAsAnsi(const Str: string; CodePage' +
        ': Word): TPtrWrapper; overload;'
      
        '    class function AllocStringAsUnicode(const Str: string): TPtr' +
        'Wrapper;'
      
        '    class function AllocStringAsAnsi(S: PWideChar): TPtrWrapper;' +
        ' overload;'
      
        '    class function AllocStringAsAnsi(S: PWideChar; CodePage: Wor' +
        'd): TPtrWrapper; overload;'
      
        '    class function AllocStringAsUtf8(const Str: string): TPtrWra' +
        'pper; overload;'
      
        '    class function AllocStringAsUtf8(S: PWideChar): TPtrWrapper;' +
        ' overload;'
      ''
      
        '    // Copy string from buffer; Len = number of characters to re' +
        'ad from Ptr, or -1 to read until null terminator.'
      
        '    class function ReadStringAsAnsi(Ptr: TPtrWrapper; Len: Integ' +
        'er = -1): string; overload;'
      
        '    class function ReadStringAsAnsi(CodePage: Word; Ptr: TPtrWra' +
        'pper; Len: Integer = -1): string; overload;'
      
        '    class function ReadStringAsUnicode(Ptr: TPtrWrapper; Len: In' +
        'teger = -1): string;'
      
        '    class function ReadStringAsUtf8(Ptr: TPtrWrapper; Len: Integ' +
        'er = -1): string;'
      ''
      
        '    // Copy string from buffer; MaxLen = maximum number of chara' +
        'cters to read from Ptr before null terminator.'
      
        '    class function ReadStringAsAnsiUpTo(CodePage: Word; Ptr: TPt' +
        'rWrapper; MaxLen: Integer): string;'
      
        '    class function ReadStringAsUnicodeUpTo(Ptr: TPtrWrapper; Max' +
        'Len: Integer): string;'
      
        '    class function ReadStringAsUtf8UpTo(Ptr: TPtrWrapper; MaxLen' +
        ': Integer): string;'
      ''
      '    // Copy string to buffer'
      
        '    // Specify -1 for MaxCharsIncNull and the entire string will' +
        ' be written.'
      
        '    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; const Va' +
        'lue: string; MaxCharsIncNull: Integer); overload;'
      
        '    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; const Va' +
        'lue: string; MaxCharsIncNull: Integer; CodePage: Word); overload' +
        ';'
      
        '    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs: Nat' +
        'iveInt; const Value: string; MaxCharsIncNull: Integer); overload' +
        ';'
      
        '    class procedure WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs: Nat' +
        'iveInt; const Value: string; MaxCharsIncNull: Integer; CodePage:' +
        ' Word); overload;'
      
        '    class procedure WriteStringAsUnicode(Ptr: TPtrWrapper; const' +
        ' Value: string; MaxCharsIncNull: Integer); overload;'
      
        '    class procedure WriteStringAsUnicode(Ptr: TPtrWrapper; Ofs: ' +
        'NativeInt; const Value: string; MaxCharsIncNull: Integer); overl' +
        'oad;'
      
        '    class procedure WriteStringAsUtf8(Ptr: TPtrWrapper; const Va' +
        'lue: string; MaxCharsIncNull: Integer); overload;'
      
        '    class procedure WriteStringAsUtf8(Ptr: TPtrWrapper; Ofs: Nat' +
        'iveInt; const Value: string; MaxCharsIncNull: Integer); overload' +
        ';'
      '  end;'
      '  {$NODEFINE TMarshal}'
      ''
      '  {Memory map}'
      '  TChunkStatus = (csUnallocated, csAllocated, csReserved,'
      '    csSysAllocated, csSysReserved);'
      '  TMemoryMap = array[0..65535] of TChunkStatus;'
      ''
      '  {Block alignment options}'
      '  TMinimumBlockAlignment = (mba8Byte, mba16Byte);'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      
        '                                                                ' +
        '                     '
      '  PUnwinder = ^TUnwinder;'
      '  TUnwinder = record'
      '    RaiseException: function(Exc: Pointer): LongBool; cdecl;'
      
        '    RegisterIPLookup: function(fn: Pointer; StartAddr, EndAddr: ' +
        'NativeUInt; Context: Pointer; GOT: NativeUInt): LongBool; cdecl;'
      '    UnregisterIPLookup: procedure(StartAddr: NativeUInt) cdecl;'
      
        '    DelphiLookup: function(Addr: NativeUInt; Context: Pointer): ' +
        'Pointer; cdecl;'
      
        '    ClosestHandler: function(Context: Pointer): NativeUInt; cdec' +
        'l;'
      '  end;'
      '  TFrameUnwinder = Pointer;'
      
        '                                                                ' +
        '                           '
      
        '  TUnwinderLookup = function(Addr: NativeUInt; Context: Pointer)' +
        ': TFrameUnwinder; cdecl;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '  PackageUnitEntry = packed record'
      '    Init, FInit : Pointer;'
      '  end;'
      ''
      
        '  { Compiler generated table to be processed sequentially to ini' +
        't & finit all package units }'
      
        '  { Init: 0..Max-1; Final: Last Initialized..0                  ' +
        '                            }'
      '  UnitEntryTable = array [0..9999999] of PackageUnitEntry;'
      '  PUnitEntryTable = ^UnitEntryTable;'
      
        '  { Pointer in this table is PPTypeInfo, except when it'#39's not; i' +
        'f the value is 1,'
      
        '    then it'#39's a "unit boundary" marker, indicating that followin' +
        'g types are in'
      
        '    the next unit along in the TPackageTypeInfo.UnitNames unit n' +
        'ame list sequence. }'
      
        '  TTypeTable = array[0..MaxInt div SizeOf(Pointer) - 1] of Point' +
        'er;'
      '  PTypeTable = ^TTypeTable;'
      ''
      '  {$NODEFINE UnitEntryTable}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      
        '  (*$HPPEMIT '#39'    typedef struct PackageUnitEntry UnitEntryTable' +
        ';'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      ''
      '  PPackageTypeInfo = ^TPackageTypeInfo;'
      '  TPackageTypeInfo = record'
      '    TypeCount: Integer;'
      '    TypeTable: PTypeTable;'
      '    UnitCount: Integer;'
      
        '    UnitNames: _PShortStr; { concatenation of Pascal strings, on' +
        'e for each unit }'
      '  end;'
      ''
      '  PackageInfoTable = record'
      
        '    UnitCount: Integer;      { number of entries in UnitInfo arr' +
        'ay; always > 0 }'
      '    UnitInfo: PUnitEntryTable;'
      '    TypeInfo: TPackageTypeInfo;'
      '  end;'
      ''
      '  PackageInfo = ^PackageInfoTable;'
      ''
      
        '  { Each package exports a '#39'@GetPackageInfoTable'#39' which can be u' +
        'sed to retrieve }'
      
        '  { the table which contains compiler generated information abou' +
        't the package DLL }'
      '  GetPackageInfoTable = function : PackageInfo;'
      ''
      '{$IFDEF DEBUG_FUNCTIONS}'
      
        '{ Inspector Query; implementation in GETMEM.INC; no need to cond' +
        'itionalize that }'
      '  THeapBlock = record'
      '    Start: Pointer;'
      '    Size: Cardinal;'
      '  end;'
      ''
      '  THeapBlockArray = array of THeapBlock;'
      '  TObjectArray = array of TObject;'
      ''
      'function GetHeapBlocks: THeapBlockArray;'
      
        'function FindObjects(AClass: TClass; FindDerived: Boolean): TObj' +
        'ectArray;'
      '{ Inspector Query }'
      '{$ENDIF}'
      ''
      '{'
      
        '  When an exception is thrown, the exception object that is thro' +
        'wn is destroyed'
      
        '  automatically when the except clause which handles the excepti' +
        'on is exited.'
      
        '  There are some cases in which an application may wish to acqui' +
        're the thrown'
      
        '  object and keep it alive after the except clause is exited.  F' +
        'or this purpose,'
      
        '  we have added the AcquireExceptionObject and ReleaseExceptionO' +
        'bject functions.'
      
        '  These functions maintain a reference count on the most current' +
        ' exception object,'
      
        '  allowing applications to legitimately obtain references.  If t' +
        'he reference count'
      
        '  for an exception that is being thrown is positive when the exc' +
        'ept clause is exited,'
      
        '  then the thrown object is not destroyed by the RTL, but assume' +
        'd to be in control'
      
        '  of the application.  It is then the application'#39's responsibili' +
        'ty to destroy the'
      
        '  thrown object.  If the reference count is zero, then the RTL w' +
        'ill destroy the'
      '  thrown object when the except clause is exited.'
      '}'
      'function AcquireExceptionObject: TObject;'
      'procedure ReleaseExceptionObject;'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure GetUnwinder(var Dest: TUnwinder);'
      'procedure SetUnwinder(const NewUnwinder: TUnwinder);'
      'function IsUnwinderSet: Boolean;'
      ''
      
        '//function SysRegisterIPLookup(ModuleHandle, StartAddr, EndAddr:' +
        ' LongInt; Context: Pointer; GOT: LongInt): LongBool;'
      '{'
      '  Do NOT call these functions.  They are for internal use only:'
      '    SysRegisterIPLookup'
      '    SysUnregisterIPLookup'
      '    BlockOSExceptions'
      '    UnblockOSExceptions'
      '    AreOSExceptionsBlocked'
      '}'
      
        '                                                                ' +
        '                     '
      
        'function SysRegisterIPLookup(StartAddr, EndAddr: NativeUInt; Con' +
        'text: Pointer; GOT: NativeUInt): LongBool;'
      
        'function SysRegisterIPLookupFunc(StartAddr, EndAddr: NativeUInt;' +
        ' Context: Pointer; GOT: NativeUInt;'
      
        '                            UnwinderLookup: TUnwinderLookup): Lo' +
        'ngBool;'
      'procedure SysUnregisterIPLookup(StartAddr: NativeUInt);'
      '//function SysAddressIsInPCMap(Addr: NativeUInt): Boolean;'
      'function SysClosestDelphiHandler(Context: Pointer): NativeUInt;'
      'procedure BlockOSExceptions;'
      'procedure UnblockOSExceptions;'
      'function AreOSExceptionsBlocked: Boolean;'
      ''
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IF DEFINED(STACK_BASED_EXCEPTIONS) OR DEFINED(WIN64)}'
      
        '// These functions are not portable.  Use AcquireExceptionObject' +
        ' above instead'
      
        'function RaiseList: Pointer; deprecated '#39'Use AcquireExceptionObj' +
        'ect'#39';  { Stack of current exception objects }'
      
        'function SetRaiseList(NewPtr: Pointer): Pointer; deprecated '#39'Use' +
        ' AcquireExceptionObject'#39';  { returns previous value }'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      
        'function ExceptObject: TObject {$IFDEF AUTOREFCOUNT} unsafe {$EN' +
        'DIF};'
      'function ExceptAddr: Pointer;'
      ''
      '{$IFDEF MSWINDOWS}'
      '{'
      
        '  Coverage support.  These are internal use structures reference' +
        'd by compiler'
      '  helper functions for QA coverage support.'
      '}'
      'type'
      '    TCVModInfo = packed record'
      '        ModName: _PAnsiChr;'
      '        LibName: _PAnsiChr;'
      '        UserData: Pointer;'
      '        end;'
      '    PCVModInfo = ^TCVModInfo;'
      ''
      '{$EXTERNALSYM _CVR_PROBE}'
      'procedure _CVR_PROBE(mi: PCVModInfo; probeNum: Cardinal); cdecl;'
      '{$EXTERNALSYM _CVR_STMTPROBE}'
      
        'function _CVR_STMTPROBE(mi: PCVModInfo; probeNum: Cardinal; True' +
        'False: Cardinal): Boolean; cdecl;'
      '{$ENDIF MSWINDOWS}'
      ''
      'type'
      '  TAssertErrorProc = procedure (const Message, Filename: string;'
      '    LineNumber: Integer; ErrorAddr: Pointer);'
      
        '  TSafeCallErrorProc = procedure (ErrorCode: HResult; ErrorAddr:' +
        ' Pointer);'
      
        '  TRaiseExceptionProc = procedure (ExceptionCode, ExceptionFlags' +
        ': UInt32;'
      '    NumberOfArguments: UInt32; Args: Pointer); stdcall;'
      ''
      '{$IFDEF DEBUG}'
      '{'
      
        '  This variable is just for debugging the exception handling sys' +
        'tem.  See'
      '  _DbgExcNotify for the usage.'
      '}'
      'var'
      '  ExcNotificationProc : procedure(NotificationKind: Integer;'
      '                                  ExceptionObject: Pointer;'
      '                                  ExceptionName: _PShortStr;'
      '                                  ExceptionLocation: Pointer;'
      '                                  HandlerAddr: Pointer) = nil;'
      '{$ENDIF DEBUG}'
      ''
      'var'
      '  DispCallByIDProc: Pointer;'
      '  ExceptProc: Pointer;    { Unhandled exception handler }'
      
        '  ErrorProc: procedure (ErrorCode: Byte; ErrorAddr: Pointer);   ' +
        '  { Error handler procedure }'
      '{$IFDEF MSWINDOWS}'
      
        '  ExceptClsProc: Pointer; { Map an OS Exception to a Delphi clas' +
        's reference }'
      
        '  ExceptObjProc: Pointer; { Map an OS Exception to a Delphi clas' +
        's instance }'
      '{$IF defined(CPU386)}'
      '  RaiseExceptionProc: Pointer;'
      '{$ELSE}'
      '  RaiseExceptionProc: TRaiseExceptionProc;'
      '{$ENDIF}'
      '  RTLUnwindProc: Pointer;'
      '{$ENDIF MSWINDOWS}'
      
        '  RaiseExceptObjProc: Pointer; { notify of the raise of an excep' +
        'tion object }'
      
        '  ExceptionAcquired: Pointer; { notification that a given except' +
        'ion object has been "acquired" (C++)}'
      
        '  ExceptionClass: TClass; { Exception base class (must be Except' +
        'ion) }'
      
        '  SafeCallErrorProc: TSafeCallErrorProc; { Safecall error handle' +
        'r }'
      '  AssertErrorProc: TAssertErrorProc; { Assertion error handler }'
      
        '  ExitProcessProc: procedure; { Hook to be called just before th' +
        'e process actually exits }'
      
        '  AbstractErrorProc: procedure; { Abstract method error handler ' +
        '}'
      '{$IFDEF MSWINDOWS}'
      
        '  HPrevInst: LongWord deprecated;    { Handle of previous instan' +
        'ce - HPrevInst cannot be tested for multiple instances in Win32}'
      '{$ENDIF}'
      
        '  MainInstance: THandle;    { Handle of the main(.EXE) HInstance' +
        ' }'
      '{$IFDEF MSWINDOWS}'
      '  {$NODEFINE MainInstance}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      
        '  (*$HPPEMIT '#39'    extern DELPHI_PACKAGE HINSTANCE MainInstance;'#39 +
        ' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      '{$ENDIF}'
      
        '  MainThreadID: TThreadID;  { ThreadID of thread that module was' +
        ' initialized in }'
      '  IsLibrary: Boolean;       { True if module is a DLL }'
      '{$IFDEF MSWINDOWS}'
      
        '  CmdShow: Integer platform;{ CmdShow parameter for CreateWindow' +
        ' }'
      '  CmdLine: PChar platform;  { Command line pointer }'
      '{$ENDIF MSWINDOWS}'
      
        '  InitProc: Pointer;        { Last installed initialization proc' +
        'edure }'
      '  ExitCode: Integer = 0;    { Program result }'
      '  ExitProc: Pointer;        { Last installed exit procedure }'
      '  ErrorAddr: Pointer = nil; { Address of run-time error }'
      '  RandSeed: Integer = 0;    { Base for random number generator }'
      '  IsConsole: Boolean;       { True if compiled as console app }'
      '  IsMultiThread: Boolean;   { True if more than one thread }'
      '  FileMode: Byte = 2;       { Standard mode for opening files }'
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      
        '  FileAccessRights: Integer platform; { Default access rights fo' +
        'r opening files }'
      '  ArgCount: Integer platform;'
      '  ArgValues: _PPAnsiChr platform;'
      '  envp: PPChar platform;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      '{$IF defined(CPUX86) or defined(CPUX64)}'
      
        '  Test8086: Byte;           { CPU family (minus one) See consts ' +
        'below }'
      
        '  Test8087: Byte = 3;       { assume 80387 FPU or OS supplied FP' +
        'U emulation }'
      
        '  TestFDIV: Shortint;       { -1: Flawed Pentium, 0: Not determi' +
        'ned, 1: Ok }'
      
        '  TestSSE: Cardinal;        { 0: no SSE, 1st bit: SSE available,' +
        ' 2nd bit: SSE2 available }'
      '{$ENDIF defined(CPUX86) or defined(CPUX64)}'
      '  CPUCount: Integer;        { Number of CPU Cores detected }'
      '  Input: Text;              { Standard input }'
      '  Output: Text;             { Standard output }'
      '  ErrOutput: Text;          { Standard error output }'
      ''
      
        '  VarClearProc:  procedure (var v: TVarData) = nil; // for inter' +
        'nal use only'
      
        '  VarAddRefProc: procedure (var v: TVarData) = nil; // for inter' +
        'nal use only'
      
        '  VarCopyProc:   procedure (var Dest: TVarData; const Source: TV' +
        'arData) = nil; // for internal use only'
      
        '  VarToLStrProc: procedure (var Dest: _AnsiStr; const Source: TV' +
        'arData; CodePage: Word = 0) = nil;   // for internal use only'
      '{$IFNDEF NEXTGEN}'
      
        '  VarToWStrProc: procedure (var Dest: _WideStr; const Source: TV' +
        'arData) = nil;   // for internal use only'
      '{$ENDIF !NEXTGEN}'
      
        '  VarToUStrProc: procedure (var Dest: UnicodeString; const Sourc' +
        'e: TVarData) = nil;// for internal use only'
      ''
      '  MonitorSupport: PMonitorSupport;'
      '  {$EXTERNALSYM MonitorSupport}'
      ''
      '{$IFDEF MSWINDOWS}'
      
        '  DLLShutdownProc: procedure = nil;     { Shutdown procedure for' +
        ' DLL }'
      ''
      'procedure DLLShutdown; stdcall;'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IF Defined(CPUX86) or Defined(CPUX64)}'
      'const'
      '  CPUi386     = 2;'
      '  CPUi486     = 3;'
      '  CPUPentium  = 4;'
      ''
      'type'
      '  TCPUIDRec = record'
      '    EAX, EBX, ECX, EDX: UInt32;'
      '  end platform;'
      ''
      'var'
      '  CPUIDTable: array[0..7] of TCPUIDRec platform;'
      ''
      
        'function GetCPUID(FunctionID: UInt32; SubFunctionID: UInt32 = 0)' +
        ': TCPUIDRec; platform;'
      ''
      '{$ENDIF }'
      ''
      '{$IF defined(WIN32) or defined(WIN64)}'
      'var'
      '  ERMSBThreshold: NativeInt = High(NativeInt);'
      '{$ENDIF defined(WIN32) or defined(WIN64)}'
      ''
      '{$IF Defined(CPUARM)}'
      'var'
      
        '  DefaultFPSCR: UInt32 platform = $00000700; { Default FPSCR reg' +
        'ister setting.'
      
        '                                 Disable Flush to Zero, RN and E' +
        'nable Invalid, Zero-div'
      '                                 and overflow exception. }'
      
        '{$ELSEIF (Defined(CPUX86) or Defined(CPUX64)) and not Defined(AR' +
        'ITH_USE_LIBM)}'
      'var'
      
        '  Default8087CW: Word platform = {$IF Defined(OSX)}$1333{$ELSE}$' +
        '1332{$ENDIF};'
      
        '                              { Default 8087 control word. FPU c' +
        'ontrol register is'
      '                                set to this value.'
      
        '                                Note: For macOS, Invalid Operati' +
        'on is masked to'
      
        '                                support the latest macOS.varEmpt' +
        'y'
      
        '                                CAUTION:  Setting this to an inv' +
        'alid value'
      
        '                                could cause unpredictable behavi' +
        'or. }'
      
        '  DefaultMXCSR: UInt32 platform = $1900; { Default MXCSR control' +
        ' word.  SSE control'
      '                                register is set to this value.'
      
        '                                CAUTION:  Setting this to an inv' +
        'alid value'
      
        '                                could cause unpredictable behavi' +
        'or. }'
      '{$ELSEIF Defined(CPUX64) and Defined(ARITH_USE_LIBM)}'
      'var'
      
        '  DefaultFPEnv: UInt32 platform = $0032; { Default FP environmen' +
        't value for Linux64.'
      
        '                                Both FPU and SSE are used on Lin' +
        'ux64.'
      
        '                                Only exception masks and roundin' +
        'g control bits are available. }'
      '{$ENDIF CPUARM or CPUX86 or CPUX64}'
      'var'
      
        '  HeapAllocFlags: Word platform = 2;   { Heap allocation flags, ' +
        'gmem_Moveable }'
      
        '  DebugHook: Byte platform = 0;        { 1 to notify debugger of' +
        ' non-Delphi exceptions'
      
        '                                >1 to notify debugger of excepti' +
        'on unwinding }'
      
        '  JITEnable: Byte platform = 0;        { 1 to call UnhandledExce' +
        'ptionFilter if the exception'
      '                                is not a Pascal exception.'
      
        '                                >1 to call UnhandledExceptionFil' +
        'ter for all exceptions }'
      
        '  NoErrMsg: Boolean platform = False;  { True causes the base RT' +
        'L to not display the message box'
      '                                when a run-time error occurs }'
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      
        '                              { CoreDumpEnabled = True will caus' +
        'e unhandled'
      
        '                                exceptions and runtime errors to' +
        ' raise a'
      
        '                                SIGABRT signal, which will cause' +
        ' the OS to'
      
        '                                coredump the process address spa' +
        'ce.  This can'
      
        '                                be useful for postmortem debuggi' +
        'ng. }'
      '  CoreDumpEnabled: Boolean platform = False;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      '  DefaultSystemCodePage: Integer;'
      
        '  DefaultUnicodeCodePage: Integer; { Used by _NewUnicodeString t' +
        'o set the codePage field of strRec }'
      '{$IFDEF MSWINDOWS}'
      '  UTF8CompareLocale: Cardinal;'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF POSIX}'
      '{$IF defined(USE_LIBICU)}'
      'function UTF8CompareCollator: Pointer;'
      'function UTF8CompareLocale: MarshaledAString;'
      '{$ELSE}'
      'function UTF8CompareLocale: Pointer;'
      '{$ENDIF defined(USE_LIBICU)}'
      '{$IF not defined(USE_LIBICU) or defined(LINUX)}'
      'function UTF8CompareLocaleName: MarshaledAString;'
      '{$ENDIF not defined(USE_LIBICU) or defined(LINUX)}'
      
        'function SetUTF8CompareLocale(const LocaleName: string): Boolean' +
        '; platform;'
      '{$ELSE}'
      'procedure SetUTF8CompareLocale; platform;'
      '{$ENDIF}'
      ''
      'type'
      '  TTextLineBreakStyle = (tlbsLF, tlbsCRLF);'
      ''
      
        'var   { Text output line break handling.  Default value for all ' +
        'text files }'
      
        '  DefaultTextLineBreakStyle: TTextLineBreakStyle = {$IFDEF POSIX' +
        '} tlbsLF {$ENDIF}'
      
        '                                                 {$IFDEF MSWINDO' +
        'WS} tlbsCRLF {$ENDIF};'
      'const'
      '   sLineBreak = {$IFDEF POSIX} _AnsiStr(#10) {$ENDIF}'
      '       {$IFDEF MSWINDOWS} _AnsiStr(#13#10) {$ENDIF};'
      ''
      ''
      'type'
      '  HRSRC = THandle;              { from windef.h / winnt.h }'
      '  TResourceHandle = HRSRC;   // make an opaque handle type'
      '  HINST = THandle;              { HINSTANCE from widnef.h }'
      '  HMODULE = HINST;              { from windef.h }'
      '  HGLOBAL = THandle;            { from windef.h }'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM HRSRC}'
      '  {$IF defined(WEAK_NATIVEINT)}'
      '  {$NODEFINE HINST '#39'HINSTANCE'#39'}'
      '  {$ELSE}'
      '  {$NODEFINE HINST}'
      '  {$ENDIF}'
      '  {$EXTERNALSYM HMODULE}'
      '  {$EXTERNALSYM HGLOBAL}'
      '{$ENDIF}'
      ''
      
        'function FindResource(ModuleHandle: HMODULE; ResourceName, Resou' +
        'rceType: PChar): TResourceHandle; {$IFDEF MSWINDOWS} stdcall; {$' +
        'ENDIF}'
      
        'function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourc' +
        'eHandle): HGLOBAL; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}'
      
        'function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResou' +
        'rceHandle): Integer; {$IFDEF MSWINDOWS} stdcall; {$ENDIF}'
      
        'function LockResource(ResData: HGLOBAL): Pointer; {$IFDEF MSWIND' +
        'OWS} stdcall; {$ENDIF}'
      'function UnlockResource(ResData: HGLOBAL): LongBool; inline;'
      
        'function FreeResource(ResData: HGLOBAL): LongBool; {$IFDEF MSWIN' +
        'DOWS} stdcall; {$ENDIF}'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM FindResource}'
      '  {$EXTERNALSYM LoadResource}'
      '  {$EXTERNALSYM SizeofResource}'
      '  {$EXTERNALSYM LockResource}'
      '  {$EXTERNALSYM UnlockResource}'
      '  {$EXTERNALSYM FreeResource}'
      '{$ENDIF}'
      ''
      '{ Memory manager support }'
      ''
      
        'procedure GetMemoryManager(var MemMgr: TMemoryManager); overload' +
        '; deprecated;'
      
        'procedure SetMemoryManager(const MemMgr: TMemoryManager); overlo' +
        'ad; deprecated;'
      
        'procedure GetMemoryManager(var MemMgrEx: TMemoryManagerEx); over' +
        'load;'
      
        'procedure SetMemoryManager(const MemMgrEx: TMemoryManagerEx); ov' +
        'erload;'
      'function IsMemoryManagerSet: Boolean;'
      ''
      'function SysGetMem(Size: NativeInt): Pointer;'
      'function SysFreeMem(P: Pointer): Integer;'
      'function SysReallocMem(P: Pointer; Size: NativeInt): Pointer;'
      'function SysAllocMem(Size: NativeInt): Pointer;'
      'function SysRegisterExpectedMemoryLeak(P: Pointer): Boolean;'
      'function SysUnregisterExpectedMemoryLeak(P: Pointer): Boolean;'
      ''
      
        '{ AllocMem allocates a block of the given size on the heap. Each' +
        ' byte in'
      
        '  the allocated buffer is set to zero. To dispose the buffer, us' +
        'e the'
      '  FreeMem standard procedure. }'
      ''
      'function AllocMem(Size: NativeInt): Pointer;'
      ''
      'var'
      ''
      '  AllocMemCount: Integer deprecated; {Unsupported}'
      '  AllocMemSize: Integer deprecated; {Unsupported}'
      ''
      
        '{Set this variable to true to report memory leaks on shutdown. T' +
        'his setting'
      
        ' has no effect if this module is sharing a memory manager owned ' +
        'by another'
      ' module.}'
      '  ReportMemoryLeaksOnShutdown: Boolean;'
      ''
      
        '{Set this variable to true to employ a "busy waiting" loop inste' +
        'ad of putting'
      
        ' the thread to sleep if a thread contention occurs inside the me' +
        'mory manager.'
      
        ' This may improve performance on multi-CPU systems with a relati' +
        'vely low thread'
      ' count, but will hurt performance otherwise.}'
      '  NeverSleepOnMMThreadContention: Boolean;'
      ''
      '{$IFDEF MSWINDOWS}'
      
        'function GetHeapStatus: THeapStatus; platform; deprecated; {Unsu' +
        'pported}'
      ''
      
        '{Returns information about the current state of the memory manag' +
        'er}'
      
        'procedure GetMemoryManagerState(var AMemoryManagerState: TMemory' +
        'ManagerState); platform;'
      ''
      '{Gets the state of every 64K block in the 4GB address space}'
      'procedure GetMemoryMap(var AMemoryMap: TMemoryMap); platform;'
      ''
      
        '{Registers expected memory leaks. Returns true on success. The l' +
        'ist of leaked'
      
        ' blocks is limited in size, so failure is possible if the list i' +
        's full.}'
      
        'function RegisterExpectedMemoryLeak(P: Pointer): Boolean; platfo' +
        'rm;'
      ''
      
        '{Removes expected memory leaks. Returns true if the previously r' +
        'egistered leak'
      ' was found and removed.}'
      
        'function UnregisterExpectedMemoryLeak(P: Pointer): Boolean; plat' +
        'form;'
      ''
      
        '{Set the minimum block alignment. In the current implementation ' +
        'blocks >=160'
      
        ' bytes will always be at least 16 byte aligned, even if only 8-b' +
        'yte alignment'
      ' (the default) is required.}'
      
        'function GetMinimumBlockAlignment: TMinimumBlockAlignment; platf' +
        'orm;'
      
        'procedure SetMinimumBlockAlignment(AMinimumBlockAlignment: TMini' +
        'mumBlockAlignment); platform;'
      ''
      
        '{Searches the current process for a shared memory manager. If no' +
        ' memory has'
      
        ' been allocated using this memory manager it will switch to usin' +
        'g the shared'
      
        ' memory manager instead. Returns true if another memory manager ' +
        'was found and'
      ' this module is now sharing it.}'
      'function AttemptToUseSharedMemoryManager: Boolean; platform;'
      ''
      
        '{Makes this memory manager available for sharing to other module' +
        's in the'
      
        ' current process. Only one memory manager may be shared per proc' +
        'ess, so this'
      ' function may fail.}'
      'function ShareMemoryManager: Boolean; platform;'
      ''
      '{$ENDIF}'
      ''
      '{ Thread support }'
      'type'
      '  TThreadFunc = function(Parameter: Pointer): Integer;'
      ''
      '{$IFDEF POSIX}'
      ''
      '{$IFDEF LINUX}'
      'type'
      '  TSize_T = Cardinal;'
      ''
      '  TSchedParam = record'
      '    sched_priority: Integer;'
      '  end;'
      '  {$DEFINE _PTHREAD_ATTR_T_DEFINED}'
      '  pthread_attr_t = record'
      '    __detachstate,'
      '    __schedpolicy: Integer;'
      '    __schedparam: TSchedParam;'
      '    __inheritsched,'
      '    __scope: Integer;'
      '    __guardsize: TSize_T;'
      '    __stackaddr_set: Integer;'
      '    __stackaddr: Pointer;'
      '    __stacksize: TSize_T;'
      '  end;'
      '  {$EXTERNALSYM pthread_attr_t}'
      '{$ENDIF LINUX}'
      '{$IFDEF MACOS}'
      'const'
      '   PTHREAD_ATTR_SIZE = 36;'
      '   SCHED_PARAM_SIZE = 4;'
      'type'
      '  TSchedParam = record'
      '    sched_priority: Integer;'
      '    opaque: array [0..SCHED_PARAM_SIZE-1] of Byte;'
      '  end;'
      '  {$DEFINE _PTHREAD_ATTR_T_DEFINED}'
      '   pthread_attr_t = record'
      '      __sig: LongInt;'
      '      opaque: array [0..PTHREAD_ATTR_SIZE-1] of Byte;'
      '   end;'
      '  {$EXTERNALSYM pthread_attr_t}  // Defined in signal.h'
      '{$ENDIF MACOS}'
      ''
      '{$IFDEF ANDROID}'
      'type'
      '  TSize_T = Cardinal;'
      '  {$DEFINE _PTHREAD_ATTR_T_DEFINED}'
      '  pthread_attr_t = record'
      '    flags: UInt32;'
      '    stack_base: Pointer;'
      '    stack_size: TSize_T;'
      '    guard_size: TSize_T;'
      '    sched_policy: Int32;'
      '    sched_priority: Int32;'
      '  end;'
      '  {$EXTERNALSYM pthread_attr_t}'
      '{$ENDIF ANDROID}'
      ''
      'type'
      '  TThreadAttr = pthread_attr_t;'
      '  PThreadAttr = ^TThreadAttr;'
      ''
      '  TBeginThreadProc = function (Attribute: PThreadAttr;'
      '    ThreadFunc: TThreadFunc; Parameter: Pointer;'
      '    var ThreadId: TThreadID): Integer;'
      '  TEndThreadProc = procedure(ExitCode: Integer);'
      ''
      'var'
      '  BeginThreadProc: TBeginThreadProc = nil;'
      '  EndThreadProc: TEndThreadProc = nil;'
      '{$ENDIF POSIX}'
      ''
      '{$IFDEF MSWINDOWS}'
      ''
      'type'
      
        '  TSystemThreadFuncProc = function(ThreadFunc: TThreadFunc; Para' +
        'meter: Pointer): Pointer;'
      '  TSystemThreadEndProc = procedure(ExitCode: Integer);'
      '  {$NODEFINE TSystemThreadFuncProc}'
      '  {$NODEFINE TSystemThreadEndProc}'
      ''
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      
        '  (*$HPPEMIT '#39'  typedef void * (__fastcall * TSystemThreadFuncPr' +
        'oc)(void *, void * );'#39' *)'
      
        '  (*$HPPEMIT '#39'  typedef void (__fastcall * TSystemThreadEndProc)' +
        '(int);'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      ''
      'var'
      
        '  // SystemThreadFuncProc and SystemThreadEndProc are set during' +
        ' the startup'
      
        '  // code by the C++ RTL when running in a C++Builder VCL applic' +
        'ation.'
      '  SystemThreadFuncProc: TSystemThreadFuncProc = nil;'
      '  SystemThreadEndProc: TSystemThreadEndProc = nil;'
      ''
      
        'function BeginThread(SecurityAttributes: Pointer; StackSize: Lon' +
        'gWord;'
      
        '  ThreadFunc: TThreadFunc; Parameter: Pointer; CreationFlags: Lo' +
        'ngWord;'
      '  var ThreadId: TThreadID): THandle;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      
        'function BeginThread(Attribute: PThreadAttr; ThreadFunc: TThread' +
        'Func;'
      
        '                     Parameter: Pointer; var ThreadId: TThreadID' +
        '): Integer;'
      ''
      '{$ENDIF}'
      'procedure EndThread(ExitCode: Integer);'
      ''
      '{ Standard procedures and functions }'
      ''
      'const'
      '{ File mode magic numbers }'
      ''
      '  fmClosed = $D7B0;'
      '  fmInput  = $D7B1;'
      '  fmOutput = $D7B2;'
      '  fmInOut  = $D7B3;'
      ''
      '{ Text file flags         }'
      
        '  tfCRLF   = $1;    // Dos compatibility flag, for CR+LF line br' +
        'eaks and EOF checks'
      ''
      'type'
      '{ Typed-file and untyped-file record }'
      ''
      
        '  TFileRec = packed record (* must match the size the compiler g' +
        'enerates: 592 bytes (616 bytes for x64) *)'
      '    Handle: NativeInt;'
      '    Mode: Word;'
      '    Flags: Word;'
      '    case Byte of'
      '      0: (RecSize: Cardinal);   //  files of record'
      '      1: (BufSize: Cardinal;    //  text files'
      '          BufPos: Cardinal;'
      '          BufEnd: Cardinal;'
      '          BufPtr: _PAnsiChr;'
      '          OpenFunc: Pointer;'
      '          InOutFunc: Pointer;'
      '          FlushFunc: Pointer;'
      '          CloseFunc: Pointer;'
      '          UserData: array[1..32] of Byte;'
      '          Name: array[0..259] of WideChar;'
      '      );'
      '  end;'
      ''
      '{ Text file record structure used for Text files }'
      '  PTextBuf = ^TTextBuf;'
      '  TTextBuf = array[0..127] of _AnsiChr;'
      
        '  TTextRec = packed record (* must match the size the compiler g' +
        'enerates: 730 bytes (754 bytes for x64) *)'
      '    Handle: NativeInt;       (* must overlay with TFileRec *)'
      '    Mode: Word;'
      '    Flags: Word;'
      '    BufSize: Cardinal;'
      '    BufPos: Cardinal;'
      '    BufEnd: Cardinal;'
      '    BufPtr: _PAnsiChr;'
      '    OpenFunc: Pointer;'
      '    InOutFunc: Pointer;'
      '    FlushFunc: Pointer;'
      '    CloseFunc: Pointer;'
      '    UserData: array[1..32] of Byte;'
      '    Name: array[0..259] of WideChar;'
      '    Buffer: TTextBuf;'
      '    CodePage: Word;'
      '    MBCSLength: ShortInt;'
      '    MBCSBufPos: Byte;'
      '    case Integer of'
      '      0: (MBCSBuffer: array[0..5] of _AnsiChr);'
      '      1: (UTF16Buffer: array[0..2] of WideChar);'
      '  end;'
      ''
      '  TTextIOFunc = function (var F: TTextRec): Integer;'
      '  TFileIOFunc = function (var F: TFileRec): Integer;'
      ''
      
        'procedure SetLineBreakStyle(var T: Text; Style: TTextLineBreakSt' +
        'yle);'
      'function GetTextCodePage(const T: Text): Word;'
      'procedure SetTextCodePage(var T: Text; CodePage: Word);'
      'procedure __IOTest;'
      'procedure SetInOutRes(NewValue: Integer);'
      'procedure ChDir(const S: string); overload;'
      'procedure ChDir(P: PChar); overload;'
      'function Flush(var t: Text): Integer;'
      'procedure _UGetDir(D: Byte; var S: UnicodeString);'
      'procedure _LGetDir(D: Byte; var S: _AnsiStr);'
      'procedure _WGetDir(D: Byte; var S: _WideStr);'
      'procedure _SGetDir(D: Byte; var S: _ShortStr);'
      'function IOResult: Integer;'
      'procedure MkDir(const S: string); overload;'
      'procedure MkDir(P: PChar); overload;'
      'procedure Move(const Source; var Dest; Count: NativeInt);'
      
        'procedure MoveChars(const Source; var Dest; Length: Integer); in' +
        'line;'
      'function ParamCount: Integer;'
      'function ParamStr(Index: Integer): string;'
      'procedure RmDir(const S: string); overload;'
      'procedure RmDir(P: PChar); overload;'
      'function UpCase(Ch: _AnsiChr): _AnsiChr; overload; inline;'
      'function UpCase(Ch: WideChar): WideChar; overload; inline;'
      ''
      '{ random functions }'
      ''
      'type'
      '  TRandom32Proc = function: UInt32;'
      '  TRandomizeProc = procedure(NewSeed: UInt64);'
      ''
      'function DefaultRandom32: UInt32;'
      'procedure DefaultRandomize(NewSeed: UInt64);'
      ''
      'var'
      '  Random32Proc: TRandom32Proc = DefaultRandom32;'
      '  RandomizeProc: TRandomizeProc = DefaultRandomize;'
      ''
      'procedure Randomize;'
      ''
      'function Random(const ARange: Integer): Integer; overload;'
      'function Random: Extended; overload;'
      ''
      'const'
      '{$IFDEF CPUX86}'
      '  feeINEXACT    = $0020;'
      '  feeUNDERFLOW  = $0010;'
      '  feeOVERFLOW   = $0008;'
      '  feeDIVBYZERO  = $0004;'
      '  feeINVALID    = $0001;'
      '  feeALLEXCEPT  = $003F;'
      '  feeDENORMALOPERAND = $0002 platform; // An Intel-specific flag'
      ''
      '  femINEXACT   = $0020;'
      '  femUNDERFLOW = $0010;'
      '  femOVERFLOW  = $0008;'
      '  femDIVBYZERO = $0004;'
      '  femINVALID   = $0001;'
      '  femALLEXCEPT = $003F;'
      '  femDENORMALOPERAND = $0002 platform; // An Intel-specific flag'
      ''
      '  ferTONEAREST  = $0000;'
      '  ferUPWARD     = $0800;'
      '  ferDOWNWARD   = $0400;'
      '  ferTOWARDZERO = $0C00;'
      '  ferALLROUND   = $0C00;'
      '{$ENDIF CPUX86}'
      '{$IF defined(CPUX64) and defined(MSWINDOWS)}'
      '  feeINEXACT    = $0020;'
      '  feeUNDERFLOW  = $0010;'
      '  feeOVERFLOW   = $0008;'
      '  feeDIVBYZERO  = $0004;'
      '  feeINVALID    = $0001;'
      '  feeALLEXCEPT  = $003F;'
      ''
      '  femINEXACT   = $1000;'
      '  femUNDERFLOW = $0800;'
      '  femOVERFLOW  = $0400;'
      '  femDIVBYZERO = $0200;'
      '  femINVALID   = $0080;'
      '  femALLEXCEPT = $1F80;'
      ''
      '  feeDENORMALOPERAND = $0002 platform; // An Intel-specific flag'
      '  femDENORMALOPERAND = $0100 platform; // An Intel-specific flag'
      ''
      '  ferTONEAREST  = $0000;'
      '  ferUPWARD     = $4000;'
      '  ferDOWNWARD   = $2000;'
      '  ferTOWARDZERO = $6000;'
      '  ferALLROUND   = $6000;'
      '{$ENDIF defined(CPUX64) and defined(MSWINDOWS)}'
      '{$IF defined(CPUX64) and defined(ARITH_USE_LIBM)}'
      '  feeINEXACT    = $0020;'
      '  feeUNDERFLOW  = $0010;'
      '  feeOVERFLOW   = $0008;'
      '  feeDIVBYZERO  = $0004;'
      '  feeINVALID    = $0001;'
      '  feeALLEXCEPT  = $003F;'
      ''
      '  femINEXACT    = $0020;'
      '  femUNDERFLOW  = $0010;'
      '  femOVERFLOW   = $0008;'
      '  femDIVBYZERO  = $0004;'
      '  femINVALID    = $0001;'
      '  femALLEXCEPT  = $003F;'
      ''
      '  feeDENORMALOPERAND = $0002 platform; // An Intel-specific flag'
      '  femDENORMALOPERAND = $0002 platform; // An Intel-specific flag'
      ''
      '  ferTONEAREST  = $0000;'
      '  ferUPWARD     = $0800;'
      '  ferDOWNWARD   = $0400;'
      '  ferTOWARDZERO = $0C00;'
      '  ferALLROUND   = $0C00;'
      '{$ENDIF defined(CPUX64) defined(ARITH_USE_LIBM)}'
      ''
      '{$IFDEF CPUARM}'
      '  feeINEXACT    = $0010;'
      '  feeUNDERFLOW  = $0008;'
      '  feeOVERFLOW   = $0004;'
      '  feeDIVBYZERO  = $0002;'
      '  feeINVALID    = $0001;'
      
        '  feeFLUSHTOZERO = $0080 platform; // An ARM-specific flag that ' +
        'is raised when a denormal is flushed to zero.'
      '  feeALLEXCEPT  = $009F;'
      ''
      '  femINEXACT   = $1000;'
      '  femUNDERFLOW = $0800;'
      '  femOVERFLOW  = $0400;'
      '  femDIVBYZERO = $0200;'
      '  femINVALID   = $0100;'
      
        '  femFLUSHTOZERO = $8000 platform; // An ARM-specific flag that ' +
        'is raised when a denormal is flushed to zero.'
      '  femALLEXCEPT = $9F00;'
      ''
      '{$IFDEF MACOS} // iOS and macOS'
      '  ferTONEAREST  = $00000000;'
      '  ferUPWARD     = $00400000;'
      '  ferDOWNWARD   = $00800000;'
      '  ferTOWARDZERO = $00C00000;'
      '{$ENDIF MACOS}'
      '{$IFDEF ANDROID}'
      '  ferTONEAREST  = $0;'
      '  ferUPWARD     = $1;'
      '  ferDOWNWARD   = $2;'
      '  ferTOWARDZERO = $3;'
      '{$ENDIF ANDROID}'
      '{$IFDEF LINUX}'
      '  ferTONEAREST  = $0;'
      '  ferUPWARD     = $1;'
      '  ferDOWNWARD   = $2;'
      '  ferTOWARDZERO = $3;'
      '{$ENDIF ANDROID}'
      
        '  ferALLROUND   = ferTONEAREST or ferUPWARD or ferDOWNWARD or fe' +
        'rTOWARDZERO;'
      '{$ENDIF CPUARM}'
      '{$IF not(defined(CPUX86) or defined(CPUX64) or defined(CPUARM))}'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF}'
      ''
      ''
      '{$IFDEF ARITH_USE_LIBM}'
      'procedure FClearExcept;'
      'procedure FCheckExcept;'
      '{$ELSE}'
      'procedure FClearExcept; inline;'
      'procedure FCheckExcept; inline;'
      '{$ENDIF ARITH_USE_LIBM}'
      ''
      
        'procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Bool' +
        'ean = True);'
      ''
      'function FGetRound: UInt32;'
      'function FSetRound(NewRound: UInt32): UInt32;'
      ''
      
        'function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32 = feeA' +
        'LLEXCEPT): UInt32;'
      'function FGetExceptFlag(Excepts: UInt32 = feeALLEXCEPT): UInt32;'
      ''
      
        'function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32 = ' +
        'femALLEXCEPT): UInt32;'
      
        'function FGetExceptMask(ExceptMasks: UInt32 = femALLEXCEPT): UIn' +
        't32;'
      ''
      
        '{$IF (defined(CPUX86) or defined(CPUX64)) and not defined(ARITH_' +
        'USE_LIBM)}'
      ''
      '{ Control 8087 control word }'
      
        'procedure Reset8087CW; {$IFDEF NEXTGEN}platform;{$ENDIF} // Rese' +
        'ts to Default8087CW'
      
        'procedure Set8087CW(NewCW: Word); {$IFDEF NEXTGEN}platform;{$END' +
        'IF}'
      'function Get8087CW: Word; {$IFDEF NEXTGEN}platform;{$ENDIF}'
      ''
      '{ Control MXCSR control word }'
      ''
      'procedure ResetMXCSR; platform; // Resets to DefaultMXCSR'
      'procedure SetMXCSR(NewMXCSR: UInt32); platform;'
      'procedure SetMXCSRExceptionFlag(NewExceptionFlag: UInt32);'
      ''
      'function GetMXCSR: UInt32; platform;'
      ''
      '{$ELSEIF defined(CPUARM)}'
      ''
      '{ Control ARM FPSCR control word }'
      'procedure SetFPSCR(NewFlag: UInt32); platform;'
      'function GetFPSCR: UInt32; platform;'
      ''
      '{$ENDIF}'
      ''
      '{ Wide character support procedures and functions for C++ }'
      '{ These functions should not be used in Delphi code!'
      ' (conversion is implicit in Delphi code)      }'
      ''
      'function WideCharToString(Source: PWideChar): UnicodeString;'
      
        'function WideCharLenToString(Source: PWideChar; SourceLen: Integ' +
        'er): UnicodeString;'
      
        'procedure WideCharToStrVar(Source: PWideChar; var Dest: UnicodeS' +
        'tring);'
      
        'procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Inte' +
        'ger;'
      '  var Dest: UnicodeString); overload;'
      
        'procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Inte' +
        'ger;'
      '  var Dest: _AnsiStr); overload;'
      
        'function StringToWideChar(const Source: UnicodeString; Dest: PWi' +
        'deChar;'
      '  DestSize: Integer): PWideChar;'
      ''
      '{ PUCS4Chars returns a pointer to the UCS4 char data in the'
      
        '  UCS4String array, or a pointer to a null char if UCS4String is' +
        ' empty }'
      ''
      'function PUCS4Chars(const S: UCS4String): PUCS4Char;'
      ''
      '{ Widestring <-> UCS4 conversion }'
      ''
      'function WideStringToUCS4String(const S: _WideStr): UCS4String;'
      'function UCS4StringToWideString(const S: UCS4String): _WideStr;'
      ''
      '{ PAnsiChar/PWideChar Unicode <-> UTF8 conversion }'
      ''
      '// UnicodeToUTF8(3):'
      '// UTF8ToUnicode(3):'
      
        '// Scans the source data to find the null terminator, up to MaxB' +
        'ytes'
      '// Dest must have MaxBytes available in Dest.'
      
        '// MaxDestBytes includes the null terminator (last char in the b' +
        'uffer will be set to null)'
      '// Function result includes the null terminator.'
      ''
      
        'function UnicodeToUtf8(Dest: _PAnsiChr; Source: PWideChar; MaxBy' +
        'tes: Integer): Integer; overload; deprecated;'
      
        'function Utf8ToUnicode(Dest: PWideChar; Source: _PAnsiChr; MaxCh' +
        'ars: Integer): Integer; overload; deprecated;'
      ''
      '// UnicodeToUtf8(4):'
      '// UTF8ToUnicode(4):'
      
        '// MaxDestBytes includes the null terminator (last char in the b' +
        'uffer will be set to null)'
      '// Function result includes the null terminator.'
      
        '// Nulls in the source data are not considered terminators - Sou' +
        'rceChars must be accurate'
      ''
      
        'function UnicodeToUtf8(Dest: _PAnsiChr; MaxDestBytes: Cardinal; ' +
        'Source: PWideChar; SourceChars: Cardinal): Cardinal; overload;'
      
        'function Utf8ToUnicode(Dest: PWideChar; MaxDestChars: Cardinal; ' +
        'Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal; overload;'
      ''
      '{ WideString <-> UTF8 conversion }'
      ''
      'function UTF8Encode(const WS: _WideStr): _RawByteStr; overload;'
      
        'function UTF8Encode(const US: UnicodeString): _RawByteStr; overl' +
        'oad;'
      
        'procedure UTF8Encode(const US: UnicodeString; var B: array of By' +
        'te); overload;'
      
        'function UTF8Encode(const A: _RawByteStr): _RawByteStr; overload' +
        ';'
      
        'function UTF8EncodeToShortString(const WS: _WideStr): _ShortStr;' +
        ' overload;'
      
        'function UTF8EncodeToShortString(const US: UnicodeString): _Shor' +
        'tStr; overload;'
      
        'function UTF8EncodeToShortString(const A: _RawByteStr): _ShortSt' +
        'r; overload;'
      
        'function UTF8Decode(const S: _RawByteStr): _WideStr; deprecated ' +
        #39'Use UTF8ToWideString or UTF8ToString'#39';'
      
        'function UTF8ToWideString(const S: _RawByteStr): _WideStr; inlin' +
        'e;'
      
        'function UTF8ToUnicodeString(const S: _RawByteStr): UnicodeStrin' +
        'g; overload;'
      
        'function UTF8ToUnicodeString(const S: _ShortStr): UnicodeString;' +
        ' overload;'
      
        'function UTF8ToUnicodeString(const S: _PAnsiChr): UnicodeString;' +
        ' overload;'
      
        'function UTF8ToString(const S: _RawByteStr): string; inline; ove' +
        'rload;'
      
        'function UTF8ToString(const S: _ShortStr): string; inline; overl' +
        'oad;'
      
        'function UTF8ToString(const S: _PAnsiChr): string; inline; overl' +
        'oad;'
      ''
      
        '// First byte in S data is considered as a length of input strin' +
        'g. Null in S data'
      
        '// is not considered as a terminator. Length of S array is ignor' +
        'ed.'
      
        'function UTF8ToString(const S: array of Byte): string; overload;' +
        ' deprecated '#39'Use UTF8ArrayToString(const S: array of Byte)'#39';'
      
        '// Length of S array is the length of input string. Null in S da' +
        'ta is not'
      '// considered as a terminator.'
      
        'function UTF8ArrayToString(const S: array of _AnsiChr): string; ' +
        'overload;'
      
        '// Length of S array is the length of input string. Null in S da' +
        'ta is not'
      '// considered as a terminator.'
      
        'function UTF8ArrayToString(const S: array of Byte): string; over' +
        'load;'
      ''
      '{ UTF8 encoded RTTI identifiers support functions }'
      
        '// They use optimistic expectation, that an identifier contains ' +
        'ASCII chars.'
      ''
      'function UTF8IdentToString(const Name: _PShortStr): string;'
      
        'function UTF8IdentStringCompare(const Name1: _PShortStr; const N' +
        'ame2: string): Boolean;'
      
        'function UTF8IdentIdentCompare(const Name1, Name2: _PShortStr): ' +
        'Boolean;'
      'function UTF8IdentLength(const Name: string): Integer;'
      ''
      '{ Ansi <-> UTF8 conversion }'
      ''
      
        '                                                                ' +
        '  '
      'function AnsiToUtf8(const S: string): _RawByteStr;'
      'function Utf8ToAnsi(const S: _RawByteStr): string;'
      ''
      '{ OLE string support procedures and functions }'
      ''
      'function OleStrToString(Source: PWideChar): UnicodeString;'
      
        'procedure OleStrToStrVar(Source: PWideChar; var Dest: _AnsiStr);' +
        ' overload;'
      
        'procedure OleStrToStrVar(Source: PWideChar; var Dest: UnicodeStr' +
        'ing); overload;'
      
        'function StringToOleStr(const Source: _AnsiStr): PWideChar; over' +
        'load;'
      
        'function StringToOleStr(const Source: UnicodeString): PWideChar;' +
        ' overload;'
      ''
      
        '{ Variant manager support procedures and functions (obsolete - s' +
        'ee Variants.pas) }'
      ''
      
        'procedure GetVariantManager(var VarMgr: TVariantManager); deprec' +
        'ated;'
      
        'procedure SetVariantManager(const VarMgr: TVariantManager); depr' +
        'ecated;'
      'function IsVariantManagerSet: Boolean; deprecated;'
      ''
      '{ Interface dispatch support }'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _IntfDispCall(Result: Pointer; const Dispatch: IDispat' +
        'ch;'
      '  DispDesc: PDispDesc); cdecl; varargs;'
      'procedure _IntfVarCall(Dest: PVarData; const Source: TVarData;'
      '  CallDesc: PCallDesc); cdecl; varargs;'
      '{$ELSE}'
      
        '// these functions are actually varargs, which dcc32 cannot hand' +
        'le, so these'
      
        '// functions cannot be invoked from pure pascal code with parame' +
        'ters'
      
        'procedure _IntfDispCall{Result: Pointer; const Dispatch: IDispat' +
        'ch;'
      '  DispDesc: PDispDesc; Params: Pointer}; cdecl;'
      'procedure _IntfVarCall{Dest: PVarData; const Source: TVarData;'
      '  CallDesc: PCallDesc; Params: Pointer}; cdecl;'
      '{$ENDIF}'
      ''
      '{ Dynamic method dispatch support }'
      ''
      
        'function GetDynaMethod(vmt: TClass; selector: SmallInt): Pointer' +
        ';'
      ''
      '{ Package/Module registration and unregistration }'
      ''
      'type'
      '  PLibModule = ^TLibModule;'
      '  TLibModule = record'
      '    Next: PLibModule;'
      '    Instance: HINST;'
      '    CodeInstance: HINST;'
      '    DataInstance: HINST;'
      '    ResInstance: HINST;'
      '    TypeInfo: PPackageTypeInfo;'
      '    Reserved: NativeInt;'
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      '    InstanceVar: Pointer platform;'
      '    InitTable: Pointer platform;'
      '    GOT: NativeUInt platform;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '    CodeSegStart: NativeUInt platform;'
      '    CodeSegEnd: NativeUInt platform;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '  end;'
      ''
      
        '  TEnumModuleFunc = function (HInstance: NativeInt; Data: Pointe' +
        'r): Boolean;'
      
        '  TEnumModuleFuncLW = function (HInstance: THandle; Data: Pointe' +
        'r): Boolean;'
      '  TModuleUnloadProc = procedure (HInstance: NativeInt);'
      '  TModuleUnloadProcLW = procedure (HInstance: THandle);'
      ''
      '  PModuleUnloadRec = ^TModuleUnloadRec;'
      '  TModuleUnloadRec = record'
      '    Next: PModuleUnloadRec;'
      '    Proc: TModuleUnloadProcLW;'
      '  end;'
      ''
      'var'
      '  LibModuleList: PLibModule = nil;'
      '  ModuleUnloadList: PModuleUnloadRec = nil;'
      ''
      'procedure RegisterModule(LibModule: PLibModule);'
      'procedure UnregisterModule(LibModule: PLibModule);'
      'function FindHInstance(Address: Pointer): HINST;'
      'function FindClassHInstance(ClassType: TClass): HINST;'
      'function FindResourceHInstance(Instance: HINST): HINST;'
      '{$IFDEF MSWINDOWS}'
      
        'function GetResourceModuleName(HostAppName, ModuleName: string):' +
        ' string;'
      '{$ENDIF}'
      
        'function LoadResourceModule(ModuleName: PChar; CheckOwner: Boole' +
        'an = True): THandle;'
      
        'procedure EnumModules(Func: TEnumModuleFunc; Data: Pointer); ove' +
        'rload;'
      
        'procedure EnumResourceModules(Func: TEnumModuleFunc; Data: Point' +
        'er); overload;'
      
        'procedure EnumModules(Func: TEnumModuleFuncLW; Data: Pointer); o' +
        'verload;'
      
        'procedure EnumResourceModules(Func: TEnumModuleFuncLW; Data: Poi' +
        'nter); overload;'
      
        'procedure AddModuleUnloadProc(Proc: TModuleUnloadProc); overload' +
        ';'
      
        'procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProc); overl' +
        'oad;'
      
        'procedure AddModuleUnloadProc(Proc: TModuleUnloadProcLW); overlo' +
        'ad;'
      
        'procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProcLW); ove' +
        'rload;'
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      
        '{ Given an HMODULE, this function will return its fully qualifie' +
        'd name.  There is'
      
        '  no direct equivalent in Linux so this function provides that c' +
        'apability. }'
      
        'function GetModuleFileName(Module: HMODULE; Buffer: PChar; BufLe' +
        'n: Integer): Integer;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      ''
      '{ ResString support function/record }'
      ''
      'type'
      '  PResStringRec = ^TResStringRec;'
      '  {$IF defined(EXTERNALLINKER)}'
      '  TResStringRec = record'
      '    Key: MarshaledAString;'
      '  end;'
      '  {$ELSE}'
      '  TResStringRec = packed record'
      '    // 32bit = 8 bytes'
      '    // 64bit = 16 bytes'
      '    Module: ^HMODULE;'
      '    Identifier: NativeUint;'
      '  end;'
      '  {$ENDIF}'
      ''
      'var'
      
        '  LoadResStringFunc: function (ResStringRec: PResStringRec): str' +
        'ing = nil;'
      ''
      'function LoadResString(ResStringRec: PResStringRec): string;'
      ''
      '{ floating number support }'
      'type'
      '  TFloatSpecial = ( fsZero, fsNZero, fsDenormal, fsNDenormal,'
      '    fsPositive, fsNegative, fsInf, fsNInf, fsNaN );'
      ''
      '  PSingleRec = ^TSingleRec;'
      '  TSingleRec = packed record'
      '  private'
      '    aSingle: Single;'
      ''
      '    function InternalGetBytes(Index: Cardinal): UInt8; inline;'
      '    function InternalGetWords(Index: Cardinal): UInt16; inline;'
      
        '    procedure InternalSetBytes(Index: Cardinal; const Value: UIn' +
        't8); inline;'
      
        '    procedure InternalSetWords(Index: Cardinal; const Value: UIn' +
        't16); inline;'
      '    function GetBytes(Index: Cardinal): UInt8; inline;'
      '    function GetWords(Index: Cardinal): UInt16; inline;'
      
        '    procedure SetBytes(Index: Cardinal; const Value: UInt8); inl' +
        'ine;'
      
        '    procedure SetWords(Index: Cardinal; const Value: UInt16); in' +
        'line;'
      '    function GetExp: UInt64; inline;'
      '    function GetFrac: UInt64; inline;'
      '    function GetSign: Boolean; inline;'
      '    procedure SetExp(NewExp: UInt64);'
      '    procedure SetFrac(NewFrac: UInt64);'
      '    procedure SetSign(NewSign: Boolean);'
      '  public'
      ''
      '    function Exponent: Integer;'
      '    function Fraction: Extended;'
      '    function Mantissa: UInt64;'
      ''
      '    property Sign: Boolean read GetSign write SetSign;'
      '    property Exp: UInt64 read GetExp write SetExp;'
      '    property Frac: UInt64 read GetFrac write SetFrac;'
      ''
      '    function SpecialType: TFloatSpecial;'
      
        '    procedure BuildUp(const SignFlag: Boolean; const Mantissa: U' +
        'Int64; const Exponent: Integer);'
      '    class operator Explicit(a: Extended): TSingleRec; inline;'
      '    class operator Explicit(a: TSingleRec): Extended; inline;'
      ''
      
        '    property Bytes[Index: Cardinal]: UInt8 read GetBytes write S' +
        'etBytes;  // 0..3'
      
        '    property Words[Index: Cardinal]: UInt16 read GetWords write ' +
        'SetWords; // 0..1'
      '  end deprecated '#39'Use TSingleHelper'#39';'
      ''
      '  PDoubleRec = ^TDoubleRec;'
      '  TDoubleRec = packed record'
      '  private'
      '    aDouble: Double;'
      ''
      '    function InternalGetBytes(Index: Cardinal): UInt8; inline;'
      '    function InternalGetWords(Index: Cardinal): UInt16; inline;'
      
        '    procedure InternalSetBytes(Index: Cardinal; const Value: UIn' +
        't8); inline;'
      
        '    procedure InternalSetWords(Index: Cardinal; const Value: UIn' +
        't16); inline;'
      '    function GetBytes(Index: Cardinal): UInt8; inline;'
      '    function GetWords(Index: Cardinal): UInt16; inline;'
      
        '    procedure SetBytes(Index: Cardinal; const Value: UInt8); inl' +
        'ine;'
      
        '    procedure SetWords(Index: Cardinal; const Value: UInt16); in' +
        'line;'
      '    function GetExp: UInt64; inline;'
      '    function GetFrac: UInt64; inline;'
      '    function GetSign: Boolean; inline;'
      '    procedure SetExp(NewExp: UInt64);'
      '    procedure SetFrac(NewFrac: UInt64);'
      '    procedure SetSign(NewSign: Boolean);'
      '  public'
      '    function Exponent: Integer;'
      '    function Fraction: Extended;'
      '    function Mantissa: UInt64;'
      ''
      '    property Sign: Boolean read GetSign write SetSign;'
      '    property Exp: UInt64 read GetExp write SetExp;'
      '    property Frac: UInt64 read GetFrac write SetFrac;'
      ''
      '    function SpecialType: TFloatSpecial;'
      
        '    procedure BuildUp(const SignFlag: Boolean; const Mantissa: U' +
        'Int64; const Exponent: Integer);'
      '    class operator Explicit(a: Extended): TDoubleRec; inline;'
      '    class operator Explicit(a: TDoubleRec): Extended; inline;'
      ''
      
        '    property Bytes[Index: Cardinal]: UInt8 read GetBytes write S' +
        'etBytes;  // 0..7'
      
        '    property Words[Index: Cardinal]: UInt16 read GetWords write ' +
        'SetWords; // 0..3'
      '  end deprecated '#39'Use TDoubleHelper'#39';'
      ''
      '  PExtended80Rec = ^TExtended80Rec;'
      '  TExtended80Rec = packed record'
      '  private'
      '{$IFDEF EXTENDEDIS10BYTES}'
      '    aExtended80: Extended;'
      '{$ELSE  !EXTENDEDIS10BYTES}'
      '    aExtended80Frac: UInt64;'
      '    aExtended80Exp:  UInt16;'
      '{$ENDIF !EXTENDEDIS10BYTES}'
      '    function InternalGetBytes(Index: Cardinal): UInt8; inline;'
      '    function InternalGetWords(Index: Cardinal): UInt16; inline;'
      
        '    procedure InternalSetBytes(Index: Cardinal; const Value: UIn' +
        't8); inline;'
      
        '    procedure InternalSetWords(Index: Cardinal; const Value: UIn' +
        't16); inline;'
      '    function GetBytes(Index: Cardinal): UInt8;'
      '    function GetWords(Index: Cardinal): UInt16;'
      '    function Get_Exp: UInt64; inline;'
      '    function GetExp: UInt64; inline;'
      '    function GetFrac: UInt64; inline;'
      '    function GetSign: Boolean; inline;'
      '    procedure SetBytes(Index: Cardinal; const Value: UInt8);'
      '    procedure SetWords(Index: Cardinal; const Value: UInt16);'
      '    procedure Set_Exp(NewExp: UInt64); inline;'
      '    procedure SetExp(NewExp: UInt64);'
      '    procedure SetFrac(NewFrac: UInt64); inline;'
      '    procedure SetSign(NewSign: Boolean);'
      '  public'
      '    function Exponent: Integer;'
      '    function Fraction: Extended;'
      '    function Mantissa: UInt64; inline;'
      ''
      '    property Sign: Boolean read GetSign write SetSign;'
      '    property Exp: UInt64 read GetExp write SetExp;'
      '    property _Exp: UInt64 read Get_Exp write Set_Exp;'
      '    property Frac: UInt64 read GetFrac write SetFrac;'
      ''
      '    function SpecialType: TFloatSpecial;'
      
        '    procedure BuildUp(const SignFlag: Boolean; const Mantissa: U' +
        'Int64; const Exponent: Integer);'
      '    class operator Explicit(a: Extended): TExtended80Rec;'
      '    class operator Explicit(a: TExtended80Rec): Extended;'
      ''
      
        '    property Bytes[Index: Cardinal]: UInt8 read GetBytes write S' +
        'etBytes;  // 0..9'
      
        '    property Words[Index: Cardinal]: UInt16 read GetWords write ' +
        'SetWords; // 0..4'
      '  end;'
      ''
      '{$IFDEF EXTENDEDIS10BYTES}'
      '  {$IF SizeOf(Extended) <> SizeOf(TExtended80Rec)}'
      '    {$MESSAGE ERROR '#39'TExtended80Rec has incorrect size'#39'}'
      '  {$ENDIF }'
      '{$ENDIF EXTENDEDIS10BYTES}'
      ''
      
        '  PExtendedRec = {$IFDEF EXTENDEDHAS10BYTES} PExtended80Rec {$EL' +
        'SE} PDoubleRec {$ENDIF};'
      
        '  TExtendedRec = {$IFDEF EXTENDEDHAS10BYTES} TExtended80Rec {$EL' +
        'SE} TDoubleRec {$ENDIF};'
      ''
      '{$IFNDEF EXTENDEDHAS10BYTES}'
      'function Int(const X: Double): Double; overload;'
      'function Frac(const X: Double): Double; overload;'
      'function Exp(const X: Double): Double; overload;'
      'function Cos(const X: Double): Double; overload;'
      'function Sin(const X: Double): Double; overload;'
      'function Ln(const X: Double): Double; overload;'
      'function ArcTan(const X: Double): Double; overload;'
      'function Sqrt(const X: Double): Double; overload;'
      ''
      'function Tangent(const X: Double): Double; overload;'
      
        'procedure SineCosine(const X: Double; var Sin, Cos: Double); ove' +
        'rload;'
      'function ExpMinus1(const X: Double): Double; overload;'
      'function LnXPlus1(const X: Double): Double; overload;'
      '{$ELSE EXTENDEDHAS10BYTES}'
      'function Int(const X: Extended): Extended;'
      'function Frac(const X: Extended): Extended;'
      'function Exp(const X: Extended): Extended;'
      'function Cos(const X: Extended): Extended;'
      'function Sin(const X: Extended): Extended;'
      'function Ln(const X: Extended): Extended;'
      'function ArcTan(const X: Extended): Extended;'
      'function Sqrt(const X: Extended): Extended;'
      ''
      'function Tangent(const X: Extended): Extended;'
      'procedure SineCosine(const X: Extended; var Sin, Cos: Extended);'
      'function ExpMinus1(const X: Extended): Extended;'
      'function LnXPlus1(const X: Extended): Extended;'
      '{$ENDIF EXTENDEDHAS10BYTES}'
      ''
      '{ Procedures and functions that need compiler magic }'
      ''
      '{$IF defined(X86ASMRTL)}'
      'procedure _ROUND;'
      'procedure _TRUNC;'
      '{$ELSE}'
      'function _Round(Val: Extended): Int64;'
      '{$IF defined(CPUARM)}'
      'function _RoundU(Val: Extended): UInt64;'
      '{$ENDIF}'
      'function _RoundCurrency(Val: Currency): Int64;'
      'function _Trunc(Val: Extended): Int64;'
      'function _Abs(Val: Extended): Extended;'
      '{$ENDIF}'
      
        '{$IF defined(CPUX86) or defined(CPUARM) or defined(EXTERNALLINKE' +
        'R)}'
      
        'function _MulDivModInt64(AValue, AMul, ADiv: Int64; Remainder: P' +
        'Int64): Int64;'
      'function _MulDivInt64(AValue, AMul, ADiv: Int64): Int64;'
      '{$ENDIF}'
      '{$IF defined(CPUX64) or defined(CPUARM)}'
      'function _MulDivComp(AValue, AMul, ADiv: Int64): Int64;'
      '{$ENDIF}'
      ''
      'procedure _AbstractError;'
      
        'procedure _Assert(const Message, Filename: string; LineNumber: I' +
        'nteger);'
      'function _Append(var t: TTextRec): Integer;'
      'function _AssignFile(var t: TFileRec; const s: PChar): Integer;'
      
        'function _AssignText(var t: TTextRec; const s: PChar; const CP: ' +
        'word): Integer;'
      
        'function _BlockRead(var F: TFileRec; Buffer: Pointer; RecCnt: In' +
        'teger; RecsRead: PInteger): Integer;'
      
        'function _BlockWrite(var F: TFileRec; Buffer: Pointer; RecCnt: I' +
        'nteger; RecsWritten: PInteger): Integer;'
      'function _Close(var t: TTextRec): Integer;'
      'function _EofFile(var f: TFileRec): Boolean;'
      'function _EofText(var t: TTextRec): Boolean;'
      'function _Eoln(var t: TTextRec): Boolean;'
      'procedure _Erase(var f: TFileRec);'
      '{$IFDEF TRIAL_EDITION}'
      'procedure _Expired;'
      '{$ENDIF}'
      'function _FilePos(var f: TFileRec): Integer;'
      'function _FileSize(var f: TFileRec): Integer;'
      'function _Flush(var t: TTextRec): Integer;'
      
        'procedure _FillChar(var Dest; Count: NativeInt; Value: _AnsiChr)' +
        ';'
      'function _FreeMem(P: Pointer): Integer;'
      'function _GetMem(Size: NativeInt): Pointer;'
      
        'function _ReallocMem(var P: Pointer; NewSize: NativeInt): Pointe' +
        'r;'
      'procedure _Halt(Code: Integer);'
      'procedure _Halt0;'
      '{$IFDEF TRIAL_EDITION}'
      '{$IFDEF MSWINDOWS}'
      'function _InitUnitPrep: Int64;'
      '{$ENDIF}'
      '{$IFDEF LINUX}'
      'function _InitUnitPrep: Integer;'
      '{$ENDIF}'
      '{$ENDIF}'
      'procedure Mark; deprecated;'
      'function _ReadRec(var f: TFileRec; Buffer: Pointer): Integer;'
      'function _ReadChar(var t: TTextRec): _AnsiChr;'
      'function _ReadLong(var t: TTextRec): Integer;'
      
        'procedure _ReadString(var t: TTextRec; s: _PShortStr; maxLen: In' +
        'teger);'
      
        'procedure _ReadCString(var t: TTextRec; s: _PAnsiChr; maxLen: In' +
        'teger);'
      
        'procedure _ReadLString(var t: TTextRec; var s: _AnsiStr; CodePag' +
        'e: Word);'
      'procedure _ReadUString(var t: TTextRec; var s: UnicodeString);'
      'procedure _ReadWString(var t: TTextRec; var s: _WideStr);'
      
        'procedure _ReadWCString(var t: TTextRec; s: PWideChar; maxBytes:' +
        ' Integer);'
      'function _ReadWChar(var t: TTextRec): WideChar;'
      'function _ReadExt(var t: TTextRec): Extended;'
      'procedure _ReadLn(var t: TTextRec);'
      'procedure _Rename(var f: TFileRec; newName: PChar);'
      'procedure Release; deprecated;'
      'function _ResetText(var t: TTextRec): Integer;'
      'function _ResetFile(var f: TFileRec; recSize: Integer): Integer;'
      'function _RewritText(var t: TTextRec): Integer;'
      
        'function _RewritFile(var f: TFileRec; recSize: Integer): Integer' +
        ';'
      'procedure _RunError(errorCode: Byte);'
      'procedure _Run0Error;'
      'procedure _Seek(var f: TFileRec; recNum: Cardinal);'
      'function _SeekEof(var t: TTextRec): Boolean;'
      'function _SeekEoln(var t: TTextRec): Boolean;'
      
        'procedure _SetTextBuf(var t: TTextRec; p: Pointer; size: Integer' +
        ');'
      'function _StrLong(val, width: Integer): _ShortStr;'
      'function _Str0Long(val: Integer): _ShortStr;'
      ''
      'procedure _Truncate(var f: TFileRec);'
      'function _ValLong(const S: string; var Code: Integer): Integer;'
      'function _WriteRec(var f: TFileRec; buffer: Pointer): Pointer;'
      
        'function _WriteChar(var t: TTextRec; c: _AnsiChr; width: Integer' +
        '): Pointer;'
      'function _Write0Char(var t: TTextRec; c: _AnsiChr): Pointer;'
      
        'function _WriteBool(var t: TTextRec; val: Boolean; width: Intege' +
        'r): Pointer;'
      'function _Write0Bool(var t: TTextRec; val: Boolean): Pointer;'
      
        'function _WriteLong(var t: TTextRec; val, width: Integer): Point' +
        'er;'
      'function _Write0Long(var t: TTextRec; val: Integer): Pointer;'
      
        'function _WriteString(var t: TTextRec; const s: _ShortStr; width' +
        ': Integer): Pointer;'
      
        'function _Write0String(var t: TTextRec; const s: _ShortStr): Poi' +
        'nter;'
      
        'function _WriteCString(var t: TTextRec; s: _PAnsiChr; width: Int' +
        'eger): Pointer;'
      'function _Write0CString(var t: TTextRec; s: _PAnsiChr): Pointer;'
      
        'function _WriteLString(var t: TTextRec; const s: _AnsiStr; width' +
        ': Integer): Pointer;'
      
        'function _Write0LString(var t: TTextRec; const s: _AnsiStr): Poi' +
        'nter;'
      
        'function _WriteWString(var t: TTextRec; const s: _WideStr; width' +
        ': Integer): Pointer;'
      
        'function _Write0WString(var t: TTextRec; const s: _WideStr): Poi' +
        'nter;'
      
        'function _WriteWCString(var t: TTextRec; s: PWideChar; width: In' +
        'teger): Pointer;'
      
        'function _Write0WCString(var t: TTextRec; s: PWideChar): Pointer' +
        ';'
      
        'function _WriteWChar(var t: TTextRec; c: WideChar; width: Intege' +
        'r): Pointer;'
      'function _Write0WChar(var t: TTextRec; c: WideChar): Pointer;'
      
        'function _WriteVariant(var T: TTextRec; const V: TVarData; Width' +
        ': Integer): Pointer;'
      
        'function _Write0Variant(var T: TTextRec; const V: TVarData): Poi' +
        'nter;'
      '{$IF not DEFined(X86ASMRTL)}'
      
        'function _Write2Ext(var T: TTextRec; val: Extended; Width, Prec:' +
        ' Integer): Pointer;'
      
        'function _Write1Ext(var T: TTextRec; val: Extended; Width: Integ' +
        'er): Pointer;'
      'function _Write0Ext(var T: TTextRec; val: Extended): Pointer;'
      '{$ELSE}'
      
        '// On x86, val is passed on the FPU stack. dcc32 passes floating' +
        ' point'
      
        '// parameters by reference, so the parameters cannot be added. T' +
        'hese'
      '// methods cannot be invoked from pure pascal code'
      
        'procedure _Write2Ext{(var T: TTextRec; val: Extended; Width, Pre' +
        'c: Integer): Pointer};'
      
        'procedure _Write1Ext{(var T: TTextRec; val: Extended; Width: Int' +
        'eger): Pointer};'
      'procedure _Write0Ext{(var T: TTextRec; val: Extended): Pointer};'
      '{$ENDIF}'
      '{$IF not defined(X86ASMRTL)}'
      
        'function _Write2Comp(var T: TTextRec; Val: Comp; Width, Prec: In' +
        'teger): Pointer;'
      
        'function _Write1Comp(var T: TTextRec; Val: Comp; Width: Integer)' +
        ': Pointer;'
      'function _Write0Comp(var T: TTextRec; Val: Comp): Pointer;'
      
        'function _Write2Currency(var T: TTextRec; Val: Currency; Width, ' +
        'Prec: Integer): Pointer;'
      
        'function _Write1Currency(var T: TTextRec; Val: Currency; Width: ' +
        'Integer): Pointer;'
      
        'function _Write0Currency(var T: TTextRec; Val: Currency): Pointe' +
        'r;'
      '{$ENDIF}'
      'function _WriteLn(var t: TTextRec): Pointer;'
      ''
      'var'
      
        '  AlternateWriteUnicodeStringProc: function(var t: TTextRec; s: ' +
        'UnicodeString): Pointer = nil;'
      ''
      
        'procedure __CToPasStr(Dest: _PShortStr; const Source: _PAnsiChr)' +
        ';'
      
        'procedure _WCharToString(Dest: _PShortStr; const Source: WideCha' +
        'r; MaxLen: Integer);'
      
        'procedure __CLenToPasStr(Dest: _PShortStr; const Source: _PAnsiC' +
        'hr; MaxLen: NativeInt);'
      
        'procedure __ArrayToPasStr(Dest: _PShortStr; const Source: _PAnsi' +
        'Chr; Len: NativeInt);'
      
        'procedure __PasToCStr(const Source: _PShortStr; const Dest: _PAn' +
        'siChr);'
      
        'procedure __PasToWCStr(const Source: _PShortStr; const Dest: PWi' +
        'deChar);'
      ''
      '{ Compiler helper for set type support }'
      '{$IF not defined(X86ASMRTL)}'
      'procedure _SetElem(var Dest {:Set}; Elem, Size: Integer);'
      'procedure _SetRange(Lo, Hi, Size: Integer; var Dest {:Set});'
      'function _SetEq(L, R: Pointer{PSet}; Size: Integer): Boolean;'
      'function _SetLe(L, R: Pointer{PSet}; Size: Integer): Boolean;'
      
        'procedure _SetIntersect(var Dest {:Set}; Src: Pointer{PSet}; Siz' +
        'e: Integer);'
      
        'procedure _SetIntersect3(var Dest {:Set}; L, R: Pointer{PSet}; S' +
        'ize: Integer);'
      
        'procedure _SetUnion(var Dest {:Set}; Src: Pointer{PSet}; Size: I' +
        'nteger);'
      
        'procedure _SetUnion3(var Dest {:Set}; L, R: Pointer{PSet}; Size:' +
        ' Integer);'
      
        'procedure _SetSub(var Dest {:Set}; Src: Pointer{PSet}; Size: Int' +
        'eger);'
      
        'procedure _SetSub3(var Dest {:Set}; L, R: Pointer{PSet}; Size: I' +
        'nteger);'
      
        'procedure _SetExpand(Src: Pointer{PSet}; var Dest {:Set}; Lo, Hi' +
        ': Integer);'
      '{$ELSE}'
      
        '// On x86, these functions have special calling conventions that' +
        ' can'#39't be'
      '// invoked from pure pascal code.'
      'procedure _SetElem;'
      'procedure _SetRange;'
      'procedure _SetEq;'
      'procedure _SetLe;'
      'procedure _SetIntersect;'
      'procedure _SetIntersect3; { BEG only }'
      'procedure _SetUnion;'
      'procedure _SetUnion3; { BEG only }'
      'procedure _SetSub;'
      'procedure _SetSub3; { BEG only }'
      'procedure _SetExpand;'
      '{$ENDIF}'
      ''
      '{ Helper routines for standard procedure }'
      
        'function _Str2Ext(val: Extended; Width, Precision: Integer): _Sh' +
        'ortStr;'
      'function _Str1Ext(val: Extended; Width: Integer): _ShortStr;'
      'function _Str0Ext(val: Extended): _ShortStr;'
      '{$IF not defined(X86ASMRTL)}'
      
        'function _Str2Comp(Val: Comp; Width, Precision: Integer): _Short' +
        'Str;'
      'function _Str1Comp(Val: Comp; Width: Integer): _ShortStr;'
      'function _Str0Comp(Val: Comp): _ShortStr;'
      
        'function _Str2Currency(Val: Currency; Width, Precision: Integer)' +
        ': _ShortStr;'
      
        'function _Str1Currency(Val: Currency; Width: Integer): _ShortStr' +
        ';'
      'function _Str0Currency(Val: Currency): _ShortStr;'
      '{$ENDIF}'
      '{$IFNDEF EXTENDEDHAS10BYTES}'
      'function _Ext80ToDouble(Val: Pointer {PExtended80}): Double;'
      
        'procedure _DoubleToExt80(Dest: Pointer {PExtended80}; Val: Doubl' +
        'e);'
      '{$ENDIF}'
      '{$IF not defined(X86ASMRTL)}'
      'function _CompDiv(Dividend, Divisor: Comp): Double;'
      '{$ENDIF}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _ValExt(s: string; var code: Integer): Extended;'
      'function _Pow10(val: Extended; Power: Integer): Extended;'
      'function _Real2Ext(val: Pointer {PReal48}): Extended;'
      'procedure _Ext2Real(Dest: Pointer {PReal48}; Val: Extended);'
      '{$ELSE}'
      '// Floating point values are passed on the FPU stack here.'
      '// dcc32 expects them to be by reference arguments as normal'
      '// parameters. These cannot be invoked from pure pascal code.'
      'procedure _ValExt;'
      'procedure _Pow10;'
      'procedure _Real2Ext;'
      'procedure _Ext2Real;'
      '{$ENDIF}'
      ''
      '{ Compiler helpers for object type support }'
      '{$IF not defined(X86ASMRTL)}'
      
        'function _ObjSetup(Self: Pointer; var VmtPtrAndAllocFlag: Pointe' +
        'r): Pointer;'
      
        'procedure _ObjCopy(Dest, Source: Pointer; VmtPtrOffs: NativeInt)' +
        ';'
      '{$ELSE}'
      
        '// On x86, it is expected that ZF is set upon failure for these ' +
        'methods'
      '// which cannot be implemented in pure pascal'
      'procedure _ObjSetup;'
      'procedure _ObjCopy;'
      '{$ENDIF}'
      'function _Fail(Self: Pointer; AllocFlag: NativeInt): Pointer;'
      'procedure _BoundErr;'
      'procedure _IntOver;'
      'procedure _IntDivByZero;'
      ''
      '{$IF defined(CPUX86) and (not defined(EXTERNALLINKER))}'
      '{ Compiler helpers for Int64 atomic operations }'
      
        'function _AtomicIncInt64(var Target: Int64; Increment: Int64): I' +
        'nt64; inline;'
      
        'function _AtomicXchgInt64(var Target: Int64; Exchange: Int64): I' +
        'nt64; inline;'
      '{$ENDIF}'
      ''
      ''
      
        '{$IF defined(EXTERNALLINKER) and (defined(LINUX64) or defined(OS' +
        'X64))}'
      
        '                                                                ' +
        '                            '
      '{$DEFINE ALPHA_EXITDLL}'
      '{$ENDIF}'
      ''
      '{$IFDEF ALPHA_EXITDLL}'
      
        '                                                                ' +
        '                            '
      'const'
      '  _ALPHA_SIGSET_NWORDS = (1024 div (8 * SizeOf(LongWord)));'
      '  {$NODEFINE _ALPHA_SIGSET_NWORDS}'
      'type'
      
        '  __alpha_sigset_t = array[0 .. _ALPHA_SIGSET_NWORDS - 1] of Lon' +
        'gWord;'
      '  {$NODEFINE __alpha_sigset_t}'
      'type'
      '  __jmp_buf = array[0..7] of LongInt;'
      '  __jmp_buf_tag = record'
      '    __jmpbuf: __jmp_buf;'
      '    __mask_was_saved: Integer;'
      '    __saved_mask: __alpha_sigset_t;'
      '  end;'
      '  _jmp_buf = __jmp_buf_tag;'
      '  {$NODEFINE __jmp_buf}'
      '  {$NODEFINE __jmp_buf_tag}'
      '  {$NODEFINE _jmp_buf}'
      '{$ENDIF}'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '{$IFDEF CPUX64}'
      'type'
      '  __m128 = record'
      '    Lo, Hi: UInt64;'
      '  end align 16;'
      '  __TExitDllJumpBuf = record'
      '    {$IF DEFINED(MSWINDOWS)}'
      '      _RIP, _RSP, _RBX, _RBP, _RSI, _RDI: Int64;'
      '      _R12, _R13, _R14, _R15: Int64;'
      '      XmmBuf: array [6..15] of __m128;'
      '    {$NODEFINE __m128}'
      '    {$NODEFINE __TExitDllJumpBuf}'
      '    {$NODEFINE TInitContext}'
      '    {$NODEFINE PInitContext}'
      '    {$ELSEIF DEFINED(LINUX)}'
      '      _RIP, _RSP, _RBX, _RBP: Int64;'
      '      _R12, _R13, _R14, _R15: Int64;'
      '      //_FS, _X87CW: Word;'
      '      XmmBuf: array [8..15] of __m128;'
      '    {$ELSE}'
      '       {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '    {$ENDIF}'
      '  end align 16;'
      '{$ENDIF}'
      '{$ENDIF}'
      ''
      '{$IFDEF ALPHA_EXITDLL}'
      
        '                                                                ' +
        '                            '
      'type'
      '  __TExitDllJumpBuf = record'
      '    JmpBuf: _jmp_buf;'
      '  end align 16;'
      '  {$NODEFINE TInitContext}'
      '  {$NODEFINE PInitContext}'
      '  {$NODEFINE __TExitDllJumpBuf}'
      '{$ENDIF}'
      ''
      ''
      '{ Module initialization context.  For internal use only. }'
      ''
      'type'
      '  PInitContext = ^TInitContext;'
      '  TInitContext = record'
      '    OuterContext:   PInitContext;     { saved InitContext   }'
      '{$IFNDEF PC_MAPPED_EXCEPTIONS}'
      '    ExcFrame:       Pointer;          { bottom exc handler  }'
      '{$ENDIF}'
      '    InitTable:      PackageInfo;      { unit init info      }'
      '    InitCount:      Integer;          { how far we got      }'
      '    Module:         PLibModule;       { ptr to module desc  }'
      '{$IFDEF CPUX86}'
      '    DLLSaveEBP:     Pointer;          { saved regs for DLLs }'
      '    DLLSaveEBX:     Pointer;          { saved regs for DLLs }'
      '    DLLSaveESI:     Pointer;          { saved regs for DLLs }'
      '    DLLSaveEDI:     Pointer;          { saved regs for DLLs }'
      '{$ENDIF}'
      '{$IFDEF MSWINDOWS}'
      '    ExitProcessTLS: procedure;        { Shutdown for TLS    }'
      '{$ENDIF}'
      
        '    DLLInitState:   Byte;             { 0 = package, 1 = DLL shu' +
        'tdown, 2 = DLL startup }'
      '    ThreadID:       TThreadID;        { Initializing Thread }'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '{$IFDEF CPUX64}'
      '    ExitDllJmpBuf:  __TExitDllJumpBuf;'
      '{$ENDIF}'
      '{$ENDIF}'
      '{$IFDEF ALPHA_EXITDLL}'
      '    ExitDllJmpBuf:  __TExitDllJumpBuf;'
      '{$ENDIF}'
      '  end platform;'
      ''
      'type'
      '  TDLLProc = procedure (Reason: Integer);'
      '  // TDLLProcEx provides the reserved param returned by WinNT'
      '  TDLLProcEx = procedure (Reason: Integer; Reserved: Pointer);'
      ''
      '{$IFDEF POSIX}'
      
        'procedure _StartExe(InitTable: PackageInfo; Module: PLibModule; ' +
        'Argc: Integer; Argv: Pointer);'
      
        'procedure _StartLib(Context: PInitContext; Module: PLibModule; D' +
        'LLProc: TDLLProcEx);'
      '{$IF defined(EXTERNALLINKER)}'
      'function _DllMain(Context: PInitContext): Integer;'
      '{$ENDIF EXTERNALLINKER}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      'procedure _StartExe(InitTable: PackageInfo; Module: PLibModule);'
      '{$IFDEF CPUX86}'
      'procedure _StartLib;'
      '{$ENDIF CPUX86}'
      '{$IFDEF CPUX64} // Int64 Types'
      'function _DllMain(Context: PInitContext): Integer;'
      
        'procedure _StartLib(ContextBuf: PInitContext; InitTable: Package' +
        'Info; Module: PLibModule; TlsProc: Pointer; DllProc: TDllProcEx;' +
        ' AHInst: HINST; Reason: LongWord; Reserved: Pointer);'
      '{$ENDIF}'
      '{$ENDIF MSWINDOWS}'
      
        'procedure _PackageLoad(const Table : PackageInfo; Module: PLibMo' +
        'dule);'
      
        'procedure _PackageUnload(const Table : PackageInfo; Module: PLib' +
        'Module);'
      ''
      '{$IFDEF MSWINDOWS}'
      'type'
      '  PExceptionRecord = ^TExceptionRecord;'
      '  TExceptionRecord = record'
      '    ExceptionCode: Cardinal;'
      '    ExceptionFlags: Cardinal;'
      '    ExceptionRecord: PExceptionRecord;'
      '    ExceptionAddress: Pointer;'
      '    NumberParameters: Cardinal;'
      '    case {IsOsException:} Boolean of'
      
        '      True:  (ExceptionInformation : array [0..14] of NativeUInt' +
        ');'
      '      False: (ExceptAddr: Pointer; ExceptObject: Pointer);'
      '  end;'
      
        '  TExceptClsProc = function(P: PExceptionRecord): Pointer{Except' +
        'Class};'
      
        '  TExceptObjProc = function(P: PExceptionRecord): Pointer{Except' +
        'ion};'
      '  TRaiseExceptObjProc = procedure(P: PExceptionRecord);'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '  _PContext = Pointer{^TContext};'
      '  {$EXTERNALSYM _PContext}'
      '  PExceptionPointers = ^TExceptionPointers;'
      '  {$EXTERNALSYM PExceptionPointers}'
      '  TExceptionPointers = record'
      '    ExceptionRecord: PExceptionRecord;'
      '    ContextRecord: _PContext;'
      '  end;'
      '  {$EXTERNALSYM TExceptionPointers}'
      
        '  _TDelphiFinallyHandlerProc = function(ExceptionPointers: PExce' +
        'ptionPointers;'
      
        '                                        EstablisherFrame: Native' +
        'UInt): Integer;'
      '  {$EXTERNALSYM _TDelphiFinallyHandlerProc}'
      
        '  _TExceptionHandlerProc = function(ExceptionPointers: PExceptio' +
        'nPointers;'
      
        '                                    EstablisherFrame: NativeUInt' +
        '): Integer;'
      '  {$EXTERNALSYM _TExceptionHandlerProc}'
      '  _TDelphiSafeCallCatchHandlerProc ='
      '    function(ExceptionPointers: PExceptionPointers;'
      
        '             EstablisherFrame: NativeUInt; ExceptionObject: Poin' +
        'ter;'
      '             ExceptionAddress: Pointer): NativeUInt;'
      '  {$EXTERNALSYM _TDelphiSafeCallCatchHandlerProc}'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'type'
      '  PRaisedException = ^TRaisedException;'
      '  TRaisedException = packed record'
      '    RefCount: Integer;'
      '    ExceptObject: TObject;'
      '    ExceptionAddr: Pointer;'
      '    HandlerEBP: LongWord;'
      '    Flags: LongWord;'
      '    Cleanup: Pointer;'
      '    Prev: PRaisedException;'
      '    ReleaseProc: Pointer;'
      '  end;'
      '  PExceptionRecord = PRaisedException;'
      '  TExceptionRecord = TRaisedException;'
      '{$ENDIF}'
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      'type'
      '  _Unwind_Action = Integer;'
      '  {$EXTERNALSYM _Unwind_Action}'
      '  _Unwind_State = Integer;'
      '  {$EXTERNALSYM _Unwind_State}'
      ''
      '{$MINENUMSIZE 4}'
      '  _Unwind_Reason_Code = ('
      '    _URC_NO_REASON, { = 0}'
      '    _URC_FOREIGN_EXCEPTION_CAUGHT, { = 1}'
      '    _URC_FATAL_PHASE2_ERROR, { = 2}'
      '    _URC_FATAL_PHASE1_ERROR, { = 3}'
      '    _URC_NORMAL_STOP, { = 4}'
      '    _URC_END_OF_STACK, { = 5}'
      '    _URC_HANDLER_FOUND, { = 6}'
      '    _URC_INSTALL_CONTEXT, { = 7}'
      '    _URC_CONTINUE_UNWIND, { = 8}'
      '    _URC_FAILURE { = 9}'
      '  );'
      '{$MINENUMSIZE 1}'
      '  {$EXTERNALSYM _Unwind_Reason_Code}'
      '  TUnwindReasonCode = _Unwind_Reason_Code;'
      '  {$EXTERNALSYM TUnwindReasonCode}'
      '  PUnwind_Exception = ^_Unwind_Exception;'
      '  {$EXTERNALSYM PUnwind_Exception}'
      
        '  _Unwind_Exception_Cleanup_Fn = procedure (reason: _Unwind_Reas' +
        'on_Code; exc: PUnwind_Exception) cdecl;'
      '  {$EXTERNALSYM _Unwind_Exception_Cleanup_Fn}'
      '  _Unwind_Exception = record'
      '    exception_class: UInt64;'
      '    exception_cleanup: _Unwind_Exception_Cleanup_Fn;'
      '    private_1: UIntPtr;        // non-zero means forced unwind'
      
        '    private_2: UIntPtr;        // holds sp that phase1 found for' +
        ' phase2 to use'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS_MACOS) or Defined(SJLJ_BASED_E' +
        'XCEPTIONS)}'
      '  {$IF Defined(CPU32BITS)}'
      '    reserved: array[0..2] of UInt32;'
      '  {$ENDIF CPU32BITS}'
      '{$ENDIF ZCX_BASED_EXCEPTIONS_MACOS or SJLJ_BASED_EXCEPTIONS}'
      '{$IF Defined(ZCX_BASED_EXCEPTIONS)}'
      '  {$IF not Defined(LONGINT64)}'
      '    reserved: array[0..2] of UInt32;'
      '  {$ENDIF !LONGINT64}'
      '  {$IF Defined(CPUARM32)}'
      '    barrier_cache_sp: UInt32;'
      '    barrier_cache_bitpattern: array[0..4] of UInt32;'
      '    cleanup_cache_bitpattern: array[0..3] of UInt32;'
      '    fnstart: UInt32;'
      '    ehtp: NativeUInt;  // _Unwind_EHT_Header'
      '    additional: UInt32;'
      '    reserved1: UInt32;'
      '  {$ENDIF CPUARM32}'
      '  {$IF Defined(CPUARM64)}'
      '    barrier_cache_sp: UInt32;'
      '    barrier_cache_bitpattern: array[0..4] of UInt32;'
      '    cleanup_cache_bitpattern: array[0..3] of UInt32;'
      '    fnstart: UInt32;'
      '    ehtp: NativeUInt;  // _Unwind_EHT_Header'
      '    additional: UInt32;'
      '    reserved1: UInt32;'
      '  {$ENDIF CPUARM64}'
      '{$ENDIF ZCX_BASED_EXCEPTIONS}'
      '  end;'
      '  {$EXTERNALSYM _Unwind_Exception}'
      '  TUnwindException = _Unwind_Exception;'
      '  {$EXTERNALSYM TUnwindException}'
      '  PUnwindException = PUnwind_Exception;'
      '  {$EXTERNALSYM PUnwindException}'
      '  _Unwind_Context = record'
      '  end;'
      '  {$EXTERNALSYM _Unwind_Context}'
      '  PUnwind_Context = ^_Unwind_Context;'
      '  {$EXTERNALSYM PUnwind_Context}'
      '  _Unwind_Control_Block = type _Unwind_Exception;'
      '  {$EXTERNALSYM _Unwind_Control_Block}'
      
        '  _Unwind_Stop_Fn = function (Version: Integer; actions: _Unwind' +
        '_Action; exceptionClass: UInt64;'
      
        '    var exceptionObject: _Unwind_Exception; var context: _Unwind' +
        '_Context; stop_parameter: Pointer): _Unwind_Reason_Code; cdecl;'
      '  {$EXTERNALSYM _Unwind_Stop_Fn}'
      ''
      'const'
      '  _UA_SEARCH_PHASE = _Unwind_Action(1);'
      '  {$EXTERNALSYM _UA_SEARCH_PHASE}'
      '  _UA_CLEANUP_PHASE = _Unwind_Action(2);'
      '  {$EXTERNALSYM _UA_CLEANUP_PHASE}'
      '  _UA_HANDLER_FRAME = _Unwind_Action(4);'
      '  {$EXTERNALSYM _UA_HANDLER_FRAME}'
      '  _UA_FORCE_UNWIND = _Unwind_Action(8);'
      '  {$EXTERNALSYM _UA_FORCE_UNWIND}'
      ''
      '  _US_VIRTUAL_UNWIND_FRAME = _Unwind_State(0);'
      '  {$EXTERNALSYM _US_VIRTUAL_UNWIND_FRAME}'
      '  _US_UNWIND_FRAME_STARTING = _Unwind_State(1);'
      '  {$EXTERNALSYM _US_UNWIND_FRAME_STARTING}'
      '  _US_UNWIND_FRAME_RESUME = _Unwind_State(2);'
      '  {$EXTERNALSYM _US_UNWIND_FRAME_RESUME}'
      '  _US_ACTION_MASK = _Unwind_State(3);'
      '  {$EXTERNALSYM _US_ACTION_MASK}'
      '  _US_FORCE_UNWIND = _Unwind_State(8);'
      '  {$EXTERNALSYM _US_FORCE_UNWIND}'
      '  _US_END_OF_STACK = _Unwind_State(16);'
      '  {$EXTERNALSYM _US_END_OF_STACK}'
      ''
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS_MACOS) or Defined(SJLJ_BASED_E' +
        'XCEPTIONS)}'
      
        '  CPPExceptionPersonality  =   UInt64($434C4E47432B2B00); // '#39'CL' +
        'NGC++\0'#39' kOurExceptionClass'
      
        '  CPPExceptionPersonality1 =   UInt64($434C4E47432B2B01); // '#39'CL' +
        'NGC++\1'#39' kOurDependentExceptionClass'
      '{$ELSEIF Defined(ZCX_BASED_EXCEPTIONS)}'
      
        '  CPPExceptionPersonality =    UInt64($474E5543432B2B00); // '#39'GN' +
        'UCC++\0'#39
      '{$ENDIF}'
      
        '  DelphiExceptionPersonality = UInt64($454D4254444C5048); // '#39'EM' +
        'BTDLPH'#39
      ''
      
        '// FIXME: System.SysUtils.pas needs to update. It uses PExceptio' +
        'nRecord'
      'type'
      '  PExceptionRecord = ^TExceptionRecord;'
      '  TExceptionRecord = record'
      '    ExceptionCode: Cardinal;'
      '    ExceptionFlags: Cardinal;'
      '    ExceptionRecord: PExceptionRecord;'
      '    ExceptionAddress: Pointer;'
      '    NumberParameters: Cardinal;'
      '    ExceptAddr: Pointer;'
      '    ExceptObject: TObject;'
      '  end;'
      '  {$NODEFINE TExceptionRecord}'
      '  (*$HPPEMIT '#39'namespace System'#39' *)'
      '  (*$HPPEMIT '#39'{'#39' *)'
      '  (*$HPPEMIT '#39'  struct DECLSPEC_DRECORD TExceptionRecord;'#39' *)'
      '  (*$HPPEMIT '#39'}'#39' *)'
      '  TRaiseExceptObjProc = procedure(P: PExceptionRecord);'
      
        '  TGetExceptionObject = function(ExceptionClass: UInt64): TObjec' +
        't;'
      ''
      'var'
      '  ExceptObjProc: TGetExceptionObject;'
      
        '{$ENDIF SJLJ_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS or ZCX_BAS' +
        'ED_EXCEPTIONS_MACOS}'
      ''
      'procedure _InitResStrings(InitTable: Pointer);'
      'procedure _InitResStringImports(InitTable: Pointer);'
      'procedure _InitImports(InitTable: Pointer);'
      '{$IFDEF MSWINDOWS}'
      'procedure _InitWideStrings(InitTable: Pointer);'
      '{$ENDIF}'
      'procedure _FinalizeResStrings(InitTable: Pointer);'
      'procedure _FinalizeResStringImports(InitTable: Pointer);'
      '{$IFDEF MSWINDOWS}'
      'procedure _FinalizeWideStrings(InitTable: Pointer);'
      '{$ENDIF}'
      ''
      
        'function _ClassCreate(InstanceOrVMT: Pointer; Alloc: ShortInt): ' +
        'Pointer;'
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _BeforeDestruction(const Instance: TObject; OuterMost:' +
        ' ShortInt);'
      '{$ELSE X86ASMRTL}'
      
        '{ dcc32 generated code depends on DL being preserved through the' +
        ' chain of'
      
        '  calls up the inherited dtor chain.  Thus a PUREPASCAL implemen' +
        'tation'
      
        '  leads to non-deterministic results at destruction time with th' +
        'e current'
      '  code generator.}'
      
        'function _BeforeDestruction(const Instance: TObject; OuterMost: ' +
        'ShortInt): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};'
      '{$ENDIF X86ASMRTL}'
      'procedure _ClassDestroy(const Instance: TObject);'
      
        'function _AfterConstruction(const Instance: TObject): TObject {$' +
        'IFDEF AUTOREFCOUNT} unsafe {$ENDIF};'
      
        'function _IsClass(const Child: TObject; Parent: TClass): Boolean' +
        ';'
      
        'function _AsClass(const Child: TObject; Parent: TClass): TObject' +
        ' {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};'
      
        'function _GetHelperIntf(const Instance: TObject; HelperClass: TC' +
        'lass): IInterface;'
      
        'function _IntfAsClass(const Intf: IInterface; Parent: TClass): T' +
        'Object {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};'
      
        'function _SafeIntfAsClass(const Intf: IInterface; Parent: TClass' +
        '): TObject {$IFDEF AUTOREFCOUNT} unsafe {$ENDIF};'
      
        'function _IntfIsClass(const Intf: IInterface; Parent: TClass): B' +
        'oolean;'
      ''
      '{ Exception Support }'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure _RaiseAtExcept;'
      'procedure _RaiseExcept;'
      'procedure _RaiseAgain;'
      'procedure _DestroyException;'
      'procedure _DoneExcept;'
      'procedure _HandleAnyException;'
      'procedure _HandleAutoException;'
      'procedure _HandleOnException;'
      'procedure _HandleFinally;'
      'procedure _HandleOnExceptionPIC;'
      'procedure _ClassHandleException;'
      'procedure _UnhandledException;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure _RaiseExcept;'
      'procedure _RaiseAgain;'
      'procedure _DoneExcept;'
      'procedure _TryFinallyExit;'
      'procedure _HandleAnyException;'
      'procedure _HandleAutoException;'
      'procedure _HandleOnException;'
      'procedure _HandleFinally;'
      'procedure _UnhandledException;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure _RaiseExcept(Obj: TObject);'
      'procedure _RaiseAtExcept(Obj: TObject; Address: Pointer);'
      'procedure _RaiseAgain;'
      
        'procedure _DestroyException(ExceptionPointers: PExceptionPointer' +
        's; EstablisherFrame: NativeUInt);'
      'procedure _DoneExcept;'
      
        'procedure _TryFinallyExit(EstablisherFrame: NativeUInt; TargetAd' +
        'dr: NativeUInt);'
      'procedure _UnhandledException;'
      
        'function _DelphiExceptionHandler(ExceptionRecord: PExceptionReco' +
        'rd;'
      '  EstablisherFrame: NativeUInt; ContextRecord: _PContext;'
      '  DispatcherContext: Pointer{PDispatcherContext}):'
      '  LongInt{TExceptionDisposition}; stdcall;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS) }'
      
        'function _HandleAutoException(const Self: TObject; var UnwindExc' +
        'eption: _Unwind_Exception): HResult;'
      'procedure _RaiseAtExcept(const Obj: TObject; Address: Pointer);'
      'procedure _RaiseExcept(const Obj: TObject);'
      'procedure _RaiseAgain;'
      
        'procedure _DestroyException(var UnwindException: _Unwind_Excepti' +
        'on);'
      'procedure _DoneExcept(var UnwindException: _Unwind_Exception);'
      'procedure _UnhandledException;'
      '{$IF Defined(ZCX_BASED_EXCEPTIONS)}'
      
        'procedure _DoneExceptUCB(var UnwindException: _Unwind_Control_Bl' +
        'ock);'
      '{$ENDIF ZCX_BASED_EXCEPTIONS}'
      
        '{$IF (not Defined(MACOS)) and Defined(CPUARM32) and (not Defined' +
        '(SJLJ_BASED_EXCEPTIONS))} // LIBCXXABI_ARM_EHABI'
      'function _DelphiPersonalityRoutine(status: _Unwind_State;'
      
        '  var exceptionObject: _Unwind_Exception; context: PUnwind_Conte' +
        'xt): _Unwind_Reason_Code; cdecl;'
      '{$ELSE !LIBCXXABI_ARM_EHABI}'
      '{$IF defined(LINUX64)}'
      'function _delphipersonalityroutine'
      '{$ELSEIF defined(ANDROID64)}'
      'function _delphipersonalityroutine'
      '{$ELSE }'
      'function _DelphiPersonalityRoutine'
      '{$ENDIF LINUX64}'
      
        '  (Version: Integer; actions: _Unwind_Action; exceptionClass: UI' +
        'nt64;'
      
        '    var exceptionObject: _Unwind_Exception; context: PUnwind_Con' +
        'text): _Unwind_Reason_Code; cdecl;'
      '{$ENDIF LIBCXXABI_ARM_EHABI}'
      '{$IFDEF ANDROID32}'
      
        'function AllocateExceptionFrame(const Obj: TObject; Address: Nat' +
        'iveUInt): NativeUInt;'
      'function IsLeafFunction(IP: NativeUInt): Boolean;'
      '{$ENDIF ANDROID32}'
      '{$ENDIF}'
      ''
      '{ Class Support }'
      
        'function _FindDynaInst(const Self: TObject; Selector: SmallInt):' +
        ' Pointer;'
      
        'function _FindDynaClass(Vmt: TClass; Selector: SmallInt): Pointe' +
        'r;'
      '{$IF defined(X86ASMRTL)}'
      
        '// These functions use ESI as the Selector, which doesn'#39't map to' +
        ' any'
      
        '// of dcc32'#39's known calling conventions. These cannot be called ' +
        'from'
      '// pure pascal code.'
      'procedure _CallDynaInst;'
      'procedure _CallDynaClass;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{ String Support }'
      ''
      '{ Compiler helper for string allocation and release }'
      'function _NewUnicodeString(CharLength: Integer): Pointer;'
      
        'function _NewAnsiString(CharLength: Integer; CodePage: Word): Po' +
        'inter;'
      'function _NewWideString(CharLength: Integer): Pointer;'
      '{$IF not defined(X86ASMRTL)}'
      'function _UStrClr(var S): Pointer;'
      'function _LStrClr(var S): Pointer;'
      'function _WStrClr(var S): Pointer;'
      '{$ELSE}'
      '// dcc32 generated code expects the result to remain in EAX,'
      '// so we have to return S'
      'procedure _UStrClr(var S);'
      'procedure _LStrClr(var S);'
      'procedure _WStrClr(var S);'
      '{$ENDIF}'
      'procedure _UStrArrayClr(var StrArray; Count: Integer);'
      'procedure _LStrArrayClr(var StrArray; Count: Integer);'
      'procedure _WStrArrayClr(var StrArray; Count: Integer);'
      'function _UStrAddRef(Str: Pointer): Pointer;'
      'function _LStrAddRef(Str: Pointer): Pointer;'
      '{$IFDEF MSWINDOWS}'
      'function _WStrAddRef(var Str: _WideStr): Pointer;'
      '{$ELSE}'
      'function _WStrAddRef(Str: Pointer): Pointer;'
      '{$ENDIF}'
      ''
      '{ Compiler helper for basic string constructors }'
      
        'procedure _UStrFromPWCharLen(var Dest: UnicodeString; Source: PW' +
        'ideChar; CharLength: Integer);'
      
        'procedure _WStrFromPWCharLen(var Dest: _WideStr; Source: PWideCh' +
        'ar; CharLength: Integer);'
      
        'procedure _LStrFromPCharLen(var Dest: _AnsiStr; Source: _PAnsiCh' +
        'r; Length: Integer; CodePage: Word);'
      
        '//procedure InternalUStrFromPCharLen(var Dest: UnicodeString; So' +
        'urce: _PAnsiChr; Length: Integer; CodePage: Integer);'
      
        'procedure _UStrFromPCharLen(var Dest: UnicodeString; Source: _PA' +
        'nsiChr; Length: Integer);'
      
        '//procedure InternalWStrFromPCharLen(var Dest: _WideStr; Source:' +
        ' _PAnsiChr; Length: Integer; CodePage: Integer);'
      
        'procedure _WStrFromPCharLen(var Dest: _WideStr; Source: _PAnsiCh' +
        'r; Length: Integer);'
      
        'procedure _LStrFromPWCharLen(var Dest: _AnsiStr; Source: PWideCh' +
        'ar; Length: Integer; CodePage: Word);'
      ''
      '{ Compiler helper for string assignment }'
      
        'procedure _UStrAsg(var Dest: UnicodeString; const Source: Unicod' +
        'eString);'
      
        'procedure _UStrLAsg(var Dest: UnicodeString; const Source: Unico' +
        'deString);'
      'procedure _WStrAsg(var Dest: _WideStr; const Source: _WideStr);'
      'procedure _WStrLAsg(var Dest: _WideStr; const Source: _WideStr);'
      'procedure _LStrAsg(var Dest: _AnsiStr; const Source: _AnsiStr);'
      'procedure _LStrLAsg(var Dest: _AnsiStr; const Source: _AnsiStr);'
      ''
      '{ string info utilities }'
      
        'function StringElementSize(const S: UnicodeString): Word; overlo' +
        'ad; inline;'
      
        'function StringElementSize(const S: _RawByteStr): Word; overload' +
        '; inline;'
      
        'function StringCodePage(const S: UnicodeString): Word; overload;' +
        ' inline;'
      
        'function StringCodePage(const S: _RawByteStr): Word; overload; i' +
        'nline;'
      
        'function StringRefCount(const S: UnicodeString): Integer; overlo' +
        'ad; inline;'
      
        'function StringRefCount(const S: _RawByteStr): Integer; overload' +
        '; inline;'
      '{$IFNDEF MSWINDOWS}'
      
        'function StringElementSize(const S: _WideStr): Word; overload; i' +
        'nline;'
      
        'function StringCodePage(const S: _WideStr): Word; overload; inli' +
        'ne;'
      
        'function StringRefCount(const S: _WideStr): Integer; overload; i' +
        'nline;'
      '{$ENDIF}'
      ''
      '{ Compiler helper for string length }'
      'function _UStrLen(const S: UnicodeString): Integer; inline;'
      'function _WStrLen(const S: _WideStr): Integer; inline;'
      '// Note: VCLE.LIB|dstring.cpp refers mangled names of _LStrLen'
      'function _LStrLen(const S: _RawByteStr): Integer; inline;'
      '//function _PStrLen(const S: _ShortStr): Integer; inline;'
      'function _PCharLen(P: _PAnsiChr): Integer;'
      'function _PWCharLen(P: PWideChar): Integer;'
      ''
      '{ Compiler helper for _UniqueString* functions }'
      'function _UniqueStringU(var Str: UnicodeString): Pointer;'
      '{$IFNDEF MSWINDOWS}'
      'function _UniqueStringW(var Str: _WideStr): Pointer;'
      '{$ENDIF}'
      'function _UniqueStringA(var Str: _AnsiStr): Pointer;'
      ''
      '{ UniqueString* functions }'
      'procedure UniqueString(var Str: UnicodeString); overload;'
      'procedure UniqueString(var Str: _WideStr); overload;'
      'procedure UniqueString(var Str: _AnsiStr); overload;'
      ''
      '{ Compiler helper for comparing array of characters }'
      '{$IF not defined(X86ASMRTL)}'
      'function _PStrCmp(const Left, Right: _ShortStr): Integer;'
      
        'function _AStrCmp(const Left, Right: _PAnsiChr; Len: NativeInt):' +
        ' Integer;'
      
        'function _WStrLCmp(const Left, Right: PWideChar; Len: NativeInt)' +
        ': Integer;'
      '{$ELSE X86ASMRTL}'
      
        '// On dcc32, these return their result in the flag register rath' +
        'er'
      '// than a typical return value.'
      '// They cannot be invoked from pure pascal code.'
      'procedure _PStrCmp;'
      'procedure _AStrCmp;'
      'procedure _WStrLCmp;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{ Compiler helper for _ShortStr support }'
      'procedure _PStrCpy(Dest: _PShortStr; Source: _PShortStr);'
      
        'procedure _PStrNCpy(Dest: _PShortStr; Source: _PShortStr; MaxLen' +
        ': Byte);'
      'procedure _PStrCat(Dest: _PShortStr; const Src: _ShortStr);'
      
        'procedure _PStrNCat(Dest: _PShortStr; const Src: _ShortStr; Size' +
        ':Integer);'
      ''
      
        'function _Copy(const S: _ShortStr; Index, Count: Integer): _Shor' +
        'tStr;'
      '{$IF not defined(X86ASMRTL)}'
      
        '// var _ShortStr is actually two parameters, Pointer to the stri' +
        'ng and size of the string.'
      'procedure _Delete(var s: _ShortStr; Index, Count: Integer);'
      '{$ELSE}'
      'procedure _Delete(s: _PShortStr; Index, Count: Integer);'
      '{$ENDIF}'
      '{$IFDEF NEXTGEN}'
      
        'procedure _Insert(const Source: _ShortStr; var S: _OpenString; I' +
        'ndex: Integer);'
      '{$ELSE}'
      
        'procedure _Insert(const Source: _ShortStr; var S: OpenString; In' +
        'dex: Integer);'
      '{$ENDIF}'
      'procedure _SetLength(s: _PShortStr; newLength: Byte);'
      
        'procedure _SetString(s: _PShortStr; buffer: _PAnsiChr; len: Byte' +
        ');'
      ''
      '{ Compiler helper for _AnsiStr support }'
      
        '// Note: VCLE.LIB|dstring.cpp refers mangled names of _LStrFromA' +
        'rray, _LStrFromWStr, _LStrFromUStr, _LStrFromPChar and _LStrFrom' +
        'PWChar'
      'function _LStrToPChar(const S: _AnsiStr): _PAnsiChr;'
      
        'procedure _LStrToString(Dest: _PShortStr; const Source: _AnsiStr' +
        '; MaxLen: Integer);'
      
        'procedure _LStrFromChar(var Dest: _AnsiStr; Source: _AnsiChr; Co' +
        'dePage: Word);'
      
        'procedure _LStrFromWChar(var Dest: _AnsiStr; Source: WideChar; C' +
        'odePage: Word);'
      
        'procedure _LStrFromPChar(var Dest: _AnsiStr; Source: _PAnsiChr; ' +
        'CodePage: Word);'
      
        'procedure _LStrFromPWChar(var Dest: _AnsiStr; Source: PWideChar;' +
        ' CodePage: Word);'
      
        'procedure _LStrFromArray(var Dest: _AnsiStr; Source: _PAnsiChr; ' +
        'Length: Integer; CodePage: Word);'
      
        'procedure _LStrFromWArray(var Dest: _AnsiStr; Source: PWideChar;' +
        ' Length: Integer; CodePage: Word);'
      
        'procedure _LStrFromUStr(var Dest: _AnsiStr; const Source: Unicod' +
        'eString; CodePage: Word);'
      
        'procedure _LStrFromWStr(var Dest: _AnsiStr; const Source: _WideS' +
        'tr; CodePage: Word);'
      
        'procedure _LStrFromString(var Dest: _AnsiStr; const Source: _Sho' +
        'rtStr; CodePage: Word);'
      'procedure _LStrCat(var Dest: _AnsiStr; const Source: _AnsiStr);'
      
        'procedure _LStrCat3(var Dest: _AnsiStr; const Source1, Source2: ' +
        '_AnsiStr);'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _LStrCatN(var Dest: _AnsiStr; ArgCnt: Integer); cdecl;' +
        ' varargs;'
      'function _LStrCmp(const Left, Right: _AnsiStr): Integer;'
      'function _LStrEqual(const Left, Right: _AnsiStr): Integer;'
      '{$ELSE X86ASMRTL}'
      '// dcc32 cannot handle varargs. This function cannot be invoked'
      '// from pure pascal code.'
      'procedure _LStrCatN{var dest:_AnsiStr; argCnt: Integer; ...};'
      
        '// These functions return their result in the flags register. Th' +
        'ey'
      '// cannot be invoked from pure pascal code.'
      'procedure _LStrCmp{left: _AnsiStr; right: _AnsiStr};'
      'procedure _LStrEqual{const Left, Right: _AnsiStr};'
      '{$ENDIF X86ASMRTL}'
      
        'function _LStrCopy(const S: _AnsiStr; Index, Count: Integer): _A' +
        'nsiStr;'
      'procedure _LStrDelete(var S: _AnsiStr; Index, Count: Integer);'
      
        'procedure _LStrInsert(const Source: _AnsiStr; var S: _AnsiStr; I' +
        'ndex: Integer);'
      
        'procedure _LStrSetLength(var Str: _AnsiStr; NewLength: Integer; ' +
        'CodePage: Word);'
      ''
      '{ Compiler helper for _WideStr support }'
      'function _WStrToPWChar(const S: _WideStr): PWideChar;'
      
        'procedure _WStrToString(Dest: _PShortStr; const Source: _WideStr' +
        '; MaxLen: Integer);'
      'procedure _WStrFromChar(var Dest: _WideStr; Source: _AnsiChr);'
      'procedure _WStrFromWChar(var Dest: _WideStr; Source: WideChar);'
      'procedure _WStrFromPChar(var Dest: _WideStr; Source: _PAnsiChr);'
      
        'procedure _WStrFromPWChar(var Dest: _WideStr; Source: PWideChar)' +
        ';'
      
        'procedure _WStrFromArray(var Dest: _WideStr; Source: _PAnsiChr; ' +
        'Length: Integer);'
      
        'procedure _WStrFromWArray(var Dest: _WideStr; Source: PWideChar;' +
        ' Length: Integer);'
      
        'procedure _WStrFromLStr(var Dest: _WideStr; const Source: _AnsiS' +
        'tr);'
      
        'procedure _WStrFromUStr(var Dest: _WideStr; const Source: Unicod' +
        'eString);'
      
        'procedure _WStrFromString(var Dest: _WideStr; const Source: _Sho' +
        'rtStr);'
      'procedure _WStrCat(var Dest: _WideStr; const Source: _WideStr);'
      
        'procedure _WStrCat3(var Dest: _WideStr; const Source1, Source2: ' +
        '_WideStr);'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _WStrCatN(var Dest: _WideStr; ArgCnt: Integer); cdecl;' +
        ' varargs;'
      'function _WStrCmp(const Left, Right: _WideStr): Integer;'
      'function _WStrEqual(const Left, Right: _WideStr): Integer;'
      '{$ELSE X86ASMRTL}'
      '// dcc32 cannot handle varargs. This function cannot be invoked'
      '// from pure pascal code.'
      'procedure _WStrCatN{var dest:_WideStr; argCnt: Integer; ...};'
      
        '// These functions return their result in the flags register. Th' +
        'ey'
      '// cannot be invoked from pure pascal code.'
      'procedure _WStrCmp{left: _WideStr; right: _WideStr};'
      'procedure _WStrEqual{const Left, Right: _WideStr};'
      '{$ENDIF X86ASMRTL}'
      
        'function _WStrCopy(const S: _WideStr; Index, Count: Integer): _W' +
        'ideStr;'
      'procedure _WStrDelete(var S: _WideStr; Index, Count: Integer);'
      
        'procedure _WStrInsert(const Source: _WideStr; var Dest: _WideStr' +
        '; Index: Integer);'
      'procedure _WStrSetLength(var S: _WideStr; NewLength: Integer);'
      ''
      '{ Compiler helper for UnicodeString support }'
      'function _UStrToPWChar(const S: UnicodeString): PWideChar;'
      
        'procedure _UStrToString(Dest: _PShortStr; const Source: UnicodeS' +
        'tring; MaxLen: Integer);'
      
        'procedure _UStrFromChar(var Dest: UnicodeString; Source: _AnsiCh' +
        'r);'
      
        'procedure _UStrFromWChar(var Dest: UnicodeString; Source: WideCh' +
        'ar);'
      
        'procedure _UStrFromPChar(var Dest: UnicodeString; Source: _PAnsi' +
        'Chr);'
      
        'procedure _UStrFromPWChar(var Dest: UnicodeString; Source: PWide' +
        'Char);'
      
        'procedure _UStrFromArray(var Dest: UnicodeString; Source: _PAnsi' +
        'Chr; Length: Integer);'
      
        'procedure _UStrFromWArray(var Dest: UnicodeString; Source: PWide' +
        'Char; Length: Integer);'
      
        'procedure _UStrFromLStr(var Dest: UnicodeString; const Source: _' +
        'AnsiStr);'
      
        'procedure _UStrFromWStr(var Dest: UnicodeString; const Source: _' +
        'WideStr);'
      
        'procedure _UStrFromString(var Dest: UnicodeString; const Source:' +
        ' _ShortStr);'
      
        'procedure _UStrCat(var Dest: UnicodeString; const Source: Unicod' +
        'eString);'
      
        'procedure _UStrCat3(var Dest: UnicodeString; const Source1, Sour' +
        'ce2: UnicodeString);'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _UStrCatN(var Dest: UnicodeString; ArgCnt: Integer); c' +
        'decl; varargs;'
      'function _UStrCmp(const Left, Right: UnicodeString): Integer;'
      'function _UStrEqual(const Left, Right: UnicodeString): Integer;'
      '{$ELSE X86ASMRTL}'
      '// dcc32 cannot handle varargs. This function cannot be invoked'
      '// from pure pascal code.'
      
        'procedure _UStrCatN{var dest:UnicodeString; argCnt: Integer; ...' +
        '};'
      
        '// These functions return their result in the flags register. Th' +
        'ey'
      '// cannot be invoked from pure pascal code.'
      'procedure _UStrCmp{const Left, Right: UnicodeString};'
      'procedure _UStrEqual{const Left, Right: UnicodeString};'
      '{$ENDIF X86ASMRTL}'
      
        'function _UStrCopy(const S: UnicodeString; Index, Count: Integer' +
        '): UnicodeString;'
      
        'procedure _UStrDelete(var S: UnicodeString; Index, Count: Intege' +
        'r);'
      
        'procedure _UStrInsert(const Source: UnicodeString; var Dest: Uni' +
        'codeString; Index: Integer);'
      
        'procedure _UStrSetLength(var Str: UnicodeString; NewLength: Inte' +
        'ger);'
      ''
      '{ string utilities }'
      
        'function _UStrPos(SubStr, Str: PWideChar; Offset: Integer): Inte' +
        'ger;'
      '{$IFDEF MSWINDOWS}'
      
        'function _WStrPos(SubStr, Str: PWideChar; Offset: Integer): Inte' +
        'ger;'
      '{$ENDIF MSWINDOWS}'
      
        'function _LStrPos(SubStr, Str: _PAnsiChr; Offset: Integer): Inte' +
        'ger;'
      ''
      
        'function Pos(const SubStr, Str: _ShortStr; Offset: Integer = 1):' +
        ' Integer; overload;'
      
        'function Pos(const SubStr, Str: UnicodeString; Offset: Integer =' +
        ' 1): Integer; overload; inline;'
      
        'function Pos(const SubStr, Str: _WideStr; Offset: Integer = 1): ' +
        'Integer; overload; inline;'
      
        'function Pos(const SubStr, Str: _RawByteStr; Offset: Integer = 1' +
        '): Integer; overload; inline;'
      
        'function StringOfChar(Ch: WideChar; Count: Integer): UnicodeStri' +
        'ng; overload;'
      
        'function StringOfChar(Ch: _AnsiChr; Count: Integer): _AnsiStr; o' +
        'verload;'
      
        'procedure SetAnsiString(Dest: _PAnsiStr; Source: _PAnsiChr; Leng' +
        'th: Integer; CodePage: Word); overload;'
      
        'procedure SetAnsiString(Dest: _PAnsiStr; Source: PWideChar; Leng' +
        'th: Integer; CodePage: Word); overload;'
      
        'procedure SetCodePage(var S: _RawByteStr; CodePage: Word; Conver' +
        't: Boolean = True);'
      
        'function UnicodeStringToUCS4String(const S: UnicodeString): UCS4' +
        'String;'
      
        'function UCS4StringToUnicodeString(const S: UCS4String): Unicode' +
        'String;'
      
        'function WideCharToUCS4String(S: PWideChar; Len: Integer = MaxIn' +
        't): UCS4String;'
      '//function UTF8Encode(const WS: UnicodeString): UTF8String;'
      '//function UTF8Decode(const S: UTF8String): UnicodeString;'
      ''
      
        'function _Write0UString(var t: TTextRec; const s: UnicodeString)' +
        ': Pointer;'
      
        'function _WriteUString(var t: TTextRec; const s: UnicodeString; ' +
        'width: Integer): Pointer;'
      ''
      ''
      '{ Compiler helper for initializing/finalizing variable }'
      
        'procedure InitializeArray(p: Pointer; typeInfo: Pointer; elemCou' +
        'nt: NativeUInt);'
      'procedure _Initialize(p: Pointer; typeInfo: Pointer);'
      
        'procedure _InitializeArray(p: Pointer; typeInfo: Pointer; elemCo' +
        'unt: NativeUInt);'
      'procedure _InitializeRecord(p: Pointer; typeInfo: Pointer);'
      '{$IF (not defined(X86ASMRTL)) or defined(MANAGED_RECORD)}'
      
        '// dcc64 generated code expects P to remain in RAX on exit from ' +
        'this function.'
      'function _Finalize(P: Pointer; TypeInfo: Pointer): Pointer;'
      
        'function _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCount' +
        ': NativeUInt): Pointer;'
      
        'function _FinalizeRecord(P: Pointer; TypeInfo: Pointer): Pointer' +
        ';'
      '{$ELSE}'
      'procedure _Finalize(p: Pointer; typeInfo: Pointer);'
      
        'procedure _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCoun' +
        't: NativeUInt);'
      'procedure _FinalizeRecord(P: Pointer; TypeInfo: Pointer);'
      '{$ENDIF}'
      '{$IF not defined(X86ASMRTL)}'
      'procedure _CopyRecord(Dest, Source, TypeInfo: Pointer);'
      
        'procedure _CopyObject(Dest, Source: Pointer; vmtPtrOffs: NativeI' +
        'nt; TypeInfo: Pointer);'
      
        'procedure _CopyArray(Dest, Source, TypeInfo: Pointer; Count: Nat' +
        'iveUInt);'
      '{$ELSE}'
      
        '// The asm implementation of these functions uses EBP as a gener' +
        'al'
      
        '// purpose register, and assumes a frame is not added. Adding pa' +
        'rameters'
      
        '// adds the frame, so in order to define the parameters for thes' +
        'e functions,'
      '// the ASM needs to be updated.'
      'procedure _CopyRecord;'
      'procedure _CopyObject;'
      'procedure _CopyArray;'
      '{$ENDIF}'
      'procedure _AddRef(P: Pointer; TypeInfo: Pointer);'
      
        'procedure _AddRefArray(P: Pointer; TypeInfo: Pointer; ElemCount:' +
        ' NativeUInt);'
      'procedure _AddRefRecord(P: Pointer; TypeInfo: Pointer);'
      ''
      'function _New(Size: NativeInt; TypeInfo: Pointer): Pointer;'
      'procedure _Dispose(P: Pointer; TypeInfo: Pointer);'
      ''
      '/// <summary>Copy Count items in Array. </summary>'
      
        'procedure CopyArray(Dest, Source, TypeInfo: Pointer; Count: Nati' +
        'veInt);'
      '/// <summary>Move Count items in Array. </summary>'
      
        '/// <remarks>MoveArray is equivalent to calling CopyArray(Dest, ' +
        'Souce, TypeInfo, Count)'
      '/// then FinalizeArray(Source, TypeInfo, count)</remarks>'
      
        'procedure MoveArray(Dest, Source, TypeInfo: Pointer; Count: Nati' +
        'veInt);'
      '/// <summary>Finalize Count items in Array. </summary>'
      
        'procedure FinalizeArray(P: Pointer; TypeInfo: Pointer; Count: Na' +
        'tiveUInt);'
      ''
      '/// <summary>Copy fields in Record. </summary>'
      'procedure CopyRecord(Dest, Source, TypeInfo: Pointer);'
      '/// <summary>Move fields in Record. </summary>'
      
        '/// <remarks>MoveRecord is equivalent to calling CopyRecord(Dest' +
        ', Souce, TypeInfo)'
      '/// then FinalizeRecord(Source, TypeInfo)</remarks>'
      'procedure MoveRecord(Dest, Source, TypeInfo: Pointer);'
      '/// <summary>Finalize fields in Record. </summary>'
      'procedure FinalizeRecord(P: Pointer; TypeInfo: Pointer);'
      ''
      '/// <summary>Call Initialize operator for Dest if exist.'
      
        '/// Otherwise call per each managed record member of the record.' +
        ' </summary>'
      'procedure InvokeRecordInitializer(Dest, TypeInfo: Pointer);'
      
        '/// <summary>Call Finalize operator per each elements of the arr' +
        'ay. </summary>'
      
        'procedure InvokeRecordInitializerArray(Dest, TypeInfo: Pointer; ' +
        'ElemCount: NativeUInt);'
      ''
      '{ 64-bit Integer helper routines }'
      '{$IF defined(CPU386) and defined(ASSEMBLER)}'
      'procedure __llmul;'
      'procedure __lldiv;'
      'procedure __lludiv;'
      'procedure __llmod;'
      'procedure __llmulo;'
      'procedure __llumulo;'
      'procedure __lldivo;'
      'procedure __llmodo;'
      'procedure __llumod;'
      'procedure __llshl;'
      'procedure __llushr;'
      '{$ENDIF}'
      
        'function _WriteInt64(var t: TTextRec; val: Int64; width: Integer' +
        '): Pointer;'
      'function _Write0Int64(var t: TTextRec; val: Int64): Pointer;'
      
        'function _WriteUInt64(var t: TTextRec; val: UInt64; width: Integ' +
        'er): Pointer;'
      'function _Write0UInt64(var t: TTextRec; val: UInt64): Pointer;'
      'function _ReadInt64(var t: TTextRec): Int64;'
      'function _ReadUInt64(var t: TTextRec): UInt64;'
      'function _StrInt64(val: Int64; width: Integer): _ShortStr;'
      'function _Str0Int64(val: Int64): _ShortStr;'
      'function _ValInt64(const S: string; var Code: Integer): Int64;'
      'function _ValUInt64(const s: string; var code: Integer): UInt64;'
      'function _StrUInt64(val: UInt64; width: Integer): _ShortStr;'
      'function _Str0UInt64(val: Int64): _ShortStr;'
      ''
      '{ check and register WeakRef information }'
      ''
      '// Both procedure/function are internal use only.'
      '// index: 0 - reserved for System.RTTI.TValue'
      
        'procedure RegisterWeakRefTypeInfo(const aTypeInfo: Pointer; cons' +
        't value: Boolean; const index: Integer);'
      'function SysHasWeakRef(const elementType: Pointer): Boolean;'
      ''
      '{ Compiler helper for Dynamic array support }'
      ''
      'function _DynArrayLength(const A: Pointer): NativeInt; inline;'
      'function _DynArrayHigh(const A: Pointer): NativeInt; inline;'
      ''
      
        'procedure DynArrayClear(var A: Pointer; TypeInfo: Pointer); inli' +
        'ne;'
      ''
      
        'procedure DynArraySetLength(var a: Pointer; typeInfo: Pointer; d' +
        'imCnt: NativeInt; lengthVec: PNativeInt);'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _DynArraySetLength(var A: Pointer; TypeInfo: Pointer; ' +
        'DimCnt: NativeInt); cdecl; varargs;'
      '{$ELSE}'
      
        '// dcc32 does not support varargs params. This cannot be called ' +
        'from'
      '// pure pascal code'
      'procedure _DynArraySetLength;'
      '{$ENDIF}'
      ''
      '{$IF defined(X86ASMRTL)}'
      
        'procedure _DynArrayCopy(a: Pointer; typeInfo: Pointer; var Resul' +
        't: Pointer);'
      
        'procedure _DynArrayCopyRange(A: Pointer; TypeInfo: Pointer; Inde' +
        'x, Count : Integer; var Result: Pointer);'
      '{$ELSE}'
      
        'procedure _DynArrayCopy(var Result: Pointer; a: Pointer; typeInf' +
        'o: Pointer);'
      
        'procedure _DynArrayCopyRange(var Result: Pointer; A: Pointer; Ty' +
        'peInfo: Pointer; Index, Count: NativeInt);'
      '{$ENDIF}'
      ''
      
        'procedure DynArrayCopy(var Result: Pointer; a: Pointer; typeInfo' +
        ': Pointer); inline;'
      
        'procedure DynArrayCopyRange(var Result: Pointer; A: Pointer; Typ' +
        'eInfo: Pointer; Index, Count: NativeInt); inline;'
      'procedure DynArrayUnique(var A: Pointer; typeInfo: Pointer);'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        '// dcc64 expects RAX to maintain a pointer to A on return, so we' +
        ' must return it'
      
        'function _DynArrayClear(var A: Pointer; TypeInfo: Pointer): Poin' +
        'ter;'
      '{$ELSE}'
      
        '// dcc32 expects EAX to maintain a pointer to A on return implem' +
        'ented by asm.'
      'procedure _DynArrayClear(var a: Pointer; typeInfo: Pointer);'
      '{$ENDIF}'
      
        'procedure _DynArrayAsg(var Dest: Pointer; Src: Pointer; TypeInfo' +
        ': Pointer);'
      'procedure _DynArrayAddRef(P: Pointer);'
      'function  _DynArrayRelease(P: Pointer): Integer;'
      ''
      
        'procedure _DynArrayCat(var Dest: Pointer; Source: Pointer; typeI' +
        'nfo: Pointer);'
      
        'procedure _DynArrayCat3(var Dest: Pointer; Source1, Source2: Poi' +
        'nter; typeInfo: Pointer);'
      
        'procedure _DynArrayCatN(var Dest: Pointer; ArgCnt: Integer; type' +
        'Info: Pointer; Arrays: PPointer);'
      
        'procedure _DynArrayDelete(var Dest: Pointer; Index, Count: Nativ' +
        'eInt; typeInfo: Pointer);'
      
        'procedure _DynArrayInsert(Source: Pointer; var Dest: Pointer; In' +
        'dex: NativeInt; typeInfo: Pointer);'
      
        'procedure _DynArrayInsertElem(const Source; var Dest: Pointer; I' +
        'ndex: NativeInt; typeInfo: Pointer);'
      ''
      '{$IF (not defined(WEAK_NATIVEINT)) or defined(CPU64BITS)}'
      
        'function DynArrayIndex(P: Pointer; const Indices: array of Nativ' +
        'eInt; TypInfo: Pointer): Pointer; overload;'
      '{$ENDIF}'
      
        'function DynArrayIndex(P: Pointer; const Indices: array of Integ' +
        'er; TypInfo: Pointer): Pointer; overload;'
      ''
      'function DynArrayDim(typeInfo: Pointer): Integer;'
      ''
      'function DynArraySize(A: Pointer): NativeInt; inline;'
      
        'procedure DynArrayAssign(var Dest: Pointer; Source: Pointer; typ' +
        'eInfo: Pointer); inline;'
      ''
      
        'function IsDynArrayRectangular(const DynArray: Pointer; typeInfo' +
        ': Pointer): Boolean;'
      
        'function DynArrayBounds(const DynArray: Pointer; typeInfo: Point' +
        'er): TBoundArray;'
      ''
      'function _IntfClear(var Dest: IInterface): Pointer;'
      
        'procedure _IntfCopy(var Dest: IInterface; const Source: IInterfa' +
        'ce);'
      
        'procedure _IntfCast(var Dest: IInterface; const Source: IInterfa' +
        'ce; const IID: TGUID);'
      
        'procedure _IntfOfsCast(var Dest: IInterface; const Source: TObje' +
        'ct; const Offset: Integer);'
      'procedure _IntfAddRef(const Dest: IInterface);'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      'function _InstClear(var Dest: TObject): Pointer;'
      'procedure _InstCopy(var Dest: TObject; const Source: TObject);'
      'procedure _InstAddRef(const Dest: TObject);'
      ''
      'procedure _ClosureAddWeakRef(var Closure: TMethod);'
      'function _ClosureRemoveWeakRef(var Closure: TMethod): Pointer;'
      
        'procedure _ClosureArrayRemoveWeakRef(var Closure: TMethod; Count' +
        ': Integer);'
      
        'procedure _CopyClosure(var Dest: TMethod; const [Ref] Source: TM' +
        'ethod);'
      
        'function _AsgClosureClassMethod(var Dest: TMethod; const Obj: Po' +
        'inter; const MethodAddr: Pointer): Pointer;'
      
        'function _AsgClosureObj(var Dest: TMethod; const Obj: Pointer; c' +
        'onst MethodAddr: Pointer): Pointer;'
      '{$ENDIF}'
      ''
      '{$IFDEF WEAKINSTREF}'
      '// Helpers for managing weak references'
      'function _InstWeakClear(var Dest: TObject): Pointer;'
      'procedure _InstWeakArrayClear(var Dest; Count: Integer);'
      'procedure _InstWeakCopy(var Dest: TObject; Source: TObject);'
      '{$ENDIF}'
      ''
      '{$IFDEF WEAKINTFREF}'
      'function _IntfWeakClear(var Dest: IInterface): Pointer;'
      'procedure _IntfWeakArrayClear(var Dest; Count: Integer);'
      
        'procedure _IntfWeakCopy(var Dest: IInterface; const Source: IInt' +
        'erface);'
      '{$ENDIF}'
      ''
      '{$IFDEF WEAKREF}'
      'procedure _CleanupInstance(Instance: Pointer);'
      '{$ENDIF}'
      ''
      '{$IFDEF WIN32}'
      'procedure _FSafeDivide;'
      'procedure _FSafeDivideR;'
      '{$ENDIF}'
      ''
      'function _CheckAutoResult(ResultCode: HResult): HResult;'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'function FPower10(val: Extended; power: Integer): Extended; depr' +
        'ecated '#39'Use Power10'#39';'
      '{$ELSE X86ASMRTL}'
      
        '// Publically accessable function that cannot be called propperl' +
        'y'
      '// from pure pascal code deprecated.'
      'procedure FPower10; deprecated '#39'Use Power10'#39';'
      '{$ENDIF X86ASMRTL}'
      'function Power10(val: Extended; power: Integer): Extended;'
      ''
      'procedure TextStart; deprecated;'
      ''
      
        '// Conversion utility routines for C++ convenience.  Not for Del' +
        'phi code.'
      'function  CompToDouble(Value: Comp): Double; cdecl;'
      'procedure DoubleToComp(Value: Double; var Result: Comp); cdecl;'
      'function  CompToCurrency(Value: Comp): Currency; cdecl;'
      
        'procedure CurrencyToComp(Value: Currency; var Result: Comp); cde' +
        'cl;'
      ''
      'function GetMemory(Size: NativeInt): Pointer; cdecl;'
      'function FreeMemory(P: Pointer): Integer; cdecl;'
      
        'function ReallocMemory(P: Pointer; Size: NativeInt): Pointer; cd' +
        'ecl;'
      ''
      ''
      '{ Internal runtime error codes }'
      ''
      'type'
      
        '  TRuntimeError = (reNone, reOutOfMemory, reInvalidPtr, reDivByZ' +
        'ero,'
      
        '    reRangeError, reIntOverflow, reInvalidOp, reZeroDivide, reOv' +
        'erflow,'
      
        '    reUnderflow, reInvalidCast, reAccessViolation, rePrivInstruc' +
        'tion,'
      '    reControlBreak, reStackOverflow,'
      '    { reVar* used in Variants.pas }'
      '    reVarTypeCast, reVarInvalidOp,'
      
        '    reVarDispatch, reVarArrayCreate, reVarNotArray, reVarArrayBo' +
        'unds,'
      '    reAssertionFailed,'
      '    reExternalException, { not used here; in SysUtils }'
      '    reIntfCastError, reSafeCallError,'
      '    reMonitorNotLocked, reNoMonitorSupport,'
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      '    reQuit,'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      '{$IFDEF POSIX}'
      '    reCodesetConversion,'
      '{$ENDIF POSIX}'
      '    rePlatformNotImplemented, reObjectDisposed'
      '  );'
      '{$NODEFINE TRuntimeError}'
      ''
      'procedure Error(errorCode: TRuntimeError);'
      '{$NODEFINE Error}'
      ''
      
        '{ GetLastError returns the last error reported by an OS API call' +
        '.  Calling'
      '  this function usually resets the OS error state.'
      '}'
      ''
      
        'function GetLastError: Integer; {$IFDEF MSWINDOWS} stdcall; {$EN' +
        'DIF}'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM GetLastError}'
      '{$ENDIF}'
      ''
      
        '{ SetLastError writes to the thread local storage area read by G' +
        'etLastError. }'
      ''
      
        'procedure SetLastError(ErrorCode: Integer); {$IFDEF MSWINDOWS} s' +
        'tdcall; {$ENDIF}'
      '{$IFDEF MSWINDOWS}'
      '  {$EXTERNALSYM SetLastError}'
      '{$ENDIF}'
      ''
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      
        '{  To improve performance, some RTL routines cache module handle' +
        's and data'
      
        '   derived from modules.  If an application dynamically loads an' +
        'd unloads'
      
        '   shared object libraries, packages, or resource packages, it i' +
        's possible for'
      
        '   the handle of the newly loaded module to match the handle of ' +
        'a recently'
      
        '   unloaded module.  The resource caches have no way to detect w' +
        'hen this happens.'
      ''
      
        '   To address this issue, the RTL maintains an internal counter ' +
        'that is'
      
        '   incremented every time a module is loaded or unloaded using R' +
        'TL functions'
      
        '   (like LoadPackage).  This provides a cache version level sign' +
        'ature that'
      
        '   can detect when modules have been cycled but have the same ha' +
        'ndle.'
      ''
      
        '   If you load or unload modules "by hand" using dlopen or dlclo' +
        'se, you must call'
      
        '   InvalidateModuleCache after each load or unload so that the R' +
        'TL module handle'
      
        '   caches will refresh themselves properly the next time they ar' +
        'e used.  This is'
      
        '   especially important if you manually tinker with the LibModul' +
        'eList list of'
      
        '   loaded modules, or manually add or remove resource modules in' +
        ' the nodes'
      '   of that list.'
      ''
      
        '   ModuleCacheID returns the "current generation" or version num' +
        'ber kept by'
      
        '   the RTL.  You can use this to implement your own refresh-on-n' +
        'ext-use'
      
        '   (passive) module handle caches as the RTL does.  The value ch' +
        'anges each'
      '   time InvalidateModuleCache is called.'
      '}'
      ''
      'function ModuleCacheID: Cardinal;'
      'procedure InvalidateModuleCache;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      ''
      'procedure SetMultiByteConversionCodePage(CodePage: Integer);'
      ''
      'function GetUILanguages(const LANGID: WORD): string;'
      'function GetLocaleOverride(const AppName: string): string;'
      
        'procedure SetLocaleOverride(const NewPreferredLanguages: string)' +
        ';'
      ''
      'type'
      '  PLongBool = ^LongBool;'
      ''
      
        '{ LocaleCharsFromUnicode is a cross-platform wrapper for WideCha' +
        'rToMultiByte'
      
        '  with an emulated implemention on non-Windows platforms. The Fl' +
        'ags parameter'
      '  isn'#39't supported on non-Windows platforms }'
      ''
      'function LocaleCharsFromUnicode(CodePage, Flags: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      ''
      '{$IFDEF POSIX}'
      
        'function LocaleCharsFromUnicode(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      '{$ENDIF}'
      ''
      
        '{ UnicodeFromLocaleChars is a cross-platform wrapper for MultiBy' +
        'teToWideChar'
      
        '  with an emulated implemention on non-Windows platforms. The Fl' +
        'ags parameter'
      '  only supports MB_ERR_INVALID_CHARS on non-Windows platforms }'
      ''
      
        'function UnicodeFromLocaleChars(CodePage, Flags: Cardinal; Local' +
        'eStr: _PAnsiChr;'
      
        '  LocaleStrLen: Integer; UnicodeStr: PWideChar; UnicodeStrLen: I' +
        'nteger): Integer; overload;'
      ''
      '{$IFDEF POSIX}'
      
        'function UnicodeFromLocaleChars(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWide' +
        'Char;'
      '  UnicodeStrLen: Integer): Integer; overload;'
      '{$ENDIF}'
      ''
      '{$IFDEF POSIX}'
      
        '{ GetACP returns the equivalent Windows codepage identifier base' +
        'd on the'
      
        '  current LANG environment variable (Linux) or CFLocaleGetIdenti' +
        'fier (Mac OS) }'
      ''
      'function GetACP: Cardinal;'
      '{$ENDIF}'
      ''
      
        '{ Compatibility consts for LocaleCharsFromUnicode/UnicodeFromLoc' +
        'aleChars }'
      ''
      '(*$HPPEMIT '#39'#if !defined(CP_ACP)'#39' *)'
      
        '(*$HPPEMIT '#39'static const System::Word CP_ACP = System::Word(0);'#39 +
        ' *)'
      '(*$HPPEMIT '#39'#endif'#39' *)'
      '(*$HPPEMIT '#39'#if !defined(CP_UTF7)'#39' *)'
      
        '(*$HPPEMIT '#39'static const System::Word CP_UTF7 = System::Word(650' +
        '00);'#39' *)'
      '(*$HPPEMIT '#39'#endif'#39' *)'
      '(*$HPPEMIT '#39'#if !defined(CP_UTF8)'#39' *)'
      
        '(*$HPPEMIT '#39'static const System::Word CP_UTF8 = System::Word(650' +
        '01);'#39' *)'
      '(*$HPPEMIT '#39'#endif'#39' *)'
      'const'
      '  CP_ACP  = 0;'
      '  CP_UTF7 = 65000;'
      '  CP_UTF8 = 65001;'
      '{$NODEFINE CP_ACP}'
      '{$NODEFINE CP_UTF7}'
      '{$NODEFINE CP_UTF8}'
      ''
      '{$IF defined(MACOS)}'
      
        '// CFLocaleRef and __CFLocale are moved from CFLocale.inc and Co' +
        'reFoundationAPI.inc'
      'type'
      '  CFLocaleRef = ^__CFLocale;'
      '  {$EXTERNALSYM CFLocaleRef}'
      '  __CFLocale = record'
      '  end;'
      '  {$EXTERNALSYM __CFLocale '#39'__CFLocale'#39'}'
      '  {$OBJTYPENAME __CFLocale '#39'B10__CFLocale'#39' '#39'G10__CFLocale'#39' }'
      '{$ENDIF defined(MACOS)}'
      ''
      '{$IFDEF ANDROID}'
      'var'
      '/// <summary>The ponter to the android native activity</summary>'
      '/// <remarks>In a service this pointer will be nil</remarks>'
      '  DelphiActivity: Pointer;'
      '/// <summary>The ponter to the android java machine</summary>'
      '  JavaMachine: Pointer;'
      '/// <summary>The ponter to the android context</summary>'
      
        '/// <remarks>In an application this pointer will be the context ' +
        'of the activity'
      
        '/// In a service this pointer will be the context of the service' +
        '</remarks>'
      '  JavaContext: Pointer;'
      '{$ENDIF}'
      ''
      '{$IFDEF USE_LIBICU}'
      'var'
      '  HICUUC: NativeUInt;'
      '  HICUI18N: NativeUInt;'
      '  LibICUSuffix: string;'
      ''
      '  procedure ReleaseICUThreadResources;'
      '{$ENDIF}'
      ''
      
        'function IsICUAvailable: Boolean; {$IFNDEF USE_LIBICU}inline;{$E' +
        'NDIF}'
      ''
      '{$IFNDEF MSWINDOWS}'
      'const'
      '{$IFDEF CPUARM}'
      '  {$IFDEF ANDROID}'
      '  LibCPP = '#39'c++_static'#39';'
      '  LibCPP_ABI = '#39'c++abi'#39';'
      '  {$ELSE}'
      '  LibCPP = {$IFDEF MACOS}'#39'c++'#39'{$ELSE}'#39'gnustl_static'#39'{$ENDIF};'
      '  {$ENDIF ANDROID}'
      '{$ELSE}'
      '  LibCPP = '#39'stdc++'#39';'
      '{$ENDIF CPUARM}'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF ANDROID}'
      
        '/// <summary>Controls the behavior of string and dynamic-array t' +
        'ypes when increasing their length</summary>'
      
        '/// <remarks>The memory manager in Android 12 later has a restri' +
        'ction on in-place memory block expansion.'
      
        '/// This may cause performance losses when extending the length ' +
        'of the string and dynamic-array types.'
      
        '/// An additional 256 bytes each of space is allocated for those' +
        ' types to avoid this problem when allocating'
      '/// memory blocks larger than 64k bytes.</remarks>'
      'var'
      '  EnableReallocMemoryGap: Boolean = True;'
      '{$ENDIF}'
      ''
      'implementation'
      ''
      'uses'
      '  SysInit;'
      ''
      'const'
      '{$IFDEF UNDERSCOREIMPORTNAME}'
      '  _PU = '#39'_'#39';'
      '{$ELSE}'
      '  _PU = '#39#39';'
      '{$ENDIF}'
      ''
      '{$IFDEF POSIX}'
      '{$I PosixAPIs.inc}'
      '{$ENDIF POSIX}'
      ''
      '{$IFDEF MACOS}'
      '{$I CoreServicesAPIs.inc}'
      '{$I CoreFoundationAPIs.inc}'
      '{$ENDIF MACOS}'
      ''
      '{$IFDEF ANDROID}'
      '{$I Android.inc}'
      '{$ENDIF ANDROID}'
      ''
      '{$IFDEF USE_LIBICU}'
      '{$I ICU.inc}'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IFDEF POSIX}'
      'const'
      '  MAX_PATH = 1024;'
      '{$ENDIF}'
      ''
      ''
      'type'
      '  // For System.pas internal use only.'
      
        '  // Note, this type is duplicated in getmem.inc for diagnostic ' +
        'purposes. Keep in sync.'
      '  PStrRec = ^StrRec;'
      '  StrRec = packed record'
      '  {$IF defined(CPU64BITS)}'
      '    _Padding: Integer; // Make 16 byte align for payload..'
      '  {$ENDIF}'
      '    codePage: Word;'
      '    elemSize: Word;'
      '    refCnt: Integer;'
      '    length: Integer;'
      '  end;'
      ''
      'type'
      '  PMethRec = ^MethRec;'
      '  MethRec = packed record'
      '    recSize: Word;'
      '    methAddr: Pointer;'
      '    nameLen: Byte;'
      '    { nameChars[nameLen]: _AnsiChr }'
      '  end;'
      ''
      'const'
      '  skew = SizeOf(StrRec);'
      '  rOff = SizeOf(StrRec); { codePage offset }'
      '  overHead = SizeOf(StrRec) + SizeOf(Char);'
      '  CP_UTF16 = 1200;'
      ''
      'type'
      '  PDynArrayRec = ^TDynArrayRec;'
      '  TDynArrayRec = packed record'
      '  {$IFDEF CPU64BITS}'
      '    _Padding: Integer; // Make 16 byte align for payload..'
      '  {$ENDIF}'
      '    RefCnt: Integer;'
      '    Length: NativeInt;'
      '  end;'
      ''
      'const'
      '  STATUS_WAIT_0 = Cardinal($00000000);'
      '  WAIT_OBJECT_0 = (STATUS_WAIT_0 + 0);'
      '  ObjCastGUID: TGUID = '#39'{CEDF24DE-80A4-447D-8C75-EB871DC121FD}'#39';'
      ''
      'const'
      '  { Record Operator Index }'
      '  roiRecFlags = 0;'
      '  roiInitializer = 1;'
      '  roiFinalizer = 2;'
      '  roiAssignOperator = 3;'
      '  { Record Operator Flags }'
      '  rofHasNonZeroInit = 1;'
      '  rofHasWeakField = 2;'
      ''
      ''
      '{ This procedure should be at the very beginning of the }'
      '{ text segment. It used to be used by _RunError to find    }'
      '{ start address of the text segment, but is not used anymore.  }'
      ''
      'procedure TextStart;'
      'begin'
      'end;'
      ''
      '{$IFNDEF PUREPASCAL}'
      '{$IFDEF PIC}'
      'function GetGOT: Pointer;'
      'begin'
      '  asm'
      '        MOV Result,EBX'
      '  end;'
      'end;'
      '{$ENDIF}'
      '{$ENDIF PUREPASCAL}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'var'
      '  Unwinder: TUnwinder;'
      ''
      'const'
      '  UNWINDFI_TOPOFSTACK = $BE00EF00;'
      ''
      'type'
      '  UNWINDPROC = Pointer;'
      ''
      'const'
      '{$IFDEF MSWINDOWS}'
      '  unwind = '#39'unwind.dll'#39';'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF LINUX32}'
      '  unwind = '#39'libcgunwind.so.1'#39';'
      '{$ENDIF LINUX32}'
      '{$IFDEF MACOS32}'
      '  unwind = '#39'libcgunwind.1.0.dylib'#39';'
      '{$ENDIF MACOS32}'
      ''
      
        '                                                                ' +
        '                     '
      
        'function _BorUnwind_RegisterIPLookup(fn: Pointer; StartAddr, End' +
        'Addr: NativeUInt;'
      '  Context: Pointer; GOT: NativeUInt): LongBool; cdecl; external'
      
        '  {$IFNDEF STATIC_UNWIND} unwind name _PU + '#39'_BorUnwind_Register' +
        'IPLookup'#39'{$ENDIF STATIC_UNWIND};'
      ''
      
        '                                                                ' +
        '                       '
      
        'procedure _BorUnwind_UnregisterIPLookup(StartAddr: NativeUInt); ' +
        'cdecl; external'
      
        '  {$IFNDEF STATIC_UNWIND} unwind name _PU + '#39'_BorUnwind_Unregist' +
        'erIPLookup'#39'{$ENDIF STATIC_UNWIND};'
      ''
      
        '                                                                ' +
        '                 '
      
        'function _BorUnwind_DelphiLookup(Addr: NativeUInt; Context: Poin' +
        'ter): UNWINDPROC; cdecl; external'
      
        '  {$IFNDEF STATIC_UNWIND} unwind name _PU + '#39'_BorUnwind_DelphiLo' +
        'okup'#39'{$ENDIF STATIC_UNWIND};'
      ''
      
        'function _BorUnwind_RaiseException(Exc: Pointer): LongBool; cdec' +
        'l; external'
      
        '  {$IFNDEF STATIC_UNWIND} unwind name _PU + '#39'_BorUnwind_RaiseExc' +
        'eption'#39'{$ENDIF STATIC_UNWIND};'
      ''
      
        '                                                                ' +
        '                          '
      
        'function _BorUnwind_ClosestDelphiHandler(Context: Pointer): Nati' +
        'veUInt; cdecl; external'
      
        '  {$IFNDEF STATIC_UNWIND} unwind name _PU + '#39'_BorUnwind_ClosestD' +
        'elphiHandler'#39'{$ENDIF STATIC_UNWIND};'
      ''
      '{$IFDEF STATIC_UNWIND}'
      '{$IFDEF PIC}'
      '{$L '#39'objs/arith.pic.o'#39'}'
      '{$L '#39'objs/diag.pic.o'#39'}'
      '{$L '#39'objs/delphiuw.pic.o'#39'}'
      '{$L '#39'objs/unwind.pic.o'#39'}'
      '{$ELSE !PIC}'
      '{$L '#39'objs/arith.o'#39'}'
      '{$L '#39'objs/diag.o'#39'}'
      '{$L '#39'objs/delphiuw.o'#39'}'
      '{$L '#39'objs/unwind.o'#39'}'
      '{$ENDIF}'
      '{$ENDIF STATIC_UNWIND}'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      'const { copied from xx.h }'
      '  cContinuable        = 0;'
      '  cNonContinuable     = 1;'
      '  cUnwinding          = 2;'
      '  cUnwindingForExit   = 4;'
      '  cUnwindInProgress   = cUnwinding or cUnwindingForExit;'
      '  cDelphiException    = $0EEDFADE;'
      '  cDelphiReRaise      = $0EEDFADF;'
      '  cDelphiExcept       = $0EEDFAE0;'
      '  cDelphiFinally      = $0EEDFAE1;'
      '  cDelphiTerminate    = $0EEDFAE2;'
      '  cDelphiUnhandled    = $0EEDFAE3;'
      '  cNonDelphiException = $0EEDFAE4;'
      '  cDelphiExitFinally  = $0EEDFAE5;'
      '{$IFDEF WIN64}'
      '  cCppExceptionMask   = $FFFFFFFE;'
      '  cCppException       = $E36C6700;'
      '{$ELSE !WIN64}'
      '  cCppException       = $0EEFFACE; { used by BCB }'
      '{$ENDIF WIN64}'
      '  EXCEPTION_CONTINUE_SEARCH    = 0;'
      '  EXCEPTION_EXECUTE_HANDLER    = 1;'
      '  EXCEPTION_CONTINUE_EXECUTION = -1;'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'const'
      '  excIsBeingHandled     = $00000001;'
      '  excIsBeingReRaised    = $00000002;'
      '{$ENDIF}'
      ''
      '{$IF defined(CPU386) and not defined(PC_MAPPED_EXCEPTIONS)}'
      'type'
      '  JmpInstruction ='
      '  packed record'
      '    opCode:   Byte;'
      '    distance: Longint;'
      '  end;'
      '{$ENDIF CPU386 and !PC_MAPPED_EXCEPTIONS}'
      ''
      '{$IFDEF CPU386}'
      'type'
      '  PExcDescEntry = ^TExcDescEntry;'
      '  TExcDescEntry = record'
      '    vTable:  Pointer;'
      '    handler: Pointer;'
      '  end;'
      '  PExcDesc = ^TExcDesc;'
      '  TExcDesc = packed record'
      '{$IFNDEF PC_MAPPED_EXCEPTIONS}'
      '    jmp: JmpInstruction;'
      '{$ENDIF}'
      '    case Integer of'
      '    0:      (instructions: array [0..0] of Byte);'
      
        '    1{...}: (cnt: Integer; excTab: array [0..0{cnt-1}] of TExcDe' +
        'scEntry);'
      '  end;'
      '{$ENDIF}'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '// Language specific exception data'
      'type'
      '  PExcDescEntry = ^TExcDescEntry;'
      '  TExcDescEntry = record'
      '    VTable:  LongWord; // 32 bit RVA'
      '    Handler: LongWord; // 32 bit RVA'
      '  end;'
      '  PExcDesc = ^TExcDesc;'
      '  TExcDesc = record'
      '    DescCount: Integer;'
      '    DescTable: array [0..0{DescCount-1}] of TExcDescEntry;'
      '  end;'
      '  PExcScope = ^TExcScope;'
      '  TExcScope = record'
      '    BeginOffset:  LongWord;  // 32 bit RVA'
      '    EndOffset:    LongWord;  // 32 bit RVA'
      
        '    TableOffset:  LongWord;  // 32 bit RVA. 0:TargetOffset=final' +
        'ly block'
      
        '                             //             1:TargetOffset=safec' +
        'all catch block'
      
        '                             //             2:TargetOffset=catch' +
        ' block'
      
        '                             //             other:TableOffset=TE' +
        'xcDesc'
      
        '    TargetOffset: LongWord;  // 32 bit RVA. start of finally/cat' +
        'ch block.'
      
        '                             //   TableOffset=0: signature is _T' +
        'DelphiFinallyHandlerProc'
      
        '                             //   TableOffset=1: signature is _T' +
        'DelphiSafeCallCatchHandlerProc'
      
        '                             //   TableOffset=2: Location to the' +
        ' catch block'
      '                             //   other: TargetOffset=0'
      '  end;'
      '  PExcData = ^TExcData;'
      '  TExcData = record'
      '    ScopeCount: Integer;'
      '    ScopeTable: array [0..0{ScopeCount-1}] of TExcScope;'
      '  end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'const'
      '  UW_EXC_CLASS_BORLANDCPP = $FBEE0001;'
      '  UW_EXC_CLASS_BORLANDDELPHI = $FBEE0101;'
      ''
      'type'
      '  // The following _Unwind_* types represent unwind.h'
      '  _Unwind_Word = NativeUInt;'
      '  _Unwind_Exception_Cleanup_Fn = Pointer;'
      '  _Unwind_Exception = packed record'
      '    exception_class: _Unwind_Word;'
      '    exception_cleanup: _Unwind_Exception_Cleanup_Fn;'
      '    private_1: _Unwind_Word;'
      '    private_2: _Unwind_Word;'
      '  end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'type'
      '  PExcFrame = ^TExcFrame;'
      '  TExcFrame = record'
      '    next: PExcFrame;'
      '    desc: PExcDesc;'
      '    hEBP: Pointer;'
      '    case Integer of'
      '    0:  ( );'
      '    1:  ( ConstructedObject: Pointer );'
      '    2:  ( SelfOfMethod: Pointer );'
      '  end;'
      ''
      '  PRaiseFrame = ^TRaiseFrame;'
      '  TRaiseFrame = packed record'
      '    NextRaise: PRaiseFrame;'
      '    ExceptAddr: Pointer;'
      '    ExceptObject: TObject;'
      '    ExceptionRecord: PExceptionRecord;'
      '  end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      
        '{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEP' +
        'TIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXC' +
        'EPTIONS_MACOS)}'
      'type'
      '  PRaiseFrame = ^TRaiseFrame;'
      '  TRaiseFrame = record'
      '    NextRaise: PRaiseFrame;'
      '    ExceptAddr: Pointer;'
      '    ExceptObject: TObject;'
      '    Allocated: Boolean;'
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      '    PrevRaise: PRaiseFrame;'
      '    HandlerSwitchValue: Integer;'
      '    ActionRecord: PByte;'
      '    LanguageSpecificData: PByte;'
      '    CatchTemp: Pointer;'
      '    AdjustedPtr: Pointer;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '    ExceptionFramePtr: Pointer;'
      '{$ENDIF}'
      '{$IFDEF MACOS64}'
      '    [align(16)]'
      '{$ENDIF MACOS64}'
      '    UnwindException: _Unwind_Exception;'
      
        '{$ENDIF SJLJ_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS or ZCX_BAS' +
        'ED_EXCEPTIONS_MACOS}'
      '  end;'
      '  PPRaiseFrame = ^PRaiseFrame;'
      
        '{$ENDIF TABLE_BASED_EXCEPTIONS or SJLJ_BASED_EXCEPTIONS or ZCX_B' +
        'ASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      ''
      'const'
      '  cCR = $0D;'
      '  cLF = $0A;'
      '  cEOF = $1A;'
      ''
      '{$IFDEF POSIX}'
      'function GetLastError: Integer;'
      'begin'
      '  Result := __error^;'
      'end;'
      ''
      'procedure SetLastError(ErrorCode: Integer);'
      'begin'
      '  __error^ := ErrorCode;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      'var'
      '  ModuleCacheVersion: Cardinal = 0;'
      ''
      'function ModuleCacheID: Cardinal;'
      'begin'
      '  Result := ModuleCacheVersion;'
      'end;'
      ''
      'procedure InvalidateModuleCache;'
      'begin'
      '  AtomicIncrement(Integer(ModuleCacheVersion));'
      'end;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      ''
      '{$IFDEF POSIX}'
      'procedure Sleep(Timeout: Integer); inline;'
      'begin'
      '  usleep(Timeout * 1000);'
      'end;'
      ''
      'function GetTickCount: Cardinal; inline;'
      '{$IFDEF ANDROID}'
      'var'
      '  res: timespec;'
      'begin'
      '  clock_gettime(CLOCK_MONOTONIC, @res);'
      
        '  Result := (Int64(1000000000) * res.tv_sec + res.tv_nsec) div 1' +
        '000000;'
      'end;'
      '{$ELSEIF defined(LINUX)}'
      'var'
      '  t: tms;'
      'begin'
      
        '  Result := Cardinal(Int64(Cardinal(times(t)) * 1000) div syscon' +
        'f(_SC_CLK_TCK));'
      'end;'
      '{$ELSEIF defined(MACOS)}'
      'begin'
      '  Result := AbsoluteToNanoseconds(MachAbsoluteTime) div 1000000;'
      'end;'
      '{$ELSE}'
      'begin'
      '  Error(rePlatformNotImplemented);'
      '{$MESSAGE ERROR '#39'Unknown Platform'#39'}'
      'end;'
      '{$ENDIF}'
      ''
      '{$ENDIF POSIX}'
      ''
      ''
      '{$IFDEF MSWINDOWS}'
      '{$I WindowsAPIs.INC}'
      ''
      'function GetCmdShow: Integer;'
      'var'
      '  SI: TStartupInfo;'
      'begin'
      '  Result := 10;                  { SW_SHOWDEFAULT }'
      '  SI.cb := SizeOf(TStartupInfo);'
      '  GetStartupInfo(SI);'
      '  if SI.dwFlags and 1 <> 0 then  { STARTF_USESHOWWINDOW }'
      '    Result := SI.wShowWindow;'
      'end;'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IF defined(CPUX86) and (not defined(EXTERNALLINKER))}'
      
        'function _AtomicIncInt64(var Target: Int64; Increment: Int64): I' +
        'nt64;'
      'var'
      '  Tmp: Int64;'
      'begin'
      '  repeat'
      '    Tmp := Target;'
      '    Result := AtomicCmpExchange(Target, Tmp + Increment, Tmp);'
      '  until Result = Tmp;'
      '  Inc(Result, Increment);'
      'end;'
      ''
      
        'function _AtomicXchgInt64(var Target: Int64; Exchange: Int64): I' +
        'nt64;'
      'var'
      '  Tmp: Int64;'
      'begin'
      '  repeat'
      '    Tmp := Target;'
      '    Result := AtomicCmpExchange(Target, Exchange, Tmp);'
      '  until Result = Tmp;'
      'end;'
      '{$ENDIF}'
      ''
      
        'function Pos(const SubStr, Str: UnicodeString; Offset: Integer):' +
        ' Integer;'
      'begin'
      '  Result := _UStrPos(Pointer(SubStr), Pointer(Str), Offset);'
      'end;'
      ''
      
        'function Pos(const SubStr, Str: _WideStr; Offset: Integer): Inte' +
        'ger;'
      'begin'
      '{$IFDEF MSWINDOWS}'
      '  Result := _WStrPos(Pointer(SubStr), Pointer(Str), Offset);'
      '{$ELSE !MSWINDOWS}'
      '  Result := _UStrPos(Pointer(SubStr), Pointer(Str), Offset);'
      '{$ENDIF !MSWINDOWS}'
      'end;'
      ''
      
        'function Pos(const SubStr, Str: _RawByteStr; Offset: Integer): I' +
        'nteger;'
      'begin'
      '  Result := _LStrPos(Pointer(SubStr), Pointer(Str), Offset);'
      'end;'
      ''
      
        'function WCharFromChar(WCharDest: PWideChar; DestChars: Integer;' +
        ' const CharSource: _PAnsiChr; SrcBytes: Integer; CodePage: Integ' +
        'er): Integer; forward;'
      
        'function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; ' +
        'const WCharSource: PWideChar; SrcChars: Integer; CodePage: Integ' +
        'er): Integer; overload; forward;'
      
        'function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; ' +
        'const WCharSource: PWideChar; SrcChars: Integer): Integer; overl' +
        'oad; forward;'
      ''
      '{ ----------------------------------------------------- }'
      '{       Memory manager                                  }'
      '{ ----------------------------------------------------- }'
      ''
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF SIMPLEHEAP}'
      '{$I SimpleHeap.inc}'
      '{$ELSE}'
      '{$I GETMEM.INC}'
      '{$ENDIF}'
      '{$ENDIF}'
      ''
      '{$IF defined(OSX32)}'
      '{$I GETMEM.INC}'
      '{$ELSE}'
      ''
      '{$IFDEF POSIX}'
      'function SysGetMem(Size: NativeInt): Pointer;'
      'begin'
      '  Result := __malloc(size);'
      'end;'
      ''
      'function SysFreeMem(P: Pointer): Integer;'
      'begin'
      '  __free(P);'
      '  Result := 0;'
      'end;'
      ''
      'function SysReallocMem(P: Pointer; Size: NativeInt): Pointer;'
      'begin'
      '  Result := realloc(P, Size);'
      'end;'
      ''
      'function SysAllocMem(Size: NativeInt): Pointer;'
      'begin'
      '  // Alocate and zero memory for 1 item of Size bytes'
      '  Result := calloc(1, Size);'
      'end;'
      ''
      'function SysRegisterExpectedMemoryLeak(P: Pointer): Boolean;'
      'begin'
      '  // not implemented for POSIX'
      '  Result := False;'
      'end;'
      ''
      'function SysUnregisterExpectedMemoryLeak(P: Pointer): Boolean;'
      'begin'
      '  // not implemented for POSIX'
      '  Result := False;'
      'end;'
      '{$ENDIF POSIX}'
      '{$ENDIF OSX}'
      ''
      'var'
      '  MemoryManager: TMemoryManagerEx = ('
      '    GetMem: SysGetMem;'
      '    FreeMem: SysFreeMem;'
      '    ReallocMem: SysReallocMem;'
      '    AllocMem: SysAllocMem;'
      '    RegisterExpectedmemoryLeak: SysRegisterExpectedMemoryLeak;'
      
        '    UnregisterExpectedmemoryLeak: SysUnregisterExpectedMemoryLea' +
        'k);'
      ''
      'function AllocMem(Size: NativeInt): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Size > 0 then'
      '  begin'
      '    Result := MemoryManager.AllocMem(Size);'
      '    if Result = nil then'
      '      Error(reOutOfMemory);'
      '  end'
      '  else'
      '    Result := nil;'
      'end;'
      '{$ELSE}'
      'asm'
      '        TEST    EAX,EAX'
      '        JZ      @@allocmemdone'
      '{$IFDEF PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBX'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EBX, [EAX].OFFSET MemoryManager.AllocMem'
      '        POP     EAX'
      '        CALL    EBX'
      '        POP     EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    MemoryManager.AllocMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '{$ENDIF !PIC}'
      '        TEST    EAX,EAX'
      '        JZ      @@allocmemerror'
      '@@allocmemdone:'
      '        REP     RET  // Optimization for branch prediction'
      '@@allocmemerror:'
      '        MOV     AL,reOutOfMemory'
      '        JMP     Error'
      'end;'
      '{$ENDIF}'
      ''
      'function RegisterExpectedMemoryLeak(P: Pointer): Boolean;'
      'begin'
      
        '  Result := (P <> nil) and MemoryManager.RegisterExpectedMemoryL' +
        'eak(P);'
      'end;'
      ''
      'function UnregisterExpectedMemoryLeak(P: Pointer): Boolean;'
      'begin'
      
        '  Result := (P <> nil) and MemoryManager.UnregisterExpectedMemor' +
        'yLeak(P);'
      'end;'
      ''
      
        '                                                                ' +
        '                                                                ' +
        '                             '
      'function _GetMem(Size: NativeInt): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Size <= 0 then'
      '    Exit(nil);'
      '  Result := MemoryManager.GetMem(Size);'
      '  if Result = nil then'
      '    Error(reOutOfMemory);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm //StackAlignSafe'
      '        TEST    EAX,EAX'
      '        JLE     @@negativeorzerosize'
      '{$IFDEF PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBX'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EBX, [EAX].OFFSET MemoryManager.GetMem'
      '        POP     EAX'
      '        CALL    EBX'
      '        POP     EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    MemoryManager.GetMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '{$ENDIF !PIC}'
      '        TEST    EAX,EAX'
      '        JZ      @@getmemerror'
      '        REP     RET // Optimization for branch prediction'
      '@@getmemerror:'
      '        MOV     AL, reOutOfMemory'
      '        JMP     Error'
      '@@negativeorzerosize:'
      '        XOR     EAX, EAX'
      '        DB      $F3 // REP RET'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function _FreeMem(P: Pointer): Integer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if P = nil then'
      '    Exit(0);'
      '  Result := MemoryManager.FreeMem(P);'
      '  if Result <> 0 then'
      '    Error(reInvalidPtr);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm //StackAlignSafe'
      '        TEST    EAX,EAX'
      '        JZ      @@freememdone'
      '{$IFDEF PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBX'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EBX, [EAX].OFFSET MemoryManager.FreeMem'
      '        POP     EAX'
      '        CALL    EBX'
      '        POP     EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    MemoryManager.FreeMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '{$ENDIF !PIC}'
      '        TEST    EAX,EAX'
      '        JNZ     @@freememerror'
      '@@freememdone:'
      '        REP     RET // Optimization for branch prediction'
      '@@freememerror:'
      '        MOV     AL,reInvalidPtr'
      '        JMP     ERROR'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'function _ReallocMem(var P: Pointer; NewSize: NativeInt): Pointe' +
        'r;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if P <> nil then'
      '  begin'
      '    if NewSize > 0 then'
      '    begin'
      '      Result := MemoryManager.ReallocMem(P, NewSize);'
      '      if Result = nil then'
      '        Error(reOutOfMemory);'
      '    end'
      '    else'
      '    begin'
      '      if MemoryManager.FreeMem(P) <> 0 then'
      '        Error(reInvalidPtr);'
      '      Result := nil;'
      '    end;'
      '    P := Result;'
      '  end else'
      '  begin'
      '    if NewSize <= 0 then'
      '      Exit(nil);'
      '    Result := MemoryManager.GetMem(NewSize);'
      '    if Result = nil then'
      '      Error(reOutOfMemory);'
      '    P := Result;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      ''
      'asm'
      '{$IFDEF PIC}'
      '        PUSH    EBX'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EBX, EAX'
      '        POP     EAX'
      '{$ENDIF PIC}'
      '        MOV     ECX, [EAX]'
      '        TEST    ECX, ECX'
      '        JE      @@alloc'
      '        TEST    EDX, EDX'
      '        JE      @@free'
      '@@resize:'
      '        PUSH    EAX'
      '        MOV     EAX, ECX'
      '{$IFDEF PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EBX, [EBX].OFFSET MemoryManager.ReallocMem'
      '        CALL    EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    MemoryManager.ReallocMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '{$ENDIF PIC}'
      '        POP     ECX'
      '        OR      EAX, EAX'
      '        JE      @@allocError'
      '        MOV     [ECX], EAX'
      '{$IFDEF PIC}'
      '        POP     EBX'
      '{$ENDIF PIC}'
      '        RET'
      '@@freeError:'
      '        MOV     AL, reInvalidPtr'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     Error'
      '@@free:'
      '        MOV     [EAX], EDX'
      '        MOV     EAX, ECX'
      '{$IFDEF PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EBX, [EBX].OFFSET MemoryManager.FreeMem'
      '        CALL    EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    MemoryManager.FreeMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '{$ENDIF !PIC}'
      '        OR      EAX, EAX'
      '        JNE     @@freeError'
      '{$IFDEF PIC}'
      '        POP     EBX'
      '{$ENDIF PIC}'
      '        RET'
      '@@allocError:'
      '        MOV     AL, reOutOfMemory'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     Error'
      '@@alloc:'
      '        TEST    EDX, EDX'
      '        JE      @@exit'
      '        PUSH    EAX'
      '        MOV     EAX, EDX'
      '{$IFDEF PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EBX, [EBX].OFFSET MemoryManager.GetMem'
      '        CALL    EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PIC}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    MemoryManager.GetMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '{$ENDIF !PIC}'
      '        POP     ECX'
      '        OR      EAX, EAX'
      '        JE      @@allocError'
      '        MOV     [ECX], EAX'
      '@@exit:'
      '{$IFDEF PIC}'
      '        POP     EBX'
      '{$ENDIF PIC}'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        '{ The default AllocMem implementation - for older memory manager' +
        's that do not'
      '  implement this themselves. }'
      'function DefaultAllocMem(Size: NativeInt): Pointer;'
      'begin'
      '  Result := _GetMem(Size);'
      '  if (Result <> nil) then'
      '    FillChar(Result^, Size, 0)'
      'end;'
      ''
      
        '{ The default (do nothing) leak registration function for backwa' +
        'rd compatibility'
      '  with older memory managers. }'
      
        'function DefaultRegisterAndUnregisterExpectedMemoryLeak(P: Point' +
        'er): Boolean;'
      'begin'
      '  Result := False;'
      'end;'
      ''
      '{ Backward compatible GetMemoryManager implementation }'
      'procedure GetMemoryManager(var MemMgr: TMemoryManager);'
      'begin'
      '  MemMgr.GetMem := MemoryManager.GetMem;'
      '  MemMgr.FreeMem := MemoryManager.FreeMem;'
      '  MemMgr.ReallocMem := MemoryManager.ReallocMem;'
      'end;'
      ''
      '{ Backward compatible SetMemoryManager implementation }'
      'procedure SetMemoryManager(const MemMgr: TMemoryManager);'
      'begin'
      '  MemoryManager.GetMem := MemMgr.GetMem;'
      '  MemoryManager.FreeMem := MemMgr.FreeMem;'
      '  MemoryManager.ReallocMem := MemMgr.ReallocMem;'
      '  MemoryManager.AllocMem := DefaultAllocMem;'
      '  MemoryManager.RegisterExpectedMemoryLeak :='
      '    DefaultRegisterAndUnregisterExpectedMemoryLeak;'
      '  MemoryManager.UnregisterExpectedMemoryLeak :='
      '    DefaultRegisterAndUnregisterExpectedMemoryLeak;'
      'end;'
      ''
      'procedure GetMemoryManager(var MemMgrEx: TMemoryManagerEx);'
      'begin'
      '  MemMgrEx := MemoryManager;'
      'end;'
      ''
      'procedure SetMemoryManager(const MemMgrEx: TMemoryManagerEx);'
      'begin'
      '  MemoryManager := MemMgrEx;'
      'end;'
      ''
      'function IsMemoryManagerSet: Boolean;'
      'begin'
      '  with MemoryManager do'
      
        '    Result := (@GetMem <> @SysGetMem) or (@FreeMem <> @SysFreeMe' +
        'm) or'
      
        '      (@ReallocMem <> @SysReallocMem) or (@AllocMem <> @SysAlloc' +
        'Mem) or'
      
        '      (@RegisterExpectedMemoryLeak <> @SysRegisterExpectedMemory' +
        'Leak) or'
      
        '      (@UnregisterExpectedMemoryLeak <> @SysUnregisterExpectedMe' +
        'moryLeak);'
      'end;'
      ''
      
        'procedure RunErrorAt(ErrCode: Integer; ErrorAtAddr: Pointer); fo' +
        'rward;'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure GetUnwinder(var Dest: TUnwinder);'
      'begin'
      '  Dest := Unwinder;'
      'end;'
      ''
      'procedure SetUnwinder(const NewUnwinder: TUnwinder);'
      'begin'
      '  Unwinder := NewUnwinder;'
      'end;'
      ''
      'function IsUnwinderSet: Boolean;'
      'begin'
      '  with Unwinder do'
      '    Result := (@RaiseException <> @_BorUnwind_RaiseException) or'
      '      (@RegisterIPLookup <> @_BorUnwind_RegisterIPLookup) or'
      '      (@UnregisterIPLookup <> @_BorUnwind_UnregisterIPLookup) or'
      '      (@DelphiLookup <> @_BorUnwind_DelphiLookup);'
      'end;'
      ''
      'procedure InitUnwinder;'
      'var'
      '  Addr: Pointer;'
      'begin'
      
        '  { We look to see if we can find a dynamic version of the unwin' +
        'der.  This'
      
        '    will be the case if the application used ShareExcept.pas.  I' +
        'f it is'
      
        '    present, then we fire it up.  Otherwise, we use our static c' +
        'opy. }'
      '  Addr := dlsym(RTLD_DEFAULT, '#39'_BorUnwind_RegisterIPLookup'#39');'
      '  if Addr <> nil then'
      '  begin'
      '    Unwinder.RegisterIPLookup := Addr;'
      
        '    Addr := dlsym(RTLD_DEFAULT, '#39'_BorUnwind_UnregisterIPLookup'#39')' +
        ';'
      '    Unwinder.UnregisterIPLookup := Addr;'
      '    Addr := dlsym(RTLD_DEFAULT, '#39'_BorUnwind_RaiseException'#39');'
      '    Unwinder.RaiseException := Addr;'
      '    Addr := dlsym(RTLD_DEFAULT, '#39'_BorUnwind_DelphiLookup'#39');'
      '    Unwinder.DelphiLookup := Addr;'
      
        '    Addr := dlsym(RTLD_DEFAULT, '#39'_BorUnwind_ClosestDelphiHandler' +
        #39');'
      '    Unwinder.ClosestHandler := Addr;'
      '  end'
      '  else'
      '  begin'
      '    dlerror;   // clear error state;  dlsym doesn'#39't'
      '    Unwinder.RegisterIPLookup := _BorUnwind_RegisterIPLookup;'
      '    Unwinder.DelphiLookup := _BorUnwind_DelphiLookup;'
      
        '    Unwinder.UnregisterIPLookup := _BorUnwind_UnregisterIPLookup' +
        ';'
      '    Unwinder.RaiseException := _BorUnwind_RaiseException;'
      '    Unwinder.ClosestHandler := _BorUnwind_ClosestDelphiHandler;'
      '  end;'
      'end;'
      ''
      
        '                                                                ' +
        '                  '
      'function SysClosestDelphiHandler(Context: Pointer): NativeUInt;'
      'begin'
      '  if not Assigned(Unwinder.ClosestHandler) then'
      '    InitUnwinder;'
      '  Result := Unwinder.ClosestHandler(Context);'
      'end;'
      ''
      
        '                                                                ' +
        '             '
      
        'function SysRegisterIPLookup(StartAddr, EndAddr: NativeUInt; Con' +
        'text: Pointer; GOT: NativeUInt): LongBool;'
      'begin'
      '//  xxx'
      '  if not Assigned(Unwinder.RegisterIPLookup) then'
      '  begin'
      '    InitUnwinder;'
      '  end;'
      
        '  Result := Unwinder.RegisterIPLookup(@Unwinder.DelphiLookup, St' +
        'artAddr, EndAddr, Context, GOT);'
      'end;'
      ''
      
        '                                                                ' +
        '                 '
      
        'function SysRegisterIPLookupFunc(StartAddr, EndAddr: NativeUInt;' +
        ' Context: Pointer; GOT: NativeUInt;'
      
        '                            UnwinderLookup: TUnwinderLookup): Lo' +
        'ngBool;'
      'begin'
      '  if not Assigned(Unwinder.RegisterIPLookup) then'
      '  begin'
      '    InitUnwinder;'
      '  end;'
      
        '  Result := Unwinder.RegisterIPLookup(@UnwinderLookup, StartAddr' +
        ', EndAddr, Context, GOT);'
      'end;'
      ''
      
        '                                                                ' +
        '               '
      'procedure SysUnregisterIPLookup(StartAddr: NativeUInt);'
      'begin'
      '  Unwinder.UnregisterIPLookup(StartAddr);'
      'end;'
      ''
      'function SysRaiseException(Exc: Pointer): LongBool;'
      'var'
      '  uexc: _Unwind_Exception;'
      'begin'
      '  uexc.exception_class := UW_EXC_CLASS_BORLANDDELPHI;'
      '  uexc.private_1 := _Unwind_Word(Exc);'
      '  uexc.private_2 := 0;'
      '  Result := Unwinder.RaiseException(@uexc);'
      'end;'
      ''
      '//  SysRaiseCPPException'
      
        '//    Called to reraise a C++ exception that is unwinding throug' +
        'h pascal code.'
      
        '                                                                ' +
        '               '
      
        'function SysRaiseCPPException(Exc: Pointer; priv2: Pointer; cls:' +
        ' NativeUInt): LongBool;'
      'var'
      '  uexc: _Unwind_Exception;'
      'begin'
      '  uexc.exception_class := cls;'
      '  uexc.private_1 := _Unwind_Word(Exc);'
      '  uexc.private_2 := _Unwind_Word(priv2);'
      '  Result := Unwinder.RaiseException(@uexc);'
      'end;'
      ''
      'const'
      '  MAX_NESTED_EXCEPTIONS = 16;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      
        '{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEP' +
        'TIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXC' +
        'EPTIONS_MACOS)}'
      'const'
      '  MAX_NESTED_EXCEPTIONS = 16;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'threadvar'
      
        '  ExceptionObjects: array[0..MAX_NESTED_EXCEPTIONS-1] of TRaised' +
        'Exception;'
      '  ExceptionObjectCount: Integer;'
      '  OSExceptionsBlocked: Integer;'
      '  ExceptionList: PRaisedException;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'threadvar'
      '  RaiseListPtr: Pointer;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      
        '{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEP' +
        'TIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXC' +
        'EPTIONS_MACOS)}'
      'threadvar'
      
        '  ExceptionObjects: array[0..MAX_NESTED_EXCEPTIONS-1] of TRaiseF' +
        'rame;'
      '  ExceptionObjectCount: Integer;'
      '  RaiseListPtr: PRaiseFrame;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      'threadvar'
      '  InOutRes: Integer;'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      ''
      'procedure BlockOSExceptions;'
      'asm  //StackAlignSafe'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        CALL    SysInit.@GetTLS'
      '        MOV     [EAX].OSExceptionsBlocked, 1'
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      ''
      'procedure UnblockOSExceptions;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysInit.@GetTLS'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     [EAX].OSExceptionsBlocked, 0'
      'end;'
      ''
      
        '// Access to a TLS variable.  Note the comment in BeginThread be' +
        'fore'
      '// you change the implementation of this function.'
      'function AreOSExceptionsBlocked: Boolean;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysInit.@GetTLS'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EAX, [EAX].OSExceptionsBlocked'
      'end;'
      ''
      'const'
      '  TRAISEDEXCEPTION_SIZE = SizeOf(TRaisedException);'
      ''
      
        '                                                                ' +
        '   '
      'function CurrentException: PRaisedException;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysInit.@GetTLS'
      '        LEA     EDX, [EAX].ExceptionObjects'
      '        MOV     EAX, [EAX].ExceptionObjectCount'
      '        OR      EAX, EAX'
      '        JE      @@Done'
      '        DEC     EAX'
      '        IMUL    EAX, TRAISEDEXCEPTION_SIZE'
      '        ADD     EAX, EDX'
      '        JMP     @@Exit'
      '@@Done:'
      '        CALL    SysInit.@GetTLS'
      '        MOV     EAX,[EAX].ExceptionList'
      '@@Exit:'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      ''
      
        '                                                                ' +
        '          '
      'function CurrentPrivateException: PRaisedException;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysInit.@GetTLS'
      '        LEA     EDX, [EAX].ExceptionObjects'
      '        MOV     EAX, [EAX].ExceptionObjectCount'
      '        OR      EAX, EAX'
      '        JE      @@Done'
      '        DEC     EAX'
      '        IMUL    EAX, TRAISEDEXCEPTION_SIZE'
      '        ADD     EAX, EDX'
      '@@Done:'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      ''
      
        '{ In the interests of code size here, this function is slightly ' +
        'overloaded.'
      
        '  It is responsible for freeing up the current exception record ' +
        'on the'
      
        '  exception stack, and it conditionally returns the thrown objec' +
        't to the'
      
        '  caller.  If the object has been acquired through AcquireExcept' +
        'ionObject,'
      '  we don'#39't return the thrown object. }'
      '                                                                '
      'function FreeException: Pointer;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    CurrentPrivateException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        OR      EAX, EAX'
      '        JE      @@Error'
      '        { EAX -> the TRaisedException }'
      '        XOR     ECX, ECX'
      
        '        { If the exception object has been referenced, we don'#39't ' +
        'return it. }'
      '        CMP     [EAX].TRaisedException.RefCount, 0'
      '        JA      @@GotObject'
      '        MOV     ECX, [EAX].TRaisedException.ExceptObject'
      '@@GotObject:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    ECX'
      '        CALL    SysInit.@GetTLS'
      '        POP     ECX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        DEC     [EAX].ExceptionObjectCount'
      '        MOV     EAX, ECX'
      '        RET'
      '@@Error:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysInit.@GetTLS'
      '        MOV     EAX, [EAX].ExceptionList'
      '        CALL    [EAX].TRaisedException.Cleanup'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        RET'
      'end;'
      ''
      'procedure ReleaseDelphiException;'
      'begin'
      '  FreeException;'
      'end;'
      ''
      
        '                                                                ' +
        '          '
      
        'function AllocateException(Exception: Pointer; ExceptionAddr: Po' +
        'inter): PRaisedException;'
      'asm'
      
        '        PUSH    EBX // This is to simplify stack aligment for PI' +
        'C and non PIC.'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '{$IFDEF PIC}'
      '        CALL    GetGOT'
      '        MOV     EBX, EAX'
      '{$ELSE !PIC}'
      '        XOR     EBX, EBX'
      '{$ENDIF !PIC}'
      '        CALL    SysInit.@GetTLS'
      
        '        CMP     [EAX].ExceptionObjectCount, MAX_NESTED_EXCEPTION' +
        'S'
      '        JE      @@TooManyNestedExceptions'
      '        INC     [EAX].ExceptionObjectCount'
      '        CALL    CurrentException'
      '        POP     EDX'
      '        POP     ECX'
      '        MOV     [EAX].TRaisedException.ExceptObject, ECX'
      '        MOV     [EAX].TRaisedException.ExceptionAddr, EDX'
      '        MOV     [EAX].TRaisedException.RefCount, 0'
      '        MOV     [EAX].TRaisedException.HandlerEBP, $FFFFFFFF'
      '        MOV     [EAX].TRaisedException.Flags, 0'
      '        MOV     [EAX].TRaisedException.Prev, 0'
      '        LEA     EDX, [EBX].OFFSET FreeException'
      '        MOV     [EAX].TRaisedException.Cleanup, EDX'
      '        LEA     EDX, [EBX].OFFSET ReleaseDelphiException'
      '        MOV     [EAX].TRaisedException.ReleaseProc, EDX'
      '{$IFDEF AUTOREFCOUNT}'
      '        MOV     EBX,EAX  // GOT no longer needed here'
      '        MOV     EAX,ECX'
      '        MOV     ECX,[EAX]'
      '        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjAddRef'
      '        MOV     EAX,EBX  // Restore EAX - PRaisedException'
      '{$ENDIF}'
      '        POP     EBX'
      '        RET'
      '@@TooManyNestedExceptions:'
      '        ADD     ESP, 12  // Throw away EDX, EBX and EAX.'
      '        MOV     EAX, 231'
      '        JMP     _RunError'
      'end;'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      'function AcquireExceptionObject: TObject;'
      'var'
      '  E: PRaisedException;'
      'begin'
      '  E := CurrentException;'
      '  if E = nil then'
      '    Exit (nil);'
      '  Inc(E.RefCount);'
      '  Result := E.ExceptObject;'
      'end;'
      '{$ELSE  AUTOREFCOUNT}'
      'function AcquireExceptionObject: TObject;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    CurrentException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        OR      EAX, EAX'
      '        JE      @@Error'
      '        INC     [EAX].TRaisedException.RefCount'
      '        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      '        RET'
      '@@Error:'
      
        '   RET // windows version doesn'#39't generate an error, and Halt0 c' +
        'alls this always'
      '        { This happens if there is no exception pending }'
      '//        JMP     _Run0Error'
      'end;'
      '{$ENDIF AUTOREFCOUNT}'
      ''
      'procedure ReleaseExceptionObject;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    CurrentException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        OR      EAX, EAX'
      '        JE      @@Error'
      '        CMP     [EAX].TRaisedException.RefCount, 0'
      '        JE      @@Error'
      '        DEC     [EAX].TRaisedException.RefCount'
      '        RET'
      '@@Error:'
      '{ This happens if there is no exception pending, or'
      '  if the reference count on a pending exception is'
      '  zero. }'
      '        JMP   _Run0Error'
      'end;'
      ''
      'function ExceptObject: TObject;'
      'var'
      '  Exc: PRaisedException;'
      'begin'
      '  Exc := CurrentException;'
      '  if Exc <> nil then'
      '    Result := TObject(Exc^.ExceptObject)'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      '{ Return current exception address }'
      'function ExceptAddr: Pointer;'
      'var'
      '  Exc: PRaisedException;'
      'begin'
      '  Exc := CurrentException;'
      '  if Exc <> nil then'
      '    Result := Exc^.ExceptionAddr'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      ''
      'function ExceptObject: TObject;'
      'begin'
      '  if RaiseListPtr <> nil then'
      '    Result := PRaiseFrame(RaiseListPtr)^.ExceptObject'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      '{ Return current exception address }'
      'function ExceptAddr: Pointer;'
      'begin'
      '  if RaiseListPtr <> nil then'
      '    Result := PRaiseFrame(RaiseListPtr)^.ExceptAddr'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      'function AcquireExceptionObject: TObject;'
      'type'
      '  ExceptionAcquiredProc = procedure (Obj: TObject);'
      'var'
      '  RaiseFrame: PRaiseFrame;'
      'begin'
      '  RaiseFrame := RaiseListPtr;'
      '  if RaiseFrame <> nil then'
      '  begin'
      '    Result := Pointer(RaiseFrame^.ExceptObject);'
      '    RaiseFrame^.ExceptObject := nil;'
      '    if Assigned(ExceptionAcquired) then'
      '      ExceptionAcquiredProc(ExceptionAcquired)(Result);'
      '  end'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      'procedure ReleaseExceptionObject;'
      'begin'
      'end;'
      ''
      'procedure _UnhandledException;'
      'type'
      '  TExceptProc = procedure (Obj: TObject; Addr: Pointer);'
      'begin'
      '  if Assigned(ExceptProc) then'
      '    TExceptProc(ExceptProc)(ExceptObject, ExceptAddr)'
      '  else'
      '    RunErrorAt(230, ExceptAddr);'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      '{$IF DEFINED(STACK_BASED_EXCEPTIONS) OR DEFINED(WIN64)}'
      'function RaiseList: Pointer;'
      'begin'
      '  Result := RaiseListPtr;'
      'end;'
      ''
      
        '                                                                ' +
        '                        '
      'function SetRaiseList(NewPtr: Pointer): Pointer;'
      'begin'
      '  Result := RaiseListPtr;'
      '  RaiseListPtr := NewPtr;'
      'end;'
      '{$ENDIF}'
      ''
      
        '{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEP' +
        'TIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXC' +
        'EPTIONS_MACOS)}'
      'function AllocateRaiseFrame: PRaiseFrame;'
      'var'
      '  Index: Integer;'
      '  RaiseFrame: PRaiseFrame;'
      'begin'
      '  RaiseFrame := nil;'
      '  for Index := 0 to MAX_NESTED_EXCEPTIONS-1 do'
      '  begin'
      '    if not ExceptionObjects[Index].Allocated then'
      '    begin'
      '      RaiseFrame := @ExceptionObjects[Index];'
      '      break;'
      '    end;'
      '  end;'
      '  if RaiseFrame = nil then'
      '    RunErrorAt(231, ReturnAddress);'
      ''
      '  RaiseFrame.Allocated := True;'
      '  Inc(ExceptionObjectCount);'
      '  RaiseFrame^.NextRaise := nil;'
      '  RaiseFrame^.ExceptObject := nil;'
      '  RaiseFrame^.ExceptAddr := nil;'
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      '  RaiseFrame^.PrevRaise := nil;'
      '{$ENDIF}'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '  RaiseFrame^.ExceptionFramePtr := nil;'
      '{$ENDIF}'
      ''
      '  Result := RaiseFrame;'
      'end;'
      ''
      'procedure ReleaseRaiseFrame(RaiseFrame: PRaiseFrame);'
      'begin'
      '  if (UIntPtr(RaiseFrame) >= UIntPtr(@ExceptionObjects)) and'
      
        '     (UIntPtr(RaiseFrame) <= UIntPtr(@ExceptionObjects[MAX_NESTE' +
        'D_EXCEPTIONS-1])) then'
      '  begin'
      '    RaiseFrame.Allocated := False;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '    RaiseFrame^.ExceptionFramePtr := nil;'
      '{$ENDIF}'
      '    ExceptionObjectCount := ExceptionObjectCount - 1;'
      '  end;'
      'end;'
      ''
      'procedure LinkRaiseFrame(RaiseFrame: PRaiseFrame); inline;'
      'var'
      '  List: PPRaiseFrame;'
      'begin'
      
        '  // Note: Taking an address of RaiseListPtr may not be allowed ' +
        'if'
      
        '  //       per-thread memory space is allocated in another space' +
        '.'
      '  //       It depends on threadvar implementation. However,'
      
        '  //       current implementation can take an address of RaiseLi' +
        'stPtr.'
      '  List := @RaiseListPtr;'
      '  RaiseFrame^.NextRaise := List^;'
      '  List^ := RaiseFrame;'
      'end;'
      ''
      'function PopRaiseFrame: PRaiseFrame; inline;'
      'var'
      '  List: PPRaiseFrame;'
      'begin'
      '  List := @RaiseListPtr;'
      '  Result := List^;'
      '  if Result = nil then'
      '    _RunError(216); // reAccessViolation'
      '  List^ := Result^.NextRaise;'
      'end;'
      ''
      
        'procedure AllocateAndPushException(ExceptObject: TObject; Except' +
        'addr: Pointer);'
      'var'
      '  RaiseFrame: PRaiseFrame;'
      'begin'
      '  RaiseFrame := AllocateRaiseFrame;'
      '  RaiseFrame^.ExceptObject := ExceptObject;'
      '  RaiseFrame^.Exceptaddr := Exceptaddr;'
      '  LinkRaiseFrame(RaiseFrame);'
      'end;'
      ''
      'procedure PopAndReleaseRaiseFrame;'
      'var'
      '  RaiseFrame: PRaiseFrame;'
      'begin'
      '  RaiseFrame := PopRaiseFrame;'
      '  ReleaseRaiseFrame(RaiseFrame);'
      'end;'
      ''
      '{ Return current exception object }'
      'function ExceptObject: TObject;'
      'var'
      '  RaiseFrame: PRaiseFrame;'
      'begin'
      '  RaiseFrame := RaiseListPtr;'
      '  if RaiseFrame <> nil then'
      '    Result := RaiseFrame^.ExceptObject'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      '{ Return current exception address }'
      'function ExceptAddr: Pointer;'
      'var'
      '  RaiseFrame: PRaiseFrame;'
      'begin'
      '  RaiseFrame := RaiseListPtr;'
      '  if RaiseFrame <> nil then'
      '    Result := Pointer(RaiseFrame^.ExceptAddr)'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      'function AcquireExceptionObject: TObject;'
      'type'
      '  ExceptionAcquiredProc = procedure (Obj: TObject);'
      'var'
      '  RaiseFrame: PRaiseFrame;'
      'begin'
      '  RaiseFrame := RaiseListPtr;'
      '  if RaiseFrame <> nil then'
      '  begin'
      '    Result := RaiseFrame^.ExceptObject;'
      '    RaiseFrame^.ExceptObject := nil;'
      '    if Assigned(ExceptionAcquired) then'
      '      ExceptionAcquiredProc(ExceptionAcquired)(Result);'
      '  end'
      '  else'
      '    Result := nil;'
      'end;'
      ''
      'procedure ReleaseExceptionObject;'
      'begin'
      'end;'
      
        '{$ENDIF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EX' +
        'CEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_' +
        'EXCEPTIONS_MACOS)}'
      ''
      '{$IFDEF MSWINDOWS}'
      '{'
      
        '  Coverage helper glue - just go directly to the external covera' +
        'ge'
      
        '  library.  NEVER put code in here, because we sometimes want to' +
        ' run'
      '  coverage analysis on the System unit.'
      '}'
      
        '                                                                ' +
        '                          '
      
        'procedure _CVR_PROBE; external '#39'coverage.dll'#39' name '#39'__CVR_PROBE'#39 +
        ';'
      
        'function _CVR_STMTPROBE; external '#39'coverage.dll'#39' name '#39'__CVR_STM' +
        'TPROBE'#39';'
      '{$ENDIF MSWINDOWS}'
      '{ ----------------------------------------------------- }'
      '{    local functions & procedures of the system unit    }'
      '{ ----------------------------------------------------- }'
      ''
      'procedure RunErrorAt(ErrCode: Integer; ErrorAtAddr: Pointer);'
      'begin'
      '  ErrorAddr := ErrorAtAddr;'
      '  _Halt(ErrCode);'
      'end;'
      ''
      'procedure ErrorAt(ErrorCode: Byte; ErrorAddr: Pointer);'
      ''
      'const'
      '  reMap: array [TRunTimeError] of Byte = ('
      '    0,   { reNone }'
      '    203, { reOutOfMemory }'
      '    204, { reInvalidPtr }'
      '    200, { reDivByZero }'
      '    201, { reRangeError }'
      '{   210    Abstract error }'
      '    215, { reIntOverflow }'
      '    207, { reInvalidOp }'
      '    200, { reZeroDivide }'
      '    205, { reOverflow }'
      '    206, { reUnderflow }'
      '    219, { reInvalidCast }'
      '    216, { reAccessViolation }'
      '    218, { rePrivInstruction }'
      '    217, { reControlBreak }'
      '    202, { reStackOverflow }'
      '    220, { reVarTypeCast }'
      '    221, { reVarInvalidOp }'
      '    222, { reVarDispatch }'
      '    223, { reVarArrayCreate }'
      '    224, { reVarNotArray }'
      '    225, { reVarArrayBounds }'
      '{   226    Thread init failure }'
      '    227, { reAssertionFailed }'
      '    0,   { reExternalException not used here; in SysUtils }'
      '    228, { reIntfCastError }'
      '    229, { reSafeCallError }'
      '    235, { reMonitorNotLocked }'
      '    236, { reNoMonitorSupport }'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '{   230   Reserved by the compiler for unhandled exceptions }'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      
        '{$IF defined(PC_MAPPED_EXCEPTIONS) or defined(STACK_BASED_EXCEPT' +
        'IONS)}'
      '{   231   Too many nested exceptions }'
      '{$ENDIF}'
      '{$IF Defined(LINUX) or Defined(MACOS) or Defined(ANDROID)}'
      '{   232   Fatal signal raised on a non-Delphi thread }'
      '    233, { reQuit }'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      '{$IFDEF POSIX}'
      '    234,  { reCodesetConversion }'
      '{$ENDIF POSIX}'
      '    237, { rePlatformNotImplemented }'
      '    238  { reObjectDisposed }'
      ');'
      ''
      'begin'
      '  errorCode := errorCode and 127;'
      '  if Assigned(ErrorProc) then'
      '    ErrorProc(errorCode, ErrorAddr);'
      '  if errorCode = 0 then'
      '    errorCode := Byte(InOutRes)'
      '  else if errorCode <= Byte(High(TRuntimeError)) then'
      '    errorCode := reMap[TRunTimeError(errorCode)];'
      '  RunErrorAt(errorCode, ErrorAddr);'
      'end;'
      ''
      
        '                                                                ' +
        '                  '
      'procedure Error(errorCode: TRuntimeError);'
      'begin'
      '  ErrorAt(Byte(errorCode), ReturnAddress);'
      'end;'
      ''
      
        'procedure SetLineBreakStyle(var T: Text; Style: TTextLineBreakSt' +
        'yle);'
      'begin'
      '  if TTextRec(T).Mode = fmClosed then'
      
        '    TTextRec(T).Flags := (TTextRec(T).Flags and not tfCRLF) or (' +
        'tfCRLF * Byte(Style))'
      '  else'
      '    SetInOutRes(107);  // can'#39't change mode of open file'
      'end;'
      ''
      'function GetTextCodePage(const T: Text): Word;'
      'begin'
      '  Result := TTextRec(T).CodePage;'
      'end;'
      ''
      'procedure SetTextCodePage(var T: Text; CodePage: Word);'
      'begin'
      '  TTextRec(T).CodePage := CodePage;'
      'end;'
      ''
      'procedure __IOTest;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if InOutRes <> 0 then'
      '    ErrorAt(byte(reNone), ReturnAddress);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      
        '// __IOTest must preserve EAX, EDX, ECX on exit with the current' +
        ' dcc32 codegen'
      'asm'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        PUSH    ECX'
      '        CALL    SysInit.@GetTLS'
      '        CMP     [EAX].InOutRes,0'
      '        POP     ECX'
      '        POP     EDX'
      '        POP     EAX'
      '        JNE     @error'
      '        RET'
      '@error:'
      '        XOR     EAX,EAX'
      '        JMP     Error'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure SetInOutRes(NewValue: Integer);'
      'begin'
      '  InOutRes := NewValue;'
      'end;'
      ''
      'procedure InOutError;'
      'begin'
      '  SetInOutRes(GetLastError);'
      'end;'
      ''
      'procedure ChDir(const S: string);'
      'begin'
      '  // U-OK'
      '  ChDir(PChar(S));'
      'end;'
      ''
      'procedure ChDir(P: PChar);'
      '{$IFDEF MSWINDOWS}'
      'begin'
      '  // U-OK'
      '  if not SetCurrentDirectory(P) then'
      '    InOutError;'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'var'
      '   us: _UTF8Str;'
      'begin'
      '  // U-OK'
      '  us := _UTF8Str(P);'
      '  if __chdir(_PAnsiChr(us)) <> 0 then'
      '    InOutError;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      'procedure _UGetDir(D: Byte; var S: UnicodeString);'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Drive: array[0..3] of WideChar;'
      '  DirBuf, SaveBuf: array[0..MAX_PATH - 1] of WideChar;'
      '  DirLen, SaveLen: DWORD;'
      '  SaveStr: string;'
      'begin'
      '  SaveLen := 0;'
      '  if D <> 0 then'
      '  begin'
      '    Drive[0] := WideChar(D + Ord('#39'A'#39') - 1);'
      '    Drive[1] := '#39':'#39';'
      '    Drive[2] := #0;'
      '    SaveLen := GetCurrentDirectoryW(MAX_PATH, SaveBuf);'
      '    if SaveLen > MAX_PATH then'
      '    begin'
      '      SetLength(SaveStr, SaveLen - 1);'
      '      GetCurrentDirectoryW(SaveLen, PChar(SaveStr));'
      '    end;'
      '    SetCurrentDirectoryW(Drive);'
      '  end;'
      '  DirLen := GetCurrentDirectoryW(MAX_PATH, DirBuf);'
      '  if DirLen <= MAX_PATH then'
      '    S := DirBuf'
      '  else'
      '  begin'
      '    SetLength(S, DirLen - 1);'
      '    GetCurrentDirectoryW(DirLen, PChar(S));'
      '  end;'
      '  if D <> 0 then'
      '  begin'
      '    if SaveLen > MAX_PATH then'
      '      SetCurrentDirectoryW(PChar(SaveStr))'
      '    else'
      '      SetCurrentDirectoryW(SaveBuf);'
      '  end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'var'
      '  DirBuf: array[0..MAX_PATH] of _AnsiChr;'
      'begin'
      '  fchdir(__chdir('#39'.'#39'));'
      '  getcwd(DirBuf, sizeof(DirBuf));'
      '  S := UTF8ToString(DirBuf);'
      '{$ENDIF POSIX}'
      'end;'
      ''
      'procedure _LGetDir(D: Byte; var S: _AnsiStr);'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Drive: array[0..3] of _AnsiChr;'
      '  DirBuf, SaveBuf: array[0..MAX_PATH] of _AnsiChr;'
      'begin'
      '  if D <> 0 then'
      '  begin'
      '    Drive[0] := _AnsiChr(Chr(D + Ord('#39'A'#39') - 1));'
      '    Drive[1] := '#39':'#39';'
      '    Drive[2] := #0;'
      '    GetCurrentDirectoryA(SizeOf(SaveBuf), SaveBuf);'
      '    SetCurrentDirectoryA(Drive);'
      '  end;'
      '  GetCurrentDirectoryA(SizeOf(DirBuf), DirBuf);'
      '  if D <> 0 then SetCurrentDirectoryA(SaveBuf);'
      '  S := DirBuf;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'var'
      '  DirBuf: array[0..MAX_PATH] of _AnsiChr;'
      'begin'
      '  getcwd(DirBuf, sizeof(DirBuf));'
      '  S := _AnsiStr(UTF8ToString(DirBuf));'
      '{$ENDIF POSIX}'
      'end;'
      ''
      'procedure _WGetDir(D: Byte; var S: _WideStr);'
      'var'
      '   U: UnicodeString;'
      'begin'
      '   _UGetDir(D, U);'
      '   S := U;'
      'end;'
      ''
      'procedure _SGetDir(D: Byte; var S: _ShortStr);'
      'var'
      '  L: _AnsiStr;'
      'begin'
      '  _LGetDir(D, L);'
      '  S := L;'
      'end;'
      ''
      'function IOResult: Integer;'
      'begin'
      '  Result := InOutRes;'
      '  InOutRes := 0;'
      'end;'
      ''
      'procedure MkDir(const S: string);'
      'begin'
      '  MkDir(PChar(s));'
      'end;'
      ''
      'procedure MkDir(P: PChar);'
      'begin'
      '{$IFDEF MSWINDOWS}'
      '  if not CreateDirectory(P, nil) then'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      
        '  if __mkdir(_PAnsiChr(UTF8Encode(P)), mode_t(S_IRWXU or S_IRWXG' +
        ' or S_IRWXO)) <> 0 then'
      '{$ENDIF POSIX}'
      '    InOutError;'
      'end;'
      ''
      '{$IF defined(WIN32) or defined(WIN64)}'
      'var'
      '  NonTemporalThreshold: NativeInt = 0;'
      '  TestAVX: Cardinal;'
      ''
      'function GetCacheSize(level: Integer): Cardinal;'
      'var'
      '  ProcInfo, CurInfo: PSystemLogicalProcessorInformation;'
      '  Len: DWORD;'
      'begin'
      '  Result := 0;'
      '  Len := 0;'
      
        '  if (GetProcAddress(GetModuleHandle(kernel), '#39'GetLogicalProcess' +
        'orInformation'#39') <> nil) and'
      
        '    not GetLogicalProcessorInformation(nil, Len) and (GetLastErr' +
        'or = ERROR_INSUFFICIENT_BUFFER) then'
      '  begin'
      '    // Too early to use memory manager.'
      '    ProcInfo := HeapAlloc(GetProcessHeap, 0, Len);'
      '    try'
      '      GetLogicalProcessorInformation(ProcInfo, Len);'
      '      CurInfo := ProcInfo;'
      '      while Len > 0 do'
      '      begin'
      '        if (CurInfo.Relationship = RelationCache)'
      '          and ((CurInfo.Cache.Level = level) or (level = 0))'
      '          and (CurInfo.Cache.Size > Result) then'
      '          Result := CurInfo.Cache.Size;'
      '        Inc(CurInfo);'
      '        Dec(Len, SizeOf(CurInfo^));'
      '      end;'
      '    finally'
      '      HeapFree(GetProcessHeap, 0, ProcInfo);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'function IsWindowsVersionOrGreater(wMajorVersion, wMinorVersion,' +
        ' wServicePackMajor: Word): Boolean;'
      'const'
      '  VER_GREATER_EQUAL = 3;'
      '  VER_MAJORVERSION = $00000002;'
      '  VER_MINORVERSION = $00000001;'
      '  VER_SERVICEPACKMAJOR = $00000020;'
      'var'
      '  osvi: TOSVersionInfoEx;'
      '  dwlConditionMask: ULONGLONG;'
      'begin'
      '    FillChar(osvi, SizeOf(TOSVersionInfoEX), 0);'
      '    osvi.dwOSVersionInfoSize := SizeOf(TOSVersionInfoEx);'
      ''
      '    dwlConditionMask := VerSetConditionMask('
      '        VerSetConditionMask('
      '        VerSetConditionMask('
      '            0, VER_MAJORVERSION, VER_GREATER_EQUAL),'
      '               VER_MINORVERSION, VER_GREATER_EQUAL),'
      '               VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);'
      ''
      '    osvi.dwMajorVersion := wMajorVersion;'
      '    osvi.dwMinorVersion := wMinorVersion;'
      '    osvi.wServicePackMajor := wServicePackMajor;'
      ''
      
        '    Result := VerifyVersionInfo(osvi, VER_MAJORVERSION or VER_MI' +
        'NORVERSION or VER_SERVICEPACKMAJOR, dwlConditionMask);'
      'end;'
      ''
      'function IsWindows7SP1OrHigher: Boolean;'
      'const'
      '  _WIN32_WINNT_WIN7 = $0601;'
      'begin'
      
        '  Result := IsWindowsVersionOrGreater(hi(_WIN32_WINNT_WIN7), lo(' +
        '_WIN32_WINNT_WIN7), 1);'
      'end;'
      ''
      'procedure InitializeAVX;'
      'const'
      '  AVXBit = 1 shl 28;'
      'var'
      '  cacheSize: Cardinal;'
      'begin'
      '  if not IsWindows7SP1OrHigher then'
      '    exit;'
      '  TestAVX := Ord(CPUIDTable[1].ECX and AVXBit <> 0);'
      '  cacheSize := GetCacheSize(0) div 2;'
      '  if cacheSize = 0 then'
      '    cacheSize := $400000;'
      '  NonTemporalThreshold := cacheSize;'
      'end;'
      '{$ENDIF defined(WIN32) or defined(WIN64)}'
      ''
      'procedure Move(const Source; var Dest; Count: NativeInt);'
      '{$IF defined(POSIX)}'
      'begin'
      '  if Count > 0 then'
      '    memmove(Dest, Source, Count);'
      'end;'
      '{$ELSEIF defined(WIN32) and not defined(PUREPASCAL)}'
      '{$CODEALIGN 16}'
      '// EAX = Source, EDX = Dest, ECX = Count'
      ''
      '  procedure _REP_MOVSB;'
      '  asm'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        ADD     EBX, 64'
      '        AND     EBX, -64 {64-Byte Align Writes}'
      '        SUB     EBX, EDX'
      '        SUB     ECX, EBX'
      '        MOVUPS  XMM0, [EAX]'
      '        MOVUPS  XMM1, [EAX+16]'
      '        MOVUPS  XMM2, [EAX+32]'
      '        MOVUPS  XMM3, [EAX+48]'
      '        LEA     ESI, [EAX+EBX]'
      '        LEA     EDI, [EDX+EBX]'
      '        REP     MOVSB'
      '        MOVUPS  [EDX], XMM0'
      '        MOVUPS  [EDX+16], XMM1'
      '        MOVUPS  [EDX+32], XMM2'
      '        MOVUPS  [EDX+48], XMM3'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '  end;'
      ''
      'asm'
      '        PUSH    EBX'
      '        CMP     ECX, 32'
      '        JG      @@LargeMove'
      '        JA      @@Exit {Count <= 0}'
      '@@Small32: {17..32 Byte Move}'
      '        CMP     CL, 16'
      '        JLE     @@Small16'
      '        MOVUPS  XMM0, [EAX] {Load First 16}'
      '        MOVUPS  XMM1, [EAX+ECX-16]  {Load Last 16}'
      '        MOVUPS  [EDX], XMM0 {Save First 16}'
      '        MOVUPS  [EDX+ECX-16], XMM1  {Save Last 16}'
      '        POP     EBX'
      '        RET'
      '@@Small16: {9..16 Byte Move}'
      '        CMP     CL, 8'
      '        JLE     @@Small8'
      '        MOVQ    XMM0, [EAX] {Load First 8}'
      '        MOVQ    XMM1, [EAX+ECX-8] {Load Last 8}'
      '        MOVQ    [EDX], XMM0 {Save First 8}'
      '        MOVQ    [EDX+ECX-8], XMM1 {Save Last 8}'
      '        POP     EBX'
      '        RET'
      '@@Small8: {4..8 Byte Move}'
      '        CMP     CL, 4'
      '        JL      @@LessThan4 {Count < 4}'
      '        MOV     EBX, [EAX] {Load First 4}'
      '        MOV     EAX, [EAX+ECX-4] {Load Last 4}'
      '        MOV     [EDX], EBX {Save First 4}'
      '        MOV     [EDX+ECX-4], EAX {Load Last 4}'
      '        POP     EBX'
      '        RET'
      '@@LessThan4: {0..3 Byte Move}'
      '        CMP     CL, 1'
      '        JL      @@Exit {Count <= 0}'
      '        MOVZX   EBX, BYTE PTR [EAX+ECX-1] {Load Last Byte}'
      '        JE      @@OneByte {Count = 1}'
      '        MOVZX   EAX, WORD PTR [EAX] {Load First 2}'
      '        MOV     [EDX], AX {Save First 2}'
      '@@OneByte:'
      '        MOV     [EDX+ECX-1], BL {Save Last Byte}'
      '@@Exit:'
      '        POP     EBX'
      '        RET'
      '@@Small64:'
      '        MOVUPS  XMM0, [EAX] {Load First 16}'
      '        MOVUPS  XMM1, [EAX+16] {Load Second 16}'
      '        MOVUPS  XMM2, [EAX+ECX-32] {Load Second To Last 16}'
      '        MOVUPS  XMM3, [EAX+ECX-16] {Load Last 16}'
      '        MOVUPS  [EDX], XMM0 {Save First 16}'
      '        MOVUPS  [EDX+16], XMM1 {Save Second 16}'
      '        MOVUPS  [EDX+ECX-32], XMM2 {Save Second To Last 16}'
      '        MOVUPS  [EDX+ECX-16], XMM3 {Save Last 16}'
      '        POP     EBX'
      '        RET'
      '@@LargeMove:'
      '        CMP     ECX, 64'
      '        JLE     @@Small64'
      '        MOV     EBX, EDX'
      '        SUB     EBX, EAX'
      '        JZ      @@Exit {Source = Dest}'
      '        CMP     EBX, ECX'
      
        '        JB      @@BackwardMove {NativeUInt(Dest - Source) < Coun' +
        't}'
      '@@ForwardMove:'
      '        TEST    TestAVX, 1'
      '        JNZ     @@ForwardAVX'
      '        MOV     EBX, EDX'
      '        CMP     ECX, ERMSBThreshold'
      '        JAE     _REP_MOVSB'
      ''
      '        MOVUPS  XMM2, [EAX] {Load First 16}'
      '        MOVUPS  XMM3, [EAX+16] {Load Second 16}'
      '        MOVUPS  XMM4, [EAX+ECX-32] {Load Second To Last 16}'
      '        MOVUPS  XMM5, [EAX+ECX-16] {Load Last 16}'
      '        SUB     ECX, 32'
      '        ADD     EAX, ECX'
      '        ADD     EDX, ECX'
      '        NEG     ECX'
      '        LEA     ECX, [ECX+EDX+32]'
      '        AND     ECX, -32 {32-Byte Align Writes}'
      '        SUB     ECX, EDX'
      '        .ALIGN 16'
      '@@ForwardLoop:'
      '        MOVUPS  XMM0, [EAX+ECX]'
      '        MOVUPS  XMM1, [EAX+ECX+16]'
      '        MOVAPS  [EDX+ECX], XMM0'
      '        MOVAPS  [EDX+ECX+16], XMM1'
      '        ADD     ECX, 32'
      '        JL      @@ForwardLoop'
      '@@ForwardDone:'
      '        MOVUPS  [EBX], XMM2 {Save First 16}'
      '        MOVUPS  [EBX+16], XMM3 {Save Second 16}'
      '        MOVUPS  [EDX], XMM4 {Save Second To Last 16}'
      '        MOVUPS  [EDX+16], XMM5 {Save Last 16}'
      '        POP     EBX'
      '        RET'
      ''
      '@@ForwardAVX:'
      '        VMOVUPS YMM1, [EAX]'
      '        VMOVUPS YMM2, [EAX+ECX-32]'
      '        PUSH    EDX'
      '        SUB     ECX, 32'
      '        ADD     EAX, ECX'
      '        ADD     EDX, ECX'
      '        NEG     ECX'
      '        LEA     ECX, [ECX+EDX+32]'
      '        AND     ECX, -32 {32-Byte Align Writes}'
      '        SUB     ECX, EDX'
      '        CMP     EBX, ECX'
      '        CMOVB   EBX, ECX'
      '        NEG     EBX'
      
        '        CMP     EBX, NonTemporalThreshold {Count and Source-Dest' +
        ' both > NonTemporalThreshold}'
      '        JA      @@ForwardAVXNonTemporalLoop'
      '        .ALIGN 16'
      '@@ForwardAVXLoop:'
      '        VMOVUPS YMM0, [EAX+ECX]'
      '        VMOVAPS [EDX+ECX], YMM0'
      '        ADD     ECX, 32'
      '        JL      @@ForwardAVXLoop'
      '@@ForwardAVXDone:'
      '        POP     EBX'
      '        VMOVUPS [EBX], YMM1'
      '        VMOVUPS [EDX], YMM2'
      '        VZEROUPPER'
      '        POP     EBX'
      '        RET'
      '        .ALIGN 16'
      '@@ForwardAVXNonTemporalLoop:'
      '        VMOVUPS YMM0, [EAX+ECX]'
      '        VMOVNTPS[EDX+ECX], YMM0'
      '        ADD     ECX, 32'
      '        JL      @@ForwardAVXNonTemporalLoop'
      '        SFENCE'
      '        JMP     @@ForwardAVXDone'
      ''
      '@@BackwardMove:'
      '        TEST    TestAVX, 1'
      '        JNZ     @@BackwardAVX'
      ''
      '        LEA     EBX, [EDX+ECX-32]'
      '        MOVUPS  XMM2, [EAX] {Load First 16}'
      '        MOVUPS  XMM3, [EAX+16] {Load Second 16}'
      '        MOVUPS  XMM4, [EAX+ECX-32] {Load Second To Last 16}'
      '        MOVUPS  XMM5, [EAX+ECX-16] {Load Last 16}'
      '        LEA     ECX, [ECX+EDX-32]'
      '        AND     ECX, -32 {32-Byte Align Writes}'
      '        SUB     ECX, EDX'
      '        .ALIGN 16'
      '@@BackwardLoop:'
      '        MOVUPS  XMM0, [EAX+ECX]'
      '        MOVUPS  XMM1, [EAX+ECX+16]'
      '        MOVAPS  [EDX+ECX], XMM0'
      '        MOVAPS  [EDX+ECX+16], XMM1'
      '        SUB     ECX, 32'
      '        JG      @@BackwardLoop'
      '@@BackwardDone:'
      '        MOVUPS  [EDX], XMM2 {Save First 16}'
      '        MOVUPS  [EDX+16], XMM3 {Save Second 16}'
      '        MOVUPS  [EBX], XMM4 {Save Second To Last 16}'
      '        MOVUPS  [EBX+16], XMM5 {Save Last 16}'
      '        POP     EBX'
      '        RET'
      ''
      '@@BackwardAVX:'
      '        PUSH    ECX'
      '        VMOVUPS YMM1, [EAX]'
      '        VMOVUPS YMM2, [EAX+ECX-32]'
      '        LEA     ECX, [ECX+EDX-32]'
      '        AND     ECX, -32 {32-Byte Align Writes}'
      '        SUB     ECX, EDX'
      '        CMP     EBX, ECX'
      '        CMOVA   EBX, ECX'
      
        '        CMP     EBX, NonTemporalThreshold {Count and Dest-Source' +
        ' both > NonTemporalThreshold}'
      '        JA      @@BackwardAVXNonTemporalLoop'
      '        .ALIGN 16'
      '@@BackwardAVXLoop:'
      '        VMOVUPS YMM0, [EAX+ECX]'
      '        VMOVAPS [EDX+ECX], YMM0'
      '        SUB     ECX, 32'
      '        JG      @@BackwardAVXLoop'
      '@@BackwardAVXDone:'
      '        POP     ECX'
      '        VMOVUPS [EDX], YMM1'
      '        VMOVUPS [EDX+ECX-32], YMM2'
      '        VZEROUPPER'
      '        POP     EBX'
      '        RET'
      '        .ALIGN 16'
      '@@BackwardAVXNonTemporalLoop:'
      '        VMOVUPS YMM0, [EAX+ECX]'
      '        VMOVNTPS[EDX+ECX], YMM0'
      '        SUB     ECX, 32'
      '        JG      @@BackwardAVXNonTemporalLoop'
      '        SFENCE'
      '        JMP     @@BackwardAVXDone'
      'end;'
      '{$CODEALIGN 0}'
      '{$ELSEIF defined(WIN64) }'
      '{$CODEALIGN 16}'
      '// RCX = Source, RDX = Dest, R8 = Count'
      
        '// subroutine used to get proper unwind info for volatile regist' +
        'ers'
      ''
      '  procedure _REP_MOVSB;'
      '  asm'
      '        .PUSHNV RSI'
      '        .PUSHNV RDI'
      ''
      '        LEA     RAX, [RDX+64]'
      '        AND     RAX, -64 {64-Byte Align Writes}'
      '        SUB     RAX, RDX'
      '        SUB     R8, RAX'
      '        MOVUPS  XMM0, [RCX]'
      '        MOVUPS  XMM1, [RCX+16]'
      '        MOVUPS  XMM2, [RCX+32]'
      '        MOVUPS  XMM3, [RCX+48]'
      '        LEA     RSI, [RCX+RAX]'
      '        LEA     RDI, [RDX+RAX]'
      '        MOV     RCX, R8'
      '        REP     MOVSB'
      '        MOVUPS  [RDX], XMM0'
      '        MOVUPS  [RDX+16], XMM1'
      '        MOVUPS  [RDX+32], XMM2'
      '        MOVUPS  [RDX+48], XMM3'
      '  end;'
      ''
      'asm'
      '        .NOFRAME'
      '        MOV     RAX, R8'
      '        CMP     RAX, 32'
      '        JG      @@LargeMove'
      '        JA      @@EXit {Count <= 0}'
      '@@Small32: {17..32 Byte Move}'
      '        CMP     AL, 16'
      '        JLE     @@Small16'
      '        MOVUPS  XMM0, [RCX] {Load First 16}'
      '        MOVUPS  XMM1, [RCX+RAX-16]  {Load Last 16}'
      '        MOVUPS  [RDX], XMM0 {Save First 16}'
      '        MOVUPS  [RDX+RAX-16], XMM1  {Save Last 16}'
      '        RET'
      '@@Small16: {9..16 Byte Move}'
      '        CMP     AL, 8'
      '        JLE     @@Small8'
      '        MOV     R8, [RCX] {Load First 8}'
      '        MOV     R9, [RCX+RAX-8] {Load Last 8}'
      '        MOV     [RDX], R8 {Save First 8}'
      '        MOV     [RDX+RAX-8], R9 {Save Last 8}'
      '        RET'
      '@@Small8: {4..8 Byte Move}'
      '        CMP     AL, 4'
      '        JL      @@LessThan4 {Count < 4}'
      '        MOV     EAX, [RCX] {Load First 4}'
      '        MOV     ECX, [RCX+R8-4] {Load Last 4}'
      '        MOV     [RDX], EAX {Save First 4}'
      '        MOV     [RDX+R8-4], ECX {Load Last 4}'
      '        RET'
      '@@LessThan4: {0..3 Byte Move}'
      '        CMP     AL, 1'
      '        JL      @@Exit {Count <= 0}'
      '        MOVZX   EAX, [RCX+R8-1] {Load Last Byte}'
      '        JE      @@OneByte {Count = 0}'
      '        MOVZX   ECX, WORD PTR [RCX] {Load First 2}'
      '        MOV     [RDX], CX {Save First 2}'
      '@@OneByte:'
      '        MOV     [RDX+R8-1], AL {Save Last Byte}'
      '@@Exit:'
      '        RET'
      '@@Small64:'
      '        MOVUPS  XMM0, [RCX] {Load First 16}'
      '        MOVUPS  XMM1, [RCX+16] {Load Second 16}'
      '        MOVUPS  XMM2, [RCX+RAX-32] {Load Second To Last 16}'
      '        MOVUPS  XMM3, [RCX+RAX-16] {Load Last 16}'
      '        MOVUPS  [RDX], XMM0 {Save First 16}'
      '        MOVUPS  [RDX+16], XMM1 {Save Second 16}'
      '        MOVUPS  [RDX+RAX-32], XMM2 {Save Second To Last 16}'
      '        MOVUPS  [RDX+RAX-16], XMM3 {Save Last 16}'
      '        RET'
      '@@LargeMove:'
      '        CMP     RAX, 64'
      '        JLE     @@Small64'
      '        MOV     R9, RDX'
      '        SUB     R9, RCX'
      '        JZ      @@Exit {Source = Dest}'
      '        CMP     R9, RAX'
      
        '        JB      @@BackwardMove {NativeUInt(Dest - Source) < Coun' +
        't}'
      '@@ForwardMove:'
      '        MOV     R10, RDX'
      '        TEST    TestAVX, 1'
      '        JNZ     @@ForwardAVX'
      '        CMP     RAX, ERMSBThreshold'
      '        JAE     _REP_MOVSB'
      ''
      '        MOVUPS  XMM2, [RCX] {Load First 16}'
      '        MOVUPS  XMM3, [RCX+16] {Load Second 16}'
      '        MOVUPS  XMM4, [RCX+RAX-32] {Load Second To Last 16}'
      '        MOVUPS  XMM5, [RCX+RAX-16] {Load Last 16}'
      '        SUB     RAX, 32'
      '        ADD     RCX, RAX'
      '        ADD     RDX, RAX'
      '        NEG     RAX'
      '        LEA     RAX, [RAX+RDX+32]'
      '        AND     RAX, -32 {32-Byte Align Writes}'
      '        SUB     RAX, RDX'
      '        .ALIGN 16'
      '@@ForwardLoop:'
      '        MOVUPS  XMM0, [RCX+RAX]'
      '        MOVUPS  XMM1, [RCX+RAX+16]'
      '        MOVAPS  [RDX+RAX], XMM0'
      '        MOVAPS  [RDX+RAX+16], XMM1'
      '        ADD     RAX, 32'
      '        JL      @@ForwardLoop'
      '@@ForwardDone:'
      '        MOVUPS  [R10], XMM2 {Save First 16}'
      '        MOVUPS  [R10+16], XMM3 {Save Second 16}'
      '        MOVUPS  [RDX], XMM4 {Save Second To Last 16}'
      '        MOVUPS  [RDX+16], XMM5 {Save Last 16}'
      '        RET'
      '        .ALIGN 16'
      ''
      '@@ForwardAVX:'
      '        VMOVUPS YMM1, [RCX] {Load First 32}'
      '        VMOVUPS YMM2, [RCX+RAX-32] {Load Last 32}'
      '        SUB     RAX, 32'
      '        ADD     RCX, RAX'
      '        ADD     RDX, RAX'
      '        NEG     RAX'
      '        LEA     RAX, [RAX+RDX+32]'
      '        AND     RAX, -32 {32-Byte Align Writes}'
      '        SUB     RAX, RDX'
      '        CMP     R9, RAX'
      '        CMOVB   R9, RAX'
      '        NEG     R9'
      
        '        CMP     R9, NonTemporalThreshold {Count and Source-Dest ' +
        'both > NonTemporalThreshold}'
      '        JA      @@ForwardAVXNonTemporalLoop'
      '        .ALIGN 16'
      '@@ForwardAVXLoop:'
      '        VMOVUPS YMM0, [RCX+RAX]'
      '        VMOVAPS [RDX+RAX], YMM0'
      '        ADD     RAX, 32'
      '        JL      @@ForwardAVXLoop'
      '@@ForwardAVXDone:'
      '        VMOVUPS [R10], YMM1 {Save First 32}'
      '        VMOVUPS [RDX], YMM2 {Save Last 32}'
      '        VZEROUPPER'
      '        RET'
      '        .ALIGN 16'
      '@@ForwardAVXNonTemporalLoop:'
      '        VMOVUPS YMM0, [RCX+RAX]'
      '        VMOVNTPS[RDX+RAX], YMM0'
      '        ADD     RAX, 32'
      '        JL      @@ForwardAVXNonTemporalLoop'
      '        SFENCE'
      '        JMP     @@ForwardAVXDone'
      ''
      '@@BackwardMove:'
      '        LEA     R10, [RDX+RAX-32]'
      '        TEST    TestAVX, 1'
      '        JNZ     @@BackwardAVX'
      ''
      '        MOVUPS  XMM2, [RCX] {Load First 16}'
      '        MOVUPS  XMM3, [RCX+16] {Load Second 16}'
      '        MOVUPS  XMM4, [RCX+RAX-32] {Load Second To Last 16}'
      '        MOVUPS  XMM5, [RCX+RAX-16] {Load Last 16}'
      '        LEA     RAX, [RAX+RDX-32]'
      '        AND     RAX, -32 {32-Byte Align Writes}'
      '        SUB     RAX, RDX'
      '        .ALIGN 16'
      '@@BackwardLoop:'
      '        MOVUPS  XMM0, [RCX+RAX]'
      '        MOVUPS  XMM1, [RCX+RAX+16]'
      '        MOVAPS  [RDX+RAX], XMM0'
      '        MOVAPS  [RDX+RAX+16], XMM1'
      '        SUB     RAX, 32'
      '        JG      @@BackwardLoop'
      '@@BackwardDone:'
      '        MOVUPS  [RDX], XMM2 {Save First 16}'
      '        MOVUPS  [RDX+16], XMM3 {Save Second 16}'
      '        MOVUPS  [R10], XMM4 {Save Second To Last 16}'
      '        MOVUPS  [R10+16], XMM5 {Save Last 16}'
      '        RET'
      ''
      '@@BackwardAVX:'
      '        VMOVUPS YMM1, [RCX] {Load First 32}'
      '        VMOVUPS YMM2, [RCX+RAX-32] {Load Last 32}'
      '        LEA     RAX, [RAX+RDX-32]'
      '        AND     RAX, -32 {32-Byte Align Writes}'
      '        SUB     RAX, RDX'
      '        CMP     R9, RAX'
      '        CMOVA   R9, RAX'
      
        '        CMP     R9, NonTemporalThreshold {Count and Dest-Source ' +
        'both > NonTemporalThreshold}'
      '        JA      @@BackwardAVXNonTemporalLoop'
      '        .ALIGN 16'
      '@@BackwardAVXLoop:'
      '        VMOVUPS YMM0, [RCX+RAX]'
      '        VMOVAPS [RDX+RAX], YMM0'
      '        SUB     RAX, 32'
      '        JG      @@BackwardAVXLoop'
      '@@BackwardAVXDone:'
      '        VMOVUPS [RDX], YMM1 {Save First 32}'
      '        VMOVUPS [R10], YMM2 {Save Last 32}'
      '        VZEROUPPER'
      '        RET'
      '        .ALIGN 16'
      '@@BackwardAVXNonTemporalLoop:'
      '        VMOVUPS YMM0, [RCX+RAX]'
      '        VMOVNTPS[RDX+RAX], YMM0'
      '        SUB     RAX, 32'
      '        JG      @@BackwardAVXNonTemporalLoop'
      '        SFENCE'
      '        JMP     @@BackwardAVXDone'
      'end;'
      '{$CODEALIGN 0}'
      '{$ELSEIF defined(PUREPASCAL)}'
      '{$POINTERMATH ON}'
      'var'
      '  S, D, I: PByte;'
      '  Temp: NativeInt;'
      '  C: NativeUInt;'
      '  L: PNativeInt;'
      'begin'
      '  S := PByte(@Source);'
      '  D := PByte(@Dest);'
      '  if S = D then'
      '    Exit;'
      '  if Count <= 0 then Exit;'
      '  if Count <= SizeOf(NativeInt) then'
      '    case Count of'
      '      1: D[0] := S[0];'
      '      2: PWord(D)[0] := PWord(S)[0];'
      '      3: if D > S then'
      '         begin'
      '           D[2] := S[2];'
      '           PWord(D)[0] := PWord(S)[0];'
      '         end'
      '         else'
      '         begin'
      '           PWord(D)[0] := PWord(S)[0];'
      '           D[2] := S[2];'
      '         end;'
      '      4: PInteger(D)[0] := PInteger(S)[0];'
      '      5: if D > S then'
      '         begin'
      '           D[4] := S[4];'
      '           PInteger(D)[0] := PInteger(S)[0];'
      '         end'
      '         else'
      '         begin'
      '           PInteger(D)[0] := PInteger(S)[0];'
      '           D[4] := S[4];'
      '         end;'
      '      6: if D > S then'
      '         begin'
      '           PWord(D)[2] := PWord(S)[2];'
      '           PInteger(D)[0] := PInteger(S)[0];'
      '         end'
      '         else'
      '         begin'
      '           PInteger(D)[0] := PInteger(S)[0];'
      '           PWord(D)[2] := PWord(S)[2];'
      '         end;'
      '      7: if D > S then'
      '         begin'
      '           D[6] := S[6];'
      '           PWord(D)[2] := PWord(S)[2];'
      '           PInteger(D)[0] := PInteger(S)[0];'
      '         end'
      '         else'
      '         begin'
      '           PInteger(D)[0] := PInteger(S)[0];'
      '           PWord(D)[2] := PWord(S)[2];'
      '           D[6] := S[6];'
      '         end;'
      '      8: PInt64(D)[0] := PInt64(S)[0];'
      '    end'
      '  else'
      '    if D > S then'
      '    begin'
      '      Temp := PNativeInt(S)^;'
      '      I := D;'
      '      C := Count - SizeOf(NativeInt);'
      '      L := PNativeInt(D + C);'
      '      Inc(S, C);'
      '      repeat'
      '        L^ := PNativeInt(S)^;'
      '        if Count <= 2 * Sizeof(NativeInt) then'
      '          Break;'
      '        Dec(Count, Sizeof(NativeInt));'
      '        Dec(S, Sizeof(NativeInt));'
      '        Dec(L);'
      '      until False;'
      '      PNativeInt(I)^ := Temp;'
      '    end'
      '    else'
      '    begin'
      '      C := Count - Sizeof(NativeInt);'
      '      Temp := PNativeInt(S + C)^;'
      '      I := D + C;'
      '      L := PNativeInt(D);'
      '      repeat'
      '        L^ := PNativeInt(S)^;'
      '        if Count <= 2 * Sizeof(NativeInt) then'
      '          Break;'
      '        Dec(Count, Sizeof(NativeInt));'
      '        Inc(S, Sizeof(NativeInt));'
      '        Inc(L);'
      '      until False;'
      '      PNativeInt(I)^ := Temp;'
      '    end;'
      'end;'
      '{$POINTERMATH OFF}'
      '{$ELSE }'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      ''
      'procedure MoveChars(const Source; var Dest; Length: Integer);'
      'begin'
      '  Move(Source, Dest, Length * SizeOf(Char));'
      'end;'
      ''
      '{$IFDEF MSWINDOWS}'
      'function GetParamStr(P: PChar; var Param: string): PChar;'
      'var'
      '  i, Len: Integer;'
      '  Start, S: PChar;'
      'begin'
      '  // U-OK'
      '  while True do'
      '  begin'
      '    while (P[0] <> #0) and (P[0] <= '#39' '#39') do'
      '      Inc(P);'
      '    if (P[0] = '#39'"'#39') and (P[1] = '#39'"'#39') then Inc(P, 2) else Break;'
      '  end;'
      '  Len := 0;'
      '  Start := P;'
      '  while P[0] > '#39' '#39' do'
      '  begin'
      '    if P[0] = '#39'"'#39' then'
      '    begin'
      '      Inc(P);'
      '      while (P[0] <> #0) and (P[0] <> '#39'"'#39') do'
      '      begin'
      '        Inc(Len);'
      '        Inc(P);'
      '      end;'
      '      if P[0] <> #0 then'
      '        Inc(P);'
      '    end'
      '    else'
      '    begin'
      '      Inc(Len);'
      '      Inc(P);'
      '    end;'
      '  end;'
      ''
      '  SetLength(Param, Len);'
      ''
      '  P := Start;'
      '  S := Pointer(Param);'
      '  i := 0;'
      '  while P[0] > '#39' '#39' do'
      '  begin'
      '    if P[0] = '#39'"'#39' then'
      '    begin'
      '      Inc(P);'
      '      while (P[0] <> #0) and (P[0] <> '#39'"'#39') do'
      '      begin'
      '        S[i] := P^;'
      '        Inc(P);'
      '        Inc(i);'
      '      end;'
      '      if P[0] <> #0 then Inc(P);'
      '    end'
      '    else'
      '    begin'
      '      S[i] := P^;'
      '      Inc(P);'
      '      Inc(i);'
      '    end;'
      '  end;'
      ''
      '  Result := P;'
      'end;'
      '{$ENDIF}'
      ''
      'function ParamCount: Integer;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  P: PChar;'
      '  S: string;'
      'begin'
      '  // U-OK'
      '  Result := 0;'
      '  P := GetParamStr(GetCommandLine, S);'
      '  while True do'
      '  begin'
      '    P := GetParamStr(P, S);'
      '    if S = '#39#39' then Break;'
      '    Inc(Result);'
      '  end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      '  if ArgCount > 1 then'
      '    Result := ArgCount - 1'
      '  else Result := 0;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      'end;'
      ''
      'type'
      '  PAnsiCharArray = array[0..0] of _PAnsiChr;'
      ''
      'function ParamStr(Index: Integer): string;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  P: PChar;'
      '  Buffer: array[0..260] of Char;'
      'begin'
      '  Result := '#39#39';'
      '  if Index = 0 then'
      
        '    SetString(Result, Buffer, GetModuleFileName(0, Buffer, Lengt' +
        'h(Buffer)))'
      '  else'
      '  begin'
      '    P := GetCommandLine;'
      '    while True do'
      '    begin'
      '      P := GetParamStr(P, Result);'
      '      if (Index = 0) or (Result = '#39#39') then Break;'
      '      Dec(Index);'
      '    end;'
      '  end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      '  if Index < ArgCount then'
      '    Result := UTF8ToString(PAnsiCharArray(ArgValues^)[Index])'
      '  else'
      '    Result := '#39#39';'
      '{$ENDIF POSIX}'
      'end;'
      '{$O+}'
      'procedure DefaultRandomize(NewSeed: UInt64);'
      'begin'
      
        '  RandSeed := Integer(UInt32(NewSeed) xor UInt32(NewSeed shr 32)' +
        ');'
      'end;'
      ''
      'procedure Randomize;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Counter: Int64;'
      'begin'
      '  if not QueryPerformanceCounter(Counter) then'
      '    Counter := GetTickCount;'
      
        '  RandomizeProc( (UInt64(Random(MAXINT)) shl 32) xor UInt64(Coun' +
        'ter) );'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IF defined(LINUX) or defined(ANDROID)}'
      'var'
      '  TimeOfDay: timeval;'
      '  NewSeed: UInt64;'
      'begin'
      '  if gettimeofday(TimeOfDay, nil) = 0 then'
      
        '    NewSeed := UInt64(TimeOfDay.tv_sec) * 1000000 + UInt64(TimeO' +
        'fDay.tv_usec)'
      '  else'
      '    NewSeed := time(nil);'
      '  RandomizeProc( (UInt64(Random(MAXINT)) shl 32) xor NewSeed );'
      'end;'
      '{$ENDIF LINUX or ANDROID}'
      '{$IFDEF MACOS}'
      'begin'
      
        '  RandomizeProc( (UInt64(Random(MAXINT)) shl 32) xor MachAbsolut' +
        'eTime );'
      'end;'
      '{$ENDIF MACOS}'
      ''
      
        '// Random integer, implemented as a deterministic linear congrue' +
        'ntial generator'
      '// with 134775813 as a and 1 as c.'
      'function DefaultRandom32: UInt32;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := UInt32(RandSeed) * $08088405 + 1;'
      '  RandSeed := Result'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '{     <-EAX     Result  }'
      '{$IFDEF PIC}'
      '        PUSH    EBX'
      '        CALL    GetGOT'
      '        MOV     EBX,EAX'
      '        MOV     ECX,[EBX].RandSeed'
      '        IMUL    EAX,[ECX],08088405H'
      '        INC     EAX'
      '        MOV     [ECX],EAX'
      '        POP     EBX'
      '{$ELSE !PIC}'
      '        IMUL    EAX,RandSeed,08088405H'
      '        INC     EAX'
      '        MOV     RandSeed,EAX'
      '{$ENDIF !PIC}'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function Random(const ARange: Integer): Integer;'
      '{$IF Defined(Win64)  and Defined(ASSEMBLER)}'
      'asm'
      '        PUSH    RBX'
      '        MOV     EBX,ECX'
      '        CALL    [Random32Proc]'
      '        MOV     EAX,EAX'
      '        IMUL    RAX,RBX'
      '        SHR     RAX,$20'
      '        POP     RBX'
      '        RET'
      'end;'
      '{$ELSEIF Defined(PUREPASCAL)}'
      'var'
      '  Temp: UInt32;'
      'begin'
      '  Temp := Random32Proc;'
      '  Result := (UInt64(UInt32(ARange)) * UInt64(Temp)) shr 32;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '{     ->EAX     Range   }'
      '{     <-EAX     Result  }'
      '{$IFDEF PIC}'
      '        PUSH    EBX'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        SUB     ESP,04H'
      '        MOV     EAX, [EBX].Random32Proc'
      '        CALL    [EAX]'
      '        ADD     ESP,04H'
      '        POP     EDX'
      '        MUL     EDX'
      '        MOV     EAX,EDX'
      '        POP     EBX'
      '{$ELSE !PIC}'
      '        PUSH    EAX'
      '        CALL    [Random32Proc] // EAX'
      '        POP     EDX'
      '        MUL     EDX'
      '        MOV     EAX,EDX'
      '{$ENDIF !PIC}'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function Random: Extended;'
      'const'
      '  two2neg32: double = ((1.0/$10000) / $10000);  // 2^-32'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  F: Extended;'
      'begin'
      '  F := Int64(Random32Proc);'
      '  Result := F * two2neg32;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '{       FUNCTION _RandExt: Extended;    }'
      ''
      '{$IFDEF PIC}'
      '        PUSH    EBX'
      '        CALL    GeTGOT'
      '        MOV     EBX,EAX'
      '        SUB     ESP,08H'
      '        MOV     EAX, [EBX].Random32Proc'
      '        CALL    [EAX]'
      '        ADD     ESP,08H'
      '        FLD     [EBX].two2neg32'
      '        PUSH    0'
      '        PUSH    EAX'
      '        FILD    qword ptr [ESP]'
      '        ADD     ESP,8'
      '        FMULP   ST(1), ST(0)'
      '        POP     EBX'
      '{$ELSE !PIC}'
      '        CALL    [Random32Proc]'
      '        FLD     two2neg32'
      '        PUSH    0'
      '        PUSH    EAX'
      '        FILD    qword ptr [ESP]'
      '        ADD     ESP,8'
      '        FMULP   ST(1), ST(0)'
      '{$ENDIF !PIC}'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure RmDir(const S: string);'
      'begin'
      '  // U-OK'
      '  RmDir(PChar(s));'
      'end;'
      ''
      'procedure RmDir(P: PChar);'
      '{$IFDEF POSIX}'
      'var'
      '   us: _UTF8Str;'
      '{$ENDIF POSIX}'
      'begin'
      '  // U-OK'
      '{$IFDEF MSWINDOWS}'
      '  if not RemoveDirectory(P) then'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '  us := _UTF8Str(P);'
      '  if __rmdir(_PAnsiChr(us)) <> 0 then'
      '{$ENDIF POSIX}'
      '    InOutError;'
      'end;'
      ''
      'function UpCase(ch: _AnsiChr): _AnsiChr;'
      'begin'
      '  Result := Ch;'
      '  if Result in ['#39'a'#39'..'#39'z'#39'] then'
      '    Dec(Result, Ord('#39'a'#39')-Ord('#39'A'#39'));'
      'end;'
      ''
      'function UpCase(Ch: WideChar): WideChar;'
      'begin'
      '  Result := Ch;'
      '  case Ch of'
      '    '#39'a'#39'..'#39'z'#39':'
      '      Result := WideChar(Word(Ch) and $FFDF);'
      '  end;'
      'end;'
      ''
      'const'
      '  cInfinity   =  1.0 / 0.0;'
      '  cNInfinity  = -1.0 / 0.0;'
      '  cNaN        =  0.0 / 0.0;'
      ''
      
        'function ExceptionFlagToMask(exceptionFlag: UInt32) : UInt32; in' +
        'line;'
      'begin'
      '{$IF     defined(CPUX86)}'
      '  Result := exceptionFlag and femALLEXCEPT;'
      '{$ELSEIF defined(CPUX64) and defined(MSWINDOWS)} // Win64'
      '  Result := (exceptionFlag shl 7) and femALLEXCEPT;'
      '{$ELSEIF defined(CPUX64) and defined(Linux)} // Linux64'
      '  Result := exceptionFlag and femALLEXCEPT;'
      '{$ELSEIF defined(CPUARM)}'
      '  Result := (exceptionFlag shl 8) and femALLEXCEPT;'
      
        '{$ELSE  !defined(CPUX86) or !defined(CPUX64) or !defined(CPUARM)' +
        '}'
      '  Result := 0;'
      
        '  if exceptionFlag and feeINEXACT <> 0   then Result := Result o' +
        'r femINEXACT;'
      
        '  if exceptionFlag and feeUNDERFLOW <> 0 then Result := Result o' +
        'r femUNDERFLOW;'
      
        '  if exceptionFlag and feeOVERFLOW <> 0  then Result := Result o' +
        'r femOVERFLOW;'
      
        '  if exceptionFlag and feeDIVBYZERO <> 0 then Result := Result o' +
        'r femDIVBYZERO;'
      
        '  if exceptionFlag and feeINVALID <> 0   then Result := Result o' +
        'r femINVALID;'
      '{$ENDIF}'
      'end;'
      ''
      
        'function ExceptionMaskToFlag( exceptionMask: UInt32) : UInt32; i' +
        'nline;'
      'begin'
      '{$IF     defined(CPUX86)}'
      '  Result := exceptionMask and feeALLEXCEPT;'
      '{$ELSEIF defined(CPUX64) and defined(MSWINDOWS)} // Win64'
      '  Result := (exceptionMask shr 7) and feeALLEXCEPT;'
      '{$ELSEIF defined(CPUX64) and defined(Linux)} // Linux64'
      '  Result := exceptionMask and feeALLEXCEPT;'
      '{$ELSEIF defined(CPUARM)}'
      '  Result := (exceptionMask shr 8) and feeALLEXCEPT;'
      
        '{$ELSE  !defined(CPUX86) or !defined(CPUX64) or !defined(CPUARM)' +
        '}'
      '  Result := 0;'
      
        '  if exceptionMask and femINEXACT <> 0   then Result := Result o' +
        'r feeINEXACT;'
      
        '  if exceptionMask and femUNDERFLOW <> 0 then Result := Result o' +
        'r feeUNDERFLOW;'
      
        '  if exceptionMask and femOVERFLOW <> 0  then Result := Result o' +
        'r feeOVERFLOW;'
      
        '  if exceptionMask and femDIVBYZERO <> 0 then Result := Result o' +
        'r feeDIVBYZERO;'
      
        '  if exceptionMask and femINVALID <> 0   then Result := Result o' +
        'r feeINVALID;'
      '{$ENDIF}'
      'end;'
      ''
      
        '{$IF Defined(NEXTGEN) or Defined(Linux64) or defined(ANDROID) or' +
        ' defined(IOS)}'
      
        '{$IF defined(IOS) or defined(ANDROID) or defined(LINUX) or (defi' +
        'ned(OSX) and defined(EXTERNALLINKER)) or (defined(IOSSIMULATOR) ' +
        'and defined(CPUX64)) }'
      'type'
      '  fexcept_t = Word;'
      '  TExceptionFlags = fexcept_t;'
      '  PExceptionFlags = ^TExceptionFlags;'
      ''
      
        '{$IF defined(IOS) or (defined(OSX) and defined(EXTERNALLINKER)) ' +
        'or (defined(IOSSIMULATOR) and defined(CPUX64)) }'
      'const'
      '  libmmodulename = '#39'/usr/lib/libSystem.dylib'#39'; // iOS device'
      '  librtlhelpername = '#39'librtlhelper.a'#39';'
      ''
      '{$IF not (defined(CPUX86) and defined(ASSEMBLER))}'
      
        '//These functions do not exist in iOSSimulator math library. We ' +
        'use two local functions.'
      
        'function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fegetexceptflag'#39';'
      '{$EXTERNALSYM fegetexceptflag}'
      
        'function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fesetexceptflag'#39';'
      '{$EXTERNALSYM fesetexceptflag}'
      '{$ENDIF not (CPUX86 and ASSEMBLER)}'
      ''
      'function fegetround(): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fegetround'#39';'
      '{$EXTERNALSYM fegetround}'
      
        'function fesetround(__rounding_direction: UInt32): UInt32; cdecl' +
        ';'
      '  external libmmodulename name _PU + '#39'fesetround'#39';'
      '{$EXTERNALSYM fesetround}'
      'function fegetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fegetenv'#39';'
      '{$EXTERNALSYM fegetenv}'
      'function fesetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fesetenv'#39';'
      '{$EXTERNALSYM fesetenv}'
      
        '{$ENDIF IOS or (OSX and EXTERNALLINKER) or (IOSSIMULATOR or CPUX' +
        '64)}'
      ''
      '{$IFDEF ANDROID32}'
      'const'
      '  libmmodulename = '#39'libm.so'#39'; // Android'
      '  librtlhelpername = '#39'librtlhelper.a'#39';'
      ''
      
        'function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external librtlhelpername name '#39'math_fegetexceptflag'#39';'
      '{$EXTERNALSYM fegetexceptflag}'
      
        'function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external librtlhelpername name '#39'math_fesetexceptflag'#39';'
      '{$EXTERNALSYM fesetexceptflag}'
      'function fegetround(): UInt32; cdecl;'
      '  external librtlhelpername name '#39'math_fegetround'#39';'
      '{$EXTERNALSYM fegetround}'
      
        'function fesetround(__rounding_direction: UInt32): UInt32; cdecl' +
        ';'
      '  external librtlhelpername name '#39'math_fesetround'#39';'
      '{$EXTERNALSYM fesetround}'
      'function fegetenv(__envp: pointer): UInt32; cdecl;'
      '  external librtlhelpername name '#39'math_fegetenv'#39';'
      '{$EXTERNALSYM fegetenv}'
      'function fesetenv(__envp: pointer): UInt32; cdecl;'
      '  external librtlhelpername name '#39'math_fesetenv'#39';'
      '{$EXTERNALSYM fesetenv}'
      '{$ENDIF ANDROID32}'
      '{$IFDEF ANDROID64}'
      'const'
      '  libmmodulename = '#39'libm.so'#39'; // Android'
      ''
      
        'function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      
        '  external libmmodulename name '#39'fegetexceptflag'#39'; // __INTRODUCE' +
        'D_IN_ARM(21)'
      '{$EXTERNALSYM fegetexceptflag}'
      
        'function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      
        '  external libmmodulename name '#39'fesetexceptflag'#39'; // __INTRODUCE' +
        'D_IN_ARM(21)'
      '{$EXTERNALSYM fesetexceptflag}'
      'function fegetround(): UInt32; cdecl;'
      
        '  external libmmodulename name '#39'fegetround'#39'; // __INTRODUCED_IN_' +
        'ARM(21)'
      '{$EXTERNALSYM fegetround}'
      
        'function fesetround(__rounding_direction: UInt32): UInt32; cdecl' +
        ';'
      
        '  external libmmodulename name '#39'fesetround'#39'; // __INTRODUCED_IN_' +
        'ARM(21)'
      '{$EXTERNALSYM fesetround}'
      'function fegetenv(__envp: pointer): UInt32; cdecl;'
      
        '  external libmmodulename name '#39'fegetenv'#39'; // __INTRODUCED_IN_AR' +
        'M(21)'
      '{$EXTERNALSYM fegetenv}'
      'function fesetenv(__envp: pointer): UInt32; cdecl;'
      
        '  external libmmodulename name '#39'fesetenv'#39'; // __INTRODUCED_IN_AR' +
        'M(21)'
      '{$EXTERNALSYM fesetenv}'
      '{$ENDIF ANDROID64}'
      ''
      '{$IF Defined(LINUX)}'
      'const'
      '  libmmodulename = '#39'libm.so'#39'; // Linux 64. Ubuntu'
      
        '  librtlhelpername = {$IFDEF PIC} '#39'librtlhelper_PIC.a'#39' {$ELSE} '#39 +
        'librtlhelper.a'#39' {$ENDIF};'
      ''
      
        'function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetexceptflag'#39';'
      '{$EXTERNALSYM fegetexceptflag}'
      
        'function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'fesetexceptflag'#39';'
      '{$EXTERNALSYM fesetexceptflag}'
      'function fegetround(): UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetround'#39';'
      '{$EXTERNALSYM fegetround}'
      
        'function fesetround(__rounding_direction: UInt32): UInt32; cdecl' +
        ';'
      '  external libmmodulename name '#39'fesetround'#39';'
      '{$EXTERNALSYM fesetround}'
      'function fegetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetenv'#39';'
      '{$EXTERNALSYM fegetenv}'
      'function fesetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name '#39'fesetenv'#39';'
      '{$EXTERNALSYM fesetenv}'
      ''
      '// GNU extension'
      '//int feenableexcept(int excepts);'
      'function feenableexcept(excepts: UInt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'feenableexcept'#39';'
      '{$EXTERNALSYM feenableexcept}'
      '//int fedisableexcept(int excepts);'
      'function fedisableexcept(excepts: UInt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'fedisableexcept'#39';'
      '{$EXTERNALSYM fedisableexcept}'
      '//int fegetexcept(void);'
      'function fegetexcept: UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetexcept'#39';'
      '{$EXTERNALSYM fegetexcept}'
      ''
      'procedure fpu_init; cdecl;'
      '  external librtlhelpername name '#39'fpu_init'#39';'
      '{$ENDIF LINUX}'
      ''
      
        '{$IF Defined(OSX64) or (defined(IOSSIMULATOR) and defined(CPUX64' +
        '))}'
      '// NEXTGEN'
      '//const'
      '//  libmmodulename = '#39'libm.so'#39'; // Linux 64. Ubuntu'
      
        '//  librtlhelpername = {$IFDEF PIC} '#39'librtlhelper_PIC.a'#39' {$ELSE}' +
        ' '#39'librtlhelper.a'#39' {$ENDIF};'
      '//'
      
        '//function fegetexceptflag(__flagp: PExceptionFlags; __excepts: ' +
        'UInt32): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fegetexceptflag'#39';'
      '//{$EXTERNALSYM fegetexceptflag}'
      
        '//function fesetexceptflag(__flagp: PExceptionFlags; __excepts: ' +
        'UInt32): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fesetexceptflag'#39';'
      '//{$EXTERNALSYM fesetexceptflag}'
      '//function fegetround(): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fegetround'#39';'
      '//{$EXTERNALSYM fegetround}'
      
        '//function fesetround(__rounding_direction: UInt32): UInt32; cde' +
        'cl;'
      '//  external libmmodulename name '#39'fesetround'#39';'
      '//{$EXTERNALSYM fesetround}'
      '//function fegetenv(__envp: pointer): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fegetenv'#39';'
      '//{$EXTERNALSYM fegetenv}'
      '//function fesetenv(__envp: pointer): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fesetenv'#39';'
      '//{$EXTERNALSYM fesetenv}'
      '//'
      '//// GNU extension'
      '////int feenableexcept(int excepts);'
      '//function feenableexcept(excepts: UInt32): UInt32; cdecl;'
      '//  external libmmodulename name '#39'feenableexcept'#39';'
      '//{$EXTERNALSYM feenableexcept}'
      '////int fedisableexcept(int excepts);'
      'function fedisableexcept(excepts: UInt32): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fedisableexcept'#39';'
      '{$EXTERNALSYM fedisableexcept}'
      'begin'
      '                              '
      '  Result := 0;'
      'end;'
      '////int fegetexcept(void);'
      '//function fegetexcept: UInt32; cdecl;'
      '//  external libmmodulename name '#39'fegetexcept'#39';'
      '//{$EXTERNALSYM fegetexcept}'
      ''
      'procedure fpu_init; cdecl;'
      'begin'
      '                              '
      'end;'
      '{$ENDIF OSX64 or (IOSSIMULATOR and CPUX64)}'
      ''
      'procedure FCheckExcept;'
      'begin'
      '  FRaiseExcept(FGetExceptFlag);'
      'end;'
      ''
      
        'procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Bool' +
        'ean = True);'
      'var'
      '  flags, masks: UInt32;'
      'begin'
      '  if excepts = 0 then Exit;'
      ''
      '  if CheckExceptionMask then'
      '  begin'
      '    masks := FGetExceptMask(ExceptionFlagToMask(excepts));'
      '    if masks <> 0 then'
      '    begin'
      '      flags := ExceptionMaskToFlag(masks);'
      '      excepts := excepts and not flags;'
      '      FSetExceptFlag(0, flags);'
      '    end;'
      '  end;'
      '  if excepts <> 0 then'
      '  begin'
      '    if excepts and feeINEXACT <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeINEXACT);'
      '      Error(reInvalidOp);'
      '    end;'
      '    if excepts and feeUNDERFLOW <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeUNDERFLOW);'
      '      Error(reUnderflow);'
      '    end;'
      '    if excepts and feeOVERFLOW <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeOVERFLOW);'
      '      Error(reOverflow);'
      '    end;'
      '    if excepts and feeDIVBYZERO <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeDIVBYZERO);'
      '      Error(reZeroDivide);'
      '    end;'
      '    if excepts and feeINVALID <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeINVALID);'
      '      Error(reInvalidOp);'
      '    end;'
      '  end;'
      'end;'
      ''
      '{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)}'
      '// iOS/Sim'
      
        '// These are the replacements for: fegetexceptflag and fesetexce' +
        'ptflag'
      'function InternalGetFPUStatusWord: UInt16;'
      'var'
      '  SW: UInt16;'
      'begin'
      '  asm'
      '    FSTSW SW'
      '  end;'
      '  Result := SW;'
      'end;'
      ''
      'procedure InternalSetFPUStatusWord(NewFlags: TExceptionFlags);'
      'var'
      '  FEnv: array[0..27] of byte;'
      'begin'
      '  asm'
      '    FNSTENV FEnv'
      '  end;'
      '  FEnv[4] := (FEnv[4] and $C0) or (NewFlags and $3F);'
      '  asm'
      '    FLDENV FEnv'
      '  end;'
      'end;'
      '{$ENDIF !(IOS and CPUX86 and ASSEMBLER)}'
      ''
      'procedure FClearExcept;'
      'var'
      '  Flags: UInt32;'
      'begin'
      
        '  Flags := not ExceptionMaskToFlag(FGetExceptMask) and feeALLEXC' +
        'EPT;'
      '  if Flags <> 0 then'
      '    FSetExceptFlag(0, Flags);'
      'end;'
      ''
      
        'function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32): UInt' +
        '32;'
      'var'
      '  flags: TExceptionFlags;'
      'begin'
      '  Excepts := Excepts and feeALLEXCEPT;'
      '  flags := FGetExceptFlag(feeALLEXCEPT);'
      '  Result := flags and Excepts;'
      '  flags := (flags and (not Excepts)) or (NewFlags and Excepts);'
      '{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)}'
      '// iOS simulator.'
      '  InternalSetFPUStatusWord(flags);'
      '  SetMXCSRExceptionFlag(flags);'
      '{$ELSEIF defined(CPUX64) and defined(Linux)}'
      '  feSetExceptFlag(@flags, Excepts);'
      '{$ELSE }'
      '  feSetExceptFlag(@flags, Excepts);'
      '{$ENDIF !(IOS and CPUX86 and ASSEMBLER)}'
      'end;'
      ''
      'function FGetExceptFlag(Excepts: UInt32): UInt32;'
      '{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)}'
      '// iOS simulator.'
      'begin'
      '  Excepts := Excepts and feeALLEXCEPT;'
      '  Result := (InternalGetFPUStatusWord or GetMXCSR) and Excepts;'
      'end;'
      '{$ELSE}'
      'var'
      '  flags: TExceptionFlags;'
      'begin'
      '  feGetExceptFlag(@flags, Excepts and feeALLEXCEPT);'
      '  Result := flags and feeALLEXCEPT;'
      'end;'
      '{$ENDIF !(IOS and CPUX86 and ASSEMBLER)}'
      ''
      'function FGetRound: UInt32;'
      'begin'
      '  Result := feGetRound;'
      'end;'
      ''
      'function FSetRound(NewRound: UInt32): UInt32;'
      'begin'
      '  Result:= feGetRound;'
      '  feSetRound(NewRound);'
      'end;'
      ''
      '{$IFDEF CPUARM}'
      'threadvar'
      '  FPSCRExceptionEnableBits: UInt32;'
      '{$ENDIF CPUARM}'
      
        '{$IF (defined(CPUX86) or defined(CPUX64)) and not defined(ARITH_' +
        'USE_LIBM)}'
      'threadvar'
      
        '  FPUExceptionMaskBits: UInt32; // for x87 FPU Control word and ' +
        'SSE MXCSR'
      
        '{$ENDIF (defined(CPUX86) or defined(CPUX64)) and defined(ARITH_U' +
        'SE_LIBM)}'
      '{$IF defined(CPUX64) and defined(ARITH_USE_LIBM)} // Linux64'
      'threadvar'
      
        '  FPExceptionMaskBits: UInt32; // for x87 FPU Control word and S' +
        'SE MXCSR'
      '{$ENDIF defined(CPUX64) and defined(ARITH_USE_LIBM)}'
      ''
      
        'function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32 = ' +
        'femALLEXCEPT): UInt32;'
      '{$IF defined(CPUARM)}'
      
        '// FPSCR of ARM architecture has "Exception Enable" flag. Cortex' +
        '-A series CPUs'
      
        '// don'#39't have hardware exception capability, but we use same fla' +
        'gs on RTL'#39's thread-local storage.'
      
        '// flag. Although, Get/SetFEnvExceptMask use "MASK" flags like M' +
        'ath.TArithmeticExceptionMask.'
      'var'
      '  CurrentEnableBits: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      
        '  CurrentEnableBits := FPSCRExceptionEnableBits and femALLEXCEPT' +
        ';'
      '  Result := (not CurrentEnableBits) and ExceptMasks;'
      
        '  FPSCRExceptionEnableBits := (CurrentEnableBits and (not Except' +
        'Masks)) or ((not NewMasks) and ExceptMasks);'
      'end;'
      '{$ELSEIF defined(CPUX86)}'
      'var'
      '  CurrentMask: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CurrentMask := FPUExceptionMaskBits and femALLEXCEPT;'
      '  Result := CurrentMask and ExceptMasks;'
      
        '  FPUExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or' +
        ' (NewMasks and ExceptMasks)or $8000;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWindows)} // DCC64'
      'var'
      '  CurrentMask: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CurrentMask := FPUExceptionMaskBits and femALLEXCEPT;'
      '  Result := CurrentMask and ExceptMasks;'
      
        '  FPUExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or' +
        ' (NewMasks and ExceptMasks)or $8000;'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(Linux) and defined(ARITH_US' +
        'E_LIBM)} // DCCLinux64'
      'var'
      '  CurrentMask: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CurrentMask := FPExceptionMaskBits and femALLEXCEPT;'
      '  Result := CurrentMask and ExceptMasks;'
      
        '  FPExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or ' +
        '(NewMasks and ExceptMasks);'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(OSX) and defined(ARITH_USE_' +
        'LIBM)} // DCCOSX64'
      'var'
      '  CurrentMask: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CurrentMask := FPExceptionMaskBits and femALLEXCEPT;'
      '  Result := CurrentMask and ExceptMasks;'
      
        '  FPExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or ' +
        '(NewMasks and ExceptMasks);'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(IOSSIMULATOR) and defined(A' +
        'RITH_USE_LIBM)} // DCCIOSSIM64'
      'var'
      '  CurrentMask: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CurrentMask := FPExceptionMaskBits and femALLEXCEPT;'
      '  Result := CurrentMask and ExceptMasks;'
      
        '  FPExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or ' +
        '(NewMasks and ExceptMasks);'
      'end;'
      '{$ELSE  !CPUARM and !CPUX86 and !CPUX64}'
      'begin'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      'end;'
      '{$ENDIF !CPUARM and !CPUX86 and !CPUX64}'
      ''
      
        'function FGetExceptMask(ExceptMasks: UInt32 = femALLEXCEPT): UIn' +
        't32;'
      '{$IF     defined(CPUARM)}'
      'begin'
      
        '  Result := (not FPSCRExceptionEnableBits) and (ExceptMasks and ' +
        'femALLEXCEPT);'
      'end;'
      '{$ELSEIF defined(CPUX86)}'
      'begin'
      '  if FPUExceptionMaskBits = 0 then'
      
        '    FPUExceptionMaskBits := (Default8087CW and $003F) or ((Defau' +
        'ltMXCSR and $1F80) shr 7) or $8000;'
      
        '  Result := FPUExceptionMaskBits and (ExceptMasks and femALLEXCE' +
        'PT);'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWINDOWS)}'
      'begin'
      '  if FPUExceptionMaskBits = 0 then'
      
        '    FPUExceptionMaskBits := ((Default8087CW and $003F) shl 7) or' +
        ' (DefaultMXCSR and $1F80) or $8000;'
      
        '  Result := FPUExceptionMaskBits and (ExceptMasks and femALLEXCE' +
        'PT);'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(Linux) and defined(ARITH_US' +
        'E_LIBM)} // Linux64'
      'begin'
      
        '  Result := FPExceptionMaskBits and (ExceptMasks and femALLEXCEP' +
        'T);'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(OSX) and defined(ARITH_USE_' +
        'LIBM)} // OSX64'
      'begin'
      
        '  Result := FPExceptionMaskBits and (ExceptMasks and femALLEXCEP' +
        'T);'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(IOSSIMULATOR) and defined(A' +
        'RITH_USE_LIBM)} // IOSSIM64'
      'begin'
      
        '  Result := FPExceptionMaskBits and (ExceptMasks and femALLEXCEP' +
        'T);'
      'end;'
      '{$ELSE}'
      'begin'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      'end;'
      '{$ENDIF !CPUARM and !CPUX86 and !CPUX64}'
      ''
      '{$ENDIF IOS or ANDROID or (OSX and EXTERNALLINKER)}'
      '{$IF defined(WIN32) }'
      '// condition is NEXTGEN and Windows (not iOS/ANDROID/OSX/LINUX)'
      ''
      'procedure FClearExcept;'
      'begin'
      'end;'
      ''
      'procedure FCheckExcept;'
      'begin'
      'end;'
      ''
      
        'procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Bool' +
        'ean = True);'
      'begin'
      'end;'
      ''
      
        'function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32): UInt' +
        '32;'
      'begin'
      '  Result := 0;'
      'end;'
      ''
      'function FGetExceptFlag(Excepts: UInt32): UInt32;'
      'begin'
      '  Result := 0;'
      'end;'
      ''
      'function FGetRound: UInt32;'
      'begin'
      '  Result := 0;'
      'end;'
      ''
      'function FSetRound(NewRound: UInt32): UInt32;'
      'begin'
      '  Result := 0;'
      'end;'
      ''
      
        'function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32 = ' +
        'femALLEXCEPT): UInt32;'
      'begin'
      '  Result := 0;'
      'end;'
      ''
      
        'function FGetExceptMask(ExceptMasks: UInt32 = femALLEXCEPT): UIn' +
        't32;'
      'begin'
      '  Result := 0;'
      'end;'
      ''
      '{$ENDIF WIN32}'
      '{$ELSE  !NEXTGEN}'
      ''
      '{$IF defined(EXTERNALLINKER) }'
      'type'
      '  fexcept_t = Word;'
      '  TExceptionFlags = fexcept_t;'
      '  PExceptionFlags = ^TExceptionFlags;'
      ''
      '{$ENDIF}'
      ''
      
        '{$IF defined(IOS) or (defined(OSX) and defined(EXTERNALLINKER)) ' +
        'or (defined(IOSSIMULATOR) and defined(CPUX64)) }'
      'const'
      '  libmmodulename = '#39'/usr/lib/libSystem.dylib'#39'; // iOS device'
      '  librtlhelpername = '#39'librtlhelper.a'#39';'
      ''
      '//{$IF not (defined(CPUX86) and defined(ASSEMBLER))}'
      
        '//These functions do not exist in iOSSimulator math library. We ' +
        'use two local functions.'
      
        '//function fegetexceptflag(__flagp: PExceptionFlags; __excepts: ' +
        'UInt32): UInt32; cdecl;'
      '//  external libmmodulename name _PU + '#39'fegetexceptflag'#39';'
      '//{$EXTERNALSYM fegetexceptflag}'
      
        '//function fesetexceptflag(__flagp: PExceptionFlags; __excepts: ' +
        'UInt32): UInt32; cdecl;'
      '//  external libmmodulename name _PU + '#39'fesetexceptflag'#39';'
      '//{$EXTERNALSYM fesetexceptflag}'
      '//{$ENDIF not (CPUX86 and ASSEMBLER)}'
      ''
      'function fegetround(): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fegetround'#39';'
      '{$EXTERNALSYM fegetround}'
      
        'function fesetround(__rounding_direction: UInt32): UInt32; cdecl' +
        ';'
      '  external libmmodulename name _PU + '#39'fesetround'#39';'
      '{$EXTERNALSYM fesetround}'
      'function fegetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fegetenv'#39';'
      '{$EXTERNALSYM fegetenv}'
      'function fesetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name _PU + '#39'fesetenv'#39';'
      '{$EXTERNALSYM fesetenv}'
      
        '{$ENDIF IOS or (OSX and EXTERNALLINKER) or (IOSSIMULATOR or CPUX' +
        '64)}'
      ''
      '{$IF Defined(LINUX) and Defined(EXTERNALLINKER)}'
      'const'
      '  libmmodulename = '#39'libm.so'#39'; // Linux 64. Ubuntu'
      
        '  librtlhelpername = {$IFDEF PIC} '#39'librtlhelper_PIC.a'#39' {$ELSE} '#39 +
        'librtlhelper.a'#39' {$ENDIF};'
      ''
      
        'function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetexceptflag'#39';'
      '{$EXTERNALSYM fegetexceptflag}'
      
        'function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl'
      '  external libmmodulename name '#39'fesetexceptflag'#39';'
      '{$EXTERNALSYM fesetexceptflag}'
      'function fegetround(): UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetround'#39';'
      '{$EXTERNALSYM fegetround}'
      
        'function fesetround(__rounding_direction: UInt32): UInt32; cdecl' +
        ';'
      '  external libmmodulename name '#39'fesetround'#39';'
      '{$EXTERNALSYM fesetround}'
      'function fegetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetenv'#39';'
      '{$EXTERNALSYM fegetenv}'
      'function fesetenv(__envp: pointer): UInt32; cdecl;'
      '  external libmmodulename name '#39'fesetenv'#39';'
      '{$EXTERNALSYM fesetenv}'
      ''
      '// GNU extension'
      '//int feenableexcept(int excepts);'
      'function feenableexcept(excepts: UInt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'feenableexcept'#39';'
      '{$EXTERNALSYM feenableexcept}'
      '//int fedisableexcept(int excepts);'
      'function fedisableexcept(excepts: UInt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'fedisableexcept'#39';'
      '{$EXTERNALSYM fedisableexcept}'
      '//int fegetexcept(void);'
      'function fegetexcept: UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetexcept'#39';'
      '{$EXTERNALSYM fegetexcept}'
      ''
      'procedure fpu_init; cdecl;'
      '  external librtlhelpername name '#39'fpu_init'#39';'
      '{$ENDIF Defined(LINUX) and Defined(EXTERNALLINKER)}'
      ''
      
        '{$IF Defined(OSX64) or defined(IOSSIMULATOR) and defined(CPUX64)' +
        '}'
      '// NEXTGEN'
      '//const'
      '//  libmmodulename = '#39'libm.so'#39'; // Linux 64. Ubuntu'
      
        '//  librtlhelpername = {$IFDEF PIC} '#39'librtlhelper_PIC.a'#39' {$ELSE}' +
        ' '#39'librtlhelper.a'#39' {$ENDIF};'
      '//'
      
        'function fegetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'fegetexceptflag'#39';'
      '//{$EXTERNALSYM fegetexceptflag}'
      
        'function fesetexceptflag(__flagp: PExceptionFlags; __excepts: UI' +
        'nt32): UInt32; cdecl;'
      '  external libmmodulename name '#39'fesetexceptflag'#39';'
      '//{$EXTERNALSYM fesetexceptflag}'
      '//function fegetround(): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fegetround'#39';'
      '//{$EXTERNALSYM fegetround}'
      
        '//function fesetround(__rounding_direction: UInt32): UInt32; cde' +
        'cl;'
      '//  external libmmodulename name '#39'fesetround'#39';'
      '//{$EXTERNALSYM fesetround}'
      '//function fegetenv(__envp: pointer): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fegetenv'#39';'
      '//{$EXTERNALSYM fegetenv}'
      '//function fesetenv(__envp: pointer): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fesetenv'#39';'
      '//{$EXTERNALSYM fesetenv}'
      '//'
      '//// GNU extension'
      '////int feenableexcept(int excepts);'
      '//function feenableexcept(excepts: UInt32): UInt32; cdecl;'
      '//  external libmmodulename name '#39'feenableexcept'#39';'
      '//{$EXTERNALSYM feenableexcept}'
      '////int fedisableexcept(int excepts);'
      'function fedisableexcept(excepts: UInt32): UInt32; cdecl;'
      '//  external libmmodulename name '#39'fedisableexcept'#39';'
      '{$EXTERNALSYM fedisableexcept}'
      'begin'
      '                              '
      '  Result := 0;'
      'end;'
      '////int fegetexcept(void);'
      '//function fegetexcept: UInt32; cdecl;'
      '//  external libmmodulename name '#39'fegetexcept'#39';'
      '//{$EXTERNALSYM fegetexcept}'
      ''
      'procedure fpu_init; cdecl;'
      'begin'
      '                              '
      'end;'
      '{$ENDIF OSX64 or (IOSSIMULATOR and CPUX64)}'
      ''
      'procedure FClearExcept;'
      'begin'
      'end;'
      ''
      'procedure FCheckExcept;'
      'begin'
      'end;'
      ''
      
        'function FSetExceptFlag(NewFlags: UInt32; Excepts: UInt32): UInt' +
        '32;'
      '{$IF  defined(CPUX86)}'
      'var'
      '  flags: UInt32;'
      '  FEnv: array[0..27] of byte;'
      'begin'
      '  Excepts := Excepts and feeALLEXCEPT;'
      '  asm'
      '    FNSTENV FEnv'
      '  end;'
      '  flags := FEnv[4] and $3F;'
      '  Result := flags and Excepts;'
      ''
      '  flags := (flags and (not Excepts)) or (NewFlags and Excepts);'
      '  FEnv[4] := flags and $3F;'
      '  asm'
      '    FLDENV FEnv'
      '  end;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWindows)} // DCC64'
      'var'
      '  flags: UInt32;'
      'begin'
      '  Excepts := Excepts and feeALLEXCEPT;'
      ''
      '  flags := GetMXCSR and feeALLEXCEPT;'
      '  Result := flags and Excepts;'
      ''
      '  flags := (flags and (not Excepts)) or (NewFlags and Excepts);'
      '  SetMXCSRExceptionFlag(flags);'
      'end;'
      '{$ELSEIF defined(CPUX64) or defined(CPUARM)}'
      'var'
      '  flags: TExceptionFlags;'
      'begin'
      '  Excepts := Excepts and feeALLEXCEPT;'
      '  flags := FGetExceptFlag(feeALLEXCEPT);'
      '  Result := flags and Excepts;'
      '  flags := (flags and (not Excepts)) or (NewFlags and Excepts);'
      '{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)}'
      '// iOS simulator.'
      '  InternalSetFPUStatusWord(flags);'
      '  SetMXCSRExceptionFlag(flags);'
      '{$ELSEIF defined(CPUX64) and defined(Linux)}'
      '  feSetExceptFlag(@flags, Excepts);'
      '{$ELSE }'
      '  feSetExceptFlag(@flags, Excepts);'
      '{$ENDIF !(IOS and CPUX86 and ASSEMBLER)}'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF !defined(CPUX86) or !defined(CPUX64)}'
      ''
      'function FGetExceptFlag(Excepts: UInt32): UInt32;'
      '{$IF  Defined(CPUX86)}'
      'var'
      '  SW: Word;'
      'begin'
      '  asm'
      '    FSTSW SW'
      '  end;'
      '  Result := SW and Excepts and feeALLEXCEPT;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWindows)} // DCC64'
      'begin'
      '  Result := GetMXCSR and Excepts and feeALLEXCEPT;'
      'end;'
      '{$ELSEIF defined(CPUX64) or defined(CPUARM)}'
      'var'
      '  flags: TExceptionFlags;'
      'begin'
      '  feGetExceptFlag(@flags, Excepts and feeALLEXCEPT);'
      '  Result := flags and feeALLEXCEPT;'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF !defined(CPUX86) or !Defined(CPUX64)}'
      ''
      
        'procedure FRaiseExcept(excepts: UInt32; CheckExceptionMask: Bool' +
        'ean = True);'
      'var'
      '  flags, masks: UInt32;'
      'begin'
      '  if excepts = 0 then Exit;'
      ''
      '  if CheckExceptionMask then'
      '  begin'
      '    masks := FGetExceptMask(ExceptionFlagToMask(excepts));'
      '    if masks <> 0 then'
      '    begin'
      '      flags := ExceptionMaskToFlag(masks);'
      '{$IF Defined(CPUX64)}'
      '      excepts := excepts and not flags;'
      '{$ENDIF}'
      '      FSetExceptFlag(0, flags);'
      '    end;'
      '  end;'
      ''
      '{$IF  Defined(CPUX86)}'
      '  asm'
      '    FWAIT'
      '  end;'
      '{$ELSEIF defined(CPUX64)}'
      '  if excepts <> 0 then'
      '  begin'
      '    if excepts and feeINEXACT <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeINEXACT);'
      '      Error(reInvalidOp);'
      '    end;'
      '    if excepts and feeUNDERFLOW <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeUNDERFLOW);'
      '      Error(reUnderflow);'
      '    end;'
      '    if excepts and feeOVERFLOW <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeOVERFLOW);'
      '      Error(reOverflow);'
      '    end;'
      '    if excepts and feeDIVBYZERO <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeDIVBYZERO);'
      '      Error(reZeroDivide);'
      '    end;'
      '    if excepts and feeINVALID <> 0 then'
      '    begin'
      '      FSetExceptFlag(0, feeINVALID);'
      '      Error(reInvalidOp);'
      '    end;'
      '  end;'
      '{$ENDIF !defined(CPUX86) or !Defined(CPUX64)}'
      'end;'
      ''
      'function FGetRound: UInt32;'
      '{$IF  defined(CPUX86)}'
      'begin'
      '  Result := Get8087CW and ferALLROUND;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWindows)} // DCC64'
      'begin'
      '  Result := GetMXCSR and ferALLROUND;'
      'end;'
      '{$ELSEIF defined(CPUX64) or defined(CPUARM)}'
      'begin'
      '  Result := feGetRound;'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF !defined(CPUX86) or !defined(CPUX64)}'
      ''
      'function FSetRound(NewRound: UInt32): UInt32;'
      '{$IF  defined(CPUX86)}'
      'var'
      '  CtlWord: Word;'
      'begin'
      '  CtlWord := Get8087CW;'
      '  Set8087CW((CtlWord and (not ferALLROUND)) or Word(NewRound));'
      '  Result := UInt32(CtlWord and ferALLROUND);'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWindows)} // DCC64'
      'var'
      '  MXCSR: UInt32;'
      'begin'
      '  MXCSR := GetMXCSR;'
      '  SetMXCSR((MXCSR and (not ferALLROUND)) or NewRound);'
      '  Result := MXCSR and ferALLROUND;'
      'end;'
      '{$ELSEIF defined(CPUX64) or defined(CPUARM)}'
      'begin'
      '  Result:= feGetRound;'
      '  feSetRound(NewRound);'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF !defined(CPUX86) or !Defined(CPUX64)}'
      ''
      '{$IFDEF CPUARM}'
      'threadvar'
      '  FPSCRExceptionEnableBits: UInt32;'
      '{$ENDIF CPUARM}'
      
        '{$IF (defined(CPUX86) or defined(CPUX64)) and not defined(ARITH_' +
        'USE_LIBM)}'
      'threadvar'
      
        '  FPUExceptionMaskBits: UInt32; // for x87 FPU Control word and ' +
        'SSE MXCSR'
      
        '{$ENDIF (defined(CPUX86) or defined(CPUX64)) and defined(ARITH_U' +
        'SE_LIBM)}'
      '{$IF defined(CPUX64) and defined(ARITH_USE_LIBM)} // Linux64'
      'threadvar'
      
        '  FPExceptionMaskBits: UInt32; // for x87 FPU Control word and S' +
        'SE MXCSR'
      '{$ENDIF defined(CPUX64) and defined(ARITH_USE_LIBM)}'
      ''
      
        'function FSetExceptMask(NewMasks: UInt32; ExceptMasks: UInt32): ' +
        'UInt32;'
      '{$IF     defined(CPUARM) and (defined(LINUX) or defined(OSX))}'
      
        '// FPSCR of ARM architecture has "Exception Enable" flag. Cortex' +
        '-A series CPUs'
      
        '// don'#39't have hardware exception capability, but we use same fla' +
        'gs on RTL'#39's thread-local storage.'
      
        '// flag. Although, Get/SetFEnvExceptMask use "MASK" flags like M' +
        'ath.TArithmeticExceptionMask.'
      'var'
      '  CurrentEnableBits: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      
        '  CurrentEnableBits := FPSCRExceptionEnableBits and femALLEXCEPT' +
        ';'
      '  Result := (not CurrentEnableBits) and ExceptMasks;'
      
        '  FPSCRExceptionEnableBits := (CurrentEnableBits and (not Except' +
        'Masks)) or ((not NewMasks) and ExceptMasks);'
      'end;'
      '{$ELSEIF defined(CPUX86)}'
      'var'
      '  CW: Word;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CW := Get8087CW;'
      
        '  Set8087CW((CW and (not ExceptMasks)) or Word(NewMasks and Exce' +
        'ptMasks));'
      '  Result := CW and ExceptMasks;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWindows)} // DCC64'
      'var'
      '  MXCSR: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  MXCSR := GetMXCSR;'
      
        '  SetMXCSR((MXCSR and (not ExceptMasks)) or (NewMasks and Except' +
        'Masks));'
      '  Result := MXCSR and ExceptMasks;'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(Linux) and defined(ARITH_US' +
        'E_LIBM)} // DCCLinux64'
      'var'
      '  CurrentMask: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CurrentMask := FPExceptionMaskBits and femALLEXCEPT;'
      '  Result := CurrentMask and ExceptMasks;'
      
        '  FPExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or ' +
        '(NewMasks and ExceptMasks);'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(OSX) and defined(ARITH_USE_' +
        'LIBM)} // DCCOSX64'
      'var'
      '  CurrentMask: UInt32;'
      'begin'
      '  ExceptMasks := ExceptMasks and femALLEXCEPT;'
      '  CurrentMask := FPExceptionMaskBits and femALLEXCEPT;'
      '  Result := CurrentMask and ExceptMasks;'
      
        '  FPExceptionMaskBits := (CurrentMask and (not ExceptMasks)) or ' +
        '(NewMasks and ExceptMasks);'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF !defined(CPUX86) or !Defined(CPUX64)}'
      ''
      'function FGetExceptMask(ExceptMasks: UInt32): UInt32;'
      '{$IF     defined(CPUARM)}'
      'begin'
      
        '  Result := (not FPSCRExceptionEnableBits) and (ExceptMasks and ' +
        'femALLEXCEPT);'
      'end;'
      '{$ELSEIF defined(CPUX86)}'
      'begin'
      '  Result := Get8087CW and ExceptMasks;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWindows)} // DCC64'
      'begin'
      '  Result := GetMXCSR and ExceptMasks;'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(Linux) and defined(ARITH_US' +
        'E_LIBM)} // Linux64'
      'begin'
      
        '  Result := FPExceptionMaskBits and (ExceptMasks and femALLEXCEP' +
        'T);'
      'end;'
      
        '{$ELSEIF defined(CPUX64) and defined(OSX) and defined(ARITH_USE_' +
        'LIBM)} // OSX64'
      'begin'
      
        '  Result := FPExceptionMaskBits and (ExceptMasks and femALLEXCEP' +
        'T);'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF !defined(CPUX86) or !Defined(CPUX64)}'
      '{$ENDIF !NEXTGEN}'
      ''
      
        '{$IF (defined(CPUX86) or defined(CPUX64)) and not defined(ARITH_' +
        'USE_LIBM)}'
      'procedure Reset8087CW;'
      'begin'
      '  Set8087CW(Default8087CW);'
      'end;'
      ''
      'procedure Set8087CW(NewCW: Word);'
      
        '{$IF defined(CPUX86) and defined(IOS) and defined(ASSEMBLER)} //' +
        ' iOS/Simulator'
      'var'
      '  M: Word;'
      'begin'
      '  Default8087CW := NewCW;'
      '  M := NewCW or $3F; // mask all exceptions'
      '  asm'
      
        '        FNCLEX  // don'#39't raise pending exceptions enabled by the' +
        ' new flags'
      '        FLDCW  M'
      '  end;'
      'end;'
      '{$ELSEIF defined(CPUX86) and defined(ASSEMBLER)} // Win32 or OSX'
      'begin'
      '  Default8087CW := NewCW;'
      '  asm'
      
        '        FNCLEX  // don'#39't raise pending exceptions enabled by the' +
        ' new flags'
      '{$IFDEF PIC}'
      '        MOV     EAX,[EBX].OFFSET Default8087CW'
      '        FLDCW   [EAX]'
      '{$ELSE !PIC}'
      '        FLDCW  Default8087CW'
      '{$ENDIF !PIC}'
      '  end;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)} // Win64'
      'asm'
      '        MOV     Default8087CW, CX'
      
        '        FNCLEX  // don'#39't raise pending exceptions enabled by the' +
        ' new flags'
      '        FLDCW   Default8087CW'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      ''
      'function Get8087CW: Word;'
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      'asm'
      '        PUSH    0'
      '        FNSTCW  [ESP].Word'
      '        POP     EAX'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}'
      'asm'
      '        PUSH    0'
      '        FNSTCW  [RSP].Word'
      '        POP     RAX'
      'end;'
      '{$ELSE }'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      ''
      'procedure ResetMXCSR;'
      'begin'
      '  if TestSSE <> 0 then'
      '    SetMXCSR(DefaultMXCSR);'
      'end;'
      ''
      'procedure SetMXCSR(NewMXCSR: UInt32);'
      
        '{$IF defined(IOS) and defined(CPUX86) and defined(ASSEMBLER)} //' +
        ' iOS Simulator'
      'var'
      '  M: UInt32;'
      'begin'
      
        '  DefaultMXCSR := NewMXCSR and $FFC0;  // Remove status flag bit' +
        's'
      '  M := NewMXCSR or $01F80; // mask all exceptions'
      '  asm'
      '        LDMXCSR M'
      '  end;'
      'end;'
      '{$ELSEIF defined(CPUX86) and defined(ASSEMBLER)}'
      'begin'
      '  if TestSSE = 0 then exit;'
      
        '  DefaultMXCSR := NewMXCSR and $FFC0;  // Remove status flag bit' +
        's'
      '  asm'
      '{$IFDEF PIC}'
      '        MOV     EAX,[EBX].OFFSET DefaultMXCSR'
      '        LDMXCSR [EAX]'
      '{$ELSE !PIC}'
      '        LDMXCSR DefaultMXCSR'
      '{$ENDIF !PIC}'
      '  end;'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}'
      'asm'
      '        AND     ECX, $FFC0 // Remove flag bits'
      '        MOV     DefaultMXCSR, ECX'
      '        LDMXCSR DefaultMXCSR'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      ''
      'procedure SetMXCSRExceptionFlag(NewExceptionFlag: UInt32);'
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      'var'
      '  MXCSR: UInt32;'
      'asm'
      '{$IFDEF PIC}'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EAX, [EAX].OFFSET TestSSE'
      '        CMP     [EAX], 0'
      '        POP     EAX'
      '{$ELSE !PIC}'
      '        CMP     TestSSE, 0'
      '{$ENDIF !PIC}'
      '        JE      @@NOSSE'
      '        STMXCSR MXCSR'
      '        AND     EAX, $003F'
      '        AND     MXCSR, $FFC0'
      '        OR      MXCSR, EAX'
      '        LDMXCSR MXCSR'
      '@@NOSSE:'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}'
      'var'
      '  MXCSR: UInt32;'
      'asm'
      '        STMXCSR MXCSR'
      '        AND     ECX, $003F'
      '        MOV     EDX, MXCSR'
      '        AND     EDX, $FFC0'
      '        OR      EDX, ECX'
      '        MOV     MXCSR, EDX'
      '        LDMXCSR MXCSR'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      ''
      'procedure ClearMXCSRStatus(ExceptionFlag: UInt32);'
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      'var'
      '  MXCSR: UInt32;'
      'asm'
      '{$IFDEF PIC}'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EAX, [EAX].OFFSET TestSSE'
      '        CMP     [EAX], 0'
      '        POP     EAX'
      '{$ELSE !PIC}'
      '        CMP     TestSSE, 0'
      '{$ENDIF !PIC}'
      '        JE      @@NOSSE'
      '        STMXCSR MXCSR'
      '        AND     EAX, $003F'
      '        NOT     EAX'
      '        AND     MXCSR, EAX'
      '        LDMXCSR MXCSR'
      '@@NOSSE:'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}'
      'var'
      '  MXCSR: UInt32;'
      'asm'
      '        STMXCSR MXCSR'
      '        AND     ECX, $003F'
      '        NOT     ECX'
      '        AND     MXCSR, ECX'
      '        LDMXCSR MXCSR'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      ''
      'function GetMXCSR: UInt32;'
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      'asm'
      '{$IFDEF PIC}'
      '        XOR     EAX, EAX'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EAX, [EAX].OFFSET TestSSE'
      '        CMP     [EAX], 0'
      '        POP     EAX'
      '        JE      @@NOSSE'
      '{$ELSE !PIC}'
      '        XOR     EAX, EAX'
      '        CMP     TestSSE, EAX'
      '        JE      @@NOSSE'
      '{$ENDIF !PIC}'
      '        PUSH    EAX'
      '        STMXCSR [ESP].DWord'
      '        POP     EAX'
      '@@NOSSE:'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}'
      'asm'
      '        PUSH    0'
      '        STMXCSR [RSP].DWord'
      '        POP     RAX'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      ''
      
        '{$ENDIF (defined(CPUX86) or defined(CPUX64)) and not defined(ARI' +
        'TH_USE_LIBM)}'
      ''
      ''
      '{$IFDEF CPUARM32}'
      'type'
      '  FENV_ARM32 = record'
      '    fpscr, r0, r1, r3: UInt32;'
      '  end;'
      ''
      'const'
      '  ARM32_FPSCR_MASK     = $FFFF00FF;'
      '  ARM32_EXCEPTION_MASK = $00009F00;'
      ''
      'procedure SetFPSCR(NewFlag: UInt32);'
      'var'
      '  fenv: FENV_ARM32;'
      'begin'
      '  fegetenv(@fenv);'
      '  fenv.fpscr := NewFLag and ARM32_FPSCR_MASK;'
      '  fesetenv(@fenv);'
      '  FPSCRExceptionEnableBits := NewFlag and ARM32_EXCEPTION_MASK;'
      'end;'
      ''
      'function GetFPSCR: UInt32;'
      'var'
      '  fenv: FENV_ARM32;'
      'begin'
      '  fegetenv(@fenv);'
      
        '  Result := fenv.fpscr and ARM32_FPSCR_MASK or FPSCRExceptionEna' +
        'bleBits;'
      'end;'
      '{$ENDIF CPUARM32}'
      ''
      '{$IF defined(CPUARM64) and (defined(IOS64) or defined(OSX64))}'
      'type'
      '  FENV_ARM64 = record'
      '    fpsr, fpcr: UInt64;'
      '  end;'
      ''
      'const'
      '  ARM64_FPSR_MASK      = $F100009F;'
      '  ARM64_FPCR_MASK      = $07C00000;'
      '  ARM64_EXCEPTION_MASK = $00009F00;'
      ''
      'procedure SetFPSCR(NewFlag: UInt32);'
      'var'
      '  fenv: FENV_ARM64;'
      'begin'
      '  fegetenv(@fenv);'
      '  fenv.fpsr := NewFLag and ARM64_FPSR_MASK;'
      '  fenv.fpcr := NewFLag and ARM64_FPCR_MASK;'
      '  fesetenv(@fenv);'
      '  FPSCRExceptionEnableBits := NewFlag and ARM64_EXCEPTION_MASK;'
      'end;'
      ''
      'function GetFPSCR: UInt32;'
      'var'
      '  fenv: FENV_ARM64;'
      'begin'
      '  fegetenv(@fenv);'
      '  Result := (fenv.fpsr and ARM64_FPSR_MASK) or'
      '            (fenv.fpcr and ARM64_FPCR_MASK) or'
      '            FPSCRExceptionEnableBits;'
      'end;'
      '{$ENDIF defined(CPUARM64) and defined(IOS64)}'
      ''
      '{$IF defined(CPUARM64) and defined(ANDROID64)}'
      'type'
      '  FENV_ARM64 = record'
      '    fpsr, fpcr: UInt32;'
      '  end;'
      ''
      'const'
      '  ARM64_FPSR_MASK      = $F800009F;'
      '  ARM64_FPCR_MASK      = $07C80000;'
      '  ARM64_EXCEPTION_MASK = $00009F00;'
      ''
      'procedure SetFPSCR(NewFlag: UInt32);'
      'var'
      '  fenv: FENV_ARM64;'
      'begin'
      '  fegetenv(@fenv);'
      '  fenv.fpsr := NewFLag and ARM64_FPSR_MASK;'
      '  fenv.fpcr := NewFLag and ARM64_FPCR_MASK;'
      '  fesetenv(@fenv);'
      '  FPSCRExceptionEnableBits := NewFlag and ARM64_EXCEPTION_MASK;'
      'end;'
      ''
      'function GetFPSCR: UInt32;'
      'var'
      '  fenv: FENV_ARM64;'
      'begin'
      '  fegetenv(@fenv);'
      '  Result := (fenv.fpsr and ARM64_FPSR_MASK) or'
      '            (fenv.fpcr and ARM64_FPCR_MASK) or'
      '            FPSCRExceptionEnableBits;'
      'end;'
      '{$ENDIF defined(CPUARM64) and defined(ANDROID64)}'
      ''
      '{$IF defined(CPUARM64) and defined(LINUX64)}'
      'type'
      '  FENV_ARM64 = record'
      '    fpsr, fpcr: UInt32;'
      '  end;'
      ''
      'const'
      '  ARM64_FPSR_MASK      = $F800009F;'
      '  ARM64_FPCR_MASK      = $07C80000;'
      '  ARM64_EXCEPTION_MASK = $00009F00;'
      ''
      'procedure SetFPSCR(NewFlag: UInt32);'
      'var'
      '  fenv: FENV_ARM64;'
      'begin'
      '  fegetenv(@fenv);'
      '  fenv.fpsr := NewFLag and ARM64_FPSR_MASK;'
      '  fenv.fpcr := NewFLag and ARM64_FPCR_MASK;'
      '  fesetenv(@fenv);'
      '  FPSCRExceptionEnableBits := NewFlag and ARM64_EXCEPTION_MASK;'
      'end;'
      ''
      'function GetFPSCR: UInt32;'
      'var'
      '  fenv: FENV_ARM64;'
      'begin'
      '  fegetenv(@fenv);'
      '  Result := (fenv.fpsr and ARM64_FPSR_MASK) or'
      '            (fenv.fpcr and ARM64_FPCR_MASK) or'
      '            FPSCRExceptionEnableBits;'
      'end;'
      '{$ENDIF defined(CPUARM64) and defined(LINUX64)}'
      ''
      '{ TSingleRec }'
      ''
      'function TSingleRec.InternalGetBytes(Index: Cardinal): UInt8;'
      'type'
      '  PByteArray = ^TByteArray;'
      '  TByteArray = array[0..32767] of Byte;'
      'begin'
      '  Result := PByteArray(@Self)[Index];'
      'end;'
      ''
      'function TSingleRec.InternalGetWords(Index: Cardinal): UInt16;'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'begin'
      '  Result := PWordArray(@Self)[Index];'
      'end;'
      ''
      
        'procedure TSingleRec.InternalSetBytes(Index: Cardinal; const Val' +
        'ue: UInt8);'
      'type'
      '  PByteArray = ^TByteArray;'
      '  TByteArray = array[0..32767] of Byte;'
      'begin'
      '  PByteArray(@Self)[Index] := Value;'
      'end;'
      ''
      
        'procedure TSingleRec.InternalSetWords(Index: Cardinal; const Val' +
        'ue: UInt16);'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'begin'
      '  PWordArray(@Self)[Index] := Value;'
      'end;'
      ''
      'function TSingleRec.GetBytes(Index: Cardinal): UInt8;'
      'begin'
      '  if Index >= 4 then Error(reRangeError);'
      '  Result := InternalGetBytes(Index);'
      'end;'
      ''
      'function TSingleRec.GetWords(Index: Cardinal): UInt16;'
      'begin'
      '  if Index >= 2 then Error(reRangeError);'
      '  Result := InternalGetWords(Index);'
      'end;'
      ''
      
        'procedure TSingleRec.SetBytes(Index: Cardinal; const Value: UInt' +
        '8);'
      'begin'
      '  if Index >= 4 then Error(reRangeError);'
      '  InternalSetBytes(Index, Value);'
      'end;'
      ''
      
        'procedure TSingleRec.SetWords(Index: Cardinal; const Value: UInt' +
        '16);'
      'begin'
      '  if Index >= 2 then Error(reRangeError);'
      '  InternalSetWords(Index, Value);'
      'end;'
      ''
      'function TSingleRec.GetSign: Boolean;'
      'begin'
      '  Result := InternalGetBytes(3) >= $80;'
      'end;'
      ''
      'procedure TSingleRec.SetSign(NewSign: Boolean);'
      'var'
      '  B: Byte;'
      'begin'
      '  B := InternalGetBytes(3);'
      '  if NewSign then B := B or $80'
      '  else            B := B and $7F;'
      '  InternalSetBytes(3, B);'
      'end;'
      ''
      'function TSingleRec.GetExp: UInt64;'
      'begin'
      '  Result := (InternalGetWords(1) shr 7) and $FF;'
      'end;'
      ''
      'procedure TSingleRec.SetExp(NewExp: UInt64);'
      'var'
      '  W: Word;'
      'begin'
      '  W := InternalGetWords(1);'
      '  W := (W and $807F) or ((NewExp and $FF) shl 7);'
      '  InternalSetWords(1, W);'
      'end;'
      ''
      'function TSingleRec.GetFrac: UInt64;'
      'begin'
      '  Result := PUInt32(@Self)^ and $007FFFFF;'
      'end;'
      ''
      'procedure TSingleRec.SetFrac(NewFrac: UInt64);'
      'var'
      '  LW: UInt32;'
      'begin'
      '  LW := PUInt32(@Self)^;'
      '  LW := (LW and $FF800000) or (NewFrac and $007FFFFF);'
      '  PUInt32(@Self)^ := LW;'
      'end;'
      ''
      'function TSingleRec.Fraction: Extended;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  if E = $FF then'
      '  begin'
      '    if F = 0 then // +/- INF.'
      '      Result := cInfinity'
      '    else // NaN'
      '      Result := cNan;'
      '  end'
      '  else if E = 0 then'
      '    Result := (F / $00800000)'
      '  else'
      '    Result := 1.0 + (F / $00800000);'
      'end;'
      ''
      'function TSingleRec.Mantissa: UInt64;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  Result := F;'
      '  if (0 < E) and (E < $FF) then'
      '    Result := Result or (UInt64(1) shl 23);'
      'end;'
      ''
      'function TSingleRec.Exponent: Integer;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  if (0 < E) and (E < $FF) then'
      '    Result := E - $7F'
      '  else if (E = 0) and (F <> 0) then'
      '    Result := -126 // Denormal'
      '  else if (E = 0) and (F = 0) then'
      '    Result := 0 // +/-Zero'
      '  else'
      '    Result := 0; // +/-INF, NaN'
      'end;'
      ''
      'function TSingleRec.SpecialType: TFloatSpecial;'
      'var'
      '  I: UInt32;'
      '  W: Word;'
      'begin'
      '  I := PUInt32(@Self)^;'
      '  W := InternalGetWords(1);'
      ''
      '  if ($0080 <= W) and (W <= $7F7F) then'
      '    Result := TFloatSpecial.fsPositive'
      '  else if ($8080 <= W) and (W <= $FF7F) then'
      '    Result := TFloatSpecial.fsNegative'
      '  else if I = 0 then'
      '    Result := TFloatSpecial.fsZero'
      '  else if I = $80000000 then'
      '    Result := TFloatSpecial.fsNZero'
      '  else if w <= $007F then'
      '    Result := TFloatSpecial.fsDenormal'
      '  else if ($8000 <= w) and (w <= $807F) then'
      '    Result := TFloatSpecial.fsNDenormal'
      '  else if I = $7F800000 then'
      '    Result := TFloatSpecial.fsInf'
      '  else if I = $FF800000 then'
      '    Result := TFloatSpecial.fsNInf'
      '  else'
      '    Result := TFloatSpecial.fsNan;'
      'end;'
      ''
      
        'procedure TSingleRec.BuildUp(const SignFlag: Boolean; const Mant' +
        'issa: UInt64; const Exponent: Integer);'
      'begin'
      '  aSingle := 0.0;'
      '  Sign := SignFlag;'
      '  Exp := Exponent + $7F;'
      '  Frac := Mantissa and $007FFFFF;'
      'end;'
      ''
      'class operator TSingleRec.Explicit(a: Extended): TSingleRec;'
      'begin'
      '  Result.aSingle := a;'
      'end;'
      ''
      'class operator TSingleRec.Explicit(a: TSingleRec): Extended;'
      'begin'
      '  Result := a.aSingle;'
      'end;'
      ''
      '{ TDoubleRec }'
      ''
      'function TDoubleRec.InternalGetBytes(Index: Cardinal): UInt8;'
      'type'
      '  PByteArray = ^TByteArray;'
      '  TByteArray = array[0..32767] of Byte;'
      'begin'
      '  Result := PByteArray(@Self)[Index];'
      'end;'
      ''
      'function TDoubleRec.InternalGetWords(Index: Cardinal): UInt16;'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'begin'
      '  Result := PWordArray(@Self)[Index];'
      'end;'
      ''
      
        'procedure TDoubleRec.InternalSetBytes(Index: Cardinal; const Val' +
        'ue: UInt8);'
      'type'
      '  PByteArray = ^TByteArray;'
      '  TByteArray = array[0..32767] of Byte;'
      'begin'
      '  PByteArray(@Self)[Index] := Value;'
      'end;'
      ''
      
        'procedure TDoubleRec.InternalSetWords(Index: Cardinal; const Val' +
        'ue: UInt16);'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'begin'
      '  PWordArray(@Self)[Index] := Value;'
      'end;'
      ''
      'function TDoubleRec.GetBytes(Index: Cardinal): UInt8;'
      'begin'
      '  if Index >= 8 then System.Error(reRangeError);'
      '  Result := InternalGetBytes(Index);'
      'end;'
      ''
      'function TDoubleRec.GetWords(Index: Cardinal): UInt16;'
      'begin'
      '  if Index >= 4 then System.Error(reRangeError);'
      '  Result := InternalGetWords(Index);'
      'end;'
      ''
      
        'procedure TDoubleRec.SetBytes(Index: Cardinal; const Value: UInt' +
        '8);'
      'begin'
      '  if Index >= 8 then Error(reRangeError);'
      '  InternalSetBytes(Index, Value);'
      'end;'
      ''
      
        'procedure TDoubleRec.SetWords(Index: Cardinal; const Value: UInt' +
        '16);'
      'begin'
      '  if Index >= 4 then Error(reRangeError);'
      '  InternalSetWords(Index, Value);'
      'end;'
      ''
      'function TDoubleRec.GetSign: Boolean;'
      'begin'
      '  Result := InternalGetBytes(7) >= $80;'
      'end;'
      ''
      'procedure TDoubleRec.SetSign(NewSign: Boolean);'
      'var'
      '  B: Byte;'
      'begin'
      '  B := InternalGetBytes(7);'
      '  if NewSign then B := B or $80'
      '  else            B := B and $7F;'
      '  InternalSetBytes(7, B);'
      'end;'
      ''
      'function TDoubleRec.GetExp: UInt64;'
      'begin'
      '  Result := (InternalGetWords(3) shr 4) and $7FF;'
      'end;'
      ''
      'procedure TDoubleRec.SetExp(NewExp: UInt64);'
      'var'
      '  W: Word;'
      'begin'
      '  W := InternalGetWords(3);'
      '  W := (W and $800F) or ((NewExp and $7FF) shl 4);'
      '  InternalSetWords(3, W);'
      'end;'
      ''
      'function TDoubleRec.GetFrac: UInt64;'
      'begin'
      '  Result := PUInt64(@Self)^ and $000FFFFFFFFFFFFF;'
      'end;'
      ''
      'procedure TDoubleRec.SetFrac(NewFrac: UInt64);'
      'var'
      '  U64: UInt64;'
      'begin'
      '  U64 := PUInt64(@Self)^;'
      
        '  U64 := (U64 and $FFF0000000000000) or (NewFrac and $000FFFFFFF' +
        'FFFFFF);'
      '  PUInt64(@aDouble)^ := U64;'
      'end;'
      ''
      'function TDoubleRec.Fraction: Extended;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  if E = $7FF then'
      '  begin'
      '    if F = 0 then // +/- INF.'
      '      Result := cInfinity'
      '    else // NaN'
      '      Result := cNan;'
      '  end'
      '  else if E = 0 then'
      '    Result := (F / $0010000000000000)'
      '  else'
      '    Result := 1.0 + (F / $0010000000000000);'
      'end;'
      ''
      'function TDoubleRec.Mantissa: UInt64;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  Result := F;'
      '  if (0 < E) and (E < $7FF) then'
      '    Result := Result or (UInt64(1) shl 52);'
      'end;'
      ''
      'function TDoubleRec.Exponent: Integer;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  if (0 < E) and (E < $7FF) then'
      '    Result := E - $3FF'
      '  else if (E = 0) and (F <> 0) then'
      '    Result := -1022 // Denormal'
      '  else if (E = 0) and (F = 0) then'
      '    Result := 0 // +/-Zero'
      '  else'
      '    Result := 0; // +/-INF, NaN'
      'end;'
      ''
      'function TDoubleRec.SpecialType: TFloatSpecial;'
      'var'
      '  U64: UInt64;'
      '  W: Word;'
      'begin'
      '  U64 := PUInt64(@Self)^;'
      '  W := InternalGetWOrds(3);'
      ''
      '  if ($0010 <= W) and (W <= $7FEF) then'
      '    Result := TFloatSpecial.fsPositive'
      '  else if ($8010 <= W) and (W <= $FFEF) then'
      '    Result := TFloatSpecial.fsNegative'
      '  else if U64 = 0 then'
      '    Result := TFloatSpecial.fsZero'
      '  else if U64 = $8000000000000000 then'
      '    Result := TFloatSpecial.fsNZero'
      '  else if w <= $000F then'
      '    Result := TFloatSpecial.fsDenormal'
      '  else if ($8000 <= w) and (w <= $800F) then'
      '    Result := TFloatSpecial.fsNDenormal'
      '  else if U64 = $7FF0000000000000 then'
      '    Result := TFloatSpecial.fsInf'
      '  else if U64 = $FFF0000000000000 then'
      '    Result := TFloatSpecial.fsNInf'
      '  else'
      '    Result := TFloatSpecial.fsNan;'
      'end;'
      ''
      
        'procedure TDoubleRec.BuildUp(const SignFlag: Boolean; const Mant' +
        'issa: UInt64; const Exponent: Integer);'
      'begin'
      '  aDouble := 0.0;'
      '  SetSign(SignFlag);'
      '  SetExp(Exponent + $3FF);'
      '  SetFrac(Mantissa and $000FFFFFFFFFFFFF);'
      'end;'
      ''
      'class operator TDoubleRec.Explicit(a: Extended): TDoubleRec;'
      'begin'
      '  Result.aDouble := a;'
      'end;'
      ''
      'class operator TDoubleRec.Explicit(a: TDoubleRec): Extended;'
      'begin'
      '  Result := a.aDouble;'
      'end;'
      ''
      '{ TExtended80Rec }'
      ''
      
        'function TExtended80Rec.InternalGetBytes(Index: Cardinal): UInt8' +
        ';'
      'type'
      '  PByteArray = ^TByteArray;'
      '  TByteArray = array[0..32767] of Byte;'
      'begin'
      '  Result := PByteArray(@Self)[Index];'
      'end;'
      ''
      
        'function TExtended80Rec.InternalGetWords(Index: Cardinal): UInt1' +
        '6;'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'begin'
      '  Result := PWordArray(@Self)[Index];'
      'end;'
      ''
      
        'procedure TExtended80Rec.InternalSetBytes(Index: Cardinal; const' +
        ' Value: UInt8);'
      'type'
      '  PByteArray = ^TByteArray;'
      '  TByteArray = array[0..32767] of Byte;'
      'begin'
      '  PByteArray(@Self)[Index] := Value;'
      'end;'
      ''
      
        'procedure TExtended80Rec.InternalSetWords(Index: Cardinal; const' +
        ' Value: UInt16);'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'begin'
      '  PWordArray(@Self)[Index] := Value;'
      'end;'
      ''
      'function TExtended80Rec.GetBytes(Index: Cardinal): UInt8;'
      'begin'
      '  if Index >= 10 then System.Error(reRangeError);'
      '  Result := InternalGetBytes(Index);'
      'end;'
      ''
      'function TExtended80Rec.GetWords(Index: Cardinal): UInt16;'
      'begin'
      '  if Index >= 5 then System.Error(reRangeError);'
      '  Result := InternalGetWords(Index);'
      'end;'
      ''
      
        'procedure TExtended80Rec.SetBytes(Index: Cardinal; const Value: ' +
        'UInt8);'
      'begin'
      '  if Index >= 10 then System.Error(reRangeError);'
      '  InternalSetBytes(Index, Value);'
      'end;'
      ''
      
        'procedure TExtended80Rec.SetWords(Index: Cardinal; const Value: ' +
        'UInt16);'
      'begin'
      '  if Index >= 5 then System.Error(reRangeError);'
      '  InternalSetWords(Index, Value);'
      'end;'
      ''
      'function TExtended80Rec.GetSign: Boolean;'
      'begin'
      '  Result := InternalGetBytes(9) >= $80;'
      'end;'
      ''
      'procedure TExtended80Rec.SetSign(NewSign: Boolean);'
      'var'
      '  B: Byte;'
      'begin'
      '  B := InternalGetBytes(9);'
      '  if NewSign then B := B or $80'
      '  else            B := B and $7F;'
      '  InternalSetBytes(9, B);'
      'end;'
      ''
      'function TExtended80Rec.Get_Exp: UInt64;'
      'begin'
      '  Result := InternalGetWords(4);'
      'end;'
      ''
      'function TExtended80Rec.GetExp: UInt64;'
      'begin'
      '  Result := InternalGetWords(4) and $7FFF;'
      'end;'
      ''
      'procedure TExtended80Rec.Set_Exp(NewExp: UInt64);'
      'begin'
      '  InternalSetWords(4, NewExp);'
      'end;'
      ''
      'procedure TExtended80Rec.SetExp(NewExp: UInt64);'
      'var'
      '  W: Word;'
      'begin'
      '  W := InternalGetWords(4);'
      '  W := (W and $8000) or (NewExp and $7FFF);'
      '  InternalSetWords(4, W);'
      'end;'
      ''
      'function TExtended80Rec.GetFrac: UInt64;'
      'begin'
      '{$IFDEF EXTENDEDIS10BYTES}'
      '  Result := PUInt64(@Self)^; // first 4 bytes are fraction part.'
      '{$ELSE  EXTENDEDIS10BYTES}'
      '  Result := aExtended80Frac;'
      '{$ENDIF EXTENDEDIS10BYTES}'
      'end;'
      ''
      'procedure TExtended80Rec.SetFrac(NewFrac: UInt64);'
      'begin'
      '{$IFDEF EXTENDEDIS10BYTES}'
      '  PUInt64(@Self)^ := NewFrac;'
      '{$ELSE  EXTENDEDIS10BYTES}'
      '  aExtended80Frac := NewFrac;'
      '{$ENDIF EXTENDEDIS10BYTES}'
      'end;'
      ''
      'function TExtended80Rec.Fraction: Extended;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  if E = $7FFF then'
      '  begin'
      '    if F = $8000000000000000 then // +/- INF.'
      '      Result := cInfinity'
      '    else // NaN'
      '      Result := cNan;'
      '  end'
      '  else'
      '    Result := F / 9223372036854775808.0; // 2^63'
      'end;'
      ''
      'function TExtended80Rec.Mantissa: UInt64;'
      'begin'
      '  Result := GetFrac;'
      'end;'
      ''
      'function TExtended80Rec.Exponent: Integer;'
      'var'
      '  E, F: UInt64;'
      'begin'
      '  E := GetExp;'
      '  F := GetFrac;'
      '  if (0 < E) and (E < $7FFF) then'
      '    Result := E - $3FFF'
      '  else if (E = 0) and (F <> 0) then'
      '    Result := -16382 // Denormal'
      '  else if (E = 0) and (F = 0) then'
      '    Result := 0 // +/-Zero'
      '  else'
      '    Result := 0; // +/-INF, NaN'
      'end;'
      ''
      'function TExtended80Rec.SpecialType: TFloatSpecial;'
      'var'
      '  I: UInt64;'
      '  W: Word;'
      'begin'
      '  I := Frac;'
      '  W := InternalGetWords(4);'
      ''
      '  if ($0001 <= W) and (W <= $7FFE) then'
      '    Result := TFloatSpecial.fsPositive'
      '  else if ($8001 <= W) and (W <= $FFFE) then'
      '    Result := TFloatSpecial.fsNegative'
      '  else if (I = 0) and (W = 0) then'
      '    Result := TFloatSpecial.fsZero'
      '  else if (I = 0) and (W = $8000) then'
      '    Result := TFloatSpecial.fsNZero'
      '  else if w = $0000 then'
      '    Result := TFloatSpecial.fsDenormal'
      '  else if w = $8000 then'
      '    Result := TFloatSpecial.fsNDenormal'
      '  else if (I = $8000000000000000) and (W = $7FFF) then'
      '    Result := TFloatSpecial.fsInf'
      '  else if (I = $8000000000000000) and (W = $FFFF)then'
      '    Result := TFloatSpecial.fsNInf'
      '  else'
      '    Result := TFloatSpecial.fsNan;'
      'end;'
      ''
      
        'procedure TExtended80Rec.BuildUp(const SignFlag: Boolean; const ' +
        'Mantissa: UInt64; const Exponent: Integer);'
      'begin'
      '{$IFDEF EXTENDEDIS10BYTES}'
      '  aExtended80 := 0.0;'
      '{$ELSE  EXTENDEDIS10BYTES}'
      '  aExtended80Frac := 0;'
      '  aExtended80Exp :=  0;'
      '{$ENDIF EXTENDEDIS10BYTES}'
      '  Sign := SignFlag;'
      '  Exp := Exponent + $3FFF;'
      '  Frac := Mantissa;'
      'end;'
      ''
      
        'class operator TExtended80Rec.Explicit(a: Extended): TExtended80' +
        'Rec;'
      '{$IFDEF EXTENDEDIS10BYTES}'
      'begin'
      '  Result.aExtended80 := a;'
      'end;'
      '{$ELSEIF defined(EXTENDEDHAS10BYTES)}'
      'begin'
      
        '  Result := PExtended80Rec(@a)^; // value is stored in first 80 ' +
        'bits'
      'end;'
      '{$ELSE  !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}'
      'var'
      '  U: UInt64;'
      '  E: Integer;'
      'begin'
      '  case PDoubleRec(@a).SpecialType of'
      '    fsNInf,'
      '    fsInf:'
      
        '      Result.BuildUp( PDoubleRec(@a).Sign, $8000000000000000, $4' +
        '000);'
      '    fsNZero,'
      '    fsZero:'
      '      Result.BuildUp( PDoubleRec(@a).Sign, 0, -16383);'
      '    fsNDenormal,'
      '    fsDenormal:'
      '      begin'
      '        U := PDoubleRec(@a).Frac; // 52bits fraction'
      '        U := U shl (64-53);'
      '        E := -1022;'
      '        while (U and $8000000000000000) = 0 do'
      '        begin'
      '          U := U * 2;'
      '          Dec(E);'
      '        end;'
      
        '        PExtended80Rec(@Result).BuildUp( PDoubleRec(@a).Sign, U,' +
        ' E);'
      '      end;'
      '    fsNegative,'
      '    fsPositive:'
      
        '      Result.BuildUp( TDoubleRec(a).Sign, TDoubleRec(a).Mantissa' +
        ' shl (64-53), TDoubleRec(a).Exponent);'
      '    fsNaN:'
      '      Result.BuildUp( True, $C000000000000000, $4000);'
      '  end;'
      'end;'
      '{$ENDIF !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}'
      ''
      
        'class operator TExtended80Rec.Explicit(a: TExtended80Rec): Exten' +
        'ded;'
      '{$IFDEF EXTENDEDIS10BYTES}'
      'begin'
      '  Result := a.aExtended80;'
      'end;'
      '{$ELSEIF defined(EXTENDEDHAS10BYTES)}'
      'begin'
      '  Result := PExtended(@a)^; // value is stored in first 80 bits'
      'end;'
      '{$ELSE  !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}'
      'var'
      '  T: Double;'
      'begin'
      '  case a.SpecialType of'
      '    fsNInf,'
      '    fsInf:'
      '      PDoubleRec(@Result).BuildUp( a.Sign, 0, $400);'
      '    fsNZero,'
      '    fsZero:'
      '      PDoubleRec(@Result).BuildUp( a.Sign, 0, -1023);'
      '    fsNDenormal,'
      '    fsDenormal:'
      '      PDoubleRec(@Result).BuildUp( a.Sign, 0, -1023);'
      '    fsNegative,'
      '    fsPositive:'
      '      begin'
      '        if a.Exponent > 1023 then'
      '        begin'
      '          FRaiseExcept(feeOVERFLOW);'
      '          if a.Sign then Result := cNInfinity'
      '          else Result := cInfinity;'
      '        end'
      '        else if a.Exponent < -(1023 + 52) then'
      '          PDoubleRec(@Result).BuildUp( a.Sign, 0, -1023)'
      '        else if a.Exponent < -1022 then'
      '        begin'
      '          // Result := Minimum normalized Double number.'
      
        '          PDoubleRec(@Result).BuildUp( a.Sign, $10000000000000, ' +
        '-1022);'
      '          // Exteneded80Rec.Mantissa has 64bit integer.'
      
        '          Result := Result * (a.Mantissa / 9223372036854775808.0' +
        '); // 2 ^ 63;'
      
        '          PDoubleRec(@T).BuildUp( False, $10000000000000, a.Expo' +
        'nent + 1022);'
      '          Result := Result * T;'
      '        end'
      '        else'
      '        begin'
      
        '          PDoubleRec(@Result).BuildUp( a.Sign, $10000000000000, ' +
        'a.Exponent);'
      
        '          Result := Result * (a.Mantissa / 9223372036854775808.0' +
        '); // 2 ^ 63;'
      '        end;'
      '      end;'
      '    fsNaN:'
      '      PDoubleRec(@Result).BuildUp( True, $8000000000000, $400);'
      '  end;'
      'end;'
      '{$ENDIF !EXTENDEDIS10BYTES and !EXTENDEDHAS10BYTES}'
      ''
      '{ TGUID }'
      ''
      'class operator TGUID.Equal(const Left, Right: TGUID): Boolean;'
      '{$IFDEF CPU64BITS}'
      'var'
      '  a, b: PInt64Array;'
      'begin'
      '  a := PInt64Array(@Left);'
      '  b := PInt64Array(@Right);'
      '  Result := (a^[0] = b^[0]) and (a^[1] = b^[1]);'
      'end;'
      '{$ELSE !CPU64BITS}'
      'var'
      '  a, b: PIntegerArray;'
      'begin'
      '  a := PIntegerArray(@Left);'
      '  b := PIntegerArray(@Right);'
      
        '  Result := (a^[0] = b^[0]) and (a^[1] = b^[1]) and (a^[2] = b^[' +
        '2]) and (a^[3] = b^[3]);'
      'end;'
      '{$ENDIF !CPU64BITS}'
      ''
      
        'class operator TGUID.NotEqual(const Left, Right: TGUID): Boolean' +
        ';'
      'begin'
      '  Result := not (Left = Right);'
      'end;'
      ''
      
        'class function TGUID.Create(const Data; BigEndian: Boolean): TGU' +
        'ID;'
      'begin'
      '  Result := PGuid(@Data)^;'
      '  if BigEndian then'
      '  begin'
      
        '    Result.D1 := (Swap(Word(Result.D1)) shl 16) or Swap(Word(Res' +
        'ult.D1 shr 16));'
      '    Result.D2 := Swap(Result.D2);'
      '    Result.D3 := Swap(Result.D3);'
      '  end;'
      'end;'
      ''
      
        'class function TGUID.Create(const Data: array of Byte; AStartInd' +
        'ex: Cardinal; BigEndian: Boolean): TGUID;'
      'begin'
      '  if Length(Data) < Integer(16 + AStartIndex) then'
      '    Result := TGUID.Empty'
      '  else'
      '    Result := TGUID.Create(Data[AStartIndex], BigEndian);'
      'end;'
      ''
      'class function TGUID.Empty: TGUID;'
      'begin'
      '  FillChar(Result, Sizeof(Result), 0);'
      'end;'
      ''
      'function TGUID.IsEmpty: Boolean;'
      '{$IFDEF CPU64BITS}'
      'var'
      '  a: PInt64Array;'
      'begin'
      '  a := PInt64Array(@Self);'
      '  Result := (a^[0] = 0) and (a^[1] = 0);'
      'end;'
      '{$ELSE !CPU64BITS}'
      'var'
      '  a: PIntegerArray;'
      'begin'
      '  a := PIntegerArray(@Self);'
      
        '  Result := (a^[0] = 0) and (a^[1] = 0) and (a^[2] = 0) and (a^[' +
        '3] = 0);'
      'end;'
      '{$ENDIF !CPU64BITS}'
      ''
      '{ StoredAttribute }'
      ''
      'constructor StoredAttribute.Create;'
      'begin'
      '  inherited Create;'
      '  FFlag := True;'
      '  _FName := '#39#39';'
      'end;'
      ''
      
        'constructor StoredAttribute.Create(const StorageHandlerFlag: Boo' +
        'lean);'
      'begin'
      '  inherited Create;'
      '  FFlag := StorageHandlerFlag;'
      '  _FName := '#39#39';'
      'end;'
      ''
      
        'constructor StoredAttribute.Create(const StorageHandlerName: str' +
        'ing);'
      'begin'
      '  inherited Create;'
      '  FFlag := True;'
      '  _FName := StorageHandlerName;'
      'end;'
      ''
      '{ HPPGENAttribute }'
      ''
      'constructor HPPGENAttribute.Create(const AData : string);'
      'begin'
      'end;'
      ''
      
        'constructor HPPGENAttribute.Create(const AFlag: Integer; const A' +
        'Data : string);'
      'begin'
      'end;'
      ''
      '{ HFAAttribute }'
      ''
      
        'constructor HFAAttribute.Create(const ElementType: Pointer; cons' +
        't ElementCount: Integer);'
      'begin'
      '  inherited Create;'
      '  FElementType := ElementType;'
      '  FElementCount := ElementCount;'
      'end;'
      ''
      '{ AlignAttribute }'
      'constructor AlignAttribute.Create(Align: Integer);'
      'begin'
      '  inherited Create;'
      '  FAlign := Align;'
      'end;'
      ''
      '{$IF     defined(ARITH_PUREPASCAL_EXT80)}'
      'function Int(const X: Extended): Extended;'
      'const'
      '  aTruncationLimit : Extended = 9223372036854775808.0;'
      'begin'
      '  if (X >= aTruncationLimit)or(X <= -aTruncationLimit) then'
      '    Result := X'
      '  else'
      '  begin'
      '    FClearExcept;'
      '    Result := Trunc(X);'
      '    FCheckExcept;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64)}'
      'function Int(const X: Double): Double;'
      'const'
      
        '  aTruncationLimit : Double =  4503599627370496; // $43300000000' +
        '00000'
      'begin'
      '  if (X >= aTruncationLimit) or (X <= -aTruncationLimit) then'
      '    Result := X'
      '  else'
      '  begin'
      '    FClearExcept;'
      '    Result := Trunc(X);'
      '    FCheckExcept;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      'function Int(const X: Double): Double;'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'begin'
      
        '  // 2^52 = $4330000000000000. The number larger than 2^52 has n' +
        'o fraction part.'
      '  if (PWordArray(@X)[3] and $7FF0) >= $4330 then'
      '    Result := X'
      '  else'
      '  begin'
      '    FClearExcept;'
      '    Result := Trunc(X);'
      '    FCheckExcept;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function Int(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        SUB     ESP,4'
      '        FNSTCW  [ESP].Word     // save'
      '        FNSTCW  [ESP+2].Word   // scratch'
      '        FWAIT'
      
        '        OR      [ESP+2].Word, $0F00  // trunc toward zero, full ' +
        'precision'
      '        FLDCW   [ESP+2].Word'
      '        FRNDINT'
      '        FWAIT'
      '        FLDCW   [ESP].Word'
      '        ADD     ESP,4'
      '        FSTP    tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        SUB     ESP,4'
      '        FNSTCW  [ESP].Word     // save'
      '        FNSTCW  [ESP+2].Word   // scratch'
      '        FWAIT'
      
        '        OR      [ESP+2].Word, $0F00  // trunc toward zero, full ' +
        'precision'
      '        FLDCW   [ESP+2].Word'
      '        FRNDINT'
      '        FWAIT'
      '        FLDCW   [ESP].Word'
      '        ADD     ESP,4'
      'end;'
      '{$ENDIF}'
      '{$ELSEIF defined(ARITH_X64_SSE)}'
      'function Int(const X: Double): Double;'
      'asm'
      '        .NOFRAME'
      '        MOVSD     [RSP+$08], XMM0'
      '        MOV       EAX, [RSP+$0C]'
      '        AND       EAX, $7FF00000'
      '        CMP       EAX, $43300000'
      '        JGE       @@EXIT'
      '        CMP       EAX, $3FE00000'
      '        JBE       @@LOW'
      '        CVTTSD2SI RAX, XMM0'
      '        CVTSI2SD  XMM0, RAX'
      '        JMP       @@EXIT'
      '@@LOW:'
      '        XORPD     XMM0, XMM0'
      '@@EXIT:'
      'end;'
      '{$ENDIF }'
      ''
      '{$IF     defined(ARITH_PUREPASCAL_EXT80)}'
      'function Frac(const X: Extended): Extended;'
      'begin'
      '  Result := X - Int(X);'
      'end;'
      '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or'
      '         defined(ARITH_USE_LIBM)}'
      'function Frac(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  Result := X - Int(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function Frac(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        FLD     ST(0)'
      '        SUB     ESP,4'
      '        FNSTCW  [ESP].Word     // save'
      '        FNSTCW  [ESP+2].Word   // scratch'
      '        FWAIT'
      
        '        OR      [ESP+2].Word, $0F00  // trunc toward zero, full ' +
        'precision'
      '        FLDCW   [ESP+2].Word'
      '        FRNDINT'
      '        FWAIT'
      '        FLDCW   [ESP].Word'
      '        ADD     ESP,4'
      '        FSUB'
      '        FSTP    tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FLD     ST(0)'
      '        SUB     ESP,4'
      '        FNSTCW  [ESP].Word     // save'
      '        FNSTCW  [ESP+2].Word   // scratch'
      '        FWAIT'
      
        '        OR      [ESP+2].Word, $0F00  // trunc toward zero, full ' +
        'precision'
      '        FLDCW   [ESP+2].Word'
      '        FRNDINT'
      '        FWAIT'
      '        FLDCW   [ESP].Word'
      '        ADD     ESP,4'
      '        FSUB'
      'end;'
      '{$ENDIF}'
      '{$ELSEIF defined(ARITH_X64_SSE)}'
      'function Frac(const X: Double): Double;'
      'asm'
      '        .NOFRAME'
      '        MOVSD     [RSP+$08], XMM0'
      '        MOV       EAX, [RSP+$0C]'
      '        AND       EAX, $7FF00000'
      '        CMP       EAX, $43300000'
      '        JGE       @@HIGH'
      '        CMP       EAX, $3FE00000'
      '        JBE       @@EXIT'
      '        CVTTSD2SI RAX, XMM0'
      '        CVTSI2SD  XMM4, RAX'
      '        SUBSD     XMM0, XMM4'
      '        JMP       @@EXIT'
      '@@HIGH:'
      '        XORPD     XMM0, XMM0'
      '@@EXIT:'
      'end;'
      '{$ENDIF }'
      ''
      '{$IF defined(CPUX64) or defined(PUREPASCAL) }'
      'type'
      '  coeffType = (cHi, cLo);'
      'const'
      '  ExpM1Iof64 : array[-64 .. 64, coeffType] of UInt64 = ('
      
        '    ($bfe43a54e4e98864, $bc6ca8a4270fadf5), ($bfe40adf8d149383, ' +
        '$3c7bbea189925bac),'
      
        '    ($bfe3daaae2395759, $bc57e46d4e1d1416), ($bfe3a9b3e10921cd, ' +
        '$bc8b67124284ea97),'
      
        '    ($bfe377f77a0fcb45, $3c4c14c2e7d1c9a4), ($bfe345729182bf1f, ' +
        '$bc8eb70d83f2dfd5),'
      
        '    ($bfe31221ff0f3ecc, $3c69a4cddcf699b7), ($bfe2de028da7dc59, ' +
        '$bc5edef1c1e9d2e5),'
      
        '    ($bfe2a910fb51295a, $bc87fb56248af1d0), ($bfe27349f8ed96eb, ' +
        '$bc8c3e2eeddb6e92),'
      
        '    ($bfe23caa2a088391, $3c8eccb4dac0c150), ($bfe2052e24a073a5, ' +
        '$3c8161c3e082442f),'
      
        '    ($bfe1ccd270f070f9, $bc8f7cca01c669f0), ($bfe1939389388e3d, ' +
        '$bc74fb4ada0efe97),'
      
        '    ($bfe1596dd9858ab1, $bc5ad6ddc4792f50), ($bfe11e5dbf7792a9, ' +
        '$bc561c5f183ad4be),'
      
        '    ($bfe0e25f8a081941, $3c74bbf0f4cffc58), ($bfe0a56f794ec7a4, ' +
        '$bc895d31f71cd295),'
      
        '    ($bfe06789be457e3b, $3c8f0422c59b7d45), ($bfe028aa7a8b63f2, ' +
        '$3c896b8384f1d3ee),'
      
        '    ($bfdfd19b804dffbf, $bc63dcfaabcf5d2c), ($bfdf4fdf228eb2ad, ' +
        '$3c437f6cecd799a3),'
      
        '    ($bfdecc17c0083500, $3c7be9229f8beebe), ($bfde463d1c396301, ' +
        '$bc43f3d38f393576),'
      
        '    ($bfddbe46d96cd831, $3c75958a5d1795c7), ($bfdd342c7833133a, ' +
        '$bc6333023ef6f763),'
      
        '    ($bfdca7e556da7e48, $bc7229736e5c8d3a), ($bfdc1968b0e55333, ' +
        '$bc7a21677c651b54),'
      
        '    ($bfdb88ad9e7d52ea, $bbfb61343fc21a3b), ($bfdaf5ab13e5474f, ' +
        '$3c703c6e249a5882),'
      
        '    ($bfda6057e0e846a4, $bc655b1912202da3), ($bfd9c8aab046af7a, ' +
        '$bc050456628532f0),'
      
        '    ($bfd92e9a0720d3ec, $bc285314b9559e64), ($bfd8921c445f4add, ' +
        '$3c618bc865c78e3b),'
      
        '    ($bfd7f327a018ddb2, $bc61a901b1ee2bd6), ($bfd751b22af608f0, ' +
        '$bc70a0249fec9629),'
      
        '    ($bfd6adb1cd9205ee, $bc74edd8a92eb584), ($bfd6071c47d953b2, ' +
        '$bc7a771b057709c4),'
      
        '    ($bfd55de73065b4df, $3c6572ec15fec83d), ($bfd4b207f3d79870, ' +
        '$bc6759d4ac130208),'
      
        '    ($bfd40373d42ce2e3, $3c753d8db804c224), ($bfd3521fe8150d2b, ' +
        '$bc6b0648a5e34bb6),'
      
        '    ($bfd29e011a428ec6, $bc6dabf5975c0c02), ($bfd1e70c28b987f3, ' +
        '$3c74e91dbb1734bd),'
      
        '    ($bfd12d35a41ba104, $3c63445f7544e0ef), ($bfd07071eef11388, ' +
        '$bc309aa682553231),'
      
        '    ($bfcf616a79dda3a8, $bc66b2eab63020c1), ($bfcddbe7247382af, ' +
        '$bc431eb13933e894),'
      
        '    ($bfcc5041854df7d4, $bc6797d4686c5393), ($bfcabe60e1f21836, ' +
        '$bc36f8b82e653e2d),'
      
        '    ($bfc9262c1c3430a1, $bc646ff6ec4a4251), ($bfc78789b0a5e0c0, ' +
        '$3c5e3a6bdaece8f9),'
      
        '    ($bfc5e25fb4fde211, $3c064eec82915df3), ($bfc43693d679612d, ' +
        '$bc69da94a869862a),'
      
        '    ($bfc2840b5836cf67, $bc685405051eb425), ($bfc0caab118a1278, ' +
        '$3c26ad4c353465b0),'
      
        '    ($bfbe14aed893eef4, $3c4e1f58934f97af), ($bfba85e8c62d9c13, ' +
        '$bc5adf7745e77188),'
      
        '    ($bfb6e8caff341fea, $bc59573ded7888b2), ($bfb33d1bb17df2e7, ' +
        '$bc4e19c873b1d6a8),'
      
        '    ($bfaf0540438fd5c3, $bc2a1ce01f9f6ca7), ($bfa7723950130405, ' +
        '$3c2c677ad8fa478d),'
      
        '    ($bf9f8152aee9450e, $3c24b00abf977627), ($bf8fc055004416db, ' +
        '$bc282ef422ab152a),'
      '    ($0000000000000000, $0000000000000000),'
      
        '    ($3f90202ad5778e46, $bc151e6d305beec6), ($3fa040ac0224fd93, ' +
        '$3c2c17a107575019),'
      
        '    ($3fa89246d053d178, $3c44967f31eb2595), ($3fb082b577d34ed8, ' +
        '$bc45272ff30eed1b),'
      
        '    ($3fb4cd4fc989cd64, $3c5557a8671b89e7), ($3fb92937074e0cd7, ' +
        '$bc5db0b9cc915fc5),'
      
        '    ($3fbd96b0eff0e794, $bc475385b2cdf93d), ($3fc10b022db7ae68, ' +
        '$bc58c4a5df1ec7e5),'
      
        '    ($3fc353bc9fb00b21, $3c66bae618011342), ($3fc5a5ac59b963cb, ' +
        '$bc6fd91307e74c50),'
      
        '    ($3fc800f67b00d7b8, $3c27ab912c69ffeb), ($3fca65c0b85ac1a9, ' +
        '$3c6a9c189196f8cd),'
      
        '    ($3fccd4315e9e0833, $bc2172c31a1781f1), ($3fcf4c6f5508ee5d, ' +
        '$3c646ef7b808180a),'
      
        '    ($3fd0e7510fd7c564, $bc71c5b2e8735a43), ($3fd22d78f0fa061a, ' +
        '$bc789843c4964554),'
      
        '    ($3fd378c3b0847980, $3c73b5223eca1712), ($3fd4c946033eb3de, ' +
        '$bc735d267d66dc96),'
      
        '    ($3fd61f14f169ebc1, $bc789e2d87fd0d92), ($3fd77a45d8117fd5, ' +
        '$bc52bb36e6b3a2af),'
      
        '    ($3fd8daee6a60c961, $3c6a4e618fb92468), ($3fda4124b2fe50cb, ' +
        '$3c6fb5f3020a46f5),'
      
        '    ($3fdbacff156c79d7, $bc66c5366444681a), ($3fdd1e944f6fbdaa, ' +
        '$bc7dcb8749a64f6e),'
      
        '    ($3fde95fb7a7a88f8, $bc7cc04a2491ed0a), ($3fe009a6068f6a8c, ' +
        '$bc8a29a322473bb6),'
      
        '    ($3fe0cb4eee42c98b, $bc8f511ef22f5ad5), ($3fe190048ef60020, ' +
        '$bc81ed925f893d67),'
      
        '    ($3fe257d334137dff, $3c8b99bfe7ce9f9e), ($3fe322c75a963b98, ' +
        '$3c73718f70534e8a),'
      
        '    ($3fe3f0edb1d18acd, $bc87d3f40a146f34), ($3fe4c2531c3c0d38, ' +
        '$bc8b4690082a4906),'
      
        '    ($3fe59704b03ddca9, $bc867241360f5dc1), ($3fe66f0fb901f2bd, ' +
        '$3c8176670eb83154),'
      
        '    ($3fe74a81b74adcac, $bc7690fec61c7ca4), ($3fe82968624ac88d, ' +
        '$bc8de6aad7622def),'
      
        '    ($3fe90bd1a87ef9a1, $bc5175cf7e67dfff), ($3fe9f1cbb08eb151, ' +
        '$3c8bf66c74a26ecd),'
      
        '    ($3feadb64da2d9acf, $bc3c71005d68edd6), ($3febc8abbf01c781, ' +
        '$bc81abb427c68493),'
      
        '    ($3fecb9af338d4a9c, $3c8912542fa88dd4), ($3fedae7e481b8284, ' +
        '$bc5e2a138ec80097),'
      
        '    ($3feea72849b21ebd, $bc7a892e30b5188f), ($3fefa3bcc305f191, ' +
        '$3c7d2c3b6d08c659),'
      
        '    ($3ff05225beb9ce55, $bc9d02df8ccf4707), ($3ff0d47240fe1412, ' +
        '$3c95ff940cd08c4d),'
      
        '    ($3ff158cc0d22ca02, $bc94a9212ef0b185), ($3ff1df3b68cfb9ef, ' +
        '$3c9ea61ab771f73c),'
      
        '    ($3ff267c8bb05d2a3, $3c5a3d1e659a0ad8), ($3ff2f27c8ca598a0, ' +
        '$3c7d4fe81eb0becb),'
      
        '    ($3ff37f5f88f7b4e5, $3c9adcd8bb9947d9), ($3ff40e7a7e37aa30, ' +
        '$bc2bb8b0f3c94f34),'
      
        '    ($3ff49fd65e20b96f, $3c93a5153fb80a4a), ($3ff5337c3e7cfe38, ' +
        '$3c7708e2df602f1d),'
      
        '    ($3ff5c97559b6cc28, $bc78aecd517b37d5), ($3ff661cb0f6c564f, ' +
        '$3c8c221ff57b390a),'
      
        '    ($3ff6fc86e505a9dd, $bc9a7d609b716bf6), ($3ff799b2864d0569, ' +
        '$bc9ba2fe6f7de08c),'
      
        '    ($3ff83957c6099668, $bc54d703cb17b345), ($3ff8db809e9ca670, ' +
        '$3c92896ff654d054),'
      
        '    ($3ff9803732a14221, $3c76a828a835e066), ($3ffa2785cd8e63ad, ' +
        '$3c787f474dbeb603),'
      
        '    ($3ffad176e45bab25, $3c9af15018e5e729), ($3ffb7e151628aed3, ' +
        '$bc9655023a9dfd8c) );'
      '{$ENDIF defined(CPUX64) or defined(PUREPASCAL) }'
      ''
      '{$IF defined(ARITH_PUREPASCAL_EXT80)}'
      '{$IF defined(ARITH_USE_LIBM)}'
      'function libm_expl(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'expl'#39';'
      ''
      'function Exp(const X: Extended): Extended;'
      'const'
      
        '  ExpUpperLimit = 11356.5234062941439494918768678621406161272923' +
        '5935; // ln( Extended-MAX );'
      
        '  ExpLowerLimit = -1.13994980468750E+0004; // ln( Double-DeNorma' +
        'l-Min );'
      'begin'
      '  FClearExcept;'
      '  if X > ExpUpperLimit then'
      '  begin'
      '    FRaiseExcept(feeOVERFLOW);'
      '    Exit( cInfinity );'
      '  end'
      '  else if X < ExpLowerLimit then'
      '  begin'
      '    FRaiseExcept(feeUNDERFLOW);'
      '    Exit( 0 );'
      '  end;'
      '  Result := libm_expl(X);'
      '  FCheckExcept;'
      'end;'
      '{$ENDIF defined(ARITH_USE_LIBM)}'
      '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64)}'
      'function Exp(const X: Double): Double;'
      'const'
      '  C64      : Double =  64.0;'
      '  C1of2    : Double =  1/2;'
      '  C1of64   : Double =  1/64;'
      '  CExp : array[3..6] of UInt64 ='
      '  ( $3fc5555555554855, $3fa5555555553b54,'
      '    $3f811112b12b282f, $3f56c16e86e89028 );'
      
        '  ExpUpperLimit = 709.78271289338397; //$40862E42FEFA39EF; // ln' +
        '( Double-MAX );'
      
        '  ExpLowerLimit = -745.1332191019411; //$C0874910D52D3051; // ln' +
        '( Double-DeNormal-Min );'
      '  Log2ofE   : UInt64 = $3ff71547652b82fe;'
      '  Log2ofEHi : UInt64 = $3ff71547652b0000;'
      '  Log2ofELo : UInt64 = $3da05fc2eefa1ffb;'
      '  LogEof2Hi : UInt64 = $3FE62E42FEFA4000;'
      '  LogEof2Lo : UInt64 = $3D48432A1B0E2634;'
      '  C2pow1023p5 : UInt64 = $7fe6a09e667f3bcd; // 2^(1023.5)'
      '  C2powM1074p5 : UInt64 = $00000000000000001; // 2^(-1074.5)'
      'type'
      '  TWords = Array[0..3] of Word;'
      '  PWords = ^TWords;'
      'var'
      '  q: Integer;'
      '  qd, X0, X1, X2, X3, f: Double;'
      '  I, Ind: UInt64;'
      '  W: Word;'
      '  yHi, yLo, y, Y2,'
      '  q0, q1, q2, qHi, qLo, pLo, pHi : Double;'
      '  t, u, v, r: Double;'
      'begin'
      '  W := PWords(@X)^[3] and $7FF0;'
      '  if (W = $0000) then Exit(1.0); // +/-Zero and +/-Denormal'
      '  if (W = $7FF0) then'
      '  begin'
      '    I := PUInt64(@X)^;'
      '    if I = $7FF0000000000000 then'
      '    begin'
      '      FRaiseExcept(feeOVERFLOW);'
      '      Exit( cInfinity );'
      '    end'
      '    else if I = $FFF0000000000000 then'
      '      Exit(0.0)'
      '    else'
      '      Exit(X);'
      '  end;'
      ''
      '  if X >= 0 then'
      '  begin'
      '    if X > ExpUpperLimit then'
      '    begin'
      '      FRaiseExcept(feeOVERFLOW);'
      '      Exit( cInfinity );'
      '    end;'
      '    X0 := X * PDouble(@Log2ofE)^;'
      '    q := Trunc(X0 + 0.5); qd := q;'
      '    if q <= 1023 then'
      '    begin'
      
        '      PUInt64(@f)^ := (UInt64(q + 1023)) shl 52; //    f := 2 ^ ' +
        'q;'
      '    end'
      '    else'
      '    begin'
      '      if X0 >= 1024.0 then'
      '      begin'
      '        FRaiseExcept(feeOVERFLOW);'
      '        Exit( cInfinity ); // +Inf'
      '      end;'
      '      qd := 1023.5;'
      '      f := PDouble(@C2pow1023p5)^;'
      '    end;'
      '  end'
      '  else'
      '  begin'
      '    if X < ExpLowerLimit then'
      '      Exit( 0.0 );'
      '    X0 := X * PDouble(@Log2ofE)^;'
      '    q := Trunc(X0 - 0.5); qd := q;'
      '    if q >= -1022 then'
      '    begin'
      
        '      PUInt64(@f)^ := (UInt64(q + 1023)) shl 52; //    f := 2 ^ ' +
        'q;'
      '    end'
      '    else'
      '    begin'
      '      if X0 <= -1075.0 then'
      '        Exit( 0.0 )'
      '      else if X0 <= -1074.5 then'
      '      begin'
      '        f := PDouble(@C2powM1074p5)^;'
      '        qd := -1074.5;'
      '      end'
      '      else'
      
        '        PUInt64(@f)^ := UInt64($10000000000000) shr (-1022 -  q)' +
        ';'
      '    end;'
      '  end;'
      ''
      '  x1 := X - qd * PDouble(@LogEof2Hi)^;'
      '  x2 := qd * PDouble(@LogEof2Lo)^;'
      '  X3 := x1 + x2;'
      '  if X3 >= 0 then'
      '    Ind := Trunc(X3 * C64 + C1of2)'
      '  else'
      '    Ind := Trunc(X3 * C64 - C1of2);'
      '  yHi := x1 - Ind * C1of64;'
      '  yLo := x2;'
      ''
      '  y :=  yHi + yLo;'
      '  y2 := y * y;'
      ''
      '  q1 :=           PDouble(@CExp[6])^;'
      '  q2 :=           PDouble(@CExp[5])^;'
      '  q1 := q1 * y2 + PDouble(@CExp[4])^;'
      '  q2 := q2 * y2 + PDouble(@CExp[3])^;'
      '  q0 := (q1 * y + q2) * y + c1of2;'
      ''
      '  qLo := q0 * y2 + yLo;'
      '  qHi := yHi;'
      ''
      '  pHi :=  PDouble(@ExpM1Iof64[Ind, cHi])^;'
      '  pLo :=  PDouble(@ExpM1Iof64[Ind, cLo])^;'
      ''
      '  t := pHi + 1.0; v := t - 1.0; r := pHi - v; u := r + pLo;'
      '  pHi := t + u; v := pHi - t;'
      '  pLo := u - v;'
      ''
      '  Result := 0;'
      '  Result := Result + qLo * pLo;'
      '  Result := Result + qHi * pLo;'
      '  Result := Result + pLo;'
      '  Result := Result + qLo * pHi;'
      '  Result := Result + qHi * pHi;'
      '  Result := Result + pHi;'
      '  Result := f * Result;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      'function libm_exp(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'exp'#39';'
      ''
      'function Exp(const X: Double): Double;'
      'const'
      
        '  ExpUpperLimit = 709.78271289338397; //$40862E42FEFA39EF; // ln' +
        '( Double-MAX );'
      
        '  ExpLowerLimit = -745.1332191019411; //$C0874910D52D3051; // ln' +
        '( Double-DeNormal-Min );'
      'begin'
      '  FClearExcept;'
      '  if X > ExpUpperLimit then'
      '  begin'
      '    FRaiseExcept(feeOVERFLOW);'
      '    Exit( cInfinity );'
      '  end'
      '  else if X < ExpLowerLimit then'
      '  begin'
      '    FRaiseExcept(feeUNDERFLOW);'
      '    Exit( 0 );'
      '  end;'
      '  Result := libm_exp(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      'function Exp(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'var'
      '  D: Double;'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        {       e**x = 2**(x*log2(e))   }'
      '        FLD     tbyte ptr X'
      '        FLDL2E              { y := x*log2e;      }'
      '        FMUL'
      '        FLD     ST(0)       { i := round(y);     }'
      '        FRNDINT'
      '        FSUB    ST(1), ST   { f := y - i;        }'
      '        FXCH    ST(1)       { z := 2**f          }'
      '        F2XM1'
      '        FLD1'
      '        FADD'
      '        FSCALE              { result := z * 2**i }'
      '        FSTP    ST(1)'
      
        '        FSTP    qword ptr D { Force save to Double to detect ove' +
        'rflow. }'
      '  end;'
      '  Result := D;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        {       e**x = 2**(x*log2(e))   }'
      '        FLD     tbyte ptr X'
      '        FLDL2E              { y := x*log2e;      }'
      '        FMUL'
      '        FLD     ST(0)       { i := round(y);     }'
      '        FRNDINT'
      '        FSUB    ST(1), ST   { f := y - i;        }'
      '        FXCH    ST(1)       { z := 2**f          }'
      '        F2XM1'
      '        FLD1'
      '        FADD'
      '        FSCALE              { result := z * 2**i }'
      '        FSTP    ST(1)'
      'end;'
      '{$ENDIF}'
      '{$ELSEIF defined(ARITH_X64_SSE)}'
      'function Exp(const X: Double): Double;'
      'type'
      '  m128 = record'
      '    Hi, Lo : UInt64'
      '  end align 16;'
      'const'
      '  ExpUpperLimit = $40862E42FEFA39EF; // ln( Double-MAX );'
      
        '  ExpLowerLimit = $C0874910D52D3051; // ln( Double-DeNormal-Min ' +
        ');'
      '  C64      : Double =  64.0;'
      '  C1of2    : Double =  1/2;'
      '  C1of64   : Double =  1/64;'
      '  CExp : array[3..6] of UInt64 ='
      '  ( $3fc5555555554855, $3fa5555555553b54,'
      '    $3f811112b12b282f, $3f56c16e86e89028 );'
      '  CLog2ofE   : UInt64 = $3ff71547652b82fe;'
      '  CLogEof2Hi : UInt64 = $3FE62E42FEFA4000;'
      '  CLogEof2Lo : UInt64 = $3D48432A1B0E2634;'
      '  C2powM1074p5 = $00000000000000001; // 2^(-1074.5)'
      '  C2pow1023p5 = $7FE6A09E667F3BCD;'
      ''
      '  C1024    : Double =  1024.0;'
      '  C1023p5  : Double =  1023.5;'
      '  CM1075   : Double = -1075;'
      '  CM1074p5 : Double = -1074.5;'
      '  CM1of2   : Double = -1/2;'
      '  C1       : Double =  1.0;'
      '  CInf     : Double = cInfinity;'
      '  CSignBit : UInt64 = $8000000000000000;'
      
        '  CSignBitPD: m128 = (Hi:$8000000000000000; Lo:$8000000000000000' +
        ');'
      'asm'
      '        .PARAMS 6'
      '        .SAVENV XMM6'
      '        .SAVENV XMM7'
      ''
      '        MOVSD   [RBP+060H], XMM0'
      '        MOV     RCX, [RBP+060H]'
      '        MOVAPS  XMM5, XMM0'
      '        MOVSD   XMM4, CLog2ofE'
      '        MOVSD   XMM3, C1of2'
      '        MOVZX   EAX, WORD PTR [RBP+066H]'
      '        XOR     EDX, EDX'
      '        TEST    AX, 07FF0H'
      '        JZ      @@One'
      '        CMP     AX, DX'
      '        JL      @@X_IS_NEGATIVE'
      ''
      '@@X_IS_POSITIVE:'
      '        MOV     RDX, ExpUpperLimit'
      '        CMP     AX, 07FF0h'
      '        JAE     @@X_IS_INF_OR_NAN'
      
        '        CMP     AX, 04087H  // Top word of ExpUpperLimit is $408' +
        '6'
      '        JAE     @@Overflow'
      ''
      '        CMP     RCX, RDX // if (X > ExpUpperLimit)'
      '        JA      @@Overflow'
      ''
      '        MULSD   XMM0, XMM4 // CLog2ofE'
      '        ADDSD   XMM0, XMM3 // C1of2'
      ''
      '        CVTTSD2SI EAX, XMM0'
      '        CVTSI2SD  XMM6, EAX'
      '        CMP     EAX, 03FFh'
      '        JNG     @@REDUCTION0'
      ''
      '@@X_IS_LARGE:'
      '        MOVSD   XMM6, C1023p5'
      '        MOV     RAX, C2pow1023p5'
      '        MOV     [rbp+028h], RAX'
      '        JMP     @@REDUCTION'
      ''
      '@@X_IS_NEGATIVE:'
      '        MOV     RDX, ExpLowerLimit'
      '        CMP     AX, 0FFF0H'
      '        JAE     @@X_IS_INF_OR_NAN'
      '        CMP     AX,0C090H'
      '        JAE     @@Zero'
      ''
      
        '        CMP     RCX, RDX // if (X < ExpLowerLimit) - (Doulbe is ' +
        'sign-flag and absolute value)'
      '        JA      @@Zero'
      ''
      '        MULSD   XMM0, XMM4 // CLog2ofE'
      '        MOVAPS  XMM7, XMM0'
      '        SUBSD   XMM0, XMM3 // C1of2'
      ''
      '        CVTTSD2SI EAX, XMM0'
      '        CVTSI2SD  XMM6, EAX'
      '        CMP     EAX, -0000003FEh'
      '        JNL     @@REDUCTION0'
      ''
      '@@X_IS_SMALL:'
      '        MOVSD   XMM0, CM1075'
      '        COMISD  XMM0, XMM7'
      '        JNC     @@Zero'
      '        MOVSD   XMM0, CM1074p5'
      '        COMISD  XMM0, XMM7'
      '        JC      @@X_IS_TOO_SMALL'
      ''
      '        MOV     RAX,C2powM1074p5'
      '        MOV     [RBP+028h], RAX'
      '        MOVSD   XMM6, CM1074p5'
      '        JMP     @@REDUCTION'
      ''
      '@@X_IS_TOO_SMALL:'
      '        MOV     ECX, -1022'
      '        MOV     R9, 010000000000000h'
      '        SUB     ECX, EAX'
      '        SHR     R9, CL'
      '        MOV     [RBP+028h], R9'
      '        JMP     @@REDUCTION'
      ''
      '@@One:  MOVSD   xmm0,C1'
      '        JMP     @@exit'
      ''
      '@@X_IS_INF_OR_NAN:'
      '        MOV     RAX, [RBP+060h]'
      '        MOV     RCX, 07FF0000000000000h'
      '        CMP     RAX, RCX'
      '        JZ      @@Overflow'
      '        MOV     RCX, 0FFF0000000000000h'
      '        CMP     RAX, RCX'
      '        JNZ     @@Self'
      ''
      '@@Zero: XORPD   XMM0, XMM0'
      '        JMP     @@exit'
      ''
      '@@Self: MOVAPS  XMM0, XMM5'
      '        JMP     @@exit'
      ''
      '@@Overflow:'
      '        MOV     ECX, feeOVERFLOW'
      '        MOV     DL, 1'
      '        CALL    FRaiseExcept'
      '        MOVSD   XMM0, CInf'
      '        JMP     @@exit'
      ''
      '@@REDUCTION0:'
      '        ADD     EAX, 03FFh'
      '        MOVSXD  RAX, EAX'
      '        SHL     RAX, 034H'
      '        MOV     [RBP+028h], RAX'
      ''
      '@@REDUCTION:'
      '        LEA     RDX, [CExp]'
      ''
      '        MOVAPS  XMM7, XMM6'
      '        MULSD   XMM7, CLogEof2Hi'
      '        MOVAPS  XMM2, XMM5'
      '        SUBSD   XMM2, XMM7'
      '        MULSD   XMM6, CLogEof2Lo'
      '        MOVAPS  XMM0, XMM2'
      '        ADDSD   XMM0, XMM6'
      '        MOVAPD  XMM1, CSignBitPD'
      '        MOVAPS  XMM4, XMM0'
      '        MULSD   XMM0, C64'
      '        ANDPD   XMM4, XMM1'
      '        ORPD    XMM3, XMM4'
      '        ADDSD   XMM0, XMM3'
      ''
      '        MOVSD   XMM1, C1of64'
      '        CVTTSD2SI EAX, XMM0'
      ''
      '        MOVAPS  XMM3, XMM6'
      '        MOVSD   XMM4, QWORD PTR [RDX]'
      '        MOVSD   XMM5, QWORD PTR [RDX+08H]'
      '        MOVSD   XMM6, QWORD PTR [RDX+10H]'
      '        MOVSD   XMM7, QWORD PTR [RDX+18H]'
      ''
      '        CVTSI2SD XMM0, EAX'
      '        MOVSXD  RDX, EAX'
      '        ADD     RDX, RDX'
      '        LEA     RCX, [ExpM1Iof64 + 400H]'
      '        LEA     RCX, [RCX + RDX * 8]'
      ''
      '        MULSD   XMM0, XMM1'
      '        SUBSD   XMM2, XMM0'
      '        MOVAPS  XMM0, XMM2'
      '        ADDSD   XMM0, XMM3'
      '        MOVAPS  XMM1, XMM0'
      '        MULSD   XMM1, XMM0'
      '        MULSD   XMM6, XMM1'
      '        MULSD   XMM7, XMM1'
      '        ADDSD   XMM4, XMM6'
      '        MOVSD   XMM6, C1of2'
      '        ADDSD   XMM5, XMM7'
      '        MULSD   XMM5, XMM0'
      '        ADDSD   XMM4, XMM5'
      '        MULSD   XMM0, XMM4'
      '        MOVSD   XMM4, [RCX]'
      '        MOVSD   XMM5, [RCX + 08h]'
      '        ADDSD   XMM6, XMM0'
      '        MOVSD   XMM0, c1'
      '        MULSD   XMM1, XMM6'
      '        ADDSD   XMM3, XMM1'
      ''
      ''
      '        MOVAPS  XMM1, XMM4'
      '        ADDSD   XMM4, XMM0'
      '        MOVAPS  XMM6, XMM4'
      '        SUBSD   XMM4, XMM0'
      '        SUBSD   XMM1, XMM4'
      '        ADDSD   XMM1, XMM5'
      '        MOVAPS  XMM7, XMM6'
      '        ADDSD   XMM7, XMM1'
      '        MOVAPS  XMM4, XMM7'
      '        SUBSD   XMM7, XMM6'
      '        SUBSD   XMM1, XMM7'
      ''
      '        MOVSD   XMM0, [RBP+028H]'
      '        MOVAPS  XMM7, XMM3'
      '        MULSD   XMM3, XMM1'
      '        MOVAPS  XMM6, XMM2'
      '        MULSD   XMM6, XMM1'
      '        ADDSD   XMM3, XMM6'
      '        ADDSD   XMM3, XMM1'
      '        MULSD   XMM7, XMM4'
      '        ADDSD   XMM3, XMM7'
      '        MULSD   XMM2, XMM4'
      '        ADDSD   XMM3, XMM2'
      '        ADDSD   XMM3, XMM4'
      '        MULSD   XMM0, XMM3'
      '@@Exit:'
      'end;'
      '{$ENDIF }'
      ''
      '{$IF defined(ARITH_PUREPASCAL_EXT80)}'
      '{$IF defined(ARITH_USE_LIBM)}'
      'function libm_expm1l(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'expm1l'#39';'
      ''
      'function ExpMinus1(const X: Extended): Extended;'
      'begin'
      '                                        '
      '  FClearExcept;'
      '  Result := libm_expm1l(X);'
      '  FCheckExcept;'
      'end;'
      '{$ENDIF defined(ARITH_USE_LIBM)}'
      '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64)}'
      'function ExpMinus1(const X: Double): Double;'
      'var'
      '  y, Y2,'
      '  q0, q1,'
      '  q, qHi, qLo,'
      '  pLo, pHi  : Double;'
      '  I : Integer;'
      '  W: Word;'
      'type'
      '  TWords = Array[0..3] of Word;'
      '  PWords = ^TWords;'
      'const'
      '  CExp : array[3..6] of UInt64 ='
      '  ( $3fc5555555554855, $3fa5555555553b54,'
      '    $3f811112b12b282f, $3f56c16e86e89028 );'
      '  C64 : Double = 64.0;'
      '  C1of2  : Double= 1/2;'
      '  C1of64 : Double = 1/64;'
      '  CLogEof2 : UInt64= $3fe62e42fefa39ef; // Ln(2);'
      '  CZero : Double = 0.0;'
      '  C1 : Double = 1.0;'
      'begin'
      '  if (Abs(x) = 0.0) then Exit(0.0); // +/-Zero'
      '  W := PWords(@X)^[3] and $7FF0;'
      '  if W = 0 then Exit(X) // Denormal'
      '  else if (W = $7FF0) or (Abs(X) >= PDouble(@CLogEof2)^) then'
      '    Result := Exp(X) - 1'
      '  else'
      '  begin'
      '    if X >= 0 then        // ABs(X) * 64 <= 22.18..'
      '      I := Trunc(X * C64 + C1of2)'
      '    else'
      '      I := Trunc(X * C64 - C1of2);'
      ''
      '    y := X - I * C1of64; // abs(y) <= 1/128'
      '    y2 := y * y;'
      ''
      '    q0 :=           PDouble(@CExp[6])^;'
      '    q1 :=           PDouble(@CExp[5])^;'
      '    q0 := q0 * y2 + PDouble(@CExp[4])^;'
      '    q1 := q1 * y2 + PDouble(@CExp[3])^;'
      ''
      '    q0 := q0 * y2;'
      '    q1 := q1 * y;'
      '    q := q0 + q1;'
      '    q := q + c1of2;'
      ''
      '    qLo := q * y2;'
      '    qHi := y;'
      ''
      '    pHi :=  PDouble(@ExpM1Iof64[I, cHi])^;'
      '    pLo :=  PDouble(@ExpM1Iof64[I, cLo])^;'
      ''
      '    Result := 0;'
      '    Result := Result + pLo;'
      '    Result := Result + qLo;'
      '    Result := Result + pHi * (qHi + qLo);'
      '    Result := Result + qHi;'
      '    Result := Result + pHi;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      'function libm_expm1(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'expm1'#39';'
      ''
      'function ExpMinus1(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_expm1(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      'function ExpMinus1(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'var'
      '  D: Double;'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        FLDL2E              { y := x*log2e;      }'
      '        FMUL'
      '        FLD     ST(0)'
      '        FABS'
      '        FLD1'
      '        FCOMPP'
      '        FSTSW   AX'
      '        SAHF'
      '        JAE     @@1'
      ''
      '        FLD     ST(0)       { i := round(y);     }'
      '        FRNDINT'
      '        FSUB    ST(1), ST   { f := y - i;        }'
      '        FXCH    ST(1)       { z := 2**f          }'
      '        F2XM1'
      '        FLD1'
      '        FADD'
      '        FSCALE              { result := z * 2**i }'
      '        FSTP    ST(1)'
      '        FLD1'
      '        FSUBP'
      '        JMP     @@EXIT'
      '@@1:    F2XM1'
      '@@EXIT:'
      
        '        FSTP    qword ptr D { Force save to Double to detect ove' +
        'rflow. }'
      '  end;'
      '  Result := D;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FLDL2E              { y := x*log2e;      }'
      '        FMUL'
      '        FLD     ST(0)'
      '        FABS'
      '        FLD1'
      '        FCOMPP'
      '        FSTSW   AX'
      '        SAHF'
      '        JAE     @@1'
      ''
      '        FLD     ST(0)       { i := round(y);     }'
      '        FRNDINT'
      '        FSUB    ST(1), ST   { f := y - i;        }'
      '        FXCH    ST(1)       { z := 2**f          }'
      '        F2XM1'
      '        FLD1'
      '        FADD'
      '        FSCALE              { result := z * 2**i }'
      '        FSTP    ST(1)'
      '        FLD1'
      '        FSUBP'
      '        JMP     @@EXIT'
      '@@1:    F2XM1'
      '@@EXIT:'
      'end;'
      '{$ENDIF}'
      '{$ELSEIF defined(ARITH_X64_SSE)}'
      'function ExpMinus1(const X: Double): Double;'
      'type'
      '  m128 = record'
      '    Hi, Lo : UInt64'
      '  end align 16;'
      'const'
      '  CExp : array[3..6] of UInt64 ='
      '  ( $3fc5555555554855, $3fa5555555553b54,'
      '    $3f811112b12b282f, $3f56c16e86e89028 );'
      '  C64 : Double = 64.0;'
      '  C1of2  : Double= 1/2;'
      '  C1of64 : Double = 1/64;'
      '  CLogEof2 : UInt64= $3fe62e42fefa39ef; // Ln(2);'
      '  CZero : Double = 0.0;'
      '  C1 : Double = 1.0;'
      
        '  CSignBitPD: m128 = (Hi:$8000000000000000; Lo:$8000000000000000' +
        ');'
      'asm'
      '        .PARAMS 1'
      '        .SAVENV XMM6'
      '        .SAVENV XMM7'
      ''
      '        MOVSD   [RBP+050H],XMM0'
      '        MOVZX   EAX, WORD PTR [RBP+056H]'
      ''
      '        MOVAPD  XMM2, CSignBitPD'
      '        MOVAPS  XMM4, XMM2'
      '        XORPD   XMM5, XMM5 // Zero'
      '        MOVAPS  XMM6, XMM0'
      
        '        ANDNPD  XMM2, XMM0 // Abs(X) : XMM2 := (Not XMM2) and XM' +
        'M0'
      ''
      '        UCOMISD xmm0, xmm5 // 0.0'
      '        JPE     @@01'
      '        JZ      @@Zero'
      ''
      '@@01:'
      '        AND     EAX, 07FF0H // Is X Denormal ?'
      '        JZ      @@Exit'
      '        CMP     AX, 07FF0H'
      '        JE      @@UseEXP'
      '        COMISD  XMM2, CLogEof2'
      '        JC      @@ExpMinusOne'
      ''
      '@@UseEXP:'
      '        MOVSD   XMM7, C1'
      '        CALL    Exp'
      '        SUBSD   XMM0, XMM7'
      '        JMP     @@Exit'
      ''
      '@@Zero:'
      '        MOVAPS  XMM0, XMM5 // 0.0'
      '        JMP     @@Exit'
      ''
      '@@ExpMinusOne:'
      '        ANDPD   XMM4, XMM6 // XMM4 has sign bit.'
      ''
      '        MOVSD   XMM7, C1of2'
      '        ORPD    XMM7, XMM4'
      ''
      '        MULSD   XMM6, C64'
      '        ADDSD   XMM6, XMM7'
      '        CVTTSD2SI EAX, XMM6'
      ''
      '        LEA     RDX, [CExp]'
      '        CVTSI2SD XMM7, EAX'
      '        MOVSXD  RAX, EAX'
      '        ADD     RAX, RAX'
      '        LEA     RCX, [ExpM1Iof64 + 400H]'
      '        LEA     RCX, [RCX + RAX * 8]'
      ''
      '        MULSD   XMM7, C1of64'
      '        MOVSD   XMM4, QWORD PTR [rdx]'
      '        MOVSD   XMM5, QWORD PTR [rdx + 08H]'
      '        SUBSD   XMM0, XMM7'
      '        MOVAPS  XMM1, XMM0'
      '        MULSD   XMM0, XMM0'
      '        MOVSD   XMM6, QWORD PTR [rdx + 10H]'
      '        MOVSD   XMM7, QWORD PTR [rdx + 18H]'
      '        MOVSD   XMM2,[C1of2]'
      ''
      '        MULSD   XMM7, XMM0'
      '        MULSD   XMM6, XMM0'
      '        ADDSD   XMM7, XMM5'
      '        ADDSD   XMM6, XMM4'
      ''
      '        MOVSD   XMM3, [RCX]'
      '        MOVSD   xmm5, [RCX+08h]'
      ''
      '        MULSD   XMM7, XMM0'
      '        MULSD   XMM6, XMM1'
      '        ADDSD   XMM7, XMM6'
      '        ADDSD   XMM7, XMM2'
      '        MULSD   XMM7, XMM0'
      ''
      '        ADDSD   XMM5, XMM7'
      '        MOVAPS  XMM2, XMM1'
      '        ADDSD   XMM2, XMM7'
      '        MOVAPS  XMM0, XMM3'
      '        MULSD   XMM0, XMM2'
      '        ADDSD   XMM0, XMM5'
      '        ADDSD   XMM0, XMM1'
      '        ADDSD   XMM0, XMM3'
      '@@Exit:'
      'end;'
      '{$ENDIF }'
      ''
      
        '{$IF    defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE' +
        ')}'
      'function pRemDouble(D: Double; var X, Y: Double): integer;'
      'var'
      '  PiOf2H, PiOf2M, PiOf2L : Double;'
      '  lowestPart: double;'
      'const'
      '  PiOf2Hi  : UInt64 = $3FF921FB54442D18; // Pi/2 : first 53bits'
      '  PiOf2Mi  : UInt64 = $3C91A62633145C04; // Pi/2 : Middle 53bits'
      '  PiOf2Lo  : UInt64 = $396707344A409382; // Pi/2 : Lowest 53bits'
      '  ExpOffset1 =  54; // $3FF - $3C9'
      '  ExpOffset2 = 105; // $3FF - $396'
      ''
      
        '  procedure adddouble(const x: double; var rh, rl : double); inl' +
        'ine;'
      '  var'
      '    hh, hl: double;'
      '    temp : double;'
      '  begin'
      '    hh := x + rh;'
      '    temp := hh - x;'
      '    hl := (x - (hh - temp)) + (rh - temp);'
      '    hl := hl + rl;'
      '    rh := hh + hl;'
      '    rl := hl - (rh - hh);'
      '  end;'
      ''
      
        '  procedure AddDouble2(const xh, xl: Double; var rh, rl : Double' +
        '); inline;'
      '  var'
      '    hh, hl: Double;'
      '    temp : double;'
      '  begin'
      '    hh := xh + rh;'
      '    temp := hh - xh;'
      '    hl := (xh - (hh - temp)) + (rh - temp);'
      '    hl := hl + xl + rl;'
      '    rh := hh + hl;'
      '    rl := hl - (rh - hh);'
      '  end;'
      ''
      '  // 3*Double precision reduction'
      '  procedure ReductionPi2n(n: integer);'
      '  var'
      '    X0,'
      '    T0, T1, T2, T3: Double;'
      '  begin'
      '    PDoubleRec(@PiOf2H).Exp := n + $3FF;'
      '    PDoubleRec(@PiOf2M).Exp := n + $3FF - ExpOffset1;'
      '    PDoubleRec(@PiOf2L).Exp := n + $3FF - ExpOffset2;'
      ''
      '    T0 := -PiOf2L;'
      '    T1 := 0;'
      '    AddDouble( lowestPart, T0, T1);'
      '    AddDouble(-PiOf2M,     T0, T1);'
      '    AddDouble( Y,          T0, T1); // T0&1 - partial sum'
      ''
      '    T2 := T0;'
      '    T3 := T1;'
      '    AddDouble(-PiOf2H, T0, T1);'
      '    AddDouble( X,      T0, T1); // T0&1 - X&Y'
      ''
      '    X0 := X;'
      '    X := T0;'
      '    Y := T1;'
      ''
      '    T0 := -T0;'
      '    T1 := -T1;'
      '    AddDouble( X0,     T0, T1);'
      '    AddDouble(-PiOf2H, T0, T1);'
      '    AddDouble2(T2,T3,  T0, T1);'
      ''
      '    lowestPart := T0;'
      '  end;'
      ''
      'const'
      '  nPi2High  : UInt64 = $BFF921FB54400000; // Pi/2 : Upper 32bit.'
      '  nPi2Low   : UInt64 = $BDD0B4611A600000; // Pi/2 : Lower 32bit'
      
        '  nPi2Small : UInt64 = $BBA3198A2E037073; // Pi - Pi2High - Pi2L' +
        'ow'
      '  TwoOfPi  : UInt64 = $3FE45F306DC9C883; // 2 / Pi'
      '  TwoPow22 : UInt64 = $4150000000000000; // 2 ^ 22'
      '  TwoPow54 : UInt64 = $4350000000000000; // 2 ^ 54'
      'var'
      '  D2 : Double;'
      '  Q: Int64;'
      '  n: integer;'
      '  hh, hl,'
      '  pHi, pLow, pSmall,'
      '  X2, Y2,'
      '  temp : double;'
      'begin'
      '  Result := 0;'
      '  X := D;'
      '  Y := 0;'
      ''
      '  D2 := Abs(D);'
      '  if D2 <= Pi / 4 then Exit'
      '  else if D2 <= 5 * Pi/4 then'
      '  begin'
      '    if D2 <= 3 * Pi/4 then Q := 1'
      '    else Q := 2;'
      '    if D < 0 then Q := -Q;'
      ''
      '    pHi := Q * PDouble(@PiOf2Hi)^;'
      '    pLow := Q * PDouble(@PiOf2Mi)^;'
      '    pSmall := Q * PDouble(@PiOf2Lo)^;'
      ''
      '    X2 := D - pHi;'
      '    X := X2 - pLow;'
      '    Y := - pLow - (X - X2);'
      '    Y := Y - pSmall;'
      '  end'
      '  else if D2 < PDouble(@TwoPow22)^ then'
      '  begin'
      '    // Reduction for small/mid number (up to 2^22)'
      '    Q := Trunc((D2 - Pi/4) * PDouble(@TwoOfPi)^) + 1;'
      ''
      '    if D < 0 then Q := -Q;'
      '    pHi := Q * PDouble(@nPi2High)^;'
      '    pLow := Q * PDouble(@nPi2Low)^;'
      '    pSmall := Q * PDouble(@nPi2Small)^;'
      ''
      '    X2 := D + pHi;'
      ''
      '    hh := pLow + X2;'
      '    temp := hh - pLow;'
      '    hl := (pLow - (hh - temp)) + (X2 - temp);'
      '    X2 := hh + hl;'
      '    Y2 := hl - (X2 - hh);'
      ''
      '    hh := pSmall + X2;'
      '    temp := hh - pSmall;'
      '    hl := (pSmall - (hh - temp)) + (X2 - temp);'
      '    hl := hl + Y2;'
      '    X2 := hh + hl;'
      '    Y2 := hl - (X2 - hh);'
      ''
      '    X := X2;'
      '    Y := Y2;'
      '  end'
      '  else'
      '  begin'
      '    // Reduction for large numbber between 2^22 to 2^53'
      '    n := PDoubleRec(@D2).Exp - $3FF;'
      '    PUInt64(@PiOf2H)^ := PiOf2Hi;'
      '    PUInt64(@PiOf2M)^ := PiOf2Mi;'
      '    PUInt64(@PiOf2L)^ := PiOf2Lo;'
      ''
      '    X := D2;'
      '    Y := 0;'
      '    lowestPart := 0;'
      ''
      '    while n >= 3 do'
      '    begin'
      '      PDoubleRec(@PiOf2H).Exp := n + $3FF;'
      '      if PiOf2H < X then'
      '        ReductionPi2n(n);'
      '      Dec(n);'
      '    end;'
      ''
      '    Q := 0;'
      '    while n >= 0 do'
      '    begin'
      '      PDoubleRec(@PiOf2H).Exp := n + $3FF;'
      '      if PiOf2H < X then'
      '      begin'
      '        Q := Q or (1 shl n);'
      '        ReductionPi2n(n);'
      '      end;'
      '      Dec(n);'
      '    end;'
      ''
      '    if X > Pi/4 then'
      '    begin'
      '      Q := Q + 1;'
      '      ReductionPi2n(0);'
      '    end;'
      '    if D < 0 then'
      '    begin'
      '      X := -X;'
      '      Y := -Y;'
      '      Q := -Q;'
      '    end;'
      '  end;'
      '  Result := Q and 3;'
      'end;'
      
        '{$ENDIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE' +
        ')}'
      ''
      '{$IFDEF ARITH_PUREPASCAL_EXT80}'
      'function pRemExtended(D: Extended; var R: Extended): integer;'
      'const'
      '  Pi2High = 1.5707963267341256;    // 3FF921FB54400000'
      '  Pi2Low  = 6.077100506303966e-11; // 3DD0B4611A600000'
      '  TwoOfPi = 0.636619772367581343;   // $3FE45F306DC9C883'
      'var'
      '  T : Double;'
      'begin'
      '  Result := 0;'
      '  R := D;'
      ''
      '  if Abs(D) <= Pi / 4 then'
      '    Exit'
      ''
      '  else if Abs(D) <= 3 * Pi/4 then Result := 1'
      '  else if Abs(D) <= 5 * Pi/4 then Result := 2'
      '  else'
      '    Result := Trunc((Abs(D) - Pi/4) * TwoOfPi) + 1;'
      ''
      '  if D < 0 then Result  := -Result;'
      ''
      '  T := D - Pi2High * Result;'
      '  R := T - Pi2Low * Result;'
      'end;'
      '{$ENDIF ARITH_PUREPASCAL_EXT80}'
      ''
      
        '{$IF    defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE' +
        ')}'
      'function pCosDouble(const x, y: Double) : Double;'
      'const'
      '  CCos : ARRAY[0..5] OF UINT64 ='
      '  ( $BDA8FA6A8A7D84DF,'
      '    $3E21EE9DC12C88AC,'
      '    $BE927E4F7F1EE922,'
      '    $3EFA01A019C8F945,'
      '    $BF56C16C16C15018,'
      '    $3FA555555555554B );'
      'var'
      '  r1, r2, s, t, u, v,'
      '  L, L1, L2,'
      '  D2, D4 : Double;'
      'begin'
      '  D2 := x * x;'
      '  D4 := D2 * D2;'
      ''
      '  L1 :=           PDouble(@CCos[0])^;'
      '  L2 :=           PDouble(@CCos[1])^;'
      '  L1 := L1 * D4 + PDouble(@CCos[2])^;'
      '  L2 := L2 * D4 + PDouble(@CCos[3])^;'
      '  L1 := L1 * D4 + PDouble(@CCos[4])^;'
      '  L2 := L2 * D4 + PDouble(@CCos[5])^;'
      ''
      '  L := L2 + L1 * D2;'
      '  L := L * D4;'
      ''
      '  s := 1.0;'
      '  t := D2 * 0.5;'
      '  u := s - t;'
      '  v := u - s;'
      '  r1 := t + v;'
      ''
      '  r2 := x * y;'
      '  r2 := L - r2;'
      '  r2 := r2 - r1;'
      '  Result := u + r2;'
      'end;'
      
        '{$ENDIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE' +
        ')}'
      ''
      '{$IF defined(ARITH_PUREPASCAL_EXT80)}'
      'type'
      '  TExtended80RecW = record'
      '    Words: array[0..4] of UInt16;'
      '  end;'
      '{$ENDIF ARITH_PUREPASCAL_EXT80}'
      ''
      '{$IF    defined(ARITH_PUREPASCAL_EXT80)}'
      'function pCosExtended(const D: extended) : extended;'
      'const'
      '  CCos : array[0..7] of TExtended80RecW ='
      '  ( (Words:($0000, $0000, $0000, $0000, $0000)),'
      '    (Words:($FF10, $FFFF, $FFFF, $FFFF, $BFFD)),'
      '    (Words:($AA60, $AAA9, $AAAA, $AAAA, $3FFA)),'
      '    (Words:($FE00, $09CC, $60B6, $B60B, $BFF5)),'
      '    (Words:($8000, $9377, $00CD, $D00D, $3FEF)),'
      '    (Words:($0000, $C3A0, $7B99, $93F2, $BFE9)),'
      '    (Words:($0000, $F000, $BB10, $8F74, $3FE2)),'
      '    (Words:($0000, $0000, $8030, $C7BD, $BFDA)) );'
      'var'
      '  I: Integer;'
      '  D2 : extended;'
      'begin'
      '  D2 := D * D;'
      '  Result := PExtended(@CCos[High(CCos)])^;'
      
        '  for I := High(CCos)-1 downto 0 do Result := Result * D2 + PExt' +
        'ended(@CCos[I])^;'
      'end;'
      '{$ENDIF defined(ARITH_PUREPASCAL_EXT80)}'
      ''
      
        '{$IF    defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE' +
        ')}'
      'function pSinDouble(const x,y: Double) : Double;'
      'const'
      '  CSin : array[0..7] of UInt64 ='
      '  ( $3DE5E0A28E7FA626,'
      '    $BE5AE60081AA5E86,'
      '    $3EC71DE37936614A,'
      '    $BF2A01A019E80E58,'
      '    $BC29D73D633765DD, $3F81111111110BA5,'
      '    $3C6A74A934AD37D5, $BFC5555555555555 );'
      'var'
      '  D2, D3, D4,'
      '  L, L1, L2: Double;'
      'begin'
      '  D2 := x * x;'
      '  D4 := D2 * D2;'
      '  D3 := D2 * x;'
      ''
      '  L1 :=           PDouble(@CSin[0])^;'
      '  L2 :=           PDouble(@CSin[1])^;'
      '  L1 := L1 * D4 + PDouble(@CSin[2])^;'
      '  L2 := L2 * D4 + PDouble(@CSin[3])^;'
      ''
      '  L1 := L1 * D4 + PDouble(@CSin[4])^; // C1_Low'
      '  L1 := L1      + PDouble(@CSin[5])^; // C1_Hi'
      '  L2 := L2 * D4 + PDouble(@CSin[6])^; // C0_Low'
      '  L  := L1 * D2 + L2;'
      '  L  := L       + PDouble(@CSin[7])^; // C0_Hi'
      ''
      '  L := L * D3;'
      '  L := L + (1 - D2 *0.5) * y;'
      ''
      '  Result := x + L;'
      'end;'
      
        '{$ENDIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SSE' +
        ')}'
      ''
      
        '{$IF    defined(ARITH_PUREPASCAL_EXT80) and not defined(ARITH_US' +
        'E_LIBM)}'
      'function pSinExtended(const D: extended) : extended;'
      'const'
      '  CSin : array[0..7] of TExtended80RecW ='
      '  ( (Words:($0000, $0000, $0000, $0000, $0000)),'
      '    (Words:($AAD8, $AAAA, $AAAA, $AAAA, $BFFC)),'
      '    (Words:($00C0, $8889, $8888, $8888, $3FF8)),'
      '    (Words:($3000, $0E4B, $00D0, $D00D, $BFF2)),'
      '    (Words:($0000, $21B8, $1D2C, $B8EF, $3FEC)),'
      '    (Words:($0000, $8C00, $2C81, $D732, $BFE5)),'
      '    (Words:($0000, $0000, $450C, $B092, $3FDE)),'
      '    (Words:($0000, $0000, $D500, $D645, $BFD6)) );'
      'var'
      '  I: Integer;'
      '  D2 : extended;'
      'begin'
      '  D2 := D * D;'
      '  Result := PExtended(@CSin[High(CSin)])^;'
      
        '  for I := High(CSin)-1 downto 0 do Result := Result * D2 + PExt' +
        'ended(@CSin[I])^;'
      '  Result := D * Result;'
      'end;'
      '{$ENDIF defined(ARITH_PUREPASCAL_EXT80)}'
      ''
      '{$IF defined(ARITH_PUREPASCAL_EXT80)}'
      '{$IF defined(ARITH_USE_LIBM)}'
      'function libm_cosl(const X: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'cosl'#39';'
      ''
      'function Cos(const X: Extended): Extended;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_cosl(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSE !defined(ARITH_USE_LIBM)}'
      'function Cos(const X: Extended): Extended;'
      'var'
      '  Q: integer;'
      '  R: Extended;'
      'begin'
      '  if Abs(x) < Pi/4 then'
      '    Result := pCosExtended(X)'
      '  else'
      '  begin'
      '    Q := pRemExtended(X, R);'
      '    case Q and $3 of'
      '      0: Result :=  pCosExtended(R);'
      '      1: Result := -pSinExtended(R);'
      '      2: Result := -pCosExtended(R);'
      '      3: Result :=  pSinExtended(R);'
      
        '      else Result := 0; // avoid warning W1035 Return value of f' +
        'unction '#39'%s'#39' might be undefined'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF defined(ARITH_USE_LIBM)}'
      
        '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SS' +
        'E)}'
      'function Cos(const X: Double): Double;'
      'var'
      '  Q: integer;'
      '  Y,Z: Double;'
      'begin'
      '  if Abs(x) < Pi/4 then'
      '    Result := pCosDouble(X, 0)'
      '  else'
      '  begin'
      '    Q := pRemDouble(X, Y, Z);'
      '    case Q of'
      '      0: Result :=  pCosDouble(Y, Z);'
      '      1: Result := -pSinDouble(Y, Z);'
      '      2: Result := -pCosDouble(Y, Z);'
      '      3: Result :=  pSinDouble(Y, Z);'
      
        '      else Result := 0; // avoid warning W1035 Return value of f' +
        'unction '#39'%s'#39' might be undefined'
      '    end;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      '// double  cos( double );'
      'function libm_cos(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'cos'#39';'
      ''
      'function Cos(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_cos(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function Cos(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        FCOS'
      '        FSTP    tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FCOS'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ENDIF }'
      ''
      '{$IF     defined(ARITH_PUREPASCAL_EXT80)}'
      '{$IF defined(ARITH_USE_LIBM)}'
      'function libm_sinl(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'sinl'#39';'
      ''
      'function Sin(const X: Extended): Extended;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_sinl(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'function Sin(const X: Extended): Extended;'
      'var'
      '  Q: integer;'
      '  R: Extended;'
      'begin'
      '  if Abs(x) < Pi/4 then'
      '    Result := pSinExtended(X)'
      '  else'
      '  begin'
      '    Q := pRemExtended(X, R);'
      '    case Q and $3 of'
      '      0: Result :=  pSinExtended(R);'
      '      1: Result :=  pCosExtended(R);'
      '      2: Result := -pSinExtended(R);'
      '      3: Result := -pCosExtended(R);'
      
        '      else Result := 0; // avoid warning W1035 Return value of f' +
        'unction '#39'%s'#39' might be undefined'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF}'
      
        '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SS' +
        'E)}'
      'function Sin(const X: Double): Double;'
      'var'
      '  Q: integer;'
      '  Y,Z: Double;'
      'begin'
      '  if Abs(x) < Pi/4 then'
      '    Result := pSinDouble(X, 0)'
      '  else'
      '  begin'
      '    Q := pRemDouble(X, Y, Z);'
      '    case Q of'
      '      0: Result :=  pSinDouble(Y, Z);'
      '      1: Result :=  pCosDouble(Y, Z);'
      '      2: Result := -pSinDouble(Y, Z);'
      '      3: Result := -pCosDouble(Y, Z);'
      
        '      else Result := 0; // avoid warning W1035 Return value of f' +
        'unction '#39'%s'#39' might be undefined'
      '    end;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      'function libm_sin(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'sin'#39';'
      ''
      'function Sin(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_sin(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function Sin(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        FSIN'
      '        FSTP    tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FSIN'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ENDIF }'
      ''
      '{$IF defined(ARITH_PUREPASCAL_EXT80)}'
      '{$IF defined(ARITH_USE_LIBM)}'
      'function libm_tanl(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'tanl'#39';'
      ''
      'function Tangent(const X: Extended): Extended;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_tanl(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSE !defined(ARITH_USE_LIBM)}'
      'function Tangent(const X: Extended): Extended;'
      'var'
      '  Q: integer;'
      '  R: Extended;'
      'begin'
      '  if Abs(x) < Pi/4 then'
      '    Result := pSinExtended(X) / pCosExtended(X)'
      '  else'
      '  begin'
      '    Q := pRemExtended(X, R);'
      '    case Q and $3 of'
      '      0: Result :=  pSinExtended(R) /  pCosExtended(R);'
      '      1: Result :=  pCosExtended(R) / -pSinExtended(R);'
      '      2: Result := -pSinExtended(R) / -pCosExtended(R);'
      '      3: Result := -pCosExtended(R) /  pSinExtended(R);'
      
        '      else Result := 0; // avoid warning W1035 Return value of f' +
        'unction '#39'%s'#39' might be undefined'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF defined(ARITH_USE_LIBM)}'
      
        '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SS' +
        'E)}'
      'function Tangent(const X: Double): Double;'
      'var'
      '  Q: integer;'
      '  Y,Z: Double;'
      'begin'
      '  if Abs(x) < Pi/4 then'
      '    Result := pSinDouble(X,0) / pCosDouble(X,0)'
      '  else'
      '  begin'
      '    Q := pRemDouble(X, Y, Z);'
      '    case Q of'
      '      0: Result :=  pSinDouble(Y, Z) /  pCosDouble(Y, Z);'
      '      1: Result :=  pCosDouble(Y, Z) / -pSinDouble(Y, Z);'
      '      2: Result := -pSinDouble(Y, Z) / -pCosDouble(Y, Z);'
      '      3: Result := -pCosDouble(Y, Z) /  pSinDouble(Y, Z);'
      
        '      else Result := 0; // avoid warning W1035 Return value of f' +
        'unction '#39'%s'#39' might be undefined'
      '    end;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      'function libm_tan(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'tan'#39';'
      ''
      'function Tangent(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_tan(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function Tangent(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD    tbyte ptr X'
      '        FPTAN'
      '        FSTP   ST(0)      { FPTAN pushes 1.0 after result }'
      '        FSTP   tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD    tbyte ptr X'
      '        FPTAN'
      '        FSTP   ST(0)      { FPTAN pushes 1.0 after result }'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ENDIF }'
      ''
      '{$IF     defined(ARITH_PUREPASCAL_EXT80)}'
      'procedure SineCosine(const X: Extended; var Sin, Cos: Extended);'
      'begin'
      '  Sin := System.Sin(X);'
      '  Cos := System.Cos(X);'
      'end;'
      
        '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SS' +
        'E)}'
      'procedure SineCosine(const X: Double; var Sin, Cos: Double);'
      'var'
      '  Q: integer;'
      '  Y,Z: Double;'
      'begin'
      '  if Abs(x) < Pi/4 then'
      '  begin'
      '    Sin := pSinDouble(X, 0);'
      '    Cos := pCosDouble(X, 0);'
      '  end'
      '  else'
      '  begin'
      '    Q := pRemDouble(X, Y, Z);'
      '    case Q of'
      '      0:'
      '        begin'
      '          Sin :=  pSinDouble(Y, Z);'
      '          Cos :=  pCosDouble(Y, Z);'
      '        end;'
      '      1:'
      '        begin'
      '          Sin :=  pCosDouble(Y, Z);'
      '          Cos := -pSinDouble(Y, Z);'
      '        end;'
      '      2:'
      '        begin'
      '          Sin := -pSinDouble(Y, Z);'
      '          Cos := -pCosDouble(Y, Z);'
      '        end;'
      '      3:'
      '        begin'
      '          Sin := -pCosDouble(Y, Z);'
      '          Cos :=  pSinDouble(Y, Z);'
      '        end;'
      '    end;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      'procedure SineCosine(const X: Double; var Sin, Cos: Double);'
      'begin'
      '  FClearExcept;'
      '  Sin := System.Sin(X);'
      '  Cos := System.Cos(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'procedure SineCosine(const X: Extended; var Sin, Cos: Extended);'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        MOV     EDX, Cos'
      '        MOV     EAX, Sin'
      '        FSINCOS'
      '        FSTP    tbyte ptr [edx]    // Cos'
      '        FSTP    tbyte ptr [eax]    // Sin'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FSINCOS'
      '        FSTP    tbyte ptr [edx]    // Cos'
      '        FSTP    tbyte ptr [eax]    // Sin'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ENDIF }'
      ''
      '{$IF     defined(ARITH_PUREPASCAL_EXT80)}'
      'function pLnXP1(frac: Extended) : Extended;'
      'type'
      '  TExtRec = packed record'
      '    F: UInt64;'
      '    E: UInt16;'
      '  end;'
      'const'
      '  CLn : array[0..8] of TExtRec ='
      '  ( (F: $0000000000000000; E: $0000),'
      '    (F: $AAAAAAAAAAAAAD00; E: $3FF9),'
      '    (F: $CCCCCCCCCCD2E800; E: $3FF4),'
      '    (F: $9249249230E9C000; E: $3FF0),'
      '    (F: $E38E3912EA680000; E: $3FEB),'
      '    (F: $BA2E75AB12000000; E: $3FE7),'
      '    (F: $9D8F6569C8000000; E: $3FE3),'
      '    (F: $87C06B7E80000000; E: $3FDF),'
      '    (F: $8723D5A800000000; E: $3FDB) );'
      'var'
      '  y, y2 : extended;'
      '  I : integer;'
      'begin'
      '  y := frac /(frac + 2);'
      '  y2 := y*y;'
      '  Result := PExtended(@CLn[High(CLn)])^;'
      '  for I := High(CLn)-1 downto 0 do'
      '    Result := Result * y2 + PExtended(@CLn[I])^;'
      '  Result := (Result * 2 * y) + 2 * y;'
      'end;'
      '{$ENDIF }'
      ''
      '{$IF     defined(ARITH_PUREPASCAL_EXT64)}'
      'function pLnXP1Double(frac: Double) : Double;'
      'const'
      '  CLn : array[0..11] of UInt64 ='
      '  ( $3fb0c835bd538f8c,'
      '    $3fa988ab1ef94f29,'
      '    $3fae3c098f53b5ee,'
      '    $3fb11053fca919d4,'
      '    $3fb3b140d1e4050f,'
      '    $3fb745d159460dd7,'
      '    $3fbc71c71cbb0290,'
      '    $3fc249249248f262,'
      '    $3c602e384367005f, $3fc99999999999b4,'
      '    $3c750aaac32dac90, $3fd5555555555555 );'
      'var'
      '  Y, Y2, Y4: Double;'
      '  R1, R2, F1, F2, F3: Double;'
      'begin'
      '  Y := frac /(frac + 2.0);'
      '  Y2 := Y * Y;'
      '  Y4 := Y2 * Y2;'
      ''
      '  R1 :=         + PDouble(@CLn[0])^;'
      '  R2 :=         + PDouble(@CLn[1])^;'
      '  R1 := R1 * Y4 + PDouble(@CLn[2])^;'
      '  R2 := R2 * Y4 + PDouble(@CLn[3])^;'
      '  R1 := R1 * Y4 + PDouble(@CLn[4])^;'
      '  R2 := R2 * Y4 + PDouble(@CLn[5])^;'
      '  R1 := R1 * Y4 + PDouble(@CLn[6])^;'
      '  R2 := R2 * Y4 + PDouble(@CLn[7])^;'
      '  R1 := R1 * Y4 + PDouble(@CLn[8])^;'
      '  R1 := R1      + PDouble(@CLn[9])^;'
      '  R2 := R2 * Y4 + PDouble(@CLn[10])^;'
      '  R2 := R2 + R1 * Y2;'
      '  R2 := R2      + PDouble(@CLn[11])^;'
      ''
      '  F1 := frac * 0.5;'
      '  F2 := frac * F1;'
      '  F3 := F2 * F1;'
      '  Result := ((((R2 * 2 * Y2 * Y) + F3)- F2) - Y * F3)+ frac;'
      'end;'
      '{$ELSEIF defined(ARITH_X64_SSE)}'
      'function pLnXP1Double(frac: Double) : Double;'
      'const'
      '  CLn : array[0..11] of UInt64 ='
      '  ( $3fb0c835bd538f8c,'
      '    $3fa988ab1ef94f29,'
      '    $3fae3c098f53b5ee,'
      '    $3fb11053fca919d4,'
      '    $3fb3b140d1e4050f,'
      '    $3fb745d159460dd7,'
      '    $3fbc71c71cbb0290,'
      '    $3fc249249248f262,'
      '    $3c602e384367005f, $3fc99999999999b4,'
      '    $3c750aaac32dac90, $3fd5555555555555 );'
      'const'
      '  C2 : Double= 2.0;'
      '  C1of2 : Double = 0.5;'
      'asm'
      '        .SAVENV XMM6'
      '        .SAVENV XMM7'
      ''
      '        LEA     RCX,  [C2]'
      '        MOVAPD  XMM1, XMM0'
      '        ADDSD   XMM0, [RCX]'
      '        LEA     RDX,  [C1of2]'
      '        MOVAPD  XMM2, XMM1'
      '        DIVSD   XMM2, XMM0'
      '        LEA     RAX,  [CLn]'
      '        MOVAPD  XMM0, XMM1'
      '        MULSD   XMM0, [RDX]'
      '        MOVAPD  XMM4, XMM1'
      '        MULSD   XMM4, XMM0'
      '        MOVAPD  XMM3, XMM4'
      '        MULSD   XMM3, XMM0'
      '        MOVSD   XMM6, [RAX]'
      '        MOVSD   XMM0, [RAX + 008H]'
      '        MOVAPD  XMM5, XMM2'
      '        MULSD   XMM5, XMM2'
      '        MOVAPD  XMM7, XMM5'
      '        MULSD   XMM7, XMM5'
      '        MULSD   XMM6, XMM7'
      '        MULSD   XMM0, XMM7'
      '        ADDSD   XMM6, [RAX + 010H]'
      '        ADDSD   XMM0, [RAX + 018H]'
      '        MULSD   XMM6, XMM7'
      '        MULSD   XMM0, XMM7'
      '        ADDSD   XMM6, [RAX + 020H]'
      '        ADDSD   XMM0, [RAX + 028H]'
      '        MULSD   XMM6, XMM7'
      '        MULSD   XMM0, XMM7'
      '        ADDSD   XMM6, [RAX + 030H]'
      '        ADDSD   XMM0, [RAX + 038H]'
      '        MULSD   XMM6, XMM7'
      '        ADDSD   XMM6, [RAX + 040H]'
      '        ADDSD   XMM6, [RAX + 048H]'
      '        MULSD   XMM0, XMM7'
      '        ADDSD   XMM0, [RAX + 050H]'
      '        MULSD   XMM6, XMM5'
      '        ADDSD   XMM0, XMM6'
      '        ADDSD   XMM0, [RAX + 058H]'
      '        MULSD   XMM0, [RCX]'
      '        MULSD   XMM0, XMM5'
      '        MULSD   XMM0, XMM2'
      '        MULSD   XMM2, XMM3'
      '        ADDSD   XMM0, XMM3'
      '        SUBSD   XMM0, XMM4'
      '        SUBSD   XMM0, XMM2'
      '        ADDSD   XMM0, XMM1'
      'end;'
      '{$ENDIF }'
      ''
      
        '{$IF defined(ARITH_USE_LIBM) and defined(ARITH_PUREPASCAL_EXT80)' +
        '}'
      'function libm_logl(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'logl'#39';'
      ''
      'function Ln(const X: Extended): Extended;'
      'begin'
      '  case PExtendedRec(@X).SpecialType of'
      
        '    TFloatSpecial.fsNInf, TFloatSpecial.fsNegative, TFloatSpecia' +
        'l.fsNDenormal:'
      '      begin'
      '        FRaiseExcept(feeINVALID);'
      '        Exit(cNaN);'
      '      end;'
      '    TFloatSpecial.fsZero, TFloatSpecial.fsNZero:'
      '      begin'
      '        FRaiseExcept(feeDIVBYZERO);'
      '        Exit(cNInfinity);'
      '      end;'
      '    TFloatSpecial.fsInf,'
      '    TFloatSpecial.fsNaN:'
      '      Exit(X);'
      '    else'
      '    begin'
      '      FClearExcept;'
      '      Result := libm_logl(X);'
      '      case PExtendedRec(@X).SpecialType of'
      '        TFloatSpecial.fsNINF:'
      '          FRaiseExcept(feeDIVBYZERO);'
      '        TFloatSpecial.fsNaN:'
      '          FRaiseExcept(feeINVALID);'
      '      end;'
      '      FCheckExcept;'
      '    end;'
      '  end;'
      'end;'
      '{$ELSEIF     defined(ARITH_PUREPASCAL_EXT80)}'
      'function Ln(const X: Extended): Extended;'
      'const'
      '  Ln2 = 0.69314718055994530941723212145818; // Ln(2)'
      'var'
      '  frac : UInt64;'
      '  exponent : integer;'
      '  E : Extended;'
      'begin'
      '  Result := X; // supress warning'
      '  case PExtendedRec(@X).SpecialType of'
      
        '    TFloatSpecial.fsNInf, TFloatSpecial.fsNegative, TFloatSpecia' +
        'l.fsNDenormal:'
      '      Error(reInvalidOp);'
      '    TFloatSpecial.fsZero, TFloatSpecial.fsNZero:'
      '      Error(reZeroDivide);'
      '    TFloatSpecial.fsInf,'
      '    TFloatSpecial.fsNaN:'
      '      Exit(X);'
      '    TFloatSpecial.fsDenormal, TFloatSpecial.fsPositive:'
      '    begin'
      
        '      frac := PExtendedRec(@X).Mantissa; // (0.5 * 2^64)<= frac ' +
        '< (1 * 2^64)'
      '      exponent := PExtendedRec(@X).Exponent + 1;'
      ''
      '      if frac <= $B504F333F9DE6480 then // sqrt(0.5) * 2^64'
      '      begin'
      
        '        // (0.5 .. 0.7 (sqrt(2)/2)) * 2 - 1 => (0.0 .. 0.4 (SQRT' +
        '(2) - 1))'
      '        PExtendedRec(@E).BuildUp(False, frac, 0);'
      '        exponent := exponent - 1;'
      '      end'
      '      else'
      '      begin'
      '        // (0.7 (sqrt(2)/2) .. 1.0) - 1 => ( 0.3 .. 0.0)'
      '        PExtendedRec(@E).BuildUp(False, frac, -1);'
      '      end;'
      ''
      '      E := E - 1;'
      '      Result := pLnXP1(E) + exponent * Ln2;'
      '    end;'
      '  end;'
      'end;'
      
        '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SS' +
        'E)}'
      'function Ln(const X: Double): Double;'
      'const'
      '  Ln2Hi: UInt64  = $3FE62E42FC000000; // High 27bits of Ln(2)'
      '  Ln2Lo: UInt64  = $3E37D1CF79ABC9E4; // rest of Ln(2)'
      'var'
      '  X2: Double;'
      '  frac : UInt64;'
      '  exponent : integer;'
      '  E: Double;'
      '  U: UInt64;'
      '  W: Word;'
      'begin'
      '  X2 := X;'
      '  U := PUInt64(@X2)^;'
      '  W := PDoubleRec(@X2)^.Words[3];'
      '  if W >= $8000 then'
      '  begin'
      '    if U = $8000000000000000 then'
      '    begin'
      '      FRaiseExcept(feeDIVBYZERO);'
      '      Exit(cNInfinity);'
      '    end'
      '    else if U <= $FFF0000000000000 then'
      '      FRaiseExcept(feeINVALID);'
      '    Exit(cNaN);'
      '  end'
      '  else'
      '  begin'
      '    if U = $0000000000000000 then'
      '    begin'
      '      FRaiseExcept(feeDIVBYZERO);'
      '      Exit(cNInfinity);'
      '    end'
      '    else if U < $7FF0000000000000 then'
      '    begin'
      '      W := (W and $7FF0) shr 4;'
      '      if W = 0 then // Denormal'
      '      begin'
      '        frac := U and $000FFFFFFFFFFFFF;'
      '        exponent := -1022;'
      '        if frac and (UInt64($FFFFFFFF) shl 21) = 0 then'
      '        begin'
      '          frac := frac shl 32;'
      '          Dec(exponent, 32);'
      '        end;'
      '        if frac and (UInt64($FFFF) shl 37) = 0 then'
      '        begin'
      '          frac := frac shl 16;'
      '          Dec(exponent, 16);'
      '        end;'
      '        if frac and (UInt64($FF) shl 45) = 0 then'
      '        begin'
      '          frac := frac shl 8;'
      '          Dec(exponent, 8);'
      '        end;'
      '        if frac and (UInt64($F) shl 49)= 0 then'
      '        begin'
      '          frac := frac shl 4;'
      '          Dec(exponent, 4);'
      '        end;'
      '        if frac and (UInt64($3) shl 51) = 0 then'
      '        begin'
      '          frac := frac shl 2;'
      '          Dec(exponent, 2);'
      '        end;'
      '        if frac and (UInt64(1) shl 52) = 0 then'
      '        begin'
      '          frac := frac shl 1;'
      '          Dec(exponent, 1);'
      '        end;'
      '        frac := frac and $000FFFFFFFFFFFFF;'
      '      end'
      '      else'
      '      begin'
      '        frac := U and $000FFFFFFFFFFFFF;'
      '        exponent := W - $3FF;'
      '      end;'
      ''
      '      if frac <= UInt64($6A09E667F3BCC) then // sqrt(0.5) * 2^53'
      '      begin'
      
        '        // (0.5 .. 0.7 (sqrt(2)/2)) * 2 - 1 => (0.0 .. 0.4 (SQRT' +
        '(2) - 1))'
      '        PUInt64(@E)^ := UInt64($3FF0000000000000) + frac;'
      '      end'
      '      else'
      '      begin'
      '        // (0.7 (sqrt(2)/2) .. 1.0) - 1 => (-0.3 .. 0.0)'
      '        PUInt64(@E)^ := UInt64($3FE0000000000000) + frac;'
      '        Inc(exponent);'
      '      end;'
      '      Result := pLnXP1Double(E-1) + exponent * PDouble(@Ln2Lo)^;'
      '      Result := Result + exponent * PDouble(@Ln2Hi)^;'
      '    end'
      '    else if U = $7FF0000000000000 then'
      '    begin'
      '      Exit(cInfinity);'
      '    end'
      '    else'
      '      Exit(cNaN);'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      '// double log ( double );'
      'function libm_log(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'log'#39';'
      ''
      'function Ln(const X: Double): Double;'
      'const'
      '  DEXP  = $7FF0000000000000; // Exponential part'
      '  DSIGN = $8000000000000000; // Sign bit.'
      '  DNINF = $FFF0000000000000; // -Inf'
      'var'
      '  I: Int64;'
      '  fType: TFloatSpecial;'
      'begin'
      '  FClearExcept;'
      '  I := PInt64(@X)^;'
      ''
      '  if (I and DEXP) = DEXP then'
      '  begin    if I = DEXP then // X is +Inf'
      '      Exit( cInfinity )'
      '    else if I <> DNINF then'
      '      Exit( X ); // X is NaN'
      '  end;'
      ''
      '  if I and (not DSIGN) = 0 then'
      '  begin'
      '    FRaiseExcept(feeDIVBYZERO);'
      '    Exit(cNInfinity);'
      '  end'
      '  else if I < 0 then'
      '  begin'
      '    FRaiseExcept(feeINVALID);'
      '    Exit(cNaN);'
      '  end;'
      ''
      '  Result := libm_log(X);'
      ''
      '  fType := PDoubleRec(@Result).SpecialType;'
      ''
      '  if fType = fsNINf then'
      '    FRaiseExcept(feeDIVBYZERO)'
      '  else if fType = fsNaN then'
      '    FRaiseExcept(feeINVALID);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function Ln(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS) } // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        FLDLN2'
      '        FXCH'
      '        FYL2X'
      '        FSTP    tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FLDLN2'
      '        FXCH'
      '        FYL2X'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ENDIF }'
      ''
      '{$IF     defined(ARITH_PUREPASCAL_EXT80)}'
      '{$IF defined(ARITH_USE_LIBM)}'
      'function libm_log1pl(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'log1pl'#39';'
      ''
      'function LnXPlus1(const X: Extended): Extended;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_log1pl(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'function LnXPlus1(const X: Extended): Extended;'
      'begin'
      '  if Abs(X) < (sqrt(2.0) - 1) then'
      '    Result := pLnXP1(X)'
      '  else'
      '    Result := Ln(1 + X);'
      'end;'
      '{$ENDIF}'
      
        '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SS' +
        'E)}'
      'function LnXPlus1(const X: Double): Double;'
      'begin'
      '  if Abs(X) < (sqrt(2.0) - 1) then'
      '    Result := pLnXP1Double(X)'
      '  else'
      '    Result := Ln(1 + X);'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      '//  double log1p ( double );'
      'function libm_log1p(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'log1p'#39';'
      ''
      'function LnXPlus1(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_log1p(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function LnXPlus1(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        FLD1'
      '        FADD'
      '        FLDLN2'
      '        FXCH'
      '        FYL2X'
      '        FSTP    tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FLD1'
      '        FADD'
      '        FLDLN2'
      '        FXCH'
      '        FYL2X'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ENDIF}'
      ''
      '{$IF defined(ARITH_PUREPASCAL_EXT80)}'
      '{$IF defined(ARITH_USE_LIBM)}'
      'function libm_atanl(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'atanl'#39';'
      ''
      'function ArcTan(const X: Extended): Extended;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_atanl(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSE !defined(ARITH_USE_LIBM)}'
      'function internalArcTan(E : Extended ): Extended;'
      'const'
      '  CArcTan: array[0..7] of TExtended80RecW ='
      '  ( (Words:($0000, $0000, $0000, $8000, $3FFF)),'
      '    (Words:($AB80, $AAAA, $AAAA, $AAAA, $BFF7)),'
      '    (Words:($8000, $CCAF, $CCCC, $CCCC, $3FF0)),'
      '    (Words:($0000, $E7D0, $2491, $9249, $BFEA)),'
      '    (Words:($0000, $E000, $37F5, $E38E, $3FE3)),'
      '    (Words:($0000, $0000, $FEB8, $BA2D, $BFDD)),'
      '    (Words:($0000, $0000, $EC00, $9D5D, $3FD7)),'
      '    (Words:($0000, $0000, $4000, $8181, $BFD1)) );'
      'var'
      '  I: Integer;'
      '  E2 : Extended;'
      'begin'
      '  E2 := E * 8;'
      '  E2 := E2 * E2;'
      '  Result := PExtended(@CArcTan[High(CArcTan)])^;'
      
        '  for I := High(CArcTan)-1 downto 0 do Result := Result * E2 + P' +
        'Extended(@CArcTan[I])^;'
      ''
      '  Result := E * Result;'
      'end;'
      ''
      'function emu_PAtan( z: Extended): Extended;'
      'const'
      '  topsOf: array[0..3] of TExtended80RecW ='
      '  ( (Words:($0000, $0000, $0000, $E700, $3FFB)),'
      '    (Words:($A4BD, $7BD6, $64EE, $B35C, $3FFD)),'
      '    (Words:($85B5, $FC47, $3074, $A111, $3FFE)),'
      '    (Words:($0000, $0000, $0000, $8000, $3FFF)) );'
      '  middles: array[0..2] of TExtended80RecW ='
      '  ( (Words:($6EE6, $1FD9, $09BD, $E9FA, $3FFC)),'
      '    (Words:($7B8D, $BD35, $845B, $F6DD, $3FFD)),'
      '    (Words:($D57F, $0235, $80DB, $CC73, $3FFE)) );'
      '  ArcTans: array[0..2] of TExtended80RecW ='
      '  ( (Words:($FA9C, $B064, $1DB2, $E607, $3FFC)),'
      '    (Words:($FA9C, $B064, $1DB2, $E607, $3FFD)),'
      '    (Words:($BBF5, $044B, $5646, $AC85, $3FFE)) );'
      'var'
      '  theta : integer;'
      'begin'
      '  theta := 0;'
      
        '  while (theta < High(topsOf)) and (z > PExtended(@topsOf[theta]' +
        ')^) do'
      '    Inc(theta);'
      '  if theta = 0 then'
      '    Result := internalArcTan(z)'
      '  else'
      '  begin'
      '    theta := theta - 1;'
      
        '    z := (z - PExtended(@middles[theta])^) / ( 1 + z * PExtended' +
        '(@middles[theta])^);'
      '    Result := internalArcTan(z) + PExtended(@ArcTans[theta])^;'
      '  end;'
      'end;'
      ''
      'function ArcTan(const X: Extended): Extended;'
      'var'
      '  A: Extended;'
      'begin'
      '  Result := X;'
      '  case PExtendedRec(@X).SpecialType of'
      '    TFloatSpecial.fsInf:'
      '      Result := Pi / 2;'
      '    TFloatSpecial.fsNInf:'
      '      Result := - Pi / 2;'
      '    TFloatSpecial.fsNZero,'
      '    TFloatSpecial.fsZero,'
      '    TFloatSpecial.fsNAN:'
      '      ;'
      '  else'
      '    if X = 0 then Exit;'
      '    A := Abs(X);'
      '    if A > 1 then'
      '      Result := Pi / 2 - emu_PAtan( 1 / A )'
      '    else'
      '      Result := emu_PAtan( A );'
      '    if X < 0 then Result := -Result;'
      '  end;'
      'end;'
      '{$ENDIF defined(ARITH_USE_LIBM)}'
      
        '{$ELSEIF defined(ARITH_PUREPASCAL_EXT64) or defined(ARITH_X64_SS' +
        'E)}'
      'function internalArcTan(D : Double ): Double;'
      'const'
      '  CArcTan: array[0..7] of UINT64 ='
      '  (  $3FB2F5A7353A1B01,'
      '     $BFB7429E98FF380E,'
      '     $3FBC71C037153954,'
      '     $BFC249248E85912A,'
      '     $BC53C41AEC2E7942, $3FC999999997B5A2,'
      '     $3C635CC7570C5D0A, $BFD555555555552D );'
      'var'
      '  L1, L2, D2, D4 : Double;'
      'begin'
      '  D2 := D *D ;'
      '  D4 := D2 * D2;'
      ''
      '  L1 :=           PDouble(@CArcTan[0])^;'
      '  L2 :=           PDouble(@CArcTan[1])^;'
      '  L1 := L1 * D4 + PDouble(@CArcTan[2])^;'
      '  L2 := L2 * D4 + PDouble(@CArcTan[3])^;'
      '  L1 := L1 * D4 + PDouble(@CArcTan[4])^;'
      '  L1 := L1      + PDouble(@CArcTan[5])^;'
      '  L2 := L2 * D4 + PDouble(@CArcTan[6])^;'
      '  Result := L2 + L1 * D2;'
      '  Result := Result + PDouble(@CArcTan[7])^;'
      '  Result := Result * D2 * D + D;'
      'end;'
      ''
      'function emu_PAtan( z: Double): Double;'
      'const'
      '  topsOf: array[0..3] of UInt64 ='
      '  ( $3FBCE00000000000,'
      '    $3FD66B8C9DCF7AD5,'
      '    $3FE422260E9F88F1,'
      '    $3FF0000000000000 );'
      '  middles: array[0..2] of UInt64 ='
      '  ( $3FCD3F4137A3FB2E,'
      '    $3FDEDBB08B77A6AF,'
      '    $3FE98E701B6046BB );'
      '  ArcTans: array[0..2, coeffType] of UInt64 ='
      '  (($3FCCC0E3B6560C9F, $3C6D41911026EB34),'
      '   ($3FDCC0E3B6560C9F, $BC4158A052703F90),'
      '   ($3FE590AAC8C08978, $BC841E1865A76537) );'
      'var'
      '  theta : integer;'
      'begin'
      '  theta := 0;'
      
        '  while (theta < High(topsOf)) and (z > PDouble(@topsOf[theta])^' +
        ') do'
      '    Inc(theta);'
      ''
      '  if theta = 0 then'
      '    Result := internalArcTan(z)'
      '  else'
      '  begin'
      '    theta := theta - 1;'
      
        '    z := (z - PDouble(@middles[theta])^) / ( 1 + z * PDouble(@mi' +
        'ddles[theta])^);'
      
        '    Result := internalArcTan(z) + PDouble(@ArcTans[theta, cLo])^' +
        ';'
      '    Result := Result + PDouble(@ArcTans[theta, cHi])^;'
      '  end;'
      'end;'
      ''
      'function ArcTan(const X: Double): Double;'
      'var'
      '  A: Double;'
      'begin'
      '  Result := X;'
      '  case PDoubleRec(@X).SpecialType of'
      '    TFloatSpecial.fsInf:'
      '      Result := Pi / 2;'
      '    TFloatSpecial.fsNInf:'
      '      Result := - Pi / 2;'
      '    TFloatSpecial.fsNZero,'
      '    TFloatSpecial.fsZero,'
      '    TFloatSpecial.fsNAN:'
      '      ;'
      '  else'
      '    if X = 0 then Exit;'
      '    A := Abs(X);'
      '    if A > 1 then'
      '      Result := Pi / 2 - emu_PAtan( 1 / A )'
      '    else'
      '      Result := emu_PAtan( A );'
      '    if X < 0 then Result := -Result;'
      '  end;'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      'function libm_atan(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'atan'#39';'
      ''
      'function ArcTan(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  Result := libm_atan(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSEIF defined(ARITH_X32_FPU)}'
      ''
      'function ArcTan(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD    tbyte ptr X'
      '        FLD1'
      '        FPATAN'
      '        FSTP   tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD    tbyte ptr X'
      '        FLD1'
      '        FPATAN'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ENDIF }'
      ''
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      ''
      'function Sqrt(const X: Extended): Extended;'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '        FLD     tbyte ptr X'
      '        FSQRT'
      '        FSTP    tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '        FLD     tbyte ptr X'
      '        FSQRT'
      '        FWAIT'
      'end;'
      '{$ENDIF}'
      '{$ELSEIF defined(CPUX64) and defined(ASSEMBLER)}'
      'function Sqrt(const X: Double): Double;'
      'asm'
      '        .NOFRAME'
      '        SQRTSD  XMM0, XMM0'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      '{$IF defined(EXTENDEDHAS10BYTES)}'
      'function libm_sqrtl(x: Extended): Extended; cdecl;'
      '  external libmmodulename name _PU + '#39'sqrtl'#39';'
      ''
      'function Sqrt(const X: Extended): Extended;'
      'begin'
      '  FClearExcept;'
      '  if X < 0 then FRaiseExcept(feeINVALID);'
      '  Result := libm_sqrtl(X);'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'function libm_sqrt(x: Double): Double; cdecl;'
      '  external libmmodulename name _PU + '#39'sqrt'#39';'
      ''
      'function Sqrt(const X: Double): Double;'
      'begin'
      '  FClearExcept;'
      '  if X < 0 then FRaiseExcept(feeINVALID);'
      '  Result := libm_sqrt(X);'
      '  FCheckExcept;'
      'end;'
      '{$ENDIF}'
      '{$ELSE }'
      '{$IF defined(EXTENDEDHAS10BYTES)}'
      'function Sqrt(const X: Extended): Extended;'
      '{$ELSE}'
      'function Sqrt(const X: Double): Double;'
      '{$ENDIF}'
      'begin'
      '  Error(rePlatformNotImplemented);'
      '  Result := 0;'
      'end;'
      '{$ENDIF }'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       functions & procedures that need compiler magic }'
      '{ ----------------------------------------------------- }'
      ''
      '{$IF defined(CPUX64) and defined(ASSEMBLER)}'
      'function _Round(Val: Extended): Int64;'
      'asm'
      '        .NOFRAME'
      '        CVTSD2SI        RAX, XMM0'
      'end;'
      '{$ELSEIF defined(X86ASMRTL)}'
      'procedure _ROUND;'
      'asm'
      '        { ->    FST(0)  Extended argument       }'
      '        { <-    EDX:EAX Result                  }'
      ''
      '        SUB     ESP,12'
      '{$IFDEF IOS} // iOS/Simulator'
      '        CALL    FClearExcept'
      '{$ENDIF IOS}'
      '        FISTP   qword ptr [ESP+4]'
      '        FWAIT'
      '{$IFDEF IOS} // iOS/Simulator'
      '        CALL    FCheckExcept'
      '{$ENDIF IOS}'
      '        POP     ECX'
      '        POP     EAX'
      '        POP     EDX'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      '{$IFDEF EXTENDEDHAS10BYTES}'
      'function llrintl(x: Extended): Int64; cdecl;'
      '  external libmmodulename name _PU + '#39'llrintl'#39';'
      ''
      'function _Round(Val: Extended): Int64;'
      'type'
      '  TWords = Array[0..4] of Word;'
      '  PWords = ^TWords;'
      'begin'
      '  if (PWords(@Val)^[4] and $7FFF) >= $403F then'
      '    FRaiseExcept(feeINVALID);'
      '  Result := llrintl(Val);'
      'end;'
      '{$ELSE}'
      'function llrint(x: Double): Int64; cdecl;'
      '  external libmmodulename name _PU + '#39'llrint'#39';'
      ''
      'function _Round(Val: Extended): Int64;'
      'type'
      '  TWords = array[0..3] of Word;'
      '  PWords = ^TWords;'
      'begin'
      '  if (PWords(@Val)^[3] and $7FFF) >= $43E0 then'
      '    FRaiseExcept(feeINVALID);'
      '  Result := llrint(Val);'
      'end;'
      '{$ENDIF}'
      '{$ELSE}'
      'function _Round(Val: Extended): Int64;'
      'begin'
      '  Error(rePlatformNotImplemented);'
      '  Result := 0;'
      'end;'
      '{$ENDIF}'
      ''
      
        '                                                                ' +
        '              '
      '{$IF defined(CPUARM)}'
      'function _RoundU(Val: Extended): UInt64;'
      'const'
      '  C: Extended = $8000000000000000;'
      'begin'
      '  Result := 0;'
      '  if Val >= C then'
      '  begin'
      '    Val := Val - C;'
      '    Result := $8000000000000000;'
      '  end;'
      '  Result := Result + UInt64(Round(Val));'
      'end;'
      '{$ENDIF}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _RoundCurrency(Val: Currency): Int64;'
      'var'
      '  I, R: Int64;'
      '  RoundingMode : UInt32;'
      'begin'
      '  I := PInt64(@Val)^;'
      '  Result := I div 10000;'
      '  R := I mod 10000;'
      ''
      '  RoundingMode := FGetRound;'
      ''
      '  if Result > 0 then'
      '  begin'
      '    case RoundingMode of'
      '      ferTONEAREST:'
      '        if (R > 5000) or ((R = 5000) and odd(Result)) then'
      '          Result := Result + 1;'
      '      ferUPWARD:'
      '        if R > 0 then Result := Result + 1;'
      '    end;'
      '  end'
      '  else'
      '  begin'
      '    case RoundingMode of'
      '      ferTONEAREST:'
      '        if (R < -5000) or ((R = -5000) and odd(Result)) then'
      '          Result := Result - 1;'
      '      ferDOWNWARD:'
      '        if R < 0 then Result := Result - 1;'
      '    end;'
      '  end'
      'end;'
      '{$ENDIF}'
      ''
      '{$IF defined(CPUX64) and defined(ASSEMBLER)}'
      'function _Trunc(Val: Extended): Int64;'
      'asm'
      '        .NOFRAME'
      '        CVTTSD2SI RAX, XMM0'
      'end;'
      '{$ELSEIF defined(X86ASMRTL)}'
      'procedure _TRUNC;'
      'asm'
      '        { ->    FST(0)  Extended argument       }'
      '        { <-    EDX:EAX Result                  }'
      ''
      '        SUB     ESP,12'
      '{$IFDEF IOS} // iOS/Simulator'
      '        CALL    FClearExcept'
      '{$ENDIF IOS}'
      '        FNSTCW  [ESP].Word          // save'
      '        FNSTCW  [ESP+2].Word        // scratch'
      '        FWAIT'
      
        '        OR      [ESP+2].Word, $0F00  // trunc toward zero, full ' +
        'precision'
      '        FLDCW   [ESP+2].Word'
      '        FISTP   qword ptr [ESP+4]'
      '        FWAIT'
      '        FLDCW   [ESP].Word'
      '{$IFDEF IOS} // iOS/Simulator'
      '        CALL    FCheckExcept'
      '{$ENDIF IOS}'
      '        POP     ECX'
      '        POP     EAX'
      '        POP     EDX'
      'end;'
      '{$ELSEIF defined(ARITH_USE_LIBM)}'
      '{$IFDEF EXTENDEDHAS10BYTES}'
      'function _Trunc(Val: Extended): Int64;'
      'var'
      '  SavedRoundMode: Int32;'
      'type'
      '  TWords = Array[0..4] of Word;'
      '  PWords = ^TWords;'
      'begin'
      '  if (PWords(@Val)^[4] and $7FFF) >= $403F then'
      '    FRaiseExcept(feeINVALID);'
      '  SavedRoundMode := FSetRound(ferTOWARDZERO);'
      '  Result := llrintl(Val);'
      '  FSetRound(SavedRoundMode);'
      'end;'
      '{$ELSE}'
      'function _Trunc(Val: Extended): Int64;'
      'var'
      '  SavedRoundMode: Int32;'
      'type'
      '  TWords = Array[0..3] of Word;'
      '  PWords = ^TWords;'
      'begin'
      '  if (PWords(@Val)^[3] and $7FFF) >= $43E0 then'
      '    FRaiseExcept(feeINVALID);'
      '  SavedRoundMode := FSetRound(ferTOWARDZERO);'
      '  Result := llrint(Val);'
      '  FSetRound(SavedRoundMode);'
      'end;'
      '{$ENDIF}'
      '{$ELSE}'
      'function _Trunc(Val: Extended): Int64;'
      'begin'
      '  Error(rePlatformNotImplemented);'
      '  Result := 0;'
      'end;'
      '{$ENDIF}'
      ''
      '{$IF defined(CPUX64) and defined(ASSEMBLER)}'
      'function _Abs(Val: Extended): Extended;'
      'const'
      '  ABSMASK : UInt64 = $7FFFFFFFFFFFFFFF;'
      'asm'
      '        .NOFRAME'
      '        MOVSD   XMM1, ABSMASK'
      '        PAND    XMM0, XMM1'
      'end;'
      '{$ELSE}'
      'function _Abs(Val: Extended): Extended;'
      'type'
      '  PWordArray = ^TWordArray;'
      '  TWordArray = array[0..16383] of Word;'
      'const'
      '  WordSize = {$IFDEF EXTENDEDHAS10BYTES} 5 {$ELSE} 4 {$ENDIF};'
      'begin'
      '  Result := Val;'
      
        '  PWordArray(@Result)^[WordSize-1] := PWordArray(@Result)^[WordS' +
        'ize-1] and $7FFF; // strip sign bit.'
      'end;'
      '{$ENDIF}'
      ''
      
        '                                                                ' +
        '                                                     '
      
        '{$IF defined(CPUARM) or defined(CPUX86) or defined(EXTERNALLINKE' +
        'R)}'
      
        'function _MulDivModInt64(AValue, AMul, ADiv: Int64; Remainder: P' +
        'Int64): Int64;'
      'var'
      '  HVal, Temp, LVal, HRes, LRes: UInt64;'
      '  Sign: Byte;'
      'begin'
      '  // This function is used by division or multiply operator'
      '  // for scaling '#39'Comp'#39' value'
      
        '  // eq. Result := Int64((Int128(AValue) * Int128(AMul)) div ADi' +
        'v);'
      
        '  // or  Result := Int64((Extended80(AValue) * Extended80(AMul))' +
        ' / Extended80(ADiv));'
      '  Sign := 0;'
      '  if AValue < 0 then'
      '  begin'
      '    AValue := - AValue;'
      '    Sign := Sign xor 3;'
      '  end;'
      '  if AMul < 0 then'
      '  begin'
      '    AMul := - AMul;'
      '    Sign := Sign xor 1;'
      '  end;'
      '  if ADiv < 0 then'
      '  begin'
      '    ADiv := - ADiv;'
      '    Sign := Sign xor 1;'
      '  end;'
      '  //'
      '  // Int128(HVal:LVal) := Int128(AValue) * Int128(AMul);'
      '  //'
      
        '  HVal := UInt64(UInt32(AValue shr 32)) * UInt64(UInt32(AMul shr' +
        ' 32));'
      '  Temp := UInt64(UInt32(AValue shr 32)) * UInt64(UInt32(AMul))'
      '        + UInt64(UInt32(AValue)) * UInt64(UInt32(AMul shr 32));'
      '  LVal := UInt64(UInt32(AValue)) * UInt64(UInt32(AMul));'
      '  Temp := Temp + (LVal shr 32);'
      '  LVal := (Temp shl 32) + UInt64(UInt32(LVal));'
      '  HVal := HVal + (Temp shr 32);'
      '  //'
      '  // Result := Int128(HVal:LVal) div ADiv;'
      '  //'
      '  //URes := HVal div UInt64(ADiv);'
      '  Temp := HVal mod UInt64(ADiv);'
      '  Temp := (Temp shl 32) + (LVal shr 32);'
      '  HRes := Temp div UInt64(ADiv);'
      '  Temp := Temp mod UInt64(ADiv);'
      '  Temp := (Temp shl 32) + UInt64(UInt32(LVal));'
      '  LRes := Temp div UInt64(ADiv);'
      '  Result := (HRes shl 32) + LRes;'
      '  if (Sign and 1) <> 0  then'
      '    Result := - Result;'
      '  if Assigned(Remainder) then'
      '  begin'
      '    Remainder^ := Temp mod UInt64(ADiv);'
      '    if (Sign and 2) <> 0  then'
      '      Remainder^ := - Remainder^;'
      '  end;'
      'end;'
      '{$ENDIF CPUARM or CPUX86}'
      ''
      
        '                                                                ' +
        '                               '
      
        '{$IF defined(CPUARM) or defined(CPUX86) or defined(EXTERNALLINKE' +
        'R)}'
      'function _MulDivInt64(AValue, AMul, ADiv: Int64): Int64;'
      'begin'
      '  Result := _MulDivModInt64(AValue, AMul, ADiv, nil);'
      'end;'
      '{$ENDIF CPUARM or CPUX86 or EXTERNALLINKER}'
      ''
      '{$IF defined(CPUX64) or defined(CPUARM)}'
      'function _MulDivComp(AValue, AMul, ADiv: Int64): Int64;'
      'var'
      '  Reaminder: Int64;'
      '  Temp: UInt64;'
      '  RoundingMode : UInt32;'
      '  IncDec: Int64;'
      'const'
      '  Half = UInt64(1) shl 31;'
      'begin'
      '  Result := MulDivInt64(AValue, AMul, ADiv, Reaminder);'
      '  if Reaminder < 0 then'
      '    Reaminder := - Reaminder;'
      '  IncDec := 1;'
      '  if Result < 0 then'
      '    IncDec := -1;'
      '  RoundingMode := FGetRound;'
      '  if RoundingMode <> ferTOWARDZERO then'
      '  begin'
      '    Temp := UInt64(Reaminder shl 32);'
      '    Temp := Temp div UInt64(ADiv);'
      '    case RoundingMode of'
      '      ferTONEAREST:'
      '        if (Temp > Half) or ((Temp = Half) and Odd(Result)) then'
      '          Inc(Result, IncDec);'
      '      ferUPWARD:'
      '        if (Temp > 0) and (IncDec > 0) then'
      '          Inc(Result, IncDec);'
      '      ferDOWNWARD:'
      '        if (Temp > 0) and (IncDec < 0) then'
      '          Inc(Result, IncDec);'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF CPUX64 or CPUARM}'
      ''
      'procedure _AbstractError;'
      'begin'
      '  if Assigned(AbstractErrorProc) then'
      '    AbstractErrorProc;'
      '  RunErrorAt(210, ReturnAddress);'
      'end;'
      ''
      'function TextOpen(var t: TTextRec): Integer; forward;'
      ''
      'procedure __FlushMBCSBuffer(var t: TTextRec);'
      'begin'
      '  t.MBCSLength := 0;'
      '  t.MBCSBufPos := 0;'
      'end;'
      ''
      'function OpenText(var t: TTextRec; Mode: Word): Integer;'
      'begin'
      '  if (t.Mode < fmClosed) or (t.Mode > fmInOut) then'
      '    Result := 102'
      '  else'
      '  begin'
      '    __FlushMBCSBuffer(t);'
      '    if t.Mode <> fmClosed then _Close(t);'
      '    t.Mode := Mode;'
      '    if (t.Name[0] = #0) and (t.OpenFunc = nil) then  // stdio'
      '      t.OpenFunc := @TextOpen;'
      '    Result := TTextIOFunc(t.OpenFunc)(t);'
      '  end;'
      '  if Result <> 0 then SetInOutRes(Result);'
      'end;'
      ''
      'function _ResetText(var t: TTextRec): Integer;'
      'begin'
      '  Result := OpenText(t, fmInput);'
      'end;'
      ''
      'function _RewritText(var t: TTextRec): Integer;'
      'begin'
      '  Result := OpenText(t, fmOutput);'
      'end;'
      ''
      'function _Append(var t: TTextRec): Integer;'
      'begin'
      '  Result := OpenText(t, fmInOut);'
      'end;'
      ''
      'function TextIn(var t: TTextRec): Integer;'
      'const'
      '  ERROR_BROKEN_PIPE = 109;'
      'begin'
      '  t.BufEnd := 0;'
      '  t.BufPos := 0;'
      '{$IFDEF MSWINDOWS}'
      
        '  if not ReadFile(t.Handle, t.BufPtr, t.BufSize, t.BufEnd, nil) ' +
        'then'
      '  begin'
      '    Result := GetLastError;'
      '    if Result = ERROR_BROKEN_PIPE then'
      
        '      Result := 0; // NT quirk: got "broken pipe"? it'#39's really e' +
        'of'
      '  end'
      '  else'
      '    Result := 0;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '  t.BufEnd := __read(t.Handle, t.BufPtr, t.BufSize);'
      '  if Integer(t.BufEnd) = -1 then'
      '  begin'
      '    t.BufEnd := 0;'
      '    Result := GetLastError;'
      '  end'
      '  else'
      '    Result := 0;'
      '{$ENDIF POSIX}'
      'end;'
      ''
      'function FileNOPProc(var t): Integer;'
      'begin'
      '  Result := 0;'
      'end;'
      ''
      'function TextOut(var t: TTextRec): Integer;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Dummy: Cardinal;'
      '{$ENDIF}'
      'begin'
      '  if t.BufPos = 0 then'
      '    Result := 0'
      '  else'
      '  begin'
      '{$IFDEF MSWINDOWS}'
      
        '    if not WriteFile(t.Handle, t.BufPtr, t.BufPos, Dummy, nil) t' +
        'hen'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '    if __write(t.Handle, t.BufPtr, t.BufPos) = ssize_t(-1) then'
      '{$ENDIF POSIX}'
      '      Result := GetLastError'
      '    else'
      '      Result := 0;'
      '    t.BufPos := 0;'
      '  end;'
      'end;'
      ''
      'function InternalClose(Handle: THandle): Boolean;'
      'begin'
      '{$IFDEF MSWINDOWS}'
      '  Result := CloseHandle(Handle);'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '  Result := __close(Handle) = 0;'
      '{$ENDIF POSIX}'
      'end;'
      ''
      'function TextClose(var t: TTextRec): Integer;'
      'begin'
      '  t.Mode := fmClosed;'
      '  if not InternalClose(t.Handle) then'
      '    Result := GetLastError'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      'function TextOpenCleanup(var t: TTextRec): Integer;'
      'begin'
      '  InternalClose(t.Handle);'
      '  t.Mode := fmClosed;'
      '  Result := GetLastError;'
      'end;'
      ''
      'function TextOpen(var t: TTextRec): Integer;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  OpenMode: DWORD;'
      '  Flags: Integer;'
      '  Std: DWORD;'
      '  Temp: THandle;'
      '  TempSize: Integer;'
      '  I, BytesRead: Cardinal;'
      'begin'
      '  Result := 0;'
      '  t.BufPos := 0;'
      '  t.BufEnd := 0;'
      '  case t.Mode of'
      '    fmInput: // called by Reset'
      '      begin'
      '        OpenMode := GENERIC_READ;'
      '        Flags := OPEN_EXISTING;'
      '        t.InOutFunc := @TextIn;'
      '      end;'
      '    fmOutput: // called by Rewrite'
      '      begin'
      '        OpenMode := GENERIC_WRITE;'
      '        Flags := CREATE_ALWAYS;'
      '        t.InOutFunc := @TextOut;'
      '      end;'
      '    fmInOut:  // called by Append'
      '      begin'
      '        OpenMode := GENERIC_READ or GENERIC_WRITE;'
      '        Flags := OPEN_EXISTING;'
      '        t.InOutFunc := @TextOut;'
      '      end;'
      '  else'
      '    Exit;'
      '  end;'
      ''
      '  t.FlushFunc := @FileNOPProc;'
      ''
      '  if t.Name[0] = #0 then  // stdin or stdout'
      '  begin'
      
        '    if t.BufPtr = nil then  // don'#39't overwrite bufptr provided b' +
        'y SetTextBuf'
      '    begin'
      '      t.BufPtr := @t.Buffer;'
      '      t.BufSize := SizeOf(t.Buffer);'
      '    end;'
      '    t.CloseFunc := @FileNOPProc;'
      '    if t.Mode = fmOutput then'
      '    begin'
      '      if @t = @ErrOutput then'
      '        Std := STD_ERROR_HANDLE'
      '      else'
      '        Std := STD_OUTPUT_HANDLE;'
      '      t.Handle := GetStdHandle(Std);'
      '    end'
      '    else'
      '      t.Handle := GetStdHandle(STD_INPUT_HANDLE);'
      '    if t.CodePage = 0 then'
      '    begin'
      '      if GetFileType(t.Handle) = 2 then'
      '      begin'
      '        if t.Mode = fmOutput then'
      '          t.CodePage := GetConsoleOutputCP'
      '        else'
      '          t.CodePage := GetConsoleCP;'
      '      end'
      '      else'
      '        t.CodePage := DefaultSystemCodePage;'
      '    end'
      '  end'
      '  else'
      '  begin'
      '    t.CloseFunc := @TextClose;'
      
        '    Temp := CreateFile(t.Name, OpenMode, FILE_SHARE_READ, nil, F' +
        'lags, FILE_ATTRIBUTE_NORMAL, 0);'
      '    if Temp = THandle(-1) then'
      '    begin'
      '      t.Mode := fmClosed;'
      '      Result := GetLastError;'
      '      Exit;'
      '    end;'
      '    t.Handle := Temp;'
      '    if t.Mode = fmInOut then      // Append mode'
      '    begin'
      '      t.Mode := fmOutput;'
      ''
      '      TempSize := GetFileSize(t.Handle, nil);'
      '      if TempSize = -1 then'
      '      begin'
      '        Result := TextOpenCleanup(t);'
      '        Exit;'
      '      end;'
      ''
      '      Dec(TempSize, 128);'
      '      if TempSize < 0 then TempSize := 0;'
      ''
      
        '      if (Integer(SetFilePointer(t.Handle, TempSize, nil, FILE_B' +
        'EGIN)) = -1) or'
      
        '         (not ReadFile(t.Handle, @(t.Buffer), 128, BytesRead, ni' +
        'l)) then'
      '      begin'
      '        Result := TextOpenCleanup(t);'
      '        Exit;'
      '      end;'
      ''
      
        '      if (t.Flags and tfCRLF) <> 0 then  // DOS mode, EOF signif' +
        'icant'
      '      begin  // scan for EOF char in last 128 byte sector.'
      '        if BytesRead > 0 then'
      '          for I := 0 to BytesRead - 1 do'
      '          begin'
      '            if t.Buffer[I] = _AnsiChr(cEOF) then'
      '            begin  // truncate the file here'
      
        '              if (Integer(SetFilePointer(t.Handle, I - BytesRead' +
        ', nil, FILE_END)) = -1) or'
      '                (not SetEndOfFile(t.Handle)) then'
      '              begin'
      '                Result := TextOpenCleanup(t);'
      '                Exit;'
      '              end;'
      '              Break;'
      '            end;'
      '          end;'
      '      end;'
      '    end;'
      '    if t.CodePage = 0 then'
      '      t.CodePage := DefaultSystemCodePage;'
      '  end;'
      '  if t.Mode <> fmInput then'
      '  begin'
      '    case GetFileType(t.Handle) of'
      '      0: begin  // bad file type'
      '           TextOpenCleanup(t);'
      '           Result := 105;'
      '           Exit;'
      '         end;'
      '      2: t.FlushFunc := @TextOut;'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'var'
      '  Flags: Integer;'
      '  Temp, I: Integer;'
      '  BytesRead: Integer;'
      '  us: _UTF8Str;'
      'begin'
      '  Result := 0;'
      '  t.BufPos := 0;'
      '  t.BufEnd := 0;'
      '  case t.Mode of'
      '    fmInput: // called by Reset'
      '      begin'
      '        Flags := O_RDONLY;'
      '        t.InOutFunc := @TextIn;'
      '      end;'
      '    fmOutput: // called by Rewrite'
      '      begin'
      '        Flags := O_CREAT or O_TRUNC or O_WRONLY;'
      '        t.InOutFunc := @TextOut;'
      '      end;'
      '    fmInOut:  // called by Append'
      '      begin'
      '        Flags := O_APPEND or O_RDWR;'
      '        t.InOutFunc := @TextOut;'
      '      end;'
      '  else'
      '    Exit;'
      '    Flags := 0;'
      '  end;'
      ''
      '  t.FlushFunc := @FileNOPProc;'
      ''
      '  if t.Name[0] = #0 then  // stdin or stdout'
      '  begin'
      
        '    if t.BufPtr = nil then  // don'#39't overwrite bufptr provided b' +
        'y SetTextBuf'
      '    begin'
      '      t.BufPtr := @t.Buffer;'
      '      t.BufSize := sizeof(t.Buffer);'
      '    end;'
      '    t.CloseFunc := @FileNOPProc;'
      '    if t.Mode = fmOutput then'
      '    begin'
      '      if @t = @ErrOutput then'
      '        t.Handle := STDERR_FILENO'
      '      else'
      '        t.Handle := STDOUT_FILENO;'
      '      t.FlushFunc := @TextOut;'
      '    end'
      '    else'
      '      t.Handle := STDIN_FILENO;'
      '    t.CodePage := CP_UTF8;'
      '  end'
      '  else'
      '  begin'
      '    t.CloseFunc := @TextClose;'
      ''
      '    us := _UTF8Str(t.Name);'
      '    Temp := open(_PAnsiChr(us), Flags, FileAccessRights);'
      '    if Temp = -1 then'
      '    begin'
      '      t.Mode := fmClosed;'
      '      Result := GetLastError;'
      '      Exit;'
      '    end;'
      ''
      '    t.Handle := Temp;'
      ''
      '    if t.Mode = fmInOut then      // Append mode'
      '    begin'
      '      t.Mode := fmOutput;'
      ''
      
        '      if (t.Flags and tfCRLF) <> 0 then  // DOS mode, EOF signif' +
        'icant'
      '      begin  // scan for EOF char in last 128 byte sector.'
      '        Temp := lseek(t.Handle, 0, SEEK_END);'
      '        if Temp = -1 then'
      '        begin'
      '          Result := TextOpenCleanup(t);'
      '          Exit;'
      '        end;'
      ''
      '        Dec(Temp, 128);'
      '        if Temp < 0 then Temp := 0;'
      ''
      '        if lseek(t.Handle, Temp, SEEK_SET) = -1 then'
      '        begin'
      '          Result := TextOpenCleanup(t);'
      '          Exit;'
      '        end;'
      ''
      '        BytesRead := __read(t.Handle, t.BufPtr, 128);'
      '        if BytesRead = -1 then'
      '        begin'
      '          Result := TextOpenCleanup(t);'
      '          Exit;'
      '        end;'
      ''
      '        for I := 0 to BytesRead - 1 do'
      '        begin'
      '          if t.Buffer[I] = _AnsiChr(cEOF) then'
      '          begin  // truncate the file here'
      
        '            if ftruncate(t.Handle, lseek(t.Handle, I - BytesRead' +
        ', SEEK_END)) = -1 then'
      '            begin'
      '              Result := TextOpenCleanup(t);'
      '              Exit;'
      '            end;'
      '            Break;'
      '          end;'
      '        end;'
      '      end;'
      '    end;'
      '    if t.CodePage = 0 then'
      '      t.CodePage := DefaultSystemCodePage;'
      '  end;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      'const'
      '  fNameLen = 259;'
      ''
      'function _AssignFile(var t: TFileRec; const s: PChar): Integer;'
      'var'
      '  Len: Integer;'
      'begin'
      '  FillChar(t, SizeOf(TFileRec), 0);'
      '  t.BufPtr := NIL;'
      '  t.Mode := fmClosed;'
      '  t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);'
      '  t.BufSize := 0;'
      '  t.OpenFunc := @TextOpen;'
      '  Len := _PWCharLen(s);'
      '  if Len >  fNameLen then'
      '  begin'
      '    SetInOutRes(3);'
      '    Len :=  fNameLen;'
      '  end;'
      '  MoveChars(s^, t.Name, Len);'
      '  t.Name[Len] := #0;'
      '  Result := 0;'
      'end;'
      ''
      
        'function _AssignText(var t: TTextRec; const s: PChar; const CP: ' +
        'word): Integer;'
      'var'
      '  Len: Integer;'
      'begin'
      '  FillChar(t, SizeOf(TTextRec), 0);'
      '  t.BufPtr := @t.Buffer;'
      '  t.Mode := fmClosed;'
      '  t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);'
      '  if CP = 0 then'
      '    t.CodePage := DefaultSystemCodePage'
      '  else'
      '    t.CodePage := CP;'
      '  t.BufSize := SizeOf(t.Buffer);'
      '  t.OpenFunc := @TextOpen;'
      '  Len := _PWCharLen(s);'
      '  if Len > fNameLen then'
      '  begin'
      '    SetInOutRes(3);'
      '    Len := fNameLen;'
      '  end;'
      '  MoveChars(s^, t.Name, Len);'
      '  t.Name[Len] := #0;'
      '  t.MBCSLength := 0;'
      '  Result := 0;'
      'end;'
      ''
      
        'function InternalFlush(var t: TTextRec; Func: TTextIOFunc): Inte' +
        'ger;'
      'begin'
      '  case t.Mode of'
      '    fmOutput,'
      '    fmInOut  : Result := Func(t);'
      '    fmInput  : Result := 0;'
      '  else'
      '    if (@t = @Output) or (@t = @ErrOutput) then'
      '      Result := 0'
      '    else'
      '      Result := 103;'
      '  end;'
      '  if Result <> 0 then SetInOutRes(Result);'
      'end;'
      ''
      'function Flush(var t: Text): Integer;'
      'begin'
      '  Result := InternalFlush(TTextRec(t), TTextRec(t).InOutFunc);'
      'end;'
      ''
      'function _Flush(var t: TTextRec): Integer;'
      'begin'
      '  Result := InternalFlush(t, t.FlushFunc);'
      'end;'
      ''
      'type'
      '{$IFDEF MSWINDOWS}'
      
        '  TIOProc = function (hFile: THandle; Buffer: Pointer; nNumberOf' +
        'BytesToWrite: DWORD;'
      
        '  var lpNumberOfBytesWritten: DWORD; lpOverlapped: Pointer): BOO' +
        'L; stdcall;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      
        '  TIOProc = function (Handle: Integer; Buffer: Pointer; Count: s' +
        'ize_t): ssize_t; cdecl;'
      '{$ENDIF POSIX}'
      ''
      
        'function BlockIO(var f: TFileRec; buffer: Pointer; recCnt: Integ' +
        'er; RecsDone: PInteger;'
      
        '  ModeMask: Integer; IOProc: TIOProc; ErrorNo: Integer): Integer' +
        ';'
      '// Note:  RecsDone ptr can be nil!'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Res: DWORD;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'var'
      '  Res: ssize_t;'
      '{$ENDIF POSIX}'
      'begin'
      
        '  if (f.Mode and ModeMask) = ModeMask then  // fmOutput or fmInO' +
        'ut / fmInput or fmInOut'
      '  begin'
      '{$IFDEF POSIX}'
      
        '    Res := IOProc(F.Handle, Buffer, ssize_t(RecCnt) * ssize_t(F.' +
        'RecSize));'
      '    if Res = -1 then'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      
        '    if not IOProc(F.Handle, Buffer, Cardinal(RecCnt) * F.RecSize' +
        ', Res, nil) then'
      '{$ENDIF MSWINDOWS}'
      '    begin'
      '      SetInOutRes(GetLastError);'
      '      Result := 0;'
      '    end'
      '    else'
      '    begin'
      '{$IFDEF POSIX}'
      '      Result := Integer(Res div ssize_t(f.RecSize));'
      '{$ELSE}'
      '      Result := Integer(Res div f.RecSize);'
      '{$ENDIF}'
      '      if RecsDone <> nil then'
      '        RecsDone^ := Result'
      '      else if Result <> RecCnt then'
      '      begin'
      '        SetInOutRes(ErrorNo);'
      '        Result := 0;'
      '      end'
      '    end;'
      '  end'
      '  else'
      '  begin'
      '    SetInOutRes(103);  // file not open'
      '    Result := 0;'
      '  end;'
      'end;'
      ''
      
        'function _BlockRead(var F: TFileRec; Buffer: Pointer; RecCnt: In' +
        'teger; RecsRead: PInteger): Integer;'
      'begin'
      '  Result := BlockIO(F, Buffer, RecCnt, RecsRead, fmInput,'
      '    {$IFDEF MSWINDOWS} ReadFile, {$ENDIF}'
      '    {$IFDEF POSIX} __read, {$ENDIF}'
      '    100);'
      'end;'
      ''
      
        'function _BlockWrite(var F: TFileRec; Buffer: Pointer; RecCnt: I' +
        'nteger; RecsWritten: PInteger): Integer;'
      'begin'
      '  Result := BlockIO(F, Buffer, RecCnt, RecsWritten, fmOutput,'
      '  {$IFDEF MSWINDOWS} WriteFile, {$ENDIF}'
      '  {$IFDEF POSIX} __write, {$ENDIF}'
      '  101);'
      'end;'
      ''
      'function _Close(var t: TTextRec): Integer;'
      'begin'
      '  Result := 0;'
      '  if (t.Mode >= fmInput) and (t.Mode <= fmInOut) then'
      '  begin'
      
        '    if (t.Mode and fmOutput) = fmOutput then  // fmOutput or fmI' +
        'nOut'
      '      Result := TTextIOFunc(t.InOutFunc)(t);'
      '    if Result = 0 then'
      '      Result := TTextIOFunc(t.CloseFunc)(t);'
      '    if Result <> 0 then'
      '      SetInOutRes(Result);'
      '  end'
      '  else'
      '  if @t <> @Input then'
      '    SetInOutRes(103);'
      'end;'
      ''
      'function _EofFile(var f: TFileRec): Boolean;'
      'begin'
      '  Result := _FilePos(f) >= _FileSize(f);'
      'end;'
      ''
      
        'function _GetAnsiChar(var t: TTextRec; var IsEof: Boolean; codep' +
        'age: word): Byte; forward;'
      
        'function _GetWideChar(var t: TTextRec; var IsEof: Boolean): Word' +
        '; forward;'
      'procedure _SkipAnsiChar(var t: TTextRec); forward;'
      'procedure _SkipWideChar(var t: TTextRec); forward;'
      ''
      
        'function _ReadByte(var t: TTextRec; var IsEof: Boolean): Byte; f' +
        'orward;'
      ''
      'function _EofText(var t: TTextRec): Boolean;'
      'begin'
      '  if t.MBCSLength <> 0 then Exit(False)'
      '  else'
      '  begin'
      '    _ReadByte(t, Result);'
      '    if Not Result then'
      '      Dec(t.BufPos);'
      '  end;'
      'end;'
      ''
      'function _Eoln(var t: TTextRec): Boolean;'
      'var'
      '  c: Word;'
      '  eof: Boolean;'
      'begin'
      '  if t.MBCSLength <> 0 then'
      '  begin'
      '    if t.MBCSLength > 0 then'
      '      c := Word(_GetAnsiChar(t, eof, DefaultSystemCodePage))'
      '    else'
      '      c := _GetWideChar(t, eof);'
      '    if eof then Exit(True);'
      '  end'
      '  else'
      '  begin'
      '    c := word(_ReadByte(t, eof));'
      '    if eof then Exit(True)'
      '    else Dec(t.BufPos);'
      '  end;'
      ''
      '  if (t.Flags and tfCRLF) <> 0 then'
      '    Result := (c = cCR) or (c = cEOF)'
      '  else'
      '    Result := (c = cLF) or (c = cEOF);'
      'end;'
      ''
      'procedure _Erase(var f: TFileRec);'
      'begin'
      '  if (f.Mode < fmClosed) or (f.Mode > fmInOut) then'
      '    SetInOutRes(102)  // file not assigned'
      '  else begin'
      '{$IFDEF MSWINDOWS}'
      '    if not DeleteFile(f.Name) then'
      '      SetInOutRes(GetLastError);'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '    if remove(_PAnsiChr(UTF8Encode(f.Name))) < 0 then'
      '       SetInOutRes(GetLastError);'
      '{$ENDIF POSIX}'
      '  end;'
      'end;'
      ''
      '{$IFDEF WIN32}'
      '// Floating-point divide reverse routine'
      '// ST(1) = ST(0) / ST(1), pop ST'
      ''
      'procedure _FSafeDivideR;'
      'asm'
      '  FXCH'
      '  JMP _FSafeDivide'
      'end;'
      ''
      '// Floating-point divide routine'
      '// ST(1) = ST(1) / ST(0), pop ST'
      ''
      'procedure _FSafeDivide;'
      'type'
      
        '  Z = packed record  // helper type to make parameter references' +
        ' more readable'
      '    Dividend: Extended;   // (TBYTE PTR [ESP])'
      '    Pad: Word;'
      '    Divisor: Extended;    // (TBYTE PTR [ESP+12])'
      '  end;'
      'asm'
      '        CMP       TestFDIV,0        //Check FDIV indicator'
      
        '        JLE       @@FDivideChecked  //Jump if flawed or don'#39't kn' +
        'ow'
      
        '        FDIV                        //Known to be ok, so just do' +
        ' FDIV'
      '        RET'
      ''
      '// FDIV constants'
      '@@FDIVRiscTable: DB 0,1,0,0,4,0,0,7,0,0,10,0,0,13,0,0;'
      ''
      '@@FDIVScale1:    DD $3F700000             // 0.9375'
      '@@FDIVScale2:    DD $3F880000             // 1.0625'
      '@@FDIV1SHL63:    DD $5F000000             // 1 SHL 63'
      ''
      '@@TestDividend:  DD $C0000000,$4150017E   // 4195835.0'
      '@@TestDivisor:   DD $80000000,$4147FFFF   // 3145727.0'
      '@@TestOne:       DD $00000000,$3FF00000   // 1.0'
      ''
      '// Flawed FDIV detection'
      '@@FDivideDetect:'
      
        '        MOV     TestFDIV,1                //Indicate correct FDI' +
        'V'
      '        PUSH    EAX'
      '        SUB     ESP,12'
      '        FSTP    TBYTE PTR [ESP]           //Save off ST'
      
        '        FLD     QWORD PTR @@TestDividend  //Ok if x - (x / y) * ' +
        'y < 1.0'
      '        FDIV    QWORD PTR @@TestDivisor'
      '        FMUL    QWORD PTR @@TestDivisor'
      '        FSUBR   QWORD PTR @@TestDividend'
      '        FCOMP   QWORD PTR @@TestOne'
      '        FSTSW   AX'
      '        SHR     EAX,7'
      '        AND     EAX,002H          //Zero if FDIV is flawed'
      '        DEC     EAX'
      '        MOV     TestFDIV,AL       //1 means Ok, -1 means flawed'
      '        FLD     TBYTE PTR [ESP]   //Restore ST'
      '        ADD     ESP,12'
      '        POP     EAX'
      '        JMP     _FSafeDivide'
      ''
      '@@FDivideChecked:'
      '        JE      @@FDivideDetect   //Do detection if TestFDIV = 0'
      '@@1:'
      '        PUSH    EAX'
      '        SUB     ESP,24'
      '        FSTP    [ESP].Z.Divisor     //Store Divisor and Dividend'
      '        FSTP    [ESP].Z.Dividend'
      '        FLD     [ESP].Z.Dividend'
      '        FLD     [ESP].Z.Divisor'
      '@@2:'
      
        '        MOV     EAX,DWORD PTR [ESP+4].Z.Divisor   //Is Divisor a' +
        ' denormal?'
      '        ADD     EAX,EAX'
      '        JNC     @@20            //Yes, @@20'
      
        '        XOR     EAX,0E000000H   //If these three bits are not al' +
        'l'
      '        TEST    EAX,0E000000H   //ones, FDIV will work'
      '        JZ      @@10            //Jump if all ones'
      '@@3:'
      '        FDIV                    //Do FDIV and exit'
      '        ADD     ESP,24'
      '        POP     EAX'
      '        RET'
      '@@10:'
      '        SHR     EAX,28      //If the four bits following the MSB'
      '                            //of the mantissa have a decimal'
      '                            //of 1, 4, 7, 10, or 13, FDIV may'
      
        '        CMP     byte ptr @@FDIVRiscTable[EAX],0 //not work corre' +
        'ctly'
      '        JZ      @@3     //Do FDIV if not 1, 4, 7, 10, or 13'
      
        '        MOV     EAX,DWORD PTR [ESP+8].Z.Divisor //Get Divisor ex' +
        'ponent'
      '        AND     EAX,7FFFH'
      '        JZ      @@3     //Ok to FDIV if denormal'
      '        CMP     EAX,7FFFH'
      '        JE      @@3     //Ok to FDIV if NAN or INF'
      
        '        MOV     EAX,DWORD PTR [ESP+8].Z.Dividend //Get Dividend ' +
        'exponent'
      '        AND     EAX,7FFFH'
      '        CMP     EAX,1     //Small number?'
      '        JE      @@11      //Yes, @@11'
      '        FMUL    DWORD PTR @@FDIVScale1  //Scale by 15/16'
      '        FXCH'
      '        FMUL    DWORD PTR @@FDIVScale1'
      '        FXCH'
      '        JMP     @@3     //FDIV is now safe'
      '@@11:'
      '        FMUL    DWORD PTR @@FDIVScale2    //Scale by 17/16'
      '        FXCH'
      '        FMUL    DWORD PTR @@FDIVScale2'
      '        FXCH'
      '        JMP     @@3     //FDIV is now safe'
      ''
      '@@20:'
      
        '        MOV     EAX,DWORD PTR [ESP].Z.Divisor     //Is entire Di' +
        'visor zero?'
      '        OR      EAX,DWORD PTR [ESP+4].Z.Divisor'
      '        JZ      @@3               //Yes, ok to FDIV'
      
        '        MOV     EAX,DWORD PTR [ESP+8].Z.Divisor   //Get Divisor ' +
        'exponent'
      '        AND     EAX,7FFFH         //Non-zero exponent is invalid'
      '        JNZ     @@3               //Ok to FDIV if invalid'
      
        '        MOV     EAX,DWORD PTR [ESP+8].Z.Dividend  //Get Dividend' +
        ' exponent'
      '        AND     EAX,7FFFH         //Denormal?'
      '        JZ      @@21              //Yes, @@21'
      '        CMP     EAX,7FFFH         //NAN or INF?'
      '        JE      @@3               //Yes, ok to FDIV'
      
        '        MOV     EAX,DWORD PTR [ESP+4].Z.Dividend  //If MSB of ma' +
        'ntissa is zero,'
      '        ADD     EAX,EAX           //the number is invalid'
      '        JNC     @@3               //Ok to FDIV if invalid'
      '        JMP     @@22'
      '@@21:'
      
        '        MOV     EAX,DWORD PTR [ESP+4].Z.Dividend  //If MSB of ma' +
        'ntissa is zero,'
      
        '        ADD     EAX,EAX                           //the number i' +
        's invalid'
      
        '        JC      @@3                               //Ok to FDIV i' +
        'f invalid'
      '@@22:'
      '        FXCH                  //Scale stored Divisor image by'
      '        FSTP    ST(0)         //1 SHL 63 and restart'
      '        FLD     ST(0)'
      '        FMUL    DWORD PTR @@FDIV1SHL63'
      '        FSTP    [ESP].Z.Divisor'
      '        FLD     [ESP].Z.Dividend'
      '        FXCH'
      '        JMP     @@2'
      'end;'
      '{$ENDIF WIN32}'
      ''
      'function _FilePos(var f: TFileRec): Integer;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Res: DWORD;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'var'
      '  Res: off_t;'
      '{$ENDIF POSIX}'
      'begin'
      '  Result := -1;'
      '  if (f.Mode > fmClosed) and (f.Mode <= fmInOut) then'
      '  begin'
      '{$IFDEF MSWINDOWS}'
      '    Res := SetFilePointer(f.Handle, 0, nil, FILE_CURRENT);'
      '    if Res = $FFFFFFFF then'
      '      InOutError'
      '    else'
      '      Result := Integer(Res div f.RecSize);'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '    Res := lseek(f.Handle, 0, SEEK_CUR);'
      '    if Res = -1 then'
      '      InOutError'
      '    else'
      '      Result := Integer(Res div off_t(f.RecSize));'
      '{$ENDIF POSIX}'
      '  end'
      '  else'
      '    SetInOutRes(103);'
      'end;'
      ''
      'function _FileSize(var f: TFileRec): Integer;'
      '{$IFDEF MSWINDOWS}'
      'begin'
      '  Result := -1;'
      '  if (f.Mode > fmClosed) and (f.Mode <= fmInOut) then'
      '  begin'
      '    Result := Integer(GetFileSize(f.Handle, nil));'
      '    if Result = -1 then'
      '      InOutError'
      '    else'
      '      Result := Cardinal(Result) div f.RecSize;'
      '  end'
      '  else'
      '    SetInOutRes(103);'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '{$IFDEF IOS}'
      'var'
      '  SavedPos: off_t;'
      '  Pos: off_t;'
      '{$ELSE !IOS}'
      'var'
      '  stat: _stat;'
      '{$ENDIF !IOS}'
      'begin'
      '  Result := -1;'
      '  if (f.Mode > fmClosed) and (f.Mode <= fmInOut) then'
      '  begin'
      '{$IFDEF IOS}'
      
        '    { Calling fstat to retrieve the st_size is not reliable on i' +
        'OS }'
      '    SavedPos := lseek(f.Handle, 0, SEEK_CUR);'
      '    if SavedPos = -1 then'
      '      InOutError'
      '    else'
      '    begin'
      '      Pos := lseek(f.Handle, 0, SEEK_END);'
      '      lseek(f.Handle, SavedPos, SEEK_SET);'
      '      if Pos = -1  then'
      '        InOutError'
      '      else'
      '        Result := Integer(Pos div f.RecSize);'
      '    end;'
      '{$ELSE !IOS}'
      '//    if _fxstat(STAT_VER_LINUX, f.Handle, stat) <> 0 then'
      '    if fstat(f.Handle, stat) <> 0 then'
      '      InOutError'
      '    else'
      '      {$IF defined(ANDROID)} // cast to st_size type'
      '      Result := Integer(stat.st_size div Int64(f.RecSize));'
      '      {$ELSE}'
      '      Result := Integer(stat.st_size div off_t(f.RecSize));'
      '      {$ENDIF}'
      '{$ENDIF !IOS}'
      '  end'
      '  else'
      '    SetInOutRes(103);'
      '{$ENDIF POSIX}'
      'end;'
      ''
      '{$IF defined(WIN32) or defined(WIN64)}'
      
        'procedure InitializeERMSBThreshold; // needs to be called in ini' +
        'tialization'
      'const'
      '  ERMSBBit = 1 shl 9; // Enhanced REP MOVSB/STOSB'
      'begin'
      '  if CPUIDTable[7].EBX and ERMSBBit <> 0 then'
      '    ERMSBThreshold := 1024;'
      'end;'
      '{$ENDIF}'
      ''
      
        'procedure _FillChar(var Dest; Count: NativeInt; Value: _AnsiChr)' +
        ';'
      '{$IF defined(POSIX)}'
      'begin'
      '  if Count > 0 then'
      '    memset(Dest, Byte(Value), Count)'
      'end;'
      '{$ELSEIF defined(WIN64) and defined(ASSEMBLER)}'
      'const'
      '  FillMask = $0101010101010101;'
      'asm'
      '        .NOFRAME'
      '        MOVZX   EAX, R8B'
      '        CMP     RDX, ERMSBThreshold'
      '        JGE     @@ERMSB'
      '        TEST    RDX,RDX'
      '        JLE     @@Done'
      '        MOV     R8, FillMask'
      
        '        IMUL    RAX, R8              // Copy Value into all Byte' +
        's of RAX'
      '        CMP     RDX, 32'
      '        JG      @@Large'
      '        SUB     RDX, 8'
      '        JG      @@Small32'
      '        LEA     R10, [offset @@SmallFill]'
      '        JMP     QWORD PTR [R10+64+RDX*8]'
      '        .ALIGN 8'
      '@@SmallFill:'
      
        '        DQ      @@Done, @@01, @@02, @@03, @@04, @@05, @@06, @@07' +
        ', @@08'
      '@@Small32: {9..32 Bytes}'
      '        CMP     DL, 8'
      '        JLE     @@Small16'
      '        CMP     DL, 16'
      '        JLE     @@Small24'
      '        MOV     [RCX+16], RAX        // Fill Third 8 Bytes'
      '@@Small24:'
      '        MOV     [RCX+ 8], RAX        // Fill Second 8 Bytes'
      '@@Small16:'
      '        MOV     [RCX+RDX], RAX       // Fill Last 8 Bytes'
      '@@08:   MOV     [RCX    ], RAX       // Fill First 8 Bytes'
      '@@Done: RET'
      '@@07:   MOV     [RCX+3], EAX'
      '@@03:   MOV     [RCX+1], AX'
      '@@01:   MOV     [RCX  ], AL'
      '        RET'
      '@@06:   MOV     [RCX+2], EAX'
      '@@02:   MOV     [RCX  ], AX'
      '        RET'
      '@@05:   MOV     [RCX+4], AL'
      '@@04:   MOV     [RCX  ], EAX'
      '        RET'
      '@@Large: {Count > 32}'
      '        MOVD    XMM0, EAX'
      
        '        PSHUFD  XMM0, XMM0, 0        // Copy Value into all Byte' +
        's of XMM0'
      '        MOVUPS  [RCX       ], XMM0   // Fill First 16 Bytes'
      '        MOVUPS  [RCX+RDX-16], XMM0   // Fill Last 16 Bytes'
      '        LEA     RDX, [RCX+RDX-1]'
      '        AND     RDX, -16'
      '        ADD     RCX, 16'
      '        AND     RCX, -16             // 16-Byte Align Writes'
      '        SUB     RCX, RDX'
      '        .ALIGN 16'
      '@@Loop:'
      '        MOVAPS  [RCX+RDX], XMM0      // Fill 16 Bytes per Loop'
      '        ADD     RCX, 16'
      '        JL      @@Loop'
      '        RET'
      '@@ERMSB:'
      '        CLD'
      '        MOV     R8, RDI'
      '        MOV     RDI, RCX'
      '        MOV     RCX, RDX'
      '        REP     STOSB'
      '        MOV     RDI, R8'
      'end;'
      '{$ELSEIF defined(WIN32) and defined(ASSEMBLER)}'
      'const'
      '  FillMask = $01010101;'
      'asm'
      '        CMP     EDX, ERMSBThreshold'
      '        JGE     @@ERMSB'
      '        TEST    EDX, EDX'
      '        JLE     @@Done'
      '        MOVZX   ECX, CL'
      
        '        IMUL    ECX, ECX, FillMask   // Copy Value into all Byte' +
        's of ECX'
      '        CMP     EDX, 32'
      '        JG      @@Large'
      '        MOV     [EAX+EDX-1], CL      // Fill Last Byte'
      '        SHR     EDX, 1               // No. of Words to Fill'
      '        JMP     DWORD PTR [@@SmallFill+EDX*4]'
      '@@Large: {Count > 32}'
      '        MOVD    XMM0, ECX'
      
        '        PSHUFD  XMM0, XMM0, 0        // Copy Value into all Byte' +
        's of XMM0'
      '        MOVUPS  [EAX       ], XMM0   // Fill First 16 Bytes'
      '        MOVUPS  [EAX+EDX-16], XMM0   // Fill Last 16 bytes'
      '        LEA     EDX, [EAX+EDX-1]'
      '        AND     EDX, -16'
      '        ADD     EAX, 16'
      '        AND     EAX, -16             // 16-Byte Align Writes'
      '        SUB     EAX, EDX'
      '        .ALIGN 8'
      '@@Loop:'
      '        MOVAPS  [EAX+EDX], XMM0      // Fill 16 Bytes per Loop'
      '        ADD     EAX, 16'
      '        JL      @@Loop'
      '        RET'
      '@@ERMSB:'
      '        CLD'
      '        PUSH    EDI'
      '        MOV     EDI, EAX'
      '        MOV     EAX, ECX'
      '        MOV     ECX, EDX'
      '        REP     STOSB'
      '        POP     EDI'
      '        RET'
      '        .ALIGN 4'
      '@@SmallFill:'
      
        '        DD      @@Done, @@02, @@04, @@06, @@08, @@10, @@12, @@14' +
        ', @@16'
      
        '        DD              @@18, @@20, @@22, @@24, @@26, @@28, @@30' +
        ', @@32'
      '@@32:   MOV     [EAX+28], ECX'
      '@@28:   MOV     [EAX+24], ECX'
      '@@24:   MOV     [EAX+20], ECX'
      '@@20:   MOV     [EAX+16], ECX'
      '@@16:   MOV     [EAX+12], ECX'
      '@@12:   MOV     [EAX+ 8], ECX'
      '@@08:   MOV     [EAX+ 4], ECX'
      '@@04:   MOV     [EAX   ], ECX'
      '        RET'
      '@@30:   MOV     [EAX+26], ECX'
      '@@26:   MOV     [EAX+22], ECX'
      '@@22:   MOV     [EAX+18], ECX'
      '@@18:   MOV     [EAX+14], ECX'
      '@@14:   MOV     [EAX+10], ECX'
      '@@10:   MOV     [EAX+ 6], ECX'
      '@@06:   MOV     [EAX+ 2], ECX'
      '@@02:   MOV     [EAX   ],  CX'
      '@@Done:'
      'end;'
      '{$ELSEIF defined(PUREPASCAL)}'
      'var'
      '  Index: NativeInt;'
      '  V: UInt64;'
      '  PB: PByte;'
      '  Total: NativeInt;'
      'begin'
      '  PB := PByte(@Dest);'
      ''
      '  if Count >= 8 then'
      '  begin'
      '    V := Byte(Value) or (Byte(Value) shl 8) or'
      '      (Byte(value) shl 16) or (Byte(value) shl 24);'
      '    V := V or (V shl 32);'
      '    Total := Count shr 3;'
      ''
      '    for Index := 0 to Total - 1 do'
      '    begin'
      '      PUInt64(PB)^ := V;'
      '      Inc(PB, 8);'
      '    end;'
      '    { Get the remainder (mod 8) }'
      '    Count := Count and $7;'
      '  end;'
      ''
      '  // Fill remain.'
      '  for Index := 0 to Count - 1 do'
      '  begin'
      '    PB^ := Byte(Value);'
      '    Inc(PB);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '  {$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure       Mark;'
      'begin'
      '  Error(reInvalidPtr);'
      'end;'
      ''
      'function _ReadRec(var f: TFileRec; Buffer: Pointer): Integer;'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if (f.Mode = fmInput) or (f.Mode = fmInOut) then'
      '  begin'
      
        '    if not ReadFile(f.Handle, Buffer, f.RecSize, Cardinal(Result' +
        '), nil) then'
      '      SetInOutRes(GetLastError)'
      '    else if Cardinal(Result) <> f.RecSize then'
      '      SetInOutRes(100);'
      '  end'
      '  else'
      '  begin'
      '    SetInOutRes(103);  // file not open for input'
      '    Result := 0;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '// -> EAX Pointer to file variable'
      '//    EDX Pointer to buffer'
      ''
      '        PUSH    EBX'
      '        XOR     ECX,ECX'
      '        MOV     EBX,EAX'
      '        MOV     CX,[EAX].TFileRec.Mode   // File must be open'
      '        SUB     ECX,fmInput'
      '        JE      @@skip'
      '        SUB     ECX,fmInOut-fmInput'
      '        JNE     @@fileNotOpen'
      '@@skip:'
      ''
      '//  ReadFile(f.Handle, buffer, f.RecSize, @result, Nil);'
      ''
      '        PUSH    0     // space for OS result'
      '        MOV     EAX,ESP'
      ''
      '        PUSH    0     // pass lpOverlapped'
      '        PUSH    EAX     // pass @result'
      ''
      
        '        PUSH    [EBX].TFileRec.RecSize    // pass nNumberOfBytes' +
        'ToRead'
      ''
      '        PUSH    EDX     // pass lpBuffer'
      '        PUSH    [EBX].TFileRec.Handle   // pass hFile'
      '        CALL    ReadFile'
      '        POP     EDX     // pop result'
      '        DEC     EAX     // check EAX = TRUE'
      '        JNZ     @@error'
      ''
      
        '        CMP     EDX,[EBX].TFileRec.RecSize  // result = f.RecSiz' +
        'e ?'
      '        JE      @@exit'
      ''
      '@@readError:'
      '        MOV EAX,100'
      '        JMP @@errExit'
      ''
      '@@fileNotOpen:'
      '        MOV EAX,103'
      '        JMP @@errExit'
      ''
      '@@error:'
      '        CALL  GetLastError'
      '@@errExit:'
      '        CALL  SetInOutRes'
      '@@exit:'
      '        POP EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      '  if (f.Mode and fmInput) = fmInput then  // fmInput or fmInOut'
      '  begin'
      '    Result := __read(f.Handle, Buffer, f.RecSize);'
      '    if Result = -1 then'
      '      InOutError'
      '    else if Cardinal(Result) <> f.RecSize then'
      '      SetInOutRes(100);'
      '  end'
      '  else'
      '  begin'
      '    SetInOutRes(103);  // file not open for input'
      '    Result := 0;'
      '  end;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      '// If the file is Input std variable, try to open it'
      '// Otherwise, runtime error.'
      'function TryOpenForInput(var t: TTextRec): Boolean;'
      'begin'
      '  if @t = @Input then'
      '  begin'
      '    t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);'
      '    _ResetText(t);'
      '  end;'
      ''
      '  Result := t.Mode = fmInput;'
      '  if not Result then'
      '    SetInOutRes(104);'
      'end;'
      ''
      '// For eof, #$1A is returned.'
      '// For errors, InOutRes is set and #$1A is returned.'
      'function _ReadByte(var t: TTextRec; var IsEof: Boolean): Byte;'
      'var'
      '  Res: Integer;'
      'begin'
      '  Result := cEof;'
      '  IsEof := True;'
      ''
      '  if t.Mode <> fmInput then'
      '    if not TryOpenForInput(t) then'
      '      exit;'
      ''
      '  if t.BufPos >= t.BufEnd then'
      '  begin'
      '    Res := TTextIOFunc(t.InOutFunc)(t);'
      '    if Res <> 0 then'
      '    begin'
      '      SetInOutRes(Res);'
      '      exit;'
      '    end;'
      '    if t.BufPos >= t.BufEnd then'
      '    begin'
      '      //  We didn'#39't get characters. Must be eof then.'
      '      if (t.Flags and tfCRLF) <> 0 then'
      '      begin'
      
        '        //  In DOS CRLF compatibility mode, synthesize an EOF ch' +
        'ar'
      '        //  Store one eof in the buffer and increment BufEnd'
      '        t.BufPtr[t.BufPos] := _AnsiChr(cEof);'
      '        inc(t.BufEnd);'
      '      end;'
      '      exit;'
      '    end;'
      '  end;'
      ''
      '  Result := Byte(t.BufPtr[t.BufPos]);'
      '  // Check for EOF char in DOS mode'
      '  if ((t.Flags and tfCRLF) <> 0) and (Result = cEof) then'
      '    Exit;'
      ''
      '  Inc(t.BufPos);'
      '  IsEof := False;'
      'end;'
      ''
      '// For eof, #$1A is returned.'
      '// For errors, InOutRes is set and #$1A is returned.'
      'function _ReadWord(var t: TTextRec; var IsEof: Boolean): Word;'
      'var'
      '  Res: Integer;'
      'begin'
      '  Result := cEof;'
      '  IsEof := True;'
      ''
      '  if t.Mode <> fmInput then'
      '    if not TryOpenForInput(t) then'
      '      exit;'
      ''
      '  if t.BufPos >= t.BufEnd then'
      '  begin'
      '    Res := TTextIOFunc(t.InOutFunc)(t);'
      '    if Res <> 0 then'
      '    begin'
      '      SetInOutRes(Res);'
      '      Exit;'
      '    end;'
      '    if t.BufPos >= t.BufEnd then'
      '    begin'
      '      //  We didn'#39't get characters. Must be eof then.'
      '      if (t.Flags and tfCRLF) <> 0 then'
      '      begin'
      
        '        //  In DOS CRLF compatibility mode, synthesize an EOF ch' +
        'ar'
      '        //  Store one eof in the buffer and increment BufEnd'
      '        t.BufPtr[t.BufPos] := _AnsiChr(cEof);'
      '        inc(t.BufEnd);'
      '      end;'
      '      Exit;'
      '    end;'
      '  end;'
      ''
      '  Result := PWord(t.BufPtr + t.BufPos)^;'
      '  // Check for EOF char in DOS mode'
      '  if ((t.Flags and tfCRLF) <> 0) and (Result = cEof) then'
      '    Exit;'
      ''
      '  Inc(t.BufPos, 2);'
      '  IsEof := False;'
      'end;'
      ''
      '//    For eof, #$1A is returned in both lower and upper 8 bits.'
      '//    For errors, InOutRes is set and #$1A is returned.'
      
        'function _GetAnsiChar(var t: TTextRec; var IsEof: Boolean; codep' +
        'age: word): Byte;'
      'var'
      '  len : integer;'
      '  W : array[0..2] of WideChar;'
      '  A : _AnsiStr;'
      '  aBuf : array[0..6] of _AnsiChr;'
      'begin'
      '  IsEof := False;'
      ''
      '  if t.MBCSLength < 0 then'
      '  begin'
      '    // Wide -> A'
      '    if t.MBCSBufPos <> 0 then'
      '    begin'
      '      // Remove partial character.'
      '      t.MBCSLength := 0;'
      '    end'
      '    else'
      '    begin'
      '      // Wide -> A'
      
        '      len := CharFromWChar(_PAnsiChr(@abuf[0]), 6, PWideChar(@t.' +
        'UTF16Buffer[0]), -t.MBCSLength, codepage);'
      '      t.MBCSLength := len;'
      '      move(aBuf[0], t.MBCSBuffer[0], len);'
      '    end;'
      '  end;'
      ''
      '  if t.MBCSLength > 0 then'
      '  begin'
      '    Result := Byte(t.MBCSBuffer[t.MBCSBufPos]);'
      '    Exit;'
      '  end;'
      '  if (t.CodePage = codepage) then'
      '  begin'
      '    Result := _ReadByte(t, IsEof);'
      '    if Not IsEof then'
      '      Dec(t.BufPos);'
      '  end'
      '  else'
      '  begin'
      '    len := 1;'
      '    W[0] := Char(_GetWideChar(t, IsEof));'
      '    if Not IsEof then'
      '    begin'
      '      if (W[0] >= #$D800) and (W[0] < #$DC00) then'
      '      begin'
      '        Inc(Len);'
      '        _SkipWideChar(t);'
      '        W[1] := Char(_GetWideChar(t, IsEof));'
      '        if IsEof then'
      '        begin'
      '          Result := cEOF;'
      '          Exit;'
      '        end;'
      '      end;'
      '      _SkipWideChar(t);'
      '      _LStrFromPWCharLen(A, PWideChar(@W[0]), Len, CodePage);'
      '      len := Length(A);'
      '      if len = 0 then'
      '        Result := 0'
      '      else'
      '      begin'
      '        Move(A[Low(string)], t.MBCSBuffer[0], Len);'
      '        t.MBCSBufPos := 0;'
      '        t.MBCSLength := Len;'
      '        Result := Byte(A[Low(string)]);'
      '      end'
      '    end'
      '    else'
      '      Result := cEOF;'
      '  end;'
      'end;'
      ''
      'procedure _SkipAnsiChar(var t: TTextRec);'
      'begin'
      '  if t.MBCSLength > 0 then'
      '  begin'
      '    Inc(t.MBCSBufPos);'
      '    if byte(t.MBCSLength) = t.MBCSBufPos then'
      '      t.MBCSLength := 0;'
      '  end'
      '  else'
      '    Inc(t.BufPos)'
      'end;'
      ''
      'function IsICUAvailable: Boolean;'
      'begin'
      '{$IFDEF USE_LIBICU}'
      '  Result := HICUUC <> 0;'
      '{$ELSE !USE_LIBICU}'
      '  Result := False;'
      '{$ENDIF USE_LIBICU}'
      'end;'
      ''
      '{$IFDEF POSIX}'
      'function LocaleNameFromCodePage(CodePage: Integer): _AnsiStr;'
      'begin'
      '  if CodePage = CP_ACP then'
      '    CodePage := GetACP;'
      '  case CodePage of'
      '    // Special cases'
      '{$IFDEF USE_LIBICU}'
      '    949:     Result := '#39'windows-949-2000'#39';'
      '    950:     Result := '#39'windows-950-2000'#39';'
      '{$ENDIF}'
      '    10000:   Result := '#39'MACROMAN'#39';         // do not localize'
      '    10004:   Result := '#39'MACARABIC'#39';        // do not localize'
      '    10005:   Result := '#39'MACHEBREW'#39';        // do not localize'
      '    10006:   Result := '#39'MACGREEK'#39';         // do not localize'
      '    10007:   Result := '#39'MACCYRILLIC'#39';      // do not localize'
      '    10010:   Result := '#39'MACROMANIA'#39';       // do not localize'
      '    10017:   Result := '#39'MACUKRAINE'#39';       // do not localize'
      '    10021:   Result := '#39'MACTHAI'#39';          // do not localize'
      '    10029:   Result := '#39'MACCENTRALEUROPE'#39'; // do not localize'
      '    10079:   Result := '#39'MACICELAND'#39';       // do not localize'
      '    10081:   Result := '#39'MACTURKISH'#39';       // do not localize'
      '    10082:   Result := '#39'MACCROATIAN'#39';      // do not localize'
      '    12000:   Result := '#39'UTF-32LE'#39';         // do not localize'
      '    12001:   Result := '#39'UTF-32BE'#39';         // do not localize'
      '    20127:   Result := '#39'ASCII'#39';            // do not localize'
      '    20866:   Result := '#39'KOI8-R'#39';           // do not localize'
      '    20932:   Result := '#39'EUC-JP'#39';           // do not localize'
      '    20936:   Result := '#39'GB2312'#39';           // do not localize'
      '    21866:   Result := '#39'KOI8-U'#39';           // do not localize'
      '    28591:   Result := '#39'ISO-8859-1'#39';       // do not localize'
      '    28592:   Result := '#39'ISO-8859-2'#39';       // do not localize'
      '    28593:   Result := '#39'ISO-8859-3'#39';       // do not localize'
      '    28594:   Result := '#39'ISO-8859-4'#39';       // do not localize'
      '    28595:   Result := '#39'ISO-8859-5'#39';       // do not localize'
      '    28596:   Result := '#39'ISO-8859-6'#39';       // do not localize'
      '    28597:   Result := '#39'ISO-8859-7'#39';       // do not localize'
      '    28598:   Result := '#39'ISO-8859-8'#39';       // do not localize'
      '    28599:   Result := '#39'ISO-8859-9'#39';       // do not localize'
      '    28600:   Result := '#39'ISO-8859-10'#39';      // do not localize'
      '    28601:   Result := '#39'ISO-8859-11'#39';      // do not localize'
      '    28603:   Result := '#39'ISO-8859-13'#39';      // do not localize'
      '    28604:   Result := '#39'ISO-8859-14'#39';      // do not localize'
      '    28605:   Result := '#39'ISO-8859-15'#39';      // do not localize'
      '    28606:   Result := '#39'ISO-8859-16'#39';      // do not localize'
      '    50221:   Result := '#39'ISO-2022-JP'#39';      // do not localize'
      '    50225:   Result := '#39'ISO-2022-KR'#39';      // do not localize'
      '    50227:   Result := '#39'ISO-2022-CN'#39';      // do not localize'
      '    51932:   Result := '#39'EUC-JP'#39';           // do not localize'
      '    51936:   Result := '#39'GB2312'#39';           // do not localize'
      '    51949:   Result := '#39'EUC-KR'#39';           // do not localize'
      '    51950:   Result := '#39'EUC-TW'#39';           // do not localize'
      '    52936:   Result := '#39'HZ-GB-2312'#39';       // do not localize'
      '    54936:   Result := '#39'GB18030'#39';          // do not localize'
      '    CP_UTF7: Result := '#39'UTF-7'#39';            // do not localize'
      '    CP_UTF8: Result := '#39'UTF-8'#39';            // do not localize'
      '  else'
      '    Str(CodePage, Result);'
      '    Result := '#39'cp'#39' + Result;  // do not localize'
      '  end;'
      'end;'
      ''
      '{$IFDEF USE_LIBICU}'
      'threadvar'
      '  LastLeadCodePage: Cardinal;'
      '  LastLeadStarters: TStarterArray;'
      '{$ENDIF USE_LIBICU}'
      ''
      
        'function IsDBCSLeadByteEx(CodePage: cardinal; TestChar: Byte): L' +
        'ongBool;'
      ''
      '{$IFDEF USE_LIBICU}'
      '  function IsDBCSLeadByteExICU: LongBool;'
      '  var'
      '    Err: UErrorCode;'
      '    Conv: PUConverter;'
      '  begin'
      '    Result := False;'
      '    Err := 0;'
      '    if CodePage <> LastLeadCodePage then'
      '    begin'
      
        '      Conv := ucnv_open(_PAnsiChr(LocaleNameFromCodePage(CodePag' +
        'e)), Err);'
      '      if Err > 0 then Exit;'
      '      try'
      '        Err := 0;'
      '        if assigned(ucnv_getStarters) then'
      '          ucnv_getStarters(Conv, LastLeadStarters, Err)'
      '        else'
      '          Err := 1;'
      '        if Err = 0 then'
      '          LastLeadCodePage := CodePage;'
      '      finally'
      '        ucnv_close(Conv);'
      '      end;'
      '    end;'
      
        '    if (Err = 0) and (LastLeadStarters[TestChar] = 1) then Resul' +
        't := True;'
      '  end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IF not Defined(USE_LIBICU) or Defined(LINUX)}'
      '  function IsDBCSLeadByteExPOSIX: LongBool;'
      '  const'
      '    MB_ERR_INVALID_CHARS = 8;'
      '  var'
      '    Dest: WideChar;'
      '  begin'
      '    Result := False;'
      '    if (TestChar > $7F) and'
      '       (UnicodeFromLocaleChars(CodePage, MB_ERR_INVALID_CHARS,'
      '           @TestChar, 1, @Dest, 1) = 0) then'
      '      Result := True'
      '  end;'
      '{$ENDIF not Defined(USE_LIBICU) or Defined(LINUX)}'
      ''
      '{$IFDEF USE_LIBICU}'
      'begin'
      '{$IFDEF LINUX}'
      '  if not IsICUAvailable then'
      '    Result := IsDBCSLeadByteExPOSIX'
      '  else'
      '{$ENDIF LINUX}'
      '    Result := IsDBCSLeadByteExICU'
      'end;'
      '{$ELSE}'
      'begin'
      '  Result := IsDBCSLeadByteExPOSIX;'
      'end;'
      '{$ENDIF}'
      '{$ENDIF POSIX}'
      ''
      '//    For eof, #$1A is returned in both lower and upper 8 bits.'
      '//    For errors, InOutRes is set and #$1A is returned.'
      
        'function _GetWideChar(var t: TTextRec; var IsEof: Boolean): Word' +
        ';'
      'var'
      '  c: byte;'
      '  ind, len: integer;'
      '  wBuf : array[0..1] of WideChar;'
      '  buf: _RawByteStr;'
      '  U : UnicodeString;'
      'begin'
      '  IsEof := False;'
      ''
      '  if t.MBCSLength > 0 then'
      '  begin'
      '    // A -> Wide'
      '    if t.MBCSBufPos <> 0 then'
      '    begin'
      '      // Remove partial character.'
      '      t.MBCSLength := 0;'
      '    end'
      '    else'
      '    begin'
      
        '      len := WCharFromChar(PWideChar(@wBuf[0]), 2, _PAnsiChr(@t.' +
        'MBCSBuffer[0]), t.MBCSLength, DefaultSystemCodePage);'
      '      t.MBCSLength := -len;'
      '      move(wBuf[0], t.UTF16Buffer[0], len*2);'
      '    end;'
      '  end;'
      ''
      '  if t.MBCSLength < 0 then'
      '  begin'
      '    Result := Word(t.UTF16Buffer[t.MBCSBufPos]);'
      '    Exit;'
      '  end'
      '  else if (t.CodePage = CP_UTF16) then'
      '  begin'
      '    Result := _ReadWord(t, IsEof);'
      '    if Not IsEof then'
      '      Dec(t.BufPos, 2);'
      '  end'
      '  else'
      '  begin'
      '    c := _ReadByte(t, IsEof);'
      '    if IsEof then'
      '    begin'
      '      Result := cEOF;'
      '      Exit;'
      '    end;'
      ''
      '    if t.CodePage = CP_UTF8 then'
      '    begin'
      '      if byte(c) in [$C2..$DF] then'
      '        Len := 2'
      '      else if byte(c) in [$E0..$EF] then'
      '        Len := 3'
      '      else if byte(c) in [$F0..$F4] then'
      '        Len := 4'
      '      else'
      '        Len := 1;'
      '    end'
      
        '    else if IsDBCSLeadByteEx(Cardinal(DefaultSystemCodePage), c)' +
        ' then'
      '      Len := 2'
      '    else'
      '      Len := 1;'
      ''
      '    SetLength(buf, len);'
      '    SetCodePage(buf, t.CodePage, False);'
      ''
      '    buf[Low(string)] := _AnsiChr(c);'
      '    ind := Low(string) + 1;'
      '    dec(Len);'
      '    while len > 0 do'
      '    begin'
      '      c := _ReadByte(t, IsEof);'
      '      buf[ind] := _AnsiChr(c);'
      '      Inc(Ind);'
      '      Dec(Len);'
      '    end;'
      ''
      '    U := UnicodeString(buf);'
      '    len := Length(U);'
      '    if Len > 0 then'
      '    begin'
      '      Move(U[Low(string)], t.UTF16Buffer[0], Len*2);'
      ''
      '      t.MBCSBufPos := 0;'
      '      t.MBCSLength := -Length(U);'
      '      Result := Word(U[Low(string)]);'
      '    end'
      '    else'
      '      Result := 0;'
      '  end;'
      'end;'
      ''
      
        'function _GetWideChar2(var t: TTextRec; var IsEof: Boolean): Wor' +
        'd;'
      'begin'
      '  if t.MBCSLength <> 0 then'
      '    Exit(_GetWideChar(t, IsEof));'
      ''
      '  Result := _ReadWord(t, IsEof);'
      '  if Not IsEof then'
      '    Dec(t.BufPos, 2);'
      'end;'
      ''
      'procedure _SkipWideChar(var t: TTextRec);'
      'begin'
      '  if t.MBCSLength < 0 then'
      '  begin'
      '    Inc(t.MBCSBufPos);'
      '    if -t.MBCSLength = t.MBCSBufPos then'
      '      t.MBCSLength := 0;'
      '  end'
      '  else'
      '    Inc(t.BufPos, 2)'
      'end;'
      ''
      'function _ReadChar(var t: TTextRec): _AnsiChr;'
      'var'
      '  eof: Boolean;'
      'begin'
      
        '  Result := _AnsiChr(_GetAnsiChar(t, eof, DefaultSystemCodePage)' +
        ');'
      '  _SkipAnsiChar(t);'
      'end;'
      ''
      
        'function _ValLongL(const s: _AnsiStr; var code: Integer): Intege' +
        'r;'
      'begin'
      '  Result := _ValLong(string(s), code);'
      'end;'
      ''
      'function _ReadLong(var t: TTextRec): Integer;'
      'type'
      '  TStrRec32 = packed record'
      '    hdr: StrRec;'
      '    data: array[0..35] of Byte;'
      '  end;'
      'var'
      '  s: TStrRec32;'
      '  c: Byte;'
      '  p: PByte;'
      '  eof: Boolean;'
      '  count: Integer;'
      '  code: Integer;'
      'begin'
      '  if _SeekEof(t) then'
      '    Result := 0'
      '  else'
      '  begin'
      '    p := @s.data[0];'
      '    for count := 1 to 32 do'
      '    begin'
      '      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '      if c <= $20 then Break;'
      '      p^ := c;'
      '      _SkipAnsiChar(t);'
      '      Inc(p);'
      '    end;'
      '    p^ := 0;'
      '    s.hdr.codePage := CP_ACP;'
      '    s.hdr.elemSize := 1;'
      '    s.hdr.refCnt := -1;'
      '    s.hdr.length := p - PByte(@s.data[0]);'
      '    Result := _ValLongL(_PAnsiChr(@s.data), code);'
      '    if code <> 0 then'
      '      SetInOutRes(106);'
      '  end;'
      'end;'
      ''
      'procedure _PushCRLF(var t: TTextRec);'
      'begin'
      '  t.MBCSBuffer[0] := _AnsiChr(cCR);'
      '  t.MBCSBuffer[1] := _AnsiChr(cLF);'
      '  t.MBCSLength := 2; //Ansi 2 byets.'
      '  t.MBCSBufPos := 0;'
      'end;'
      ''
      
        'function ReadAnsiLineEx(var t: TTextRec; buf: Pointer; maxLen: I' +
        'nteger; var Count: Integer; CodePage: Word): Pointer;'
      'var'
      '  c : Byte;'
      '  eof: Boolean;'
      '  p : PByte;'
      'begin'
      '  Result := @t;'
      '  Count := 0;'
      ''
      '  if t.Mode <> fmInput then'
      '    if not TryOpenForInput(t) then'
      '      exit;'
      ''
      '  if maxLen <= 0 then Exit;'
      '  if CodePage = 0 then'
      '    CodePage := DefaultSystemCodePage;'
      ''
      '  p := PByte(buf);'
      '  while (maxLen > 0) do'
      '  begin'
      '    c := _GetAnsiChar(t, eof, CodePage);'
      '    if eof then Exit;'
      '    if c = cLF then'
      '    begin'
      '      Exit;'
      '    end'
      '    else if c = cCR then'
      '    begin'
      '      _SkipAnsiChar(t);'
      '      c := _GetAnsiChar(t, eof, CodePage);'
      '      if c = cLF then'
      '      begin'
      '        _SkipAnsiChar(t);'
      '        _PushCRLF(t);'
      '        Exit;'
      '      end'
      '      else'
      '      continue;'
      '    end'
      '    else'
      '    begin'
      '      p^ := c;'
      '      _SkipAnsiChar(t);'
      '      Inc(p);'
      '      Dec(maxLen);'
      '      inc(Count);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'function ReadAnsiLineEx2(var t: TTextRec; buf: Pointer; maxLen: ' +
        'Integer; var Count: Integer): Pointer;'
      'var'
      '  c : Byte;'
      '  eof: Boolean;'
      '  p : PByte;'
      'begin'
      '  if t.MBCSLength <> 0 then'
      '    Exit(ReadAnsiLineEx(t, buf, maxLen, Count, t.CodePage));'
      ''
      '  Result := @t;'
      '  Count := 0;'
      ''
      '  if t.Mode <> fmInput then'
      '    if not TryOpenForInput(t) then'
      '      exit;'
      ''
      '  if maxLen <= 0 then Exit;'
      ''
      '  p := PByte(buf);'
      '  while (maxLen > 0) do'
      '  begin'
      '    c := _ReadByte(t, eof);'
      '    if eof then Exit;'
      '    if c = cLF then'
      '    begin'
      '      Dec(t.BufPos);'
      '      Exit;'
      '    end'
      '    else if c = cCR then'
      '    begin'
      '      c := _ReadByte(t, eof);'
      '      if (c = cEOF) then Exit;'
      '      if c = cLF then'
      '      begin'
      '        _PushCRLF(t);'
      '        Exit;'
      '      end'
      '      else'
      '      Dec(t.BufPos);'
      '      continue;'
      '    end'
      '    else'
      '    begin'
      '      p^ := c;'
      '      Inc(p);'
      '      Dec(maxLen);'
      '      inc(Count);'
      '    end;'
      '  end;'
      'end;'
      ''
      '// maxLen and Count are the number of (wide)char.'
      
        'function ReadWideLineEx(var t: TTextRec; buf: Pointer; maxLen: I' +
        'nteger; var Count: Integer): Pointer;'
      'var'
      '  w : Word;'
      '  eof: Boolean;'
      '  p : PWord;'
      'begin'
      '  Result := @t;'
      '  Count := 0;'
      ''
      '  if t.Mode <> fmInput then'
      '    if not TryOpenForInput(t) then'
      '      exit;'
      ''
      '  if maxLen <= 0 then Exit;'
      ''
      '  p := PWord(buf);'
      '  while (maxLen > 0) do'
      '  begin'
      '    w := _GetWideChar(t, eof);'
      '    if eof then Exit;'
      '    if w = cLF then'
      '    begin'
      '      Exit;'
      '    end'
      '    else if w = cCR then'
      '    begin'
      '      _SkipWideChar(t);'
      '      w := _GetWideChar(t, eof);'
      '      if w = cLF then'
      '      begin'
      '        _SkipWideChar(t);'
      '        _PushCRLF(t);'
      '        Exit;'
      '      end'
      '      else'
      '      continue;'
      '    end'
      '    else'
      '    begin'
      '      p^ := w;'
      '      _SkipWideChar(t);'
      '      Inc(p);'
      '      Dec(maxLen);'
      '      inc(Count);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'function ReadWideLineEx2(var t: TTextRec; buf: Pointer; maxLen: ' +
        'Integer; var Count: Integer): Pointer;'
      'var'
      '  w : Word;'
      '  eof: Boolean;'
      '  p : PWord;'
      'begin'
      '  if t.MBCSLength <> 0 then'
      '    Exit(ReadAnsiLineEx(t, buf, maxLen, Count, t.CodePage));'
      ''
      '  Result := @t;'
      '  Count := 0;'
      ''
      '  if t.Mode <> fmInput then'
      '    if not TryOpenForInput(t) then'
      '      exit;'
      ''
      '  if maxLen <= 0 then Exit;'
      ''
      '  p := PWord(buf);'
      '  while (maxLen > 0) do'
      '  begin'
      '    w := _ReadWord(t, eof);'
      '    if eof then Exit;'
      '    if w = cLF then'
      '    begin'
      '      Dec(t.BufPos, 2);'
      '      Exit;'
      '    end'
      '    else if w = cCR then'
      '    begin'
      '      w := _ReadWord(t, eof);'
      '      if w = cLF then'
      '      begin'
      '        _PushCRLF(t);'
      '        Exit;'
      '      end'
      '      else'
      '      Dec(t.BufPos, 2);'
      '      continue;'
      '    end'
      '    else'
      '    begin'
      '      p^ := w;'
      '      Inc(p);'
      '      Dec(maxLen);'
      '      inc(Count);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure _ReadString(var t: TTextRec; s: _PShortStr; maxLen: In' +
        'teger);'
      'var'
      '  Count: Integer;'
      'begin'
      
        '  ReadAnsiLineEx(t, @s^[1], maxLen, Count, DefaultSystemCodePage' +
        ');'
      '  Byte(s^[0]) := Count;'
      'end;'
      ''
      
        'procedure _ReadCString(var t: TTextRec; s: _PAnsiChr; maxLen: In' +
        'teger);'
      'var'
      '  Count: Integer;'
      'begin'
      '  ReadAnsiLineEx(t, s, maxLen, Count, DefaultSystemCodePage);'
      '  s[Count] := #0;'
      'end;'
      ''
      
        'procedure _ReadLString(var t: TTextRec; var s: _AnsiStr; CodePag' +
        'e: Word);'
      'var'
      '  Count: Integer;'
      '  Temp, Buf: _RawByteStr;'
      '  U: UnicodeString;'
      'begin'
      '  s := '#39#39';'
      ''
      '  if t.CodePage = 0 then TryOpenForInput(t);'
      '  if t.CodePage = CP_UTF16 then'
      '  begin'
      '    _ReadUString(t, U);'
      '    _LStrFromUStr(s, U, CodePage);'
      '  end'
      '  else'
      '  begin'
      '    SetLength(Buf, 255);'
      '    SetCodePage(Buf, t.CodePage, False);'
      ''
      '    ReadAnsiLineEx2(t, @buf[Low(string)], 255, Count);'
      '    SetLength(Buf, Count);'
      '    Temp := buf;'
      '    while Count = 255 do'
      '    begin'
      '      SetLength(Buf, 255);'
      '      SetCodePage(Buf, t.CodePage, False);'
      '      ReadAnsiLineEx2(t, @buf[Low(string)], 255, Count);'
      '      SetLength(Buf, Count);'
      '      Temp := Temp + Buf;'
      '    end;'
      '    if CodePage <> t.CodePage then'
      '    begin'
      '      if Temp <> '#39#39' then'
      '      begin'
      '        _UStrFromLStr(U, Temp);'
      '        _LStrFromUStr(s, U, CodePage);'
      '      end;'
      '    end'
      '    else'
      '      s := Temp;'
      '  end;'
      'end;'
      ''
      'procedure _ReadUString(var t: TTextRec; var s: UnicodeString);'
      'var'
      '  Count: Integer;'
      '  Buf: UnicodeString;'
      '  a: _AnsiStr;'
      'begin'
      '  s := '#39#39';'
      ''
      '  if t.CodePage = 0 then TryOpenForInput(t);'
      '  if t.CodePage = CP_UTF16 then'
      '  begin'
      '    SetLength(Buf, 255);'
      '    ReadWideLineEx2(t, Pointer(Buf), 255, Count);'
      '    SetLength(Buf, Count);'
      '    s := Buf;'
      ''
      '    while Count = 255 do'
      '    begin'
      '      SetLength(Buf, 255);'
      '      ReadWideLineEx2(t, PWideChar(Buf), 255, Count);'
      '      SetLength(Buf, Count);'
      '      s := s + Buf;'
      '      Buf := '#39#39';'
      '    end;'
      '  end'
      '  else'
      '  begin'
      '    _ReadLString(t, a, t.CodePage);'
      '    if a <> '#39#39' then'
      '      _UStrFromLStr(s, a);'
      '  end;'
      'end;'
      ''
      'function _ReadWChar(var t: TTextRec): WideChar;'
      'var'
      '  eof: Boolean;'
      'begin'
      '  Result := WideChar(_GetWideChar(t, eof));'
      '  _SkipWideChar(t);'
      'end;'
      ''
      
        'procedure _ReadWCString(var t: TTextRec; s: PWideChar; maxBytes:' +
        ' Integer);'
      'var'
      '  Count: Integer;'
      'begin'
      '  ReadWideLineEx(t, s, maxBytes div 2, Count);'
      '  s[Count] := #0;'
      'end;'
      ''
      'procedure _ReadWString(var t: TTextRec; var s: _WideStr);'
      'var'
      '  Temp: UnicodeString;'
      'begin'
      '  _ReadUString(t, Temp);'
      '  s := _WideStr(Temp);'
      'end;'
      ''
      
        'function _ValExtL(const s: _AnsiStr; var code: Integer): Extende' +
        'd;'
      'begin'
      '  Val(string(s), Result, code);'
      'end;'
      ''
      'function _ReadExt(var t: TTextRec): Extended;'
      'var'
      '  p: PWord;'
      '  count: Integer;'
      '  c: Byte;'
      '  eof: Boolean;'
      '  code: Integer;'
      '  u: UnicodeString;'
      'begin'
      '  if _SeekEof(t) then'
      '    Result := 0'
      '  else'
      '  begin'
      '    SetLength(U, 64);'
      '    p := PWord(U);'
      '    for count := 1 to 64 do'
      '    begin'
      '      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '      if c <= $20 then break;'
      '      p^ := c;'
      '      _SkipAnsiChar(t);'
      '      Inc(p);'
      '    end;'
      '    SetLength(U, (PByte(p) - PByte(U)) div sizeof(word));'
      '    Val(u, Result, code);'
      '    if code <> 0 then'
      '      SetInOutRes(106);'
      '  end;'
      'end;'
      ''
      'procedure _ReadLn(var t: TTextRec);'
      'var'
      '  c: Byte;'
      '  eof: Boolean;'
      'begin'
      '  c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '  _SkipAnsiChar(t);'
      '  while True do'
      '  begin'
      '    if c = cLF then break; // accept LF as end of line'
      '    if eof then break;'
      '    if c = cCR then'
      '    begin'
      '      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '      _SkipAnsiChar(t);'
      '      if c = cLF then break; // accept CR+LF as end of line'
      '      if eof then break; // accept CR+EOF as end of line'
      '      // else CR+ anything else is not a line break.'
      '    end'
      '    else'
      '    begin'
      '      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '      _SkipAnsiChar(t);'
      '    end;'
      '  end;'
      'end;'
      ''
      'procedure _Rename(var f: TFileRec; newName: PChar);'
      'var'
      '  I: Integer;'
      '  oldName: string;'
      '{$IFDEF POSIX}'
      '  usOldName: _UTF8Str;'
      '  usNewName: _UTF8Str;'
      '{$ENDIF POSIX}'
      'begin'
      '  if f.Mode = fmClosed then'
      '  begin'
      '    if newName = nil then newName := '#39#39';'
      '    oldName := f.Name;'
      '{$IFDEF POSIX}'
      '    usNewName := _UTF8Str(newName);'
      '    usOldName := _UTF8Str(oldName);'
      
        '    if __rename(_PAnsiChr(usOldName), _PAnsiChr(usNewName)) = 0 ' +
        'then'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '    if MoveFile(PChar(oldName), newName) then'
      '{$ENDIF MSWINDOWS}'
      '    begin'
      '      I := 0;'
      '      while (newName[I] <> #0) and (I < High(f.Name)) do'
      '      begin'
      '        f.Name[I] := newName[I];'
      '        Inc(I);'
      '      end'
      '    end'
      '    else'
      '      SetInOutRes(GetLastError);'
      '  end'
      '  else'
      '    SetInOutRes(102);'
      'end;'
      ''
      'procedure Release;'
      'begin'
      '  Error(reInvalidPtr);'
      'end;'
      ''
      'function _CloseFile(var f: TFileRec): Integer;'
      'begin'
      '  f.Mode := fmClosed;'
      '  Result := 0;'
      '  if not InternalClose(f.Handle) then'
      '  begin'
      '    InOutError;'
      '    Result := 1;'
      '  end;'
      'end;'
      ''
      
        'function OpenFile(var f: TFileRec; recSiz: Integer; mode: Intege' +
        'r): Integer;'
      '{$IFDEF POSIX}'
      'var'
      '   Flags: Integer;'
      '   uName: _UTF8Str;'
      'begin'
      '  Result := 0;'
      '  if (f.Mode >= fmClosed) and (f.Mode <= fmInOut) then'
      '  begin'
      '    if f.Mode <> fmClosed then // not yet closed: close it'
      '    begin'
      '      Result := TFileIOFunc(f.CloseFunc)(f);'
      '      if Result <> 0 then'
      '      begin'
      '        SetInOutRes(Result);'
      '        Exit;'
      '      end'
      '    end;'
      ''
      '    if recSiz <= 0 then'
      '    begin'
      '      SetInOutRes(106);'
      '      Exit;'
      '    end;'
      ''
      '    f.RecSize := recSiz;'
      '    f.InOutFunc := @FileNopProc;'
      ''
      '    if f.Name[0] <> #0 then'
      '    begin'
      '      f.CloseFunc := @_CloseFile;'
      '      case mode of'
      '        1: begin'
      '             Flags := O_APPEND or O_WRONLY;'
      '             f.Mode := fmOutput;'
      '           end;'
      '        2: begin'
      '             Flags := O_RDWR;'
      '             f.Mode := fmInOut;'
      '           end;'
      '        3: begin'
      '             Flags := O_CREAT or O_TRUNC or O_RDWR;'
      '             f.Mode := fmInOut;'
      '           end;'
      '      else'
      '        Flags := O_RDONLY;'
      '        f.Mode := fmInput;'
      '      end;'
      ''
      '      uName := _UTF8Str(f.Name);'
      
        '      f.Handle := __open(_PAnsiChr(uName), Flags, FileAccessRigh' +
        'ts);'
      '    end'
      '    else  // stdin or stdout'
      '    begin'
      '      f.CloseFunc := @FileNopProc;'
      '      if mode = 3 then'
      '        f.Handle := STDOUT_FILENO'
      '      else'
      '        f.Handle := STDIN_FILENO;'
      '    end;'
      ''
      '    if f.Handle = -1 then'
      '    begin'
      '      f.Mode := fmClosed;'
      '      InOutError;'
      '    end;'
      '  end'
      '  else'
      '    SetInOutRes(102);'
      'end;'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      'const'
      '  ShareTab: array [0..7] of Integer ='
      
        '    (FILE_SHARE_READ OR FILE_SHARE_WRITE,  // OF_SHARE_COMPAT   ' +
        '  0x00000000'
      
        '     0,                                    // OF_SHARE_EXCLUSIVE' +
        '  0x00000010'
      
        '     FILE_SHARE_READ,                      // OF_SHARE_DENY_WRIT' +
        'E 0x00000020'
      
        '     FILE_SHARE_WRITE,                     // OF_SHARE_DENY_READ' +
        '  0x00000030'
      
        '     FILE_SHARE_READ OR FILE_SHARE_WRITE,  // OF_SHARE_DENY_NONE' +
        '  0x00000040'
      '     0,0,0);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '   DesiredAccess: DWORD;'
      '   SharedMode: Integer;'
      '   CreationDisposition: Integer;'
      'begin'
      '  Result := 0;'
      '  if (f.Mode >= fmClosed) and (f.Mode <= fmInOut) then'
      '  begin'
      '    if f.Mode <> fmClosed then // not yet closed: close it'
      '    begin'
      '      Result := TFileIOFunc(f.CloseFunc)(f);'
      '      if Result <> 0 then'
      '      begin'
      '        SetInOutRes(Result);'
      '        Exit;'
      '      end'
      '    end;'
      ''
      '    if recSiz <= 0 then'
      '    begin'
      '      SetInOutRes(106);'
      '      Exit;'
      '    end;'
      ''
      '    f.RecSize := recSiz;'
      '    f.InOutFunc := @FileNopProc;'
      ''
      '    if f.Name[0] <> #0 then'
      '    begin'
      '      f.CloseFunc := @_CloseFile;'
      '      SharedMode := shareTab[(FileMode and $70) shr 4];'
      '      case mode of'
      '        1: begin'
      '             CreationDisposition := OPEN_EXISTING;'
      '             DesiredAccess := GENERIC_WRITE;'
      '             f.Mode := fmOutput;'
      '           end;'
      '        2: begin'
      '             CreationDisposition := OPEN_EXISTING;'
      '             DesiredAccess := GENERIC_READ OR GENERIC_WRITE;'
      '             f.Mode := fmInOut;'
      '           end;'
      '        3: begin'
      '             DesiredAccess := GENERIC_READ OR GENERIC_WRITE;'
      '             CreationDisposition := CREATE_ALWAYS;'
      '             f.Mode := fmInOut;'
      '           end;'
      '      else'
      '        CreationDisposition := OPEN_EXISTING;'
      '        DesiredAccess := GENERIC_READ;'
      '        f.Mode := fmInput;'
      '      end;'
      
        '      f.Handle := CreateFile(f.Name, DesiredAccess, SharedMode, ' +
        'nil,'
      
        '                             CreationDisposition, FILE_ATTRIBUTE' +
        '_NORMAL, 0);'
      '    end'
      '    else  // stdin or stdout'
      '    begin'
      '      f.CloseFunc := @FileNopProc;'
      '      if mode = 3 then'
      '        f.Handle := GetStdHandle(STD_OUTPUT_HANDLE)'
      '      else'
      '        f.Handle := GetStdHandle(STD_INPUT_HANDLE);;'
      '    end;'
      '    if f.Handle = -1 then'
      '    begin'
      '      f.Mode := fmClosed;'
      '      InOutError;'
      '    end;'
      '  end'
      '  else'
      '    SetInOutRes(102);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '//->  EAX Pointer to file record'
      '//    EDX Record size'
      '//    ECX File mode'
      ''
      '        PUSH     EBX'
      '        PUSH     ESI'
      '        PUSH     EDI'
      ''
      '        MOV      ESI,EDX'
      '        MOV      EDI,ECX'
      '        XOR      EDX,EDX'
      '        MOV      EBX,EAX'
      ''
      '        MOV      DX,[EAX].TFileRec.Mode'
      '        SUB      EDX,fmClosed'
      '        JE       @@alreadyClosed'
      '        CMP      EDX,fmInOut-fmClosed'
      '        JA       @@notAssignedError'
      ''
      '//  not yet closed: close it. File parameter is still in EAX'
      ''
      '        CALL     [EBX].TFileRec.CloseFunc'
      '        TEST     EAX,EAX'
      '        JNE      @@errExit'
      ''
      '@@alreadyClosed:'
      ''
      '        CMP     ESI,0'
      '        JLE     @@invalidRecSize'
      '        MOV     [EBX].TFileRec.Mode,fmInOut'
      '        MOV     [EBX].TFileRec.RecSize,ESI'
      '        MOV     [EBX].TFileRec.CloseFunc,offset _CloseFile'
      '        MOV     [EBX].TFileRec.InOutFunc,offset FileNopProc'
      ''
      '        CMP     word ptr [EBX].TFileRec.Name,0'
      '        JE      @@isCon'
      ''
      '        MOV     EAX,GENERIC_READ OR GENERIC_WRITE'
      '        MOV     DL,FileMode'
      '        AND     EDX,070H'
      '        SHR     EDX,4-2'
      '        MOV     EDX,dword ptr [shareTab+EDX]'
      '        MOV     ECX,CREATE_ALWAYS'
      ''
      '        SUB     EDI,3'
      '        JE      @@calledByRewrite'
      ''
      '        MOV     ECX,OPEN_EXISTING'
      '        INC     EDI'
      '        JE      @@skip'
      ''
      '        MOV     EAX,GENERIC_WRITE'
      '        INC     EDI'
      '        MOV     [EBX].TFileRec.Mode,fmOutput'
      '        JE      @@skip'
      ''
      '        MOV     EAX,GENERIC_READ'
      '        MOV     [EBX].TFileRec.Mode,fmInput'
      ''
      '@@skip:'
      '@@calledByRewrite:'
      ''
      
        '//  CreateFile(t.FileName, EAX, EDX, Nil, ECX, FILE_ATTRIBUTE_NO' +
        'RMAL, 0);'
      ''
      '        PUSH     0'
      '        PUSH     FILE_ATTRIBUTE_NORMAL'
      '        PUSH     ECX'
      '        PUSH     0'
      '        PUSH     EDX'
      '        PUSH     EAX'
      '        LEA      EAX,[EBX].TFileRec.Name'
      '        PUSH     EAX'
      '        CALL     CreateFile'
      '@@checkHandle:'
      '        CMP      EAX,-1'
      '        JZ       @@error'
      ''
      '        MOV      [EBX].TFileRec.Handle,EAX'
      '        JMP      @@exit'
      ''
      '@@isCon:'
      '        MOV      [EBX].TFileRec.CloseFunc,offset FileNopProc'
      '        CMP      EDI,3'
      '        JE       @@output'
      '        PUSH     STD_INPUT_HANDLE'
      '        JMP      @@1'
      '@@output:'
      '        PUSH     STD_OUTPUT_HANDLE'
      '@@1:'
      '        CALL     GetStdHandle'
      '        JMP      @@checkHandle'
      ''
      '@@notAssignedError:'
      '        MOV      EAX,102'
      '        JMP      @@errExit'
      ''
      '@@invalidRecSize:'
      '        MOV      EAX,106'
      '        JMP      @@errExit'
      ''
      '@@error:'
      '        MOV      [EBX].TFileRec.Mode,fmClosed'
      '        CALL     GetLastError'
      ''
      '@@errExit:'
      '        CALL     SetInOutRes'
      ''
      '@@exit:'
      '        POP      EDI'
      '        POP      ESI'
      '        POP      EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      ''
      'function _ResetFile(var f: TFileRec; recSize: Integer): Integer;'
      'var'
      '  m: Byte;'
      'begin'
      '  m := FileMode and 3;'
      '  if m > 2 then m := 2;'
      '  Result := OpenFile(f, recSize, m);'
      'end;'
      ''
      
        'function _RewritFile(var f: TFileRec; recSize: Integer): Integer' +
        ';'
      'begin'
      '  Result := OpenFile(f, recSize, 3);'
      'end;'
      ''
      'procedure _Seek(var f: TFileRec; recNum: Cardinal);'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Val64: UInt64;'
      '  Val32Low: UInt32;'
      '  Val32High: UInt32;'
      '  Res: Integer;'
      'begin'
      '  if (f.Mode >= fmInput) and (f.Mode <= fmInOut) then'
      '  begin'
      '    Val64 := UInt64(recNum) * f.RecSize;'
      '    Val32High := UInt32(Val64 shr 32);'
      '    Val32Low := UInt32(Val64);'
      ''
      
        '    Res := Integer(SetFilePointer(f.Handle, Val32Low, @Val32High' +
        ', FILE_BEGIN));'
      '    if (Res = -1) and (GetLastError <> 0{NO_ERROR}) then'
      '      InOutError'
      '    else'
      '    begin'
      '      if Res < 0 then'
      '        SetInOutRes(131);'
      '    end'
      '  end else'
      '    SetInOutRes(103);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '// -> EAX Pointer to file variable'
      '//    EDX Record number'
      ''
      '        MOV      ECX,EAX'
      
        '        MOVZX    EAX,[EAX].TFileRec.Mode // check whether file i' +
        's open'
      '        SUB      EAX,fmInput'
      '        CMP      EAX,fmInOut-fmInput'
      '        JA       @@fileNotOpen'
      ''
      '//  SetFilePointer(f.Handle, recNum*f.RecSize, FILE_BEGIN)'
      '        PUSH     FILE_BEGIN    // pass dwMoveMethod'
      '        MOV      EAX,[ECX].TFileRec.RecSize'
      '        MUL      EDX'
      '        PUSH     0           // pass lpDistanceToMoveHigh'
      '        PUSH     EAX           // pass lDistanceToMove'
      '        PUSH     [ECX].TFileRec.Handle   // pass hFile'
      '        CALL     SetFilePointer          // get current position'
      '        INC      EAX'
      '        JZ       InOutError'
      '        JMP      @@exit'
      ''
      '@@fileNotOpen:'
      '        MOV      EAX,103'
      '        JMP      SetInOutRes'
      ''
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      '  if (f.Mode >= fmInput) and (f.Mode <= fmInOut) then'
      '  begin'
      
        '    if Integer(recNum) < 0 then  // Match windows behaviour. Onl' +
        'y 0 .. MaxInt sizes are allowed.'
      
        '      SetInOutRes(131)           // Negative seeks are dissablow' +
        'ed.'
      '    else'
      '                                                 '
      '      if lseek(f.Handle, f.RecSize * recNum, SEEK_SET) = -1 then'
      '        InOutError;'
      '  end'
      '  else'
      '    SetInOutRes(103);'
      'end;'
      '{$ENDIF POSIX}'
      ''
      'function _SeekEof(var t: TTextRec): Boolean;'
      'var'
      '  c: Byte;'
      '  eof: Boolean;'
      'begin'
      '  Result := False;'
      '  while True do'
      '  begin'
      '    c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '    if c > $20 then break;'
      '    if eof then'
      '    begin'
      '      Result := True;'
      '      break;'
      '    end;'
      '    _SkipAnsiChar(t);'
      '  end;'
      'end;'
      ''
      'function _SeekEoln(var t: TTextRec): Boolean;'
      'var'
      '  c: Byte;'
      '  eof: Boolean;'
      'begin'
      '  Result := False;'
      '  while True do'
      '  begin'
      '    c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '    if c > $20 then break;'
      '    if eof then'
      '    begin'
      '      Result := True;'
      '      break;'
      '    end;'
      '    if (c = cLF) or (c = cCR) then'
      '    begin'
      '      Result := True;'
      '      break;'
      '    end;'
      '    _SkipAnsiChar(t);'
      '  end;'
      'end;'
      ''
      
        'procedure _SetTextBuf(var t: TTextRec; p: Pointer; size: Integer' +
        ');'
      'begin'
      '  if size < 0 then'
      '    Error(reRangeError);'
      '  t.BufPtr := P;'
      '  t.BufSize := size;'
      '  t.BufPos := 0;'
      '  t.BufEnd := 0;'
      'end;'
      ''
      'function _StrLong(val, width: Integer): _ShortStr;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: Integer;'
      '  sign: Integer;'
      '  a: array [0..19] of _AnsiChr;'
      '  P: _PAnsiChr;'
      'begin'
      '  // U-OK'
      '  sign := val;'
      '  val := Abs(val);'
      '  I := 0;'
      '  repeat'
      '    a[I] := _AnsiChr((Cardinal(val) mod 10) + Ord('#39'0'#39'));'
      '    Inc(I);'
      '    val := Cardinal(val) div 10;'
      '  until val = 0;'
      ''
      '  if sign < 0 then'
      '  begin'
      '    a[I] := '#39'-'#39';'
      '    Inc(I);'
      '  end;'
      ''
      '  if width < I then'
      '    width := I;'
      '  if width > 255 then'
      '    width := 255;'
      '  Result[0] := _AnsiChr(width);'
      '  P := @Result[1];'
      '  while width > I do'
      '  begin'
      '    P^ := '#39' '#39';'
      '    Inc(P);'
      '    Dec(width);'
      '  end;'
      '  repeat'
      '    Dec(I);'
      '    P^ := a[I];'
      '    Inc(P);'
      '  until I <= 0;'
      'end;'
      '{$ELSE}'
      'asm'
      
        '{       PROCEDURE _StrLong( val: Integer; width: Integer; VAR s:' +
        ' _ShortStr );'
      '      ->EAX     Value'
      '        EDX     Width'
      '        ECX     Pointer to string       }'
      ''
      
        '        PUSH    EBX             { VAR i: Integer;               ' +
        '}'
      
        '        PUSH    ESI             { VAR sign : Integer;           ' +
        '}'
      '        PUSH    EDI'
      
        '        PUSH    EDX             { store width on the stack      ' +
        '}'
      
        '        SUB     ESP,20          { VAR a: array [0..19] of Char; ' +
        '}'
      ''
      '        MOV     EDI,ECX'
      ''
      
        '        MOV     ESI,EAX         { sign := val                   ' +
        '}'
      ''
      
        '        CDQ                     { val := Abs(val);  canned seque' +
        'nce }'
      '        XOR     EAX,EDX'
      '        SUB     EAX,EDX'
      ''
      '        MOV     ECX,10'
      
        '        XOR     EBX,EBX         { i := 0;                       ' +
        '}'
      ''
      
        '@@repeat1:                      { repeat                        ' +
        '}'
      
        '        XOR     EDX,EDX         {   a[i] := Chr( val MOD 10 + Or' +
        'd('#39'0'#39') );}'
      ''
      
        '        DIV     ECX             {   val := val DIV 10;          ' +
        '}'
      ''
      '        ADD     EDX,'#39'0'#39
      '        MOV     [ESP+EBX],DL'
      
        '        INC     EBX             {   i := i + 1;                 ' +
        '}'
      
        '        TEST    EAX,EAX         { until val = 0;                ' +
        '}'
      '        JNZ     @@repeat1'
      ''
      '        TEST    ESI,ESI'
      '        JGE     @@2'
      '        MOV     byte ptr [ESP+EBX],'#39'-'#39
      '        INC     EBX'
      '@@2:'
      
        '        MOV     [EDI],BL        { s^++ := Chr(i);               ' +
        '}'
      '        INC     EDI'
      ''
      
        '        MOV     ECX,[ESP+20]    { spaceCnt := width - i;        ' +
        '}'
      '        CMP     ECX,255'
      '        JLE     @@3'
      '        MOV     ECX,255'
      '@@3:'
      '        SUB     ECX,EBX'
      
        '        JLE     @@repeat2       { for k := 1 to spaceCnt do s^++' +
        ' := '#39' '#39';        }'
      '        ADD     [EDI-1],CL'
      '        MOV     AL,'#39' '#39
      '        REP     STOSB'
      ''
      
        '@@repeat2:                      { repeat                        ' +
        '}'
      
        '        MOV     AL,[ESP+EBX-1]  {   s^ := a[i-1];               ' +
        '}'
      '        MOV     [EDI],AL'
      
        '        INC     EDI             {   s := s + 1                  ' +
        '}'
      
        '        DEC     EBX             {   i := i - 1;                 ' +
        '}'
      
        '        JNZ     @@repeat2       { until i = 0;                  ' +
        '}'
      ''
      '        ADD     ESP,20+4'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF}'
      ''
      'function _Str0Long(val: Integer): _ShortStr;'
      'begin'
      '  Result := _StrLong(val, 0);'
      'end;'
      ''
      'procedure _Truncate(var f: TFileRec);'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if (f.Mode = fmOutput) or (f.Mode = fmInOut) then'
      '  begin'
      '    if not SetEndOfFile(f.Handle) then'
      '      InOutError;'
      '  end else'
      '    SetInOutRes(103);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '// -> EAX Pointer to text or file variable'
      ''
      
        '       MOVZX   EDX,[EAX].TFileRec.Mode   // check whether file i' +
        's open'
      '       SUB     EDX,fmInput'
      '       CMP     EDX,fmInOut-fmInput'
      '       JA      @@fileNotOpen'
      ''
      '       PUSH    [EAX].TFileRec.Handle'
      '       CALL    SetEndOfFile'
      '       DEC     EAX'
      '       JZ      @@exit'
      '       JMP     InOutError'
      ''
      '@@fileNotOpen:'
      '       MOV     EAX,103'
      '       JMP     SetInOutRes'
      ''
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      
        '  if (f.Mode and fmOutput) = fmOutput then  // fmOutput or fmInO' +
        'ut'
      '  begin'
      
        '    if ftruncate(f.Handle, lseek(f.Handle, 0, SEEK_CUR)) = -1 th' +
        'en'
      '      InOutError;'
      '  end'
      '  else'
      '    SetInOutRes(103);'
      'end;'
      '{$ENDIF POSIX}'
      ''
      '// Hex : ( '#39'$'#39' | '#39'X'#39' | '#39'x'#39' | '#39'0X'#39' | '#39'0x'#39' ) [0-9A-Fa-f]*'
      '// Dec : ( '#39'+'#39' | '#39'-'#39' )? [0-9]*'
      'function _ValLong(const S: string; var Code: Integer): Integer;'
      '{$IFDEF PUREPASCAL}'
      'const'
      '  FirstIndex = Low(string);'
      'var'
      '  I: Integer;'
      '  Dig: Integer;'
      '  Sign: Boolean;'
      '  Empty: Boolean;'
      'begin'
      '  I := FirstIndex;'
      '  Sign := False;'
      '  Result := 0;'
      '  Empty := True;'
      ''
      '  if S = '#39#39' then'
      '  begin'
      '    Code := 1;'
      '    Exit;'
      '  end;'
      '  while S[I] = '#39' '#39' do'
      '    Inc(I);'
      ''
      '  if S[I] = '#39'-'#39' then'
      '  begin'
      '    Sign := True;'
      '    Inc(I);'
      '  end'
      '  else if S[I] = '#39'+'#39' then'
      '    Inc(I);'
      '  // Hex'
      
        '  if ((S[I] = '#39'0'#39') and (I < High(S)) and ((S[I+1] = '#39'X'#39') or (S[I' +
        '+1] = '#39'x'#39'))) or'
      '      (S[I] = '#39'$'#39') or'
      '      (S[I] = '#39'X'#39') or'
      '      (S[I] = '#39'x'#39') then'
      '  begin'
      '    if S[I] = '#39'0'#39' then'
      '      Inc(I);'
      '    Inc(I);'
      '    while True do'
      '    begin'
      '      case S[I] of'
      '       '#39'0'#39'..'#39'9'#39': Dig := Ord(S[I]) - Ord('#39'0'#39');'
      '       '#39'A'#39'..'#39'F'#39': Dig := Ord(S[I]) - Ord('#39'A'#39') + 10;'
      '       '#39'a'#39'..'#39'f'#39': Dig := Ord(S[I]) - Ord('#39'a'#39') + 10;'
      '      else'
      '        Break;'
      '      end;'
      '      if (Result < 0) or (Result > (High(Integer) shr 3)) then'
      '        Break;'
      '      Result := Result shl 4 + Dig;'
      '      Inc(I);'
      '      Empty := False;'
      '    end;'
      ''
      '    if Sign then'
      '      Result := - Result;'
      '  end'
      '  // Decimal'
      '  else'
      '  begin'
      '    while True do'
      '    begin'
      '      case S[I] of'
      '        '#39'0'#39'..'#39'9'#39': Dig := Ord(S[I]) - Ord('#39'0'#39');'
      '      else'
      '        Break;'
      '      end;'
      '      if (Result < 0) or (Result > (High(Integer) div 10)) then'
      '        Break;'
      '      Result := Result*10 + Dig;'
      '      Inc(I);'
      '      Empty := False;'
      '    end;'
      ''
      '    if Sign then'
      '      Result := - Result;'
      '    if (Result <> 0) and (Sign <> (Result < 0)) then'
      '      Dec(I);'
      '  end;'
      ''
      '  if ((S[I] <> Char(#0)) or Empty) then'
      '    Code := I + 1 - FirstIndex'
      '  else'
      '    Code := 0;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      
        '{       FUNCTION _ValLong( s: string; VAR code: Integer ) : Inte' +
        'ger;    }'
      '{     ->EAX     Pointer to string       }'
      '{       EDX     Pointer to code result  }'
      '{     <-EAX     Result                  }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EAX'
      
        '        PUSH    EAX             { save for the error case       ' +
        '}'
      ''
      '        TEST    EAX,EAX'
      '        JE      @@empty'
      ''
      '        XOR     EAX,EAX'
      '        XOR     EBX,EBX'
      '        MOV     EDI,07FFFFFFFH / 10     { limit }'
      ''
      '@@blankLoop:'
      '        MOV     BX,[ESI]'
      '        ADD     ESI, 2'
      '        CMP     BX,'#39' '#39
      '        JE      @@blankLoop'
      ''
      '@@endBlanks:'
      '        MOV     CH,0'
      '        CMP     BX,'#39'-'#39
      '        JE      @@minus'
      '        CMP     BX,'#39'+'#39
      '        JE      @@plus'
      ''
      '@@checkDollar:'
      '        CMP     BX,'#39'$'#39
      '        JE      @@dollar'
      ''
      '        CMP     BX, '#39'x'#39
      '        JE      @@dollar'
      '        CMP     BX, '#39'X'#39
      '        JE      @@dollar'
      '        CMP     BX, '#39'0'#39
      '        JNE     @@firstDigit'
      '        MOV     BX, [ESI]'
      '        ADD     ESI, 2'
      '        CMP     BX, '#39'x'#39
      '        JE      @@dollar'
      '        CMP     BX, '#39'X'#39
      '        JE      @@dollar'
      '        TEST    BX, BX'
      '        JE      @@endDigits'
      '        JMP     @@digLoop'
      ''
      '@@firstDigit:'
      '        TEST    BX,BX'
      '        JE      @@error'
      ''
      '@@digLoop:'
      '        SUB     BX,'#39'0'#39
      '        CMP     BX,9'
      '        JA      @@error'
      '        CMP     EAX,EDI         { value > limit ?       }'
      '        JA      @@overFlow'
      '        LEA     EAX,[EAX+EAX*4]'
      '        ADD     EAX,EAX'
      
        '        ADD     EAX,EBX         { fortunately, we can'#39't have a c' +
        'arry    }'
      '        MOV     BX,[ESI]'
      '        ADD     ESI, 2'
      '        TEST    BX,BX'
      '        JNE     @@digLoop'
      ''
      '@@endDigits:'
      '        DEC     CH'
      '        JE      @@negate'
      '        TEST    EAX,EAX'
      '        JGE     @@successExit'
      '        JMP     @@overFlow'
      ''
      '@@empty:'
      '        ADD     ESI, 2'
      '        JMP     @@error'
      ''
      '@@negate:'
      '        NEG     EAX'
      '        JLE     @@successExit'
      
        '        JS      @@successExit           { to handle 2**31 correc' +
        'tly, where the negate overflows }'
      ''
      '@@error:'
      '@@overFlow:'
      '        POP     EBX'
      '        SUB     ESI,EBX'
      '        JMP     @@exit'
      ''
      '@@minus:'
      '        INC     CH'
      '@@plus:'
      '        MOV     BX,[ESI]'
      '        ADD     ESI, 2'
      '        JMP     @@checkDollar'
      ''
      '@@dollar:'
      '        MOV     EDI,0FFFFFFFH'
      '        MOV     BX,[ESI]'
      '        ADD     ESI, 2'
      '        TEST    BX,BX'
      '        JZ      @@empty'
      ''
      '@@hDigLoop:'
      '        CMP     BX,'#39'a'#39
      '        JB      @@upper'
      '        SUB     BX,'#39'a'#39' - '#39'A'#39
      '@@upper:'
      '        SUB     BX,'#39'0'#39
      '        CMP     BX,9'
      '        JBE     @@digOk'
      '        SUB     BX,'#39'A'#39' - '#39'0'#39
      '        CMP     BX,5'
      '        JA      @@error'
      '        ADD     BX,10'
      '@@digOk:'
      '        CMP     EAX,EDI'
      '        JA      @@overFlow'
      '        SHL     EAX,4'
      '        ADD     EAX,EBX'
      '        MOV     BX,[ESI]'
      '        ADD     ESI, 2'
      '        TEST    BX,BX'
      '        JNE     @@hDigLoop'
      ''
      '        DEC     CH'
      '        JNE     @@successExit'
      '        NEG     EAX'
      ''
      '@@successExit:'
      
        '        POP     ECX                     { saved copy of string p' +
        'ointer  }'
      
        '        XOR     ESI,ESI         { signal no error to caller     ' +
        '}'
      ''
      '@@exit:'
      '        SHR     ESI, 1'
      '        MOV     [EDX],ESI'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF}'
      ''
      'function _WriteRec(var f: TFileRec; buffer: Pointer): Pointer;'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  NumWritten: Cardinal;'
      'begin'
      '  if (f.Mode = fmOutput) or (f.Mode = fmInOut) then'
      '  begin'
      
        '    if not WriteFile(f.Handle, Buffer, f.RecSize, NumWritten, ni' +
        'l) then'
      '      SetInOutRes(GetLastError)'
      '    else'
      '    begin'
      '      if f.RecSize <> NumWritten then'
      '        SetInOutRes(101);'
      '    end;'
      '  end'
      '  else'
      '    SetInOutRes(5);'
      '  Result := @F;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '// -> EAX Pointer to file variable'
      '//    EDX Pointer to buffer'
      '// <- EAX Pointer to file variable'
      '        PUSH    EBX'
      ''
      '        MOV     EBX,EAX'
      ''
      '        MOVZX   EAX,[EAX].TFileRec.Mode'
      '        SUB     EAX,fmOutput'
      
        '        CMP     EAX,fmInOut-fmOutput  // File must be fmInOut or' +
        ' fmOutput'
      '        JA      @@fileNotOpen'
      ''
      '//  WriteFile(f.Handle, buffer^, f.RecSize, @result, Nil);'
      ''
      '        PUSH    0                       // space for OS result'
      '        MOV     EAX,ESP'
      ''
      '        PUSH    0                       // pass lpOverlapped'
      '        PUSH    EAX                     // pass @result'
      
        '        PUSH    [EBX].TFileRec.RecSize  // pass nNumberOfBytesTo' +
        'Read'
      '        PUSH    EDX                     // pass lpBuffer'
      '        PUSH    [EBX].TFileRec.Handle   // pass hFile'
      '        CALL    WriteFile'
      '        POP     EDX                     // pop result'
      '        DEC     EAX                     // check EAX = TRUE'
      '        JNZ     @@error'
      ''
      
        '        CMP     EDX,[EBX].TFileRec.RecSize  // result = f.RecSiz' +
        'e ?'
      '        JE      @@exit'
      ''
      '@@writeError:'
      '        MOV     EAX,101'
      '        JMP     @@errExit'
      ''
      '@@fileNotOpen:'
      '        MOV     EAX,5'
      '        JMP     @@errExit'
      ''
      '@@error:'
      '        CALL    GetLastError'
      '@@errExit:'
      '        CALL    SetInOutRes'
      '@@exit:'
      '        MOV     EAX,EBX'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'var'
      '  Dummy: Integer;'
      'begin'
      '  _BlockWrite(f, Buffer, 1, @Dummy);'
      '  Result := @F;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      
        '// If the file is Output or ErrOutput std variable, try to open ' +
        'it'
      '// Otherwise, runtime error.'
      'function TryOpenForOutput(var t: TTextRec): Boolean;'
      'begin'
      '  if (@t = @Output) or (@t = @ErrOutput) then'
      '  begin'
      '    t.Flags := tfCRLF * Byte(DefaultTextLineBreakStyle);'
      '    _RewritText(t);'
      '  end;'
      ''
      '  Result := t.Mode = fmOutput;'
      '  if not Result then'
      '    SetInOutRes(105);'
      'end;'
      ''
      
        'function _WriteBytes(var t: TTextRec; const b; cnt: Integer): Po' +
        'inter;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Dest, Source: _PAnsiChr;'
      '  RemainingBytes: Integer;'
      '  Temp: Integer;'
      'begin'
      '  // U-OK'
      '  Result := @t;'
      '  if (t.Mode <> fmOutput) and not TryOpenForOutput(t) then Exit;'
      ''
      '  Source := Pointer(@b);'
      '  Dest := t.BufPtr + t.BufPos;'
      '  RemainingBytes := t.BufSize - t.BufPos;'
      '  while RemainingBytes <= cnt do'
      '  begin'
      '    Inc(t.BufPos, RemainingBytes);'
      '    Dec(cnt, RemainingBytes);'
      '    Move(Source^, Dest^, RemainingBytes);'
      '    Inc(Source, RemainingBytes);'
      '    Temp := TTextIOFunc(t.InOutFunc)(t);'
      '    if Temp <> 0 then'
      '    begin'
      '      SetInOutRes(Temp);'
      '      Exit;'
      '    end;'
      '    Dest := t.BufPtr + t.BufPos;'
      '    RemainingBytes := t.BufSize - t.BufPos;'
      '  end;'
      '  Inc(t.BufPos, cnt);'
      '  Move(Source^, Dest^, cnt);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm //StackAlignSafe'
      '// -> EAX Pointer to file record'
      '//    EDX Pointer to buffer'
      '//    ECX Number of bytes to write'
      '// <- EAX Pointer to file record'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EDX'
      ''
      '        CMP     [EAX].TTextRec.Mode,fmOutput'
      '        JE      @@loop'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        PUSH    ECX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    TryOpenForOutput'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        TEST    AL,AL'
      '        POP     ECX'
      '        POP     EDX'
      '        POP     EAX'
      '        JE      @@exit'
      ''
      '@@loop:'
      '        MOV     EDI,[EAX].TTextRec.BufPtr'
      '        ADD     EDI,[EAX].TTextRec.BufPos'
      ''
      '//  remainingBytes = t.bufSize - t.bufPos'
      ''
      '        MOV     EDX,[EAX].TTextRec.BufSize'
      '        SUB     EDX,[EAX].TTextRec.BufPos'
      ''
      '//  if (remainingBytes <= cnt)'
      ''
      '        CMP     EDX,ECX'
      '        JG      @@1'
      ''
      '//  t.BufPos += remainingBytes, cnt -= remainingBytes'
      ''
      '        ADD     [EAX].TTextRec.BufPos,EDX'
      '        SUB     ECX,EDX'
      ''
      '//  copy remainingBytes, advancing ESI'
      ''
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        MOV     ECX,EDX'
      '        REP     MOVSB'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    [EAX].TTextRec.InOutFunc'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        TEST    EAX,EAX'
      '        JNZ     @@error'
      ''
      '        POP     ECX'
      '        POP     EAX'
      '        JMP     @@loop'
      ''
      '@@error:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SetInOutRes'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        POP     ECX'
      '        POP     EAX'
      '        JMP     @@exit'
      '@@1:'
      '        ADD     [EAX].TTextRec.BufPos,ECX'
      '        REP     MOVSB'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      'end;'
      '{$ENDIF}'
      ''
      'function _WriteSpaces(var t: TTextRec; cnt: Integer): Pointer;'
      'var'
      '  A: _AnsiStr;'
      'begin'
      '  Result := @t;'
      '  if cnt > 64 then'
      '  begin'
      '    SetLength(A, 64);'
      '    FillChar(A[Low(A)], 64, #$20);'
      '    while cnt > 64 do'
      '    begin'
      '      _Write0LString(t, A);'
      '      if InOutRes <> 0 then Exit;'
      '      Dec(cnt, 64);'
      '    end;'
      '  end;'
      '  if cnt > 0 then'
      '  begin'
      '    SetLength(A, cnt);'
      '    FillChar(A[Low(A)], cnt, #$20);'
      '    _Write0LString(t, A);'
      '    if InOutRes <> 0 then Exit;'
      '  end;'
      'end;'
      ''
      
        'procedure InternalUStrFromPCharLen(var Dest: UnicodeString; Sour' +
        'ce: _PAnsiChr; Length: Integer; CodePage: Integer); forward;'
      ''
      ''
      'function _Write0Char(var t: TTextRec; c: _AnsiChr): Pointer;'
      ''
      '  procedure WriteUnicodeFromMBCSBuffer;'
      '  var'
      '    U : UnicodeString;'
      '  begin'
      
        '    InternalUStrFromPCharLen(U, t.MBCSBuffer, t.MBCSLength, Defa' +
        'ultSystemCodePage);'
      '    _Write0UString(t, U);'
      '    t.MBCSLength := 0;'
      '    t.MBCSBufPos := 0;'
      '  end;'
      ''
      'begin'
      '  if t.CodePage = 0 then TryOpenForOutput(t);'
      '  if (t.CodePage = DefaultSystemCodePage) then'
      '  begin'
      '    Result := _WriteBytes(t, c, 1);'
      '    exit;'
      '  end;'
      ''
      '  if t.MBCSLength = 0 then'
      '  begin'
      '    t.MBCSLength := 1;'
      '    if DefaultSystemCodePage = CP_UTF8 then'
      '    begin'
      '      if byte(c) in [$C2..$DF] then'
      '        t.MBCSLength := 2'
      '      else if byte(c) in [$E0..$EF] then'
      '        t.MBCSLength := 3'
      '      else if byte(c) in [$F0..$F4] then'
      '        t.MBCSLength := 4;'
      '    end'
      '{$IFDEF MSWINDOWS}'
      
        '    else if IsDBCSLeadByteEx(UINT(DefaultSystemCodePage), Byte(c' +
        ')) then'
      '      t.MBCSLength := 2;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '                                                     '
      '    else'
      '      t.MBCSLength := 1;'
      '{$ENDIF POSIX}'
      '    t.MBCSBufPos := 0;'
      '  end;'
      ''
      '  if t.MBCSLength > 0 then'
      '  begin'
      '    t.MBCSBuffer[t.MBCSBufPos] := c;'
      '    Inc(t.MBCSBufPos);'
      '    if t.MBCSBufPos = byte(t.MBCSLength) then'
      '      WriteUnicodeFromMBCSBuffer;'
      '  end;'
      '  Result := @t;'
      'end;'
      ''
      
        'function _WriteChar(var t: TTextRec; c: _AnsiChr; width: Integer' +
        '): Pointer;'
      'var'
      '  A: _AnsiStr;'
      'begin'
      '  if width <= 1 then'
      '    Result := _Write0Char(t, c)'
      '  else'
      '  begin'
      '    __FlushMBCSBuffer(t);'
      '    if t.CodePage = 0 then TryOpenForOutput(t);'
      '    if t.CodePage = DefaultSystemCodePage then'
      '    begin'
      '      _WriteSpaces(t, width-1);'
      '      Result := _WriteBytes(t, c, 1);'
      '    end'
      '    else'
      '    begin'
      '      _LStrFromChar(A, c, DefaultSystemCodePage);'
      '      Result := _WriteLString(t, A, width);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'function _WriteBool(var t: TTextRec; val: Boolean; width: Intege' +
        'r): Pointer;'
      'const'
      '  BoolStrs: array [Boolean] of _ShortStr = ('#39'FALSE'#39', '#39'TRUE'#39');'
      'begin'
      '  Result := _WriteString(t, BoolStrs[val<>false], width);'
      'end;'
      ''
      'function _Write0Bool(var t: TTextRec; val: Boolean): Pointer;'
      'begin'
      '  Result := _WriteBool(t, val, 0);'
      'end;'
      ''
      
        'function _WriteLong(var t: TTextRec; val, width: Integer): Point' +
        'er;'
      'var'
      '{$IFNDEF NEXTGEN}'
      '  S: string[31];'
      '{$ELSE}'
      '  S: _ShortStr;'
      '{$ENDIF}'
      'begin'
      '  Str(val:0, S);'
      '  Result := _WriteString(t, S, width);'
      'end;'
      ''
      'function _Write0Long(var t: TTextRec; val: Integer): Pointer;'
      'begin'
      '  Result := _WriteLong(t, val, 0);'
      'end;'
      ''
      
        'function _Write0String(var t: TTextRec; const s: _ShortStr): Poi' +
        'nter;'
      'begin'
      '  result := _WriteString(t, s, 0);'
      'end;'
      ''
      
        'function _WriteString(var t: TTextRec; const s: _ShortStr; width' +
        ': Integer): Pointer;'
      'begin'
      '  Result := _WriteLString(t, s, width);'
      'end;'
      ''
      'function _Write0CString(var t: TTextRec; s: _PAnsiChr): Pointer;'
      'begin'
      '  Result := _WriteCString(t, s, 0);'
      'end;'
      ''
      
        'function _WriteCString(var t: TTextRec; s: _PAnsiChr; width: Int' +
        'eger): Pointer;'
      'var'
      '  A: _AnsiStr;'
      'begin'
      '  _LStrFromPChar(A, s, DefaultSystemCodePage);'
      '  Result := _WriteLString(t, A, width);'
      'end;'
      ''
      
        'function _Write0LString(var t: TTextRec; const s: _AnsiStr): Poi' +
        'nter;'
      'begin'
      '  __FlushMBCSBuffer(t);'
      '  Result := @t;'
      '  if s <> '#39#39' then'
      '  begin'
      '    if t.CodePage = 0 then TryOpenForOutput(t);'
      '    if t.CodePage = PWord(PByte(s) - 12)^ then'
      '      Result := _WriteBytes(t, s[Low(string)], Length(s))'
      '    else'
      '      Result := _Write0UString(t, UnicodeString(s));'
      '  end;'
      'end;'
      ''
      
        'function _WriteLString(var t: TTextRec; const s: _AnsiStr; width' +
        ': Integer): Pointer;'
      'var'
      '  i: Integer;'
      'begin'
      '  __FlushMBCSBuffer(t);'
      '  if s = '#39#39' then'
      '    Result := _WriteSpaces(t, width)'
      '  else'
      '  begin'
      '    if t.CodePage = 0 then TryOpenForOutput(t);'
      '    if t.CodePage = PWord(PByte(s) - 12)^ then'
      '    begin'
      '      i := Length(s);'
      '      _WriteSpaces(t, width - i);'
      '      Result := _WriteBytes(t, s[Low(string)], i);'
      '    end'
      '    else'
      '      Result := _WriteUString(t, UnicodeString(s), width);'
      '  end;'
      'end;'
      ''
      
        'function _Write0UString(var t: TTextRec; const s: UnicodeString)' +
        ': Pointer;'
      'begin'
      '  Result := _WriteUString(t, s, 0);'
      'end;'
      ''
      
        'function _WriteUString(var t: TTextRec; const s: UnicodeString; ' +
        'width: Integer): Pointer;'
      'var'
      '  i: Integer;'
      '  A: _AnsiStr;'
      'begin'
      '  if s = '#39#39' then'
      '    Result := _WriteSpaces(t, width )'
      '  else'
      '  begin'
      '    if t.CodePage = 0 then TryOpenForOutput(t);'
      '    if t.CodePage = CP_UTF16 then // Output is UTF16'
      '    begin'
      '      i := Length(s);'
      '      _WriteSpaces(t, width - i);'
      
        '      Result := _WriteBytes(t, s[Low(string)], i*sizeof(WideChar' +
        '));'
      '    end'
      '    else'
      '    begin'
      '      if assigned(AlternateWriteUnicodeStringProc) then'
      '        Result := AlternateWriteUnicodeStringProc(t, s)'
      '      else'
      '      begin'
      '        _LStrFromUStr(A, s, t.CodePage);'
      '        i := Length(A);'
      '        _WriteSpaces(t, width - i);'
      '        Result := _WriteBytes(t, A[Low(string)], i);'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'function _Write0WString(var t: TTextRec; const s: _WideStr): Poi' +
        'nter;'
      'begin'
      '  Result := _WriteUString(t, s, 0);'
      'end;'
      ''
      
        'function _WriteWString(var t: TTextRec; const s: _WideStr; width' +
        ': Integer): Pointer;'
      'begin'
      '  Result := _WriteUString(t, UnicodeString(s), width);'
      'end;'
      ''
      
        'function _Write0WCString(var t: TTextRec; s: PWideChar): Pointer' +
        ';'
      'begin'
      '  Result := _WriteUString(t, UnicodeString(s), 0);'
      'end;'
      ''
      
        'function _WriteWCString(var t: TTextRec; s: PWideChar; width: In' +
        'teger): Pointer;'
      'begin'
      '  Result := _WriteUString(t, UnicodeString(s), width);'
      'end;'
      ''
      'function _Write0WChar(var t: TTextRec; c: WideChar): Pointer;'
      'begin'
      '  Result := @t;'
      '  if t.CodePage = 0 then TryOpenForOutput(t);'
      '  if t.CodePage = CP_UTF16 then'
      '  begin'
      '    _WriteBytes(t, c, sizeof(WideChar));'
      '    exit;'
      '  end;'
      ''
      '  if t.MBCSLength > 0 then'
      '  begin'
      '    if (Word(c) >= $DC00) and (Word(c) < $E000) then'
      '    begin'
      '      t.UTF16Buffer[1] := c;'
      '      t.UTF16Buffer[2] := #0;'
      ''
      '      _WriteUString(t, UnicodeString(t.UTF16Buffer), 0);'
      '    end;'
      '    t.MBCSLength := 0;'
      '    exit;'
      '  end;'
      ''
      '  if (Word(c) >= $D800) and (Word(c) < $DC00) then'
      '  begin'
      '    t.MBCSLength := 2;'
      '    t.UTF16Buffer[0] := c;'
      '  end'
      '  else'
      '    _WriteUString(t, UnicodeString(c), 0);'
      'end;'
      ''
      
        'function _WriteWChar(var t: TTextRec; c: WideChar; width: Intege' +
        'r): Pointer;'
      'begin'
      '  if width <= 1 then'
      '    result := _Write0WChar(t, c)'
      '  else'
      '  begin'
      '    if t.MBCSLength < 0 then'
      '    begin'
      '      _Write0WChar(t, '#39'?'#39');'
      '      t.UTF16Buffer[0] := #0;'
      '    end;'
      ''
      '    _WriteSpaces(t, width - 1);'
      '    Result := _Write0WChar(t, c);'
      '  end;'
      'end;'
      ''
      
        'function _Write0Variant(var T: TTextRec; const V: TVarData): Poi' +
        'nter;'
      'begin'
      '  Result := _WriteVariant(T, V, 0);'
      'end;'
      ''
      
        'function _WriteVariant(var T: TTextRec; const V: TVarData; Width' +
        ': Integer): Pointer;'
      'var'
      '  S: _AnsiStr;'
      '  U: UnicodeString;'
      'begin'
      '  if (V.VType = varString) and Assigned(VarToLStrProc) then'
      '  begin'
      '    VarToLStrProc(S, V);'
      '    _WriteLString(T, S, Width);'
      '  end'
      '  else if Assigned(VarToUStrProc) then'
      '  begin'
      '    VarToUStrProc(U, V);'
      '    _WriteUString(T, U, Width);'
      '  end'
      '  else'
      '    Error(reVarInvalidOp);'
      '  Result := @T;'
      'end;'
      ''
      '{$IF not DEFined(X86ASMRTL)}'
      
        'function _Write2Ext(var T: TTextRec; Val: Extended; Width, Prec:' +
        ' Integer): Pointer;'
      'var'
      ' S : _ShortStr;'
      'begin'
      '  S := _Str2Ext(Val, Width, Prec);'
      '  Result := _WriteString(T, S, Width);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _Write2Ext;'
      'const'
      '{$IFDEF MACOS}'
      '  SizeOfExtendedOnStack = 16;'
      '{$ELSE}'
      '  SizeOfExtendedOnStack = 12;'
      '{$ENDIF}'
      'asm'
      
        '{       PROCEDURE _Write2Ext( VAR t: Text; val: Extended; width,' +
        ' prec: Integer);'
      '      ->EAX     Pointer to file record'
      '        [ESP+4] Extended value'
      '        EDX     Field width'
      
        '        ECX     precision (<0: scientific, >= 0: fixed point)   ' +
        '}'
      ''
      
        '        FLD     tbyte ptr [ESP+4]       { load value            ' +
        '}'
      '{$IFDEF ALIGN_STACK}'
      '{$IFDEF MACOS}'
      '        SUB     ESP, 4'
      '{$ELSE}'
      '        SUB     ESP, 8'
      '{$ENDIF}'
      '{$ENDIF}'
      
        '        SUB     ESP,256                 { VAR s: String;        ' +
        '}'
      ''
      '        PUSH    EAX'
      '        PUSH    EDX'
      ''
      '{       Str( val, width, prec, s );     }'
      ''
      '        SUB     ESP, SizeOfExtendedOnStack'
      
        '        FSTP    tbyte ptr [ESP]         { pass value            ' +
        '        }'
      
        '        MOV     EAX,EDX                 { pass field width      ' +
        '        }'
      
        '        MOV     EDX,ECX                 { pass precision        ' +
        '        }'
      
        '                                        { pass destination strin' +
        'g    }'
      '        LEA     ECX,[ESP+8+SizeOfExtendedOnStack]'
      '        CALL    _Str2Ext'
      ''
      '{       Write( t, s, width );   }'
      ''
      '        POP     ECX                     { pass width    }'
      '        POP     EAX                     { pass text     }'
      '        MOV     EDX,ESP                 { pass string   }'
      '{$IFDEF ALIGN_STACK}'
      '{$IFDEF MACOS}'
      '        SUB     ESP, 8'
      '{$ELSE}'
      '        SUB     ESP, 4'
      '{$ENDIF}'
      '{$ENDIF}'
      '        CALL    _WriteString'
      ''
      '        ADD     ESP,256'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF}'
      '        RET     SizeOfExtendedOnStack'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not DEFined(X86ASMRTL)}'
      
        'function _Write1Ext(var T: TTextRec; Val: Extended; Width: Integ' +
        'er): Pointer;'
      'begin'
      '  Result := _Write2Ext(T, Val, Width, -1);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _Write1Ext;'
      'asm'
      
        '{       PROCEDURE _Write1Ext( VAR t: Text; val: Extended; width:' +
        ' Integer);'
      '  ->    EAX     Pointer to file record'
      '        [ESP+4] Extended value'
      '        EDX     Field width             }'
      ''
      '        OR      ECX,-1'
      '        JMP     _Write2Ext'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not DEFined(X86ASMRTL)}'
      'function _Write0Ext(var T: TTextRec; Val: Extended): Pointer;'
      'begin'
      '  Result := _Write2Ext(T, Val, 23, -1);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _Write0Ext;'
      'asm'
      '{       PROCEDURE _Write0Ext( VAR t: Text; val: Extended);'
      '      ->EAX     Pointer to file record'
      '        [ESP+4] Extended value  }'
      ''
      '        MOV     EDX,23  { field width   }'
      '        OR      ECX,-1'
      '        JMP     _Write2Ext'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'function _Write2Comp(var T: TTextRec; Val: Comp; Width, Prec: In' +
        'teger): Pointer;'
      'var'
      ' S : _ShortStr;'
      'begin'
      '  S := _Str2Comp(Val, Width, Prec);'
      '  Result := _WriteString(T, S, Width);'
      'end;'
      ''
      
        'function _Write1Comp(var T: TTextRec; Val: Comp; Width: Integer)' +
        ': Pointer;'
      'begin'
      '  Result := _Write2Comp(T, Val, Width, -1);'
      'end;'
      ''
      'function _Write0Comp(var T: TTextRec; Val: Comp): Pointer;'
      'begin'
      '  Result := _Write2Comp(T, Val, 23, -1);'
      'end;'
      ''
      
        'function _Write2Currency(var T: TTextRec; Val: Currency; Width, ' +
        'Prec: Integer): Pointer;'
      'var'
      ' S : _ShortStr;'
      'begin'
      '  S := _Str2Currency(Val, Width, Prec);'
      '  Result := _WriteString(T, S, Width);'
      'end;'
      ''
      
        'function _Write1Currency(var T: TTextRec; Val: Currency; Width: ' +
        'Integer): Pointer;'
      'begin'
      '  Result := _Write2Currency(T, Val, Width, -1);'
      'end;'
      ''
      
        'function _Write0Currency(var T: TTextRec; Val: Currency): Pointe' +
        'r;'
      'begin'
      '  Result := _Write2Currency(T, Val, 23, -1);'
      'end;'
      '{$ENDIF !CPUX86}'
      ''
      ''
      'function _WriteLn(var t: TTextRec): Pointer;'
      'begin'
      '  if (t.Flags and tfCRLF) <> 0 then'
      '    _Write0Char(t, _AnsiChr(cCR));'
      '  Result := _Write0Char(t, _AnsiChr(cLF));'
      '  _Flush(t);'
      'end;'
      ''
      
        'procedure __CToPasStr(Dest: _PShortStr; const Source: _PAnsiChr)' +
        ';'
      'begin'
      '  __CLenToPasStr(Dest, Source, 255);'
      'end;'
      ''
      
        'procedure __CLenToPasStr(Dest: _PShortStr; const Source: _PAnsiC' +
        'hr; MaxLen: NativeInt);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: NativeInt;'
      'begin'
      '  I := 0;'
      '  if Source <> nil then'
      '  begin'
      '    if MaxLen > 255 then MaxLen := 255;'
      '    while (Source[I] <> #0) and (I < MaxLen) do'
      '    begin'
      '      Dest^[I+1] := Source[I];'
      '      Inc(I);'
      '    end;'
      '  end;'
      '  Byte(Dest^[0]) := I;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '{     ->EAX     Pointer to destination  }'
      '{       EDX     Pointer to source       }'
      '{       ECX     cnt                     }'
      ''
      '        PUSH    EBX'
      '        PUSH    EAX             { save destination      }'
      ''
      '        TEST    EDX,EDX'
      '        JZ      @@nilStr'
      '        CMP     ECX,255'
      '        JBE     @@loop'
      '        MOV     ECX,255'
      '@@loop:'
      '        MOV     BL,[EDX]        { ch = *src++;          }'
      '        INC     EDX'
      '        TEST    BL,BL           { if (ch == 0) break    }'
      '        JE      @@endLoop'
      '        INC     EAX             { *++dest = ch;         }'
      '        MOV     [EAX],BL'
      '        DEC     ECX             { while (--cnt != 0)    }'
      '        JNZ     @@loop'
      ''
      '@@endLoop:'
      '        POP     EDX'
      '        SUB     EAX,EDX'
      ''
      '@@setLength:'
      '        MOV     [EDX],AL'
      '        POP     EBX'
      '        RET'
      ''
      '@@nilStr:'
      '        POP     EDX'
      '        XOR     EAX,EAX'
      '        JMP     @@setLength'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure __ArrayToPasStr(Dest: _PShortStr; const Source: _PAnsi' +
        'Chr; Len: NativeInt);'
      'begin'
      '  if Len > 255 then Len := 255;'
      '  Byte(Dest^[0]) := Len;'
      '  Move(Source^, Dest^[1], Len);'
      'end;'
      ''
      
        'procedure __PasToCStr(const Source: _PShortStr; const Dest: _PAn' +
        'siChr);'
      'begin'
      '  Move(Source^[1], Dest^, Byte(Source^[0]));'
      '  Dest[Byte(Source^[0])] := #0;'
      'end;'
      ''
      
        '// __PasToWCStr is called from Str() standard procedure if 2nd p' +
        'arameter'
      
        '// is zero based WideChar array. In this case, character code is' +
        ' restricted'
      '// to ASCII. So, conversion is simple.'
      
        'procedure __PasToWCStr(const Source: _PShortStr; const Dest: PWi' +
        'deChar);'
      'var'
      '  I, N: NativeInt;'
      'begin'
      '  N := Byte(Source^[0]);'
      '  for I := 1 to N do'
      '    Dest[I - 1] := WideChar(Ord(Source^[I]));'
      '  Dest[N] := #0;'
      'end;'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for set type support            }'
      '{ ----------------------------------------------------- }'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      'procedure _SetElem(var Dest {:Set}; Elem, Size: Integer);'
      'var'
      '  P: PByte;'
      '  I: Integer;'
      'begin'
      '  P := @Dest;'
      '  for I := 0 to Size - 1 do'
      '    P[I] := 0;'
      '  if (Elem >= 0) and ((Elem div 8) < Size) then'
      '    P[Elem div 8] := 1 shl (Elem mod 8);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure       _SetElem;'
      'asm'
      
        '        {       PROCEDURE _SetElem( VAR d: SET; elem, size: Byte' +
        ');      }'
      
        '        {       EAX     =       dest address                    ' +
        '        }'
      
        '        {       DL      =       element number                  ' +
        '        }'
      
        '        {       CL      =       size of set                     ' +
        '        }'
      ''
      '        PUSH    EBX'
      '        PUSH    EDI'
      ''
      '        MOV     EDI,EAX'
      ''
      '        XOR     EBX,EBX { zero extend set size into ebx }'
      '        MOV     BL,CL'
      '        MOV     ECX,EBX { and use it for the fill       }'
      ''
      '        XOR     EAX,EAX { for zero fill                 }'
      '        REP     STOSB'
      ''
      
        '        SUB     EDI,EBX { point edi at beginning of set again   ' +
        '}'
      ''
      
        '        INC     EAX             { eax is still zero - make it 1 ' +
        '}'
      '        MOV     CL,DL'
      '        ROL     AL,CL   { generate a mask               }'
      '        SHR     ECX,3   { generate the index            }'
      '        CMP     ECX,EBX { if index >= siz then exit     }'
      '        JAE     @@exit'
      '        OR      [EDI+ECX],AL{ set bit                   }'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      'procedure _SetRange(Lo, Hi, Size: Integer; var Dest {:Set});'
      'var'
      '  P: PByte;'
      '  I: Integer;'
      '  LoIndex, HiIndex: Integer;'
      '  LoMask, HiMask: Byte;'
      'begin'
      '  P := @dest;'
      '  for I := 0 to Size - 1 do'
      '    P[I] := 0;'
      '  if Hi >= Size * 8 then'
      '    Hi := Size * 8 - 1;'
      '  if Lo < 0 then'
      '    Lo := 0;'
      '  if Lo <= Hi then'
      '  begin'
      '    LoMask := $ff shl (Lo mod 8);'
      '    LoIndex := Lo div 8;'
      '    HiMask := UInt32($FF) shr (7 - (Hi mod 8));'
      '    HiIndex := Hi div 8;'
      '    P[LoIndex] := LoMask;'
      '    for I := LoIndex+1 to HiIndex do'
      '      P[I] := $ff;'
      '    P[HiIndex] := P[HiIndex] and HiMask;'
      '  end;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetRange;'
      'asm'
      
        '{       PROCEDURE _SetRange( lo, hi, size: Byte; VAR d: SET );  ' +
        '}'
      '{ ->    AL      low limit of range      }'
      '{       DL      high limit of range     }'
      '{       ECX     Pointer to set          }'
      '{       AH      size of set             }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        XOR     EBX,EBX { EBX = set size                }'
      '        MOV     BL,AH'
      '        MOVZX   ESI,AL  { ESI = low zero extended       }'
      '        MOVZX   EDX,DL  { EDX = high zero extended      }'
      '        MOV     EDI,ECX'
      ''
      '{       clear the set                                   }'
      ''
      '        MOV     ECX,EBX'
      '        XOR     EAX,EAX'
      '        REP     STOSB'
      ''
      '{       prepare for setting the bits                    }'
      ''
      '        SUB     EDI,EBX { point EDI at start of set     }'
      '        SHL     EBX,3   { EBX = highest bit in set + 1  }'
      '        CMP     EDX,EBX'
      '        JB      @@inrange'
      
        '        LEA     EDX,[EBX-1]     { ECX = highest bit in set      ' +
        '}'
      ''
      '@@inrange:'
      '        CMP     ESI,EDX { if lo > hi then exit;         }'
      '        JA      @@exit'
      ''
      
        '        DEC     EAX     { loMask = 0xff << (lo & 7)             ' +
        '}'
      '        MOV     ECX,ESI'
      '        AND     CL,07H'
      '        SHL     AL,CL'
      ''
      '        SHR     ESI,3   { loIndex = lo >> 3;            }'
      ''
      
        '        MOV     CL,DL   { hiMask = 0xff >> (7 - (hi & 7));      ' +
        '}'
      '        NOT     CL'
      '        AND     CL,07'
      '        SHR     AH,CL'
      ''
      '        SHR     EDX,3   { hiIndex = hi >> 3;            }'
      ''
      '        ADD     EDI,ESI { point EDI to set[loIndex]     }'
      '        MOV     ECX,EDX'
      
        '        SUB     ECX,ESI { if ((inxDiff = (hiIndex - loIndex)) ==' +
        ' 0)     }'
      '        JNE     @@else'
      ''
      
        '        AND     AL,AH   { set[loIndex] = hiMask & loMask;       ' +
        '}'
      '        MOV     [EDI],AL'
      '        JMP     @@exit'
      ''
      '@@else:'
      '        STOSB           { set[loIndex++] = loMask;      }'
      '        DEC     ECX'
      '        MOV     AL,0FFH { while (loIndex < hiIndex)     }'
      '        REP     STOSB   {   set[loIndex++] = 0xff;      }'
      
        '        MOV     [EDI],AH        { set[hiIndex] = hiMask;        ' +
        '}'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      'function _SetEq(L, R: Pointer; Size: Integer): Boolean;'
      'var'
      '  I: Integer;'
      'begin'
      '  Result := False;'
      '  for I := 0 to Size - 1 do'
      '    if PByte(L)[I] <> PByte(R)[I] then Exit;'
      '  Result := True;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetEq;'
      'asm'
      
        '{       FUNCTION _SetEq( CONST l, r: Set; size: Byte): Condition' +
        'Code;   }'
      '{       EAX     =       left operand    }'
      '{       EDX     =       right operand   }'
      '{       CL      =       size of set     }'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EAX'
      '        MOV     EDI,EDX'
      ''
      '        AND     ECX,0FFH'
      ''
      '@@Loop:'
      '        DEC     ECX'
      '        JZ      @@ByteCheck'
      '        MOVZX   EAX,WORD PTR [ESI+ECX-1]'
      '        MOVZX   EDX,WORD PTR [EDI+ECX-1]'
      '        CMP     EAX,EDX'
      '        JNE     @@Leave'
      '        DEC     ECX'
      '        JNZ     @@Loop'
      '@@Leave:'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        RET'
      ''
      '@@ByteCheck:'
      '        MOV     AL,[ESI+ECX]'
      '        MOV     DL,[EDI+ECX]'
      '        CMP     AL,DL'
      '        JNE     @@Leave'
      '        OR      ECX,ECX // set zero flag'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        RET'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      'function _SetLe(L, R: Pointer; Size: Integer): Boolean;'
      'var'
      '  I: Integer;'
      'begin'
      '  Result := False;'
      '  for I := 0 to Size - 1 do'
      '    if (PByte(L)[I] and not PByte(R)[I]) <> 0 then Exit;'
      '  Result := True;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetLe;'
      'asm'
      
        '{       FUNCTION _SetLe( CONST l, r: Set; size: Byte): Condition' +
        'Code;   }'
      '{       EAX     =       left operand            }'
      '{       EDX     =       right operand           }'
      '{       CL      =       size of set (>0 && <= 32)       }'
      ''
      '@@loop:'
      '        MOV     CH,[EDX]'
      '        NOT     CH'
      '        AND     CH,[EAX]'
      '        JNE     @@exit'
      '        INC     EDX'
      '        INC     EAX'
      '        DEC     CL'
      '        JNZ     @@loop'
      '@@exit:'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _SetIntersect(var Dest {:Set}; Src: Pointer{PSet}; Siz' +
        'e: Integer);'
      'var'
      '  I: Integer;'
      '  PD, PS: PByte;'
      'begin'
      '  PD := PByte(@Dest);'
      '  PS := PByte(Src);'
      '  for I := 0 to Size - 1 do'
      '    PD[I] := PD[I] and PS[I];'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetIntersect;'
      'asm'
      
        '{       PROCEDURE _SetIntersect( VAR dest: Set; CONST src: Set; ' +
        'size: Byte);}'
      '{       EAX     =       destination operand             }'
      '{       EDX     =       source operand                  }'
      '{       CL      =       size of set (0 < size <= 32)    }'
      ''
      '@@loop:'
      '        MOV     CH,[EDX]'
      '        INC     EDX'
      '        AND     [EAX],CH'
      '        INC     EAX'
      '        DEC     CL'
      '        JNZ     @@loop'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _SetIntersect3(var Dest {:Set}; L, R: Pointer{PSet}; S' +
        'ize: Integer);'
      'var'
      '  I: Integer;'
      '  PD, PL, PR: PByte;'
      'begin'
      '  PD := PByte(@Dest);'
      '  PL := PByte(L);'
      '  PR := PByte(R);'
      '  for I := 0 to Size - 1 do'
      '    PD[I] := PL[I] and PR[I];'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetIntersect3;'
      'asm'
      
        '{       PROCEDURE _SetIntersect3( VAR dest: Set; CONST src: Set;' +
        ' size: Integer; src2: Set);}'
      '{       EAX     =       destination operand             }'
      '{       EDX     =       source operand                  }'
      '{       ECX     =       size of set (0 < size <= 32)    }'
      '{       [ESP+4] = 2nd source operand                    }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        MOV     ESI,[ESP+8+4]'
      '@@loop:'
      '        MOV     BL,[EDX+ECX-1]'
      '        AND     BL,[ESI+ECX-1]'
      '        MOV     [EAX+ECX-1],BL'
      '        DEC     ECX'
      '        JNZ     @@loop'
      ''
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _SetUnion(var Dest {:Set}; Src: Pointer{PSet}; Size: I' +
        'nteger);'
      'var'
      '  I: Integer;'
      '  PD, PS: PByte;'
      'begin'
      '  PD := PByte(@Dest);'
      '  PS := PByte(Src);'
      '  for I := 0 to Size - 1 do'
      '    PD[I] := PD[I] or PS[I];'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetUnion;'
      'asm'
      
        '{       PROCEDURE _SetUnion( VAR dest: Set; CONST src: Set; size' +
        ': Byte);        }'
      '{       EAX     =       destination operand             }'
      '{       EDX     =       source operand                  }'
      '{       CL      =       size of set (0 < size <= 32)    }'
      ''
      '@@loop:'
      '        MOV     CH,[EDX]'
      '        INC     EDX'
      '        OR      [EAX],CH'
      '        INC     EAX'
      '        DEC     CL'
      '        JNZ     @@loop'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _SetUnion3(var Dest {:Set}; L, R: Pointer{PSet}; Size:' +
        ' Integer);'
      'var'
      '  I: Integer;'
      '  PD, PL, PR: PByte;'
      'begin'
      '  PD := PByte(@Dest);'
      '  PL := PByte(L);'
      '  PR := PByte(R);'
      '  for I := 0 to Size - 1 do'
      '    PD[I] := PL[I] or PR[I];'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetUnion3;'
      'asm'
      
        '{       PROCEDURE _SetUnion3( VAR dest: Set; CONST src: Set; siz' +
        'e: Integer; src2: Set);}'
      '{       EAX     =       destination operand             }'
      '{       EDX     =       source operand                  }'
      '{       ECX     =       size of set (0 < size <= 32)    }'
      '{ [ESP+4] = 2nd source operand    }'
      ''
      '      PUSH  EBX'
      '      PUSH  ESI'
      '      MOV   ESI,[ESP+8+4]'
      '@@loop:'
      '      MOV   BL,[EDX+ECX-1]'
      '      OR    BL,[ESI+ECX-1]'
      '      MOV   [EAX+ECX-1],BL'
      '      DEC   ECX'
      '      JNZ   @@loop'
      ''
      '      POP   ESI'
      '      POP   EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _SetSub(var Dest {:Set}; Src: Pointer{PSet}; Size: Int' +
        'eger);'
      'var'
      '  I: Integer;'
      '  PD, PS: PByte;'
      'begin'
      '  PD := PByte(@Dest);'
      '  PS := PByte(Src);'
      '  for I := 0 to Size - 1 do'
      '    PD[I] := PD[I] and not PS[I];'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetSub;'
      'asm'
      
        '{       PROCEDURE _SetSub( VAR dest: Set; CONST src: Set; size: ' +
        'Byte);  }'
      '{       EAX     =       destination operand             }'
      '{       EDX     =       source operand                  }'
      '{       CL      =       size of set (0 < size <= 32)    }'
      ''
      '@@loop:'
      '        MOV     CH,[EDX]'
      '        NOT     CH'
      '        INC     EDX'
      '        AND     [EAX],CH'
      '        INC     EAX'
      '        DEC     CL'
      '        JNZ     @@loop'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _SetSub3(var Dest {:set}; L, R: Pointer{PSet}; Size: I' +
        'nteger);'
      'var'
      '  I: Integer;'
      '  PD, PL, PR: PByte;'
      'begin'
      '  PD := PByte(@Dest);'
      '  PL := PByte(L);'
      '  PR := PByte(R);'
      '  for I := 0 to Size - 1 do'
      '    PD[I] := PL[I] and not PR[I];'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetSub3;'
      'asm'
      
        '{       PROCEDURE _SetSub3( VAR dest: Set; CONST src: Set; size:' +
        ' Integer; src2: Set);}'
      '{       EAX     =       destination operand             }'
      '{       EDX     =       source operand                  }'
      '{       ECX     =       size of set (0 < size <= 32)    }'
      '{       [ESP+4] = 2nd source operand                    }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        MOV     ESI,[ESP+8+4]'
      '@@loop:'
      '        MOV     BL,[ESI+ECX-1]'
      '        NOT     BL'
      '        AND     BL,[EDX+ECX-1]'
      '        MOV     [EAX+ECX-1],BL'
      '        DEC     ECX'
      '        JNZ     @@loop'
      ''
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _SetExpand(Src: Pointer{PSet}; var Dest {:Set}; Lo, Hi' +
        ': Integer);'
      'var'
      '  I: Integer;'
      '  PD, PS: PByte;'
      'begin'
      '  PD := PByte(@Dest);'
      '  PS := PByte(Src);'
      '  for I := 0 to Lo - 1 do'
      '    PD[I] := 0;'
      '  for I := Lo to Hi - 1 do'
      '    PD[I] := PS[I - Lo];'
      '  for I := Hi to 31 do'
      '    PD[I] := 0;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _SetExpand;'
      'asm'
      
        '{       PROCEDURE _SetExpand( CONST src: Set; VAR dest: Set; lo,' +
        ' hi: Byte);     }'
      '{     ->EAX     Pointer to source (packed set)          }'
      '{       EDX     Pointer to destination (expanded set)   }'
      '{       CH      high byte of source                     }'
      '{       CL      low byte of source                      }'
      ''
      '{       algorithm:              }'
      '{       clear low bytes         }'
      '{       copy high-low+1 bytes   }'
      '{       clear 31-high bytes     }'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EAX'
      '        MOV     EDI,EDX'
      ''
      '        MOV     EDX,ECX { save low, high in dl, dh      }'
      '        XOR     ECX,ECX'
      '        XOR     EAX,EAX'
      ''
      '        MOV     CL,DL   { clear low bytes               }'
      '        REP     STOSB'
      ''
      '        MOV     CL,DH   { copy high - low bytes }'
      '        SUB     CL,DL'
      '        REP     MOVSB'
      ''
      '        MOV     CL,32   { copy 32 - high bytes  }'
      '        SUB     CL,DH'
      '        REP     STOSB'
      ''
      '        POP     EDI'
      '        POP     ESI'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      'function ScaleExt(var val: Extended): Integer;'
      'var'
      '  expBase10: Integer;'
      '  ExpBase2: Int16;'
      'begin'
      '  Result := 0;'
      '  while (val <> 0) do'
      '  begin'
      '    ExpBase2 := PExtendedRec(@val)^.Exponent;'
      
        '    // exp10 * 2 ** 16 = exp2 * log10(2) * 2**16. Log10(2) * 2 *' +
        '* 16 ~= 19728'
      '    expBase10 := ExpBase2 * 19728;'
      '    // Temp = High 16 bits of result, sign extended'
      '    expBase10 := PSmallInt(PByte(@expBase10)+2)^;'
      '    if expBase10 = 0 then break;'
      '    Inc(Result, expBase10);'
      '    val := Power10(val, -expBase10);'
      '  end;'
      'end;'
      ''
      '// Rounding at next of position.'
      '// digBuf[-1] keeps '#39'0'#39
      '// If rounding overflow, return True.'
      '// Otherwise, return False.'
      'function RoundDigits(digBuf: PByte; position: Integer): Boolean;'
      'var'
      '  I: Integer;'
      'begin'
      '  Result := False;'
      '  if (digBuf[position+1] >= Byte('#39'5'#39')) then'
      '  begin'
      '    I := position;'
      '    while True do'
      '    begin'
      '      if digBuf[I] = Byte('#39'9'#39') then'
      '      begin'
      '        digBuf[I] := Byte('#39'0'#39');'
      '        dec(I);'
      '      end'
      '      else'
      '      begin'
      '        Inc(digBuf[I]);'
      '        Result := (I = -1);'
      '        break;'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure EmitDigits(val: Extended; digCnt: Integer; digBuf: PBy' +
        'te; var Exponent: Integer);'
      'type'
      '    TBCDBytes = array [0..9] of Byte;'
      ''
      '  function GetBcdBytes(val:Extended): TBcdBytes;'
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      '  asm'
      '      FLD       tbyte ptr Val'
      '      FBSTP     [Result]'
      '      FWAIT'
      '  end;'
      '{$ELSE}'
      '  var'
      '    I: Int64;'
      '    Ind, D: Integer;'
      '  begin'
      '    FillChar(Result, SizeOf(Result), 0);'
      '    if val < 0 then Result[9] := $80;'
      '    I := Round(Abs(val));'
      '    Ind := 0;'
      '    while (I > 0) and (Ind < 9) do'
      '    begin'
      '      D := I mod 100;'
      '      Result[Ind] := (D mod 10) + ((D div 10) shl 4);'
      '      I := I div 100;'
      '      Inc(Ind);'
      '    end;'
      '  end;'
      '{$ENDIF}'
      ''
      'var'
      '  bcdBytes: TBcdBytes;'
      '  I: Integer;'
      'begin'
      '  Exponent := ScaleExt(val);'
      '  digBuf[0] := Byte('#39'0'#39');'
      '  val := Round(abs(val) * 1E17);'
      '  if val >= 1E18 then'
      '  begin'
      '    val := val - 1E18;'
      '    digBuf[0] := Byte('#39'1'#39');'
      '    Dec(digCnt);'
      '  end;'
      '  bcdBytes := GetBcdBytes(val);'
      '  for I := 8 downto 0 do'
      '    PWord(@digBuf[17-I*2])^ := $3030 +'
      '      ((bcdBytes[I] and $0F) SHL 8) +'
      '      ((bcdBytes[I] and $F0) SHR 4);'
      '  digBuf[19] := $0;'
      '  if (digCnt <= 18) then'
      '    RoundDigits(digBuf, digCnt);'
      'end;'
      ''
      
        'function _Str2Ext(val: Extended; Width, Precision: Integer): _Sh' +
        'ortStr;'
      'var'
      '  digBuf : array[0..19] of Byte;'
      '  PBuf: PByte;'
      '  PResult: _PAnsiChr;'
      '  exp: Integer;'
      '  I: Integer;'
      '  MinWidth: Integer;'
      '  tmpVal: Extended;'
      'begin'
      '  if Width > 255 then Width := 255;'
      ''
      '  case PExtendedRec(@val).SpecialType of'
      
        '    TFloatSpecial.fsNAN:  Exit(_ShortStr(StringOfChar('#39' '#39', Width' +
        ' - 3) + '#39'Nan'#39'));'
      
        '    TFloatSpecial.fsInf:  Exit(_ShortStr(StringOfChar('#39' '#39', Width' +
        ' - 4) + '#39'+Inf'#39'));'
      
        '    TFloatSpecial.fsNInf: Exit(_ShortStr(StringOfChar('#39' '#39', Width' +
        ' - 4) + '#39'-Inf'#39'));'
      '  end;'
      '  tmpVal := val;'
      '  exp := ScaleExt(tmpVal);'
      
        '  // 6.64613997892457936E35 ~= 2**119, which is the cutof for di' +
        'splaying scientific notation'
      
        '  if (precision < 0) or (Abs(val) > 6.64613997892457936E35) or (' +
        'Abs(exp)>35) then'
      '  begin'
      
        '    if Width < 10 then  // Emit digits generates between 2 and 1' +
        '8 characters'
      
        '      Width := 10;      // 8 characters for sign, decimal, and e' +
        'xponent parts.'
      '    EmitDigits(val, Width - 8, @digBuf, exp);'
      '    SetLength(Result, Width);'
      '    PResult := @Result[1];'
      
        '    if Width > 18+8 then  // Pad with whitespace if wider than 1' +
        '8+8 characters'
      '    begin'
      '      FillChar(Result[1], Width-(18 + 8), '#39' '#39');'
      '      PResult := @result[Width - (18 + 8)+1];'
      '    end;'
      '    if val < 0 then // Emit sign'
      '      PResult[0] := '#39'-'#39
      '    else'
      '      PResult[0] := '#39' '#39';'
      '    PBuf := @digBuf[1];'
      
        '    if digBuf[0] = Byte('#39'1'#39') then  // Special case for when Scal' +
        'eExt overflowed.'
      '    begin'
      '      PBuf := @digBuf[0];'
      '      inc(exp);'
      '    end;'
      '    PResult[1] := _AnsiChr(PBuf^); // Emit decimal'
      '    PResult[2] := '#39'.'#39';'
      '    if Width - 9 < 17 then // Digits from EmitDigits'
      '      Move(PBuf[1], PResult[3], Width - 9)'
      '    else'
      '      Move(PBuf[1], PResult[3], 17);'
      ''
      '    Result[width-5] := '#39'E'#39'; // Exponent part'
      '    if exp < 0 then'
      '    begin'
      '      Result[width-4] := '#39'-'#39';'
      '      exp := -exp;'
      '    end'
      '    else'
      '      Result[Width-4] := '#39'+'#39';'
      '    for I := 3 downto 0 do'
      '    begin'
      '      Result[Width-3+I] := _AnsiChr(Ord('#39'0'#39') + (exp mod 10));'
      '      exp := exp div 10;'
      '    end;'
      '  end'
      '  else // fixed notation.'
      '  begin'
      '    EmitDigits(val, 18, @digBuf, exp);'
      '    PBuf := @digBuf[0];'
      
        '    if digBuf[0] = Byte('#39'1'#39') then // It'#39's possbile the log 2 -> ' +
        'log 10 exponent overflows'
      '      inc(exp)'
      '    else'
      '      Inc(PBuf);'
      ''
      '    if precision > 256 - 40 then'
      '      precision := 256 - 40;'
      ''
      
        '    // Check if emitted digits are in decimal and round if they ' +
        'are.'
      '    if (18 > precision + exp) and (-1 <= precision + exp) then'
      '    begin'
      '      if RoundDigits(PBuf, exp + precision) then'
      '      begin //Rounding could overflow'
      '        // The rounding overflow will happen'
      '        // if PBuf point to digBuf[1]'
      '        Dec(PBuf);'
      '        inc(exp);'
      '      end;'
      '    end;'
      ''
      '    MinWidth := 0;'
      '    if precision > 0 then'
      '      Inc(MinWidth, 1 + precision);'
      '    if exp <= 0 then'
      '      Inc(MinWidth)'
      '    else'
      '      Inc(MinWidth, exp+1);'
      '    if val < 0 then'
      '      inc(MinWidth);'
      ''
      '    if MinWidth > width then'
      '    begin'
      '      SetLength(Result, MinWidth);'
      '      PResult := @Result[1];'
      '    end'
      '    else'
      '    begin'
      '      SetLength(Result, width);'
      
        '      FillChar(Result[1], width - MinWidth, '#39' '#39'); // Fill with l' +
        'eading whitespace'
      '      PResult := @Result[Width - MinWidth+1];'
      '    end;'
      ''
      '    if val < 0 then // Emit Sign'
      '    begin'
      '      PResult^ := '#39'-'#39';'
      '      Inc(PResult);'
      '    end;'
      ''
      '    if exp < 0 then  //Emit Integer part'
      '      PResult^ := '#39'0'#39
      '    else'
      '    begin'
      '      if exp < 18 then // Up to 18 digits were emitted'
      '        Move(pbuf^, PResult^, exp+1)'
      '      else'
      '      begin // If larger than 10**18, need to emit extra 0s.'
      '        Move(pbuf^, PResult^, 18);'
      '        FillChar(PResult[18], exp-17, '#39'0'#39');'
      '      end;'
      '      Inc(PResult, exp);'
      '    end;'
      ''
      '    if precision > 0 then  // Emit decimal part'
      '    begin'
      '      PResult[1] := '#39'.'#39';'
      '      Inc(PResult, 2);'
      '      FillChar(PResult^, -exp-1, '#39'0'#39'); // emit leading 0s.'
      '      if -exp - 1 >0 then'
      '        inc(PResult, - exp - 1);'
      '      if exp < 0 then'
      '        I := 18'
      '      else if (exp < 18) then'
      '      begin'
      '        Inc(PBuf, exp + 1);'
      '        I := 17 - exp;'
      '      end'
      '      else'
      '        I := 0;'
      '      if I >= precision then'
      
        '        Move(PBuf^, PResult^, Precision) // all digits from Emit' +
        'Digits'
      '      else'
      '      begin'
      
        '        Move(PBuf^, PResult^, I); //remainder of digits from Emi' +
        'tDigits'
      
        '        FillChar(PResult[I], precision - I, '#39'0'#39'); // trailing 0s' +
        '.'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      'function _Str1Ext(val: Extended; width: Integer): _ShortStr;'
      'begin'
      '  Result := _Str2Ext(val, width, -1);'
      'end;'
      ''
      'function _Str0Ext(val: Extended): _ShortStr;'
      'begin'
      '  Result := _Str2Ext(val, 23, -1);'
      'end;'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'function _StrC64Digits(Val: UInt64; Width, Precision: Integer; s' +
        'cale: Integer; sign: Boolean): _ShortStr;'
      ''
      
        '  procedure AppendChar(var P: _PAnsiChr; const ch : _AnsiChr); i' +
        'nline;'
      '  begin'
      '    P^ := ch;'
      '    Inc(P);'
      '  end;'
      ''
      
        '  procedure AppendString(var P: _PAnsiChr; const S: _PAnsiChr; c' +
        'onst Count: integer); inline;'
      '  begin'
      '    Move(S^, P^, Count);'
      '    Inc(P, Count);'
      '  end;'
      ''
      'var'
      '  Ind,'
      '  IntInd, E, w : Integer;'
      '  P: _PAnsiChr;'
      
        '  IntPart: array[0..18] of _AnsiChr; // 9223372036854775807 - 19' +
        ' digits.'
      '  IntLen: Integer;'
      '  ExpPart: array[0..5] of _AnsiChr;'
      ''
      '  function CheckNR: Boolean;'
      '  var'
      '    Ind2: Integer;'
      '  begin'
      '    Ind2 := Ind + 1;'
      
        '    while (Ind2 <= High(intPart)) and (IntPart[Ind2] = '#39'0'#39') do I' +
        'nc(Ind2);'
      
        '    Result := (Ind2 <= High(intPart)) or Odd(Ord(IntPart[Ind-1])' +
        ');'
      '  end;'
      ''
      'begin'
      '  if sign then Val := not Val + 1;'
      ''
      '  if Val = 0 then'
      '  begin'
      '    IntInd := High(IntPart);'
      '    IntPart[IntInd] := '#39'0'#39';'
      '  end'
      '  else'
      '  begin'
      '    IntInd := High(IntPart) + 1;'
      '    while Val <> 0 do'
      '    begin'
      '      Dec(IntInd);'
      '      IntPart[IntInd] := _AnsiChr($30 + Val mod 10);'
      '      Val := Val div 10;'
      '    end;'
      '  end;'
      ''
      '  if Precision < 0 then'
      '  begin // scientific notation'
      '    IntLen := High(IntPart) - IntInd + 1;'
      '    P := @Result[1];'
      ''
      '    if sign then AppendChar(P, '#39'-'#39')'
      '    else AppendChar(P, '#39' '#39');'
      ''
      '    if Width < 10 then Width := 10;'
      '    Ind := 2 + (Width - 10);'
      '    if 2 + (Width - 10) < IntLen then'
      '    begin'
      '      Ind := IntInd + 2 + (Width - 10);'
      
        '      if (IntPart[Ind] > '#39'5'#39') or ((IntPart[Ind] = '#39'5'#39') and Check' +
        'NR) then'
      '      begin'
      '        Dec(Ind);'
      '        while Ind >= IntInd do'
      '        begin'
      '          if IntPart[Ind] = '#39'9'#39' then'
      '          begin'
      '            IntPart[Ind] := '#39'0'#39';'
      '            Dec(Ind);'
      '          end'
      '          else'
      '          begin'
      '            IntPart[Ind] := Succ(IntPart[Ind]);'
      '            Break;'
      '          end;'
      '        end;'
      '        if Ind < IntInd then'
      '        begin'
      '          IntPart[Ind] := '#39'1'#39';'
      '          Dec(IntInd);'
      '          Inc(IntLen);'
      '        end;'
      '      end;'
      '    end;'
      ''
      '    AppendChar(P, IntPart[IntInd]); Inc(IntInd);'
      '    AppendChar(P, '#39'.'#39');'
      '    if IntLen = 1 then AppendChar(P, '#39'0'#39')'
      '    else               AppendChar(P, IntPart[IntInd]);'
      '    Inc(IntInd);'
      ''
      '    Ind := 1;'
      '    while (Ind <= Width -10) and (IntInd <= High(IntPart)) do'
      '    begin'
      '      AppendChar(P, IntPart[IntInd]);'
      '      Inc(Ind);'
      '      Inc(IntInd);'
      '    end;'
      '    while (Ind <= Width -10) do'
      '    begin'
      '      AppendChar(P, '#39'0'#39');'
      '      Inc(Ind);'
      '    end;'
      ''
      '    E := IntLen - 1 - Scale;'
      '    ExpPart := '#39'E+0000'#39';'
      '    if E < 0 then'
      '    begin'
      '      ExpPart[1] := '#39'-'#39';'
      '      E := -E;'
      '    end;'
      '    ExpPart[5] := _AnsiChr($30 + (E mod 10));'
      '    E := E div 10;'
      '    ExpPart[4] := _AnsiChr($30 + (E mod 10));'
      '    AppendString(P, ExpPart, Length(ExpPart));'
      '  end'
      '  else'
      '  begin // fixed notation'
      '    if High(IntPart) - Scale < IntInd then'
      '    begin'
      '      for Ind := IntInd - 1 downto High(IntPart) - Scale do'
      '        IntPart[Ind] := '#39'0'#39';'
      '      IntInd := High(IntPart) - Scale;'
      '    end;'
      ''
      '    IntLen := High(IntPart) - IntInd + 1;'
      ''
      '    P := @Result[1];'
      ''
      '    if IntLen > Scale then'
      '      w := IntLen - Scale // 123'
      '    else'
      '      w := 1; // 0'
      '    if Precision > 0 then'
      '      w := w + Precision + 1; // 0.123'
      '    if sign then Inc(w);'
      ''
      
        '    for Ind := 1 to Width - w do AppendChar(P, '#39' '#39'); // fill lea' +
        'ding space'
      '    if sign then AppendChar(P, '#39'-'#39');'
      ''
      
        '    for Ind := IntInd to High(IntPart) - Scale do AppendChar(P, ' +
        'IntPart[Ind]);'
      '    if Precision > 0 then'
      '    begin'
      '      AppendChar(P, '#39'.'#39');'
      ''
      '      if Precision > Scale then'
      
        '        for Ind := High(IntPart) - Scale + 1 to High(IntPart) do' +
        ' AppendChar(P, IntPart[Ind])'
      '      else'
      
        '        for Ind := High(IntPart) - Scale + 1 to High(IntPart) - ' +
        'Scale + Precision do AppendChar(P, IntPart[Ind]);'
      ''
      '      for Ind := 1 to Precision - Scale do AppendChar(P, '#39'0'#39');'
      '    end;'
      '  end;'
      '  SetLength(Result, P - @Result[1]);'
      'end;'
      ''
      
        'function _Str2Comp(Val: Comp; Width, Precision: Integer): _Short' +
        'Str;'
      'begin'
      
        '  Result := _StrC64Digits(PUInt64(@Val)^, Width, Precision, 0, V' +
        'al < 0);'
      'end;'
      ''
      'function _Str1Comp(Val: Comp; Width: Integer): _ShortStr;'
      'begin'
      '  Result := _Str2Comp(Val, Width, -1);'
      'end;'
      ''
      'function _Str0Comp(Val: Comp): _ShortStr;'
      'begin'
      '  Result := _Str2Comp(Val, 23, -1);'
      'end;'
      ''
      ''
      
        'function _Str2Currency(Val: Currency; Width, Precision: Integer)' +
        ': _ShortStr;'
      'begin'
      '  if Val = 0 then'
      
        '    Result := _StrC64Digits(PUInt64(@Val)^, Width, Precision, 0,' +
        ' False)'
      '  else'
      
        '    Result := _StrC64Digits(PUInt64(@Val)^, Width, Precision, 4,' +
        ' Val < 0);'
      'end;'
      ''
      
        'function _Str1Currency(Val: Currency; Width: Integer): _ShortStr' +
        ';'
      'begin'
      '  Result := _Str2Currency(Val, Width, -1);'
      'end;'
      ''
      'function _Str0Currency(Val: Currency): _ShortStr;'
      'begin'
      '  Result := _Str2Currency(Val, 23, -1);'
      'end;'
      ''
      '{$ENDIF !X86ASMRTL}'
      ''
      ''
      
        '                                                                ' +
        '                             '
      '{$IF (Not DEFined(X86ASMRTL))}'
      'function _ValExt(s: string; var code: Integer): Extended;'
      'var'
      '  Ch: Char;'
      '  Digits, ExpValue: Integer;'
      '  Neg, NegExp, Valid: Boolean;'
      'begin'
      '  Result := 0.0;'
      '  Code := 0;'
      '  if S = '#39#39' then'
      '  begin'
      '    Inc(Code);'
      '    Exit;'
      '  end;'
      '  Neg := False;'
      '  NegExp := False;'
      '  Valid := False;'
      '  while S[Code + Low(string)] = '#39' '#39' do'
      '    Inc(Code);'
      '  Ch := S[Code + Low(string)];'
      '  if (Ch = '#39'+'#39') or (Ch = '#39'-'#39') then'
      '  begin'
      '    Inc(Code);'
      '    Neg := (Ch = '#39'-'#39');'
      '  end;'
      '  while True do'
      '  begin'
      '    Ch := S[Code + Low(string)];'
      '    Inc(Code);'
      
        '    if not ((Ord(Ch) >= Ord('#39'0'#39')) and (Ord(Ch) <= Ord('#39'9'#39'))) the' +
        'n'
      '      Break;'
      '    Result := (Result * 10) + Ord(Ch) - Ord('#39'0'#39');'
      '    Valid := True;'
      '  end;'
      '  Digits := 0;'
      '  if Ch = '#39'.'#39' then'
      '  begin'
      '    while True do'
      '    begin'
      '      Ch := S[Code + Low(string)];'
      '      Inc(Code);'
      
        '      if not ((Ord(Ch) >= Ord('#39'0'#39')) and (Ord(Ch) <= Ord('#39'9'#39'))) t' +
        'hen'
      '      begin'
      '        if not Valid then {Starts with '#39'.'#39'}'
      '        begin'
      '          if Ch = #0 then'
      '          begin'
      '            Dec(Code); {S = '#39'.'#39'}'
      
        '            Valid := True; // SB: Added for compatibility with x' +
        '86 asm version'
      '          end;'
      '        end;'
      '        Break;'
      '      end;'
      '      Result := (Result * 10) + Ord(Ch) - Ord('#39'0'#39');'
      '      Dec(Digits);'
      '      Valid := True;'
      '    end;'
      '  end;'
      '  ExpValue := 0;'
      '  if (Ord(Ch) or $20) = Ord('#39'e'#39') then'
      '    begin {Ch in ['#39'E'#39','#39'e'#39']}'
      '      Valid := False;'
      '      Ch := S[Code + Low(string)];'
      '      if (Ch = '#39'+'#39') or (Ch = '#39'-'#39') then'
      '      begin'
      '        Inc(Code);'
      '        NegExp := (Ch = '#39'-'#39');'
      '      end;'
      '      while True do'
      '      begin'
      '        Ch := S[Code + Low(string)];'
      '        Inc(Code);'
      
        '        if not ((Ord(Ch) >= Ord('#39'0'#39')) and (Ord(Ch) <= Ord('#39'9'#39')))' +
        ' then'
      '          Break;'
      '        ExpValue := (ExpValue * 10) + Ord(Ch) - Ord('#39'0'#39');'
      '        Valid := True;'
      '      end;'
      '     if NegExp then'
      '       ExpValue := -ExpValue;'
      '    end;'
      '  Digits := Digits + ExpValue;'
      '  if Digits <> 0 then'
      '    Result := Power10(Result, Digits);'
      '  if Neg then'
      '    Result := -Result;'
      '  if Valid and (Ch = #0) then'
      '    Code := 0;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _ValExt;'
      'const'
      '  Ten: Double = 10.0;'
      'asm'
      '// -> EAX Pointer to string'
      '//  EDX Pointer to code result'
      '// <- FST(0)  Result'
      ''
      '      PUSH    EBX'
      '{$IFDEF PIC}'
      '      PUSH    EAX'
      '      CALL    GetGOT'
      '      MOV     EBX,EAX'
      '      POP     EAX'
      '{$ELSE}'
      '      XOR     EBX,EBX'
      '{$ENDIF}'
      '      PUSH    ESI'
      '      PUSH    EDI'
      ''
      '      PUSH    EBX     // SaveGOT = ESP+8'
      '      MOV     ESI,EAX'
      '      PUSH    EAX     // save for the error case'
      ''
      '      FLDZ'
      '      XOR     EAX,EAX'
      '      XOR     EBX,EBX'
      '      XOR     EDI,EDI'
      ''
      '      PUSH    EBX     // temp to get digs to fpu'
      ''
      '      TEST    ESI,ESI'
      '      JE      @@empty'
      ''
      '@@blankLoop:'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '      CMP     BX,'#39' '#39
      '      JE      @@blankLoop'
      ''
      '@@endBlanks:'
      '      MOV     CH,0'
      '      CMP     BX,'#39'-'#39
      '      JE      @@minus'
      '      CMP     BX,'#39'+'#39
      '      JE      @@plus'
      '      JMP     @@firstDigit'
      ''
      '@@minus:'
      '      INC     CH'
      '@@plus:'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      ''
      '@@firstDigit:'
      '      TEST    BX,BX'
      '      JE      @@error'
      ''
      '      MOV     EDI,[ESP+8]     // SaveGOT'
      ''
      '@@digLoop:'
      '      SUB     BX,'#39'0'#39
      '      CMP     BX,9'
      '      JA      @@dotExp'
      '      FMUL    qword ptr [EDI] + offset Ten'
      '      MOV     dword ptr [ESP],EBX'
      '      FIADD   dword ptr [ESP]'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '      TEST    BX,BX'
      '      JNE     @@digLoop'
      '      JMP     @@prefinish'
      ''
      '@@dotExp:'
      '      CMP     BX,'#39'.'#39' - '#39'0'#39
      '      JNE     @@exp'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '      TEST    BX,BX'
      '      JE      @@prefinish'
      ''
      '//  EDI = SaveGot'
      '@@fracDigLoop:'
      '      SUB     BX,'#39'0'#39
      '      CMP     BX,9'
      '      JA      @@exp'
      '      FMUL    qword ptr [EDI] + offset Ten'
      '      MOV     dword ptr [ESP],EBX'
      '      FIADD   dword ptr [ESP]'
      '      DEC     EAX'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '      TEST    BX,BX'
      '      JNE     @@fracDigLoop'
      ''
      '@@prefinish:'
      '      XOR     EDI,EDI'
      '      JMP     @@finish'
      ''
      '@@exp:'
      '      CMP     BX,'#39'E'#39' - '#39'0'#39
      '      JE      @@foundExp'
      '      CMP     BX,'#39'e'#39' - '#39'0'#39
      '      JNE     @@error'
      '@@foundExp:'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '      MOV     AH,0'
      '      CMP     BX,'#39'-'#39
      '      JE      @@minusExp'
      '      CMP     BX,'#39'+'#39
      '      JE      @@plusExp'
      '      JMP     @@firstExpDigit'
      '@@minusExp:'
      '      INC     AH'
      '@@plusExp:'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '@@firstExpDigit:'
      '      SUB     BX,'#39'0'#39
      '      CMP     BX,9'
      '      JA      @@error'
      '      MOV     EDI,EBX'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '      TEST    BX,BX'
      '      JZ      @@endExp'
      '@@expDigLoop:'
      '      SUB     BX,'#39'0'#39
      '      CMP     BX,9'
      '      JA      @@error'
      '      LEA     EDI,[EDI+EDI*4]'
      '      ADD     EDI,EDI'
      '      ADD     EDI,EBX'
      '      MOV     BX,[ESI]'
      '      ADD     ESI, 2'
      '      TEST    BX,BX'
      '      JNZ     @@expDigLoop'
      '@@endExp:'
      '      DEC     AH'
      '      JNZ     @@expPositive'
      '      NEG     EDI'
      '@@expPositive:'
      '      MOVSX   EAX,AL'
      ''
      '@@finish:'
      '      ADD     EAX,EDI'
      '      PUSH    EDX'
      '      PUSH    ECX'
      '      CALL    _Pow10'
      '      POP     ECX'
      '      POP     EDX'
      ''
      '      DEC     CH'
      '      JE      @@negate'
      ''
      '@@successExit:'
      
        '      ADD     ESP,12   // pop temp and saved copy of string poin' +
        'ter'
      ''
      '      XOR     ESI,ESI   // signal no error to caller'
      ''
      '@@exit:'
      '      SHR     ESI,1'
      '      MOV     [EDX],ESI'
      '      POP     EDI'
      '      POP     ESI'
      '      POP     EBX'
      '      RET'
      ''
      '@@negate:'
      '      FCHS'
      '      JMP     @@successExit'
      ''
      '@@empty:'
      '      ADD     ESI,2'
      ''
      '@@error:'
      '      POP     EAX'
      '      POP     EBX'
      '      SUB     ESI,EBX'
      '      ADD     ESP,4'
      '      JMP     @@exit'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not DEFined(X86ASMRTL)}'
      'function FPower10(val: Extended; power: Integer): Extended;'
      'begin'
      '  Result := Power10(val, power);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure FPower10;'
      'asm'
      '  JMP  _Pow10'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IFDEF WIN64}'
      'procedure RestoreMXCSR(NewMXCSR: UInt32);'
      'var'
      '  MXCSR: UInt32;'
      'asm'
      '        MOV     MXCSR, ECX'
      '        LDMXCSR MXCSR'
      'end;'
      '{$ENDIF}'
      ''
      'const'
      '{$IFDEF EXTENDEDHAS10BYTES}'
      '  Pow10Tab0: array[0..31] of Extended = ('
      '    1e0,  1e1,  1e2,  1e3,  1e4,  1e5,  1e6,  1e7,  1e8,  1e9,'
      '    1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,'
      '    1e20, 1e21, 1e22, 1e23, 1e24, 1e25, 1e26, 1e27, 1e28, 1e29,'
      '    1e30, 1e31);'
      '  Pow10Tab1: array[0..14] of Extended = ('
      
        '    1e32,  1e64,  1e96,  1e128, 1e160, 1e192, 1e224, 1e256, 1e28' +
        '8, 1e320,'
      '    1e352, 1e384, 1e416, 1e448, 1e480);'
      '  Pow10Tab2: array[0..8] of Extended = ('
      
        '    1e512, 1e1024, 1e1536, 1e2048, 1e2560, 1e3072, 1e3584, 1e409' +
        '6, 1e4608);'
      '{$ELSE !EXTENDEDHAS10BYTES}'
      '// 1e0 ... 1e31'
      '  Pow10Tab0P: array[0..31, coeffType] of UInt64= ('
      
        '    ($3FF0000000000000, $0000000000000000), ($4024000000000000, ' +
        '$0000000000000000),'
      
        '    ($4059000000000000, $0000000000000000), ($408F400000000000, ' +
        '$0000000000000000),'
      
        '    ($40C3880000000000, $0000000000000000), ($40F86A0000000000, ' +
        '$0000000000000000),'
      
        '    ($412E848000000000, $0000000000000000), ($416312D000000000, ' +
        '$0000000000000000),'
      
        '    ($4197D78400000000, $0000000000000000), ($41CDCD6500000000, ' +
        '$0000000000000000),'
      
        '    ($4202A05F20000000, $0000000000000000), ($42374876E8000000, ' +
        '$0000000000000000),'
      
        '    ($426D1A94A0000000, $40B0000000000000), ($42A2309CE4000000, ' +
        '$40E4000000000000),'
      
        '    ($42D6BCC41C000000, $4124800000000000), ($430C6BF524000000, ' +
        '$4151A00000000000),'
      
        '    ($4341C37934000000, $419F040000000000), ($4376345784000000, ' +
        '$41BD8A0000000000),'
      
        '    ($43ABC16D64000000, $41FA764000000000), ($43E158E460000000, ' +
        '$421227A000000000),'
      
        '    ($4415AF1D78000000, $4246B18800000000), ($444B1AE4D4000000, ' +
        '$4297177A80000000),'
      
        '    ($4480F0CF04000000, $42D26EAC90000000), ($44B52D02C4000000, ' +
        '$430F0A57B4000000),'
      
        '    ($44EA784378000000, $432D99DB42000000), ($45208B2A2C000000, ' +
        '$433401484A000000),'
      
        '    ($4554ADF4B4000000, $43A99019A5C80000), ($4589D971E4000000, ' +
        '$43BFD0803CE80000),'
      
        '    ($45C027E72C000000, $4418F89409844000), ($45F431E0F8000000, ' +
        '$444736B90BE55000),'
      
        '    ($46293E5938000000, $446A08CE9DBD4800), ($465F8DEF88000000, ' +
        '$44416048A5934000)'
      '  );'
      '  Pow10Tab0N: array[0..31, coeffType] of UInt64= ('
      
        '    ($3FF0000000000000, $0000000000000000), ($3FB9999998000000, ' +
        '$3DF999999999999A),'
      
        '    ($3F847AE144000000, $3DDD70A3D70A3D71), ($3F50624DD0000000, ' +
        '$3DA78D4FDF3B645A),'
      
        '    ($3F1A36E2E8000000, $3D68E219652BD3C3), ($3EE4F8B588000000, ' +
        '$3D1C6D1E108C3F3E),'
      
        '    ($3EB0C6F7A0000000, $3CE6BDB1A6D698FE), ($3E7AD7F298000000, ' +
        '$3CC5E57A42BC3D33),'
      
        '    ($3E45798EE0000000, $3C918461CEFCFDC2), ($3E112E0BE8000000, ' +
        '$3C236B4A59731681),'
      
        '    ($3DDB7CDFD8000000, $3C1D7BDBAB7D6AE7), ($3DA5FD7FE0000000, ' +
        '$3BE7964955FDEF1F),'
      
        '    ($3D71979980000000, $3BB2DEA11197F27F), ($3D3C25C268000000, ' +
        '$3B525DA07099432D),'
      
        '    ($3D06849B84000000, $3B55095CD80F5385), ($3CD203AF9C000000, ' +
        '$3B273AB0ACD90F9D),'
      
        '    ($3C9CD2B294000000, $3AEEC44DE15B4C2F), ($3C670EF544000000, ' +
        '$3AB236A4B44909BF),'
      
        '    ($3C32725DD0000000, $3A7D243ABA0E75FE), ($3BFD83C94C000000, ' +
        '$3A4DB69561A52B32),'
      
        '    ($3BC79CA10C000000, $39F248446BAA23D3), ($3B92E3B408000000, ' +
        '$39E074DA7BEED3F7),'
      
        '    ($3B5E392010000000, $39575EE5962A6499), ($3B282DB340000000, ' +
        '$3922B25144EEB6E1),'
      
        '    ($3AF357C298000000, $393A88EA76A58925), ($3ABEF2D0F4000000, ' +
        '$38FDA7DD8AA27508),'
      
        '    ($3A88C240C4000000, $38B5D962776A54D9), ($3A53CE9A34000000, ' +
        '$38A791E07E48775F),'
      
        '    ($3A1FB0F6BC000000, $38628300CA0D8BCB), ($39E95A5EFC000000, ' +
        '$3835359A3B3E096F),'
      
        '    ($39B4484BFC000000, $38075E14FC31A126), ($398039D664000000, ' +
        '$37C89687F9E901D6)'
      '  );'
      ''
      '// 1e0, 1e32, 1e64, 1e96, 1e128, 1e160, 1e192, 1e224'
      '  Pow10Tab1P: array[0..7, coeffType] of UInt64 = ('
      
        '    ($3FF0000000000000, $0000000000000000), ($4693B8B5B4000000, ' +
        '$44D056E16B3BE040),'
      
        '    ($4D384F03E8000000, $4B73FF9F4DAA797F), ($53DDF67560000000, ' +
        '$5226C59B14A2C5D0),'
      
        '    ($5A827748F8000000, $58C301D319BF8CDE), ($6126C2D424000000, ' +
        '$5F66FFCC2F54AEF7),'
      
        '    ($67CC0E1EF0000000, $660A724EAAD50B78), ($6E714A52DC000000, ' +
        '$6CCFE33CC92F82BD)'
      '  );'
      '  Pow10Tab1N: array[0..7, coeffType] of UInt64 = ('
      
        '    ($3FF0000000000000, $0000000000000000), ($3949F623D4000000, ' +
        '$378A8A732974CFBC),'
      
        '    ($32A50FFD44000000, $30DE94E7A694FC8E), ($2C0116805C000000, ' +
        '$2A57FD75539B11DC),'
      
        '    ($255BBA08CC000000, $23AC64BCE4A0AC7D), ($1EB67E9C10000000, ' +
        '$1D03DB73A09359ED),'
      
        '    ($18123FF06C000000, $16675423CC067B63), ($116D9CA79C000000, ' +
        '$0FA894629D7B49F1)'
      '  );'
      ''
      
        '  OneE256Hi : UInt64 = $75154FDD7C000000; // Higher 26 bits of 1' +
        'e256 About 9.9999999e255'
      
        '  OneE256Lo : UInt64 = $736B9DF9DE8DDDBC; // 1E256 - OneE256Hi A' +
        'bout 9.6548e247'
      
        '  // To avoid internal denormalization, 1e-256 * 2^850 ( about 0' +
        '.75) is used instead small number; 1E-256'
      
        '  OneEm256Hi: UInt64 = $3FE8062864000000; // Higher 26 bits of 1' +
        'e-256 * 2^850.'
      
        '  OneEm256Lo: UInt64 = $3E158DE864E7EA44; // (1E-256 * 2^850) - ' +
        'OneEm256Hi'
      '  OneEm256Offset: UInt64 = $0AD0000000000000; // 1/2^850'
      ''
      '  HIGH25BITSMASK = $FFFFFFFFF8000000;'
      '{$ENDIF !EXTENDEDHAS10BYTES}'
      'function Power10(val: Extended; power: Integer): Extended;'
      '{$IFDEF PUREPASCAL}'
      '{$IFDEF EXTENDEDHAS10BYTES}'
      '  var'
      '  I, P: Integer;'
      'begin'
      '  FClearExcept;'
      '  Result := Val;'
      '  if Power > 0 then'
      '  begin'
      '    if Power >= 5120 then'
      '      Exit(cInfinity);'
      '    Result := Result * Pow10Tab0[Power and $1F];'
      '    P := Power shr 5;'
      '    if P <> 0 then'
      '    begin'
      '      I := P and $F;'
      '      if I <> 0 then'
      '        Result := Result * Pow10Tab1[I - 1];'
      '      I := P shr 4;'
      '      if I <> 0 then'
      '        Result := Result * Pow10Tab2[I - 1];'
      '    end;'
      '  end'
      '  else if Power < 0 then'
      '  begin'
      '    P := -Power;'
      '    if P >= 5120 then'
      '      Exit(0);'
      '    Result := Result / Pow10Tab0[P and $1F];'
      '    P := P shr 5;'
      '    if P <> 0 then'
      '    begin'
      '      I := P and $F;'
      '      if I <> 0 then'
      '        Result := Result / Pow10Tab1[I - 1];'
      '      I := P shr 4;'
      '      if I <> 0 then'
      '        Result := Result / Pow10Tab2[I - 1];'
      '    end;'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE !EXTENDEDHAS10BYTES}'
      '  function MulDD(A: Double; BHi, BLo: UInt64 ): Double;'
      '  var'
      '    AHi, ALo: Double;'
      '  begin'
      '    PUInt64(@AHi)^ := PUInt64(@A)^ and HIGH25BITSMASK;'
      '    ALo := A - AHi;'
      '    if BLo = 0 then'
      '      Result := AHi * PDouble(@BHi)^ + ALo * PDouble(@BHi)^'
      '    else'
      '    begin'
      '      Result :=          ALo * PDouble(@BLo)^;'
      '      Result := Result + AHi * PDouble(@BLo)^;'
      '      Result := Result + ALo * PDouble(@BHi)^;'
      '      Result := Result + AHi * PDouble(@BHi)^;'
      '    end;'
      '  end;'
      ''
      'var'
      '  I, P: Integer;'
      '{$IFDEF WIN64}'
      '  OldExceptMask: UInt32;'
      '{$ENDIF}'
      'begin'
      '  FClearExcept;'
      '{$IFDEF WIN64}'
      '  OldExceptMask := FSetExceptMask(femUNDERFLOW, femUNDERFLOW);'
      '{$ENDIF}'
      '  Result := Val;'
      '  if Power > 0 then'
      '  begin'
      '    if Power >= 632 then // +308 - (-324) (Exp of  MinDouble)'
      '    begin'
      '      FRaiseExcept(feeOVERFLOW);'
      '      Exit(cInfinity);'
      '    end;'
      '//  Result := Result * 10^^(P and $1F)'
      '    I := Power and $1F;'
      '    if I <> 0 then'
      
        '      Result := MulDD(Result, Pow10Tab0P[I,cHi], Pow10Tab0P[I,cL' +
        'o]);'
      ''
      '    P := Power shr 5;'
      '    if P <> 0 then'
      '    begin'
      '      I := P and $7;'
      '      if I <> 0 then'
      
        '        Result := MulDD(Result, Pow10Tab1P[I, cHi], Pow10Tab1P[I' +
        ', cLo]);'
      '      I := P shr 3;'
      '      while I > 0 do'
      '    begin'
      '//      Result := Result * 1E256;'
      '        Result := MulDD(Result, OneE256Hi, OneE256Lo);'
      '        Dec(I);'
      '      end;'
      '    end;'
      '  end'
      '  else if Power < 0 then'
      '  begin'
      '    P := -Power;'
      '    if P >= 632 then'
      '    begin'
      '      FRaiseExcept(feeUNDERFLOW);'
      '      Exit(0);'
      '    end;'
      ''
      '//  Result := Result * 10^^(-(P and $1F))'
      '    I := P and $1F;'
      '    if I <> 0 then'
      
        '      Result := MulDD(Result, Pow10Tab0N[I,cHi], Pow10Tab0N[I,cL' +
        'o]);'
      ''
      '    P := P shr 5;'
      '    if P <> 0 then'
      '    begin'
      '      I := P and $7;'
      '      if I <> 0 then'
      
        '        Result := MulDD(Result, Pow10Tab1N[I, cHi], Pow10Tab1N[I' +
        ', cLo]);'
      '      I := P shr 3;'
      '      while I > 0 do'
      '      begin'
      '//      Result := Result * 1E-256;'
      
        '        Result := MulDD(Result, OneEm256Hi, OneEm256Lo) * PDoubl' +
        'e(@OneEm256Offset)^;'
      '        Dec(I);'
      '      end;'
      '    end;'
      '  end;'
      '{$IFDEF WIN64}'
      
        '  RestoreMXCSR((GetMXCSR and not femUNDERFLOW) or (OldExceptMask' +
        ' and femUNDERFLOW));'
      '{$ENDIF}'
      '  FCheckExcept;'
      'end;'
      '{$ENDIF !EXTENDEDHAS10BYTES}'
      '{$ELSE !PUREPASCAL}'
      '{$IF     defined(CPUX86) and defined(IOS)} // iOS/Simulator'
      'begin'
      '  FClearExcept;'
      '  asm'
      '    FLD   tbyte ptr val'
      '    MOV   EAX, power'
      '    CALL  _Pow10'
      '    FSTP  tbyte ptr Result'
      '  end;'
      '  FCheckExcept;'
      'end;'
      '{$ELSE}'
      'asm'
      '    FLD   tbyte ptr val'
      '    MOV   EAX, power'
      '    CALL  _Pow10'
      '    FSTP  tbyte ptr Result'
      'end;'
      '{$ENDIF}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      'function _Pow10(val: Extended; Power: Integer): Extended;'
      'begin'
      '  Result := Power10(val, Power);'
      'end;'
      '{$ELSE X86ASMRTL}'
      '//function _Pow10(val: Extended; Power: Integer): Extended;'
      'procedure _Pow10;'
      'asm'
      '// -> FST(0)  val'
      '// -> EAX Power'
      '// <- FST(0)  val * 10**Power'
      ''
      '//  This routine generates 10**power with no more than two'
      
        '//  floating point multiplications. Up to 10**31, no multiplicat' +
        'ions'
      '//  are needed.'
      ''
      '      PUSH   EBX'
      '{$IFDEF PIC}'
      '      PUSH   EAX'
      '      CALL   GetGOT'
      '      MOV    EBX, EAX'
      '      POP    EAX'
      '{$ELSE}'
      '      XOR    EBX, EBX'
      '{$ENDIF}'
      '      TEST   EAX, EAX'
      '      JL     @@neg'
      '      JE     @@exit'
      '      CMP    EAX, 5120'
      '      JGE    @@inf'
      '      MOV    EDX, EAX'
      '      AND    EDX, 01FH'
      '      {$IF defined(EXTENDEDIS16BYTES)}'
      '      LEA    EDX, [EDX*8]'
      '      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]'
      '      {$ELSEIF defined(EXTENDEDIS12BYTES)}'
      '      LEA    EDX, [EDX+EDX*2]'
      '      FLD    tbyte ptr Pow10Tab0[EBX+EDX*4]'
      '      {$ELSEIF defined(EXTENDEDIS10BYTES)}'
      '      LEA    EDX, [EDX+EDX*4]'
      '      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]'
      '      {$ELSE}'
      '      {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '      {$ENDIF}'
      ''
      '      FMULP'
      ''
      '      SHR    EAX,5'
      '      JE     @@exit'
      ''
      '      MOV    EDX, EAX'
      '      AND    EDX, 0FH'
      '      JE     @@skip2ndMul'
      '      {$IF defined(EXTENDEDIS16BYTES)}'
      '      LEA    EDX, [EDX*8]'
      '      FLD    tbyte ptr (Pow10Tab1-16)[EBX+EDX*2]'
      '      {$ELSEIF defined(EXTENDEDIS12BYTES)}'
      '      LEA    EDX, [EDX+EDX*2]'
      '      FLD    tbyte ptr (Pow10Tab1-12)[EBX+EDX*4]'
      '      {$ELSEIF defined(EXTENDEDIS10BYTES)}'
      '      LEA    EDX, [EDX+EDX*4]'
      '      FLD    tbyte ptr (Pow10Tab1-10)[EBX+EDX*2]'
      '      {$ELSE}'
      '      {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '      {$ENDIF}'
      '      FMULP'
      ''
      '@@skip2ndMul:'
      '      SHR    EAX, 4'
      '      JE     @@exit'
      '      {$IF defined(EXTENDEDIS16BYTES)}'
      '      LEA    EAX, [EAX*8]'
      '      FLD    tbyte ptr (Pow10Tab2-16)[EBX+EAX*2]'
      '      {$ELSEIF defined(EXTENDEDIS12BYTES)}'
      '      LEA    EAX, [EAX+EAX*2]'
      '      FLD    tbyte ptr (Pow10Tab2-12)[EBX+EAX*4]'
      '      {$ELSEIF defined(EXTENDEDIS10BYTES)}'
      '      LEA    EAX, [EAX+EAX*4]'
      '      FLD    tbyte ptr (Pow10Tab2-10)[EBX+EAX*2]'
      '      {$ELSE}'
      '      {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '      {$ENDIF}'
      '      FMULP'
      '      JMP    @@exit'
      ''
      '@@neg:'
      '      NEG    EAX'
      '      CMP    EAX, 5120'
      '      JGE    @@zero'
      '      MOV    EDX, EAX'
      '      AND    EDX, 01FH'
      '      {$IF defined(EXTENDEDIS16BYTES)}'
      '      LEA    EDX, [EDX*8]'
      '      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]'
      '      {$ELSEIF defined(EXTENDEDIS12BYTES)}'
      '      LEA    EDX, [EDX+EDX*2]'
      '      FLD    tbyte ptr Pow10Tab0[EBX+EDX*4]'
      '      {$ELSEIF defined(EXTENDEDIS10BYTES)}'
      '      LEA    EDX, [EDX+EDX*4]'
      '      FLD    tbyte ptr Pow10Tab0[EBX+EDX*2]'
      '      {$ELSE}'
      '      {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '      {$ENDIF}'
      '      FDIVP'
      ''
      '      SHR    EAX, 5'
      '      JE     @@exit'
      ''
      '      MOV    EDX, EAX'
      '      AND    EDX, 0FH'
      '      JE     @@skip2ndDiv'
      '      {$IF defined(EXTENDEDIS16BYTES)}'
      '      LEA    EDX, [EDX*8]'
      '      FLD    tbyte ptr (Pow10Tab1-16)[EBX+EDX*2]'
      '      {$ELSEIF defined(EXTENDEDIS12BYTES)}'
      '      LEA    EDX, [EDX+EDX*2]'
      '      FLD    tbyte ptr (Pow10Tab1-12)[EBX+EDX*4]'
      '      {$ELSEIF defined(EXTENDEDIS10BYTES)}'
      '      LEA    EDX, [EDX+EDX*4]'
      '      FLD    tbyte ptr (Pow10Tab1-10)[EBX+EDX*2]'
      '      {$ELSE}'
      '      {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '      {$ENDIF}'
      '      FDIVP'
      ''
      '@@skip2ndDiv:'
      '      SHR    EAX, 4'
      '      JE     @@exit'
      '      {$IF defined(EXTENDEDIS16BYTES)}'
      '      LEA    EAX, [EAX*8]'
      '      FLD    tbyte ptr (Pow10Tab2-16)[EBX+EAX*2]'
      '      {$ELSEIF defined(EXTENDEDIS12BYTES)}'
      '      LEA    EAX, [EAX+EAX*2]'
      '      FLD    tbyte ptr (Pow10Tab2-12)[EBX+EAX*4]'
      '      {$ELSEIF defined(EXTENDEDIS10BYTES)}'
      '      LEA    EAX, [EAX+EAX*4]'
      '      FLD    tbyte ptr (Pow10Tab2-10)[EBX+EAX*2]'
      '      {$ELSE}'
      '      {$MESSAGE ERROR '#39'Unknown condition'#39'}'
      '      {$ENDIF}'
      '      FDIVP'
      ''
      '      JMP    @@exit'
      ''
      '@@inf:'
      '      FSTP   ST(0)'
      '      FLD    tbyte ptr @@infval[EBX]'
      '      JMP    @@exit'
      ''
      '@@zero:'
      '      FSTP   ST(0)'
      '      FLDZ'
      ''
      '@@exit:'
      '      POP    EBX'
      '      RET'
      ''
      '@@infval:  DW  $0000,$0000,$0000,$8000,$7FFF'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      'const'
      '  RealBias = $81;'
      '  DoubleBias = $3FF;'
      '  ExtBias  = $3FFF;'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      'function _Real2Ext(val: Pointer {PReal48}): Extended;'
      'var'
      '  LBytes: PByte;'
      '  LDouble: Double;'
      'begin'
      '  LBytes := val; { [0 .. 5] }'
      ''
      '  { Decompose the Real48. Check if the exponent is non-zero. }'
      '  if LBytes[0] <> 0 then'
      '  begin'
      '    PUInt64(@LDouble)^ :='
      
        '      ((UInt64(LBytes[5]) and $80) shl 56) or                 { ' +
        'Sign Bit }'
      
        '      ((UInt64(LBytes[0]) + DoubleBias - RealBias) shl 52) or { ' +
        'Exponent }'
      '      ('
      '        ((UInt64(LBytes[5]) and $7F) shl 32) or'
      '        (UInt64(LBytes[4]) shl 24) or'
      '        (UInt64(LBytes[3]) shl 16) or'
      '        (UInt64(LBytes[2]) shl 8) or'
      '        (UInt64(LBytes[1]) shl 0)'
      
        '      ) shl 13;                                               { ' +
        'Mantissa }'
      '  end else'
      '    LDouble := 0;'
      ''
      
        '  { On 386, this will convert the Double to Extended, on x64 Ext' +
        'ended = Double. }'
      '  Result := LDouble;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _Real2Ext;//( val : Real ) : Extended;'
      'asm'
      '// -> EAX Pointer to value'
      '// <- FST(0)  Result'
      ''
      '//  the REAL data type has the following format:'
      '//  8 bit exponent (bias 129), 39 bit fraction, 1 bit sign'
      ''
      '        MOV    DH, [EAX+5]  // isolate the sign bit'
      '        AND    DH, 80H'
      '        MOV    DL, [EAX]  // fetch exponent'
      '        TEST   DL, DL   // exponent zero means number is zero'
      '        JE     @@zero'
      ''
      '        ADD    DX, ExtBias - RealBias // adjust exponent bias'
      ''
      '        PUSH   EDX   // the exponent is at the highest address'
      ''
      
        '        MOV    EDX, [EAX+2] // load high fraction part, set hidd' +
        'en bit'
      '        OR     EDX, 80000000H'
      '        PUSH   EDX   // push high fraction part'
      ''
      
        '        MOV    DL, [EAX+1]  // load remaining low byte of fracti' +
        'on'
      '        SHL    EDX, 24    // clear low 24 bits'
      '        PUSH   EDX'
      ''
      '        FLD    tbyte ptr [ESP] // pop result onto chip'
      '        ADD    ESP, 12'
      ''
      '        RET'
      ''
      '@@zero:'
      '        FLDZ'
      '        RET'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      'procedure _Ext2Real(Dest: Pointer {PReal48}; Val: Extended);'
      'type'
      '  PReal48Rec = ^TReal48Rec;'
      '  TReal48Rec = packed record'
      '    Exp: Byte;'
      '    MLo: Byte;'
      '    MHi: UInt32;'
      '  end;'
      '  {$IFDEF EXTENDEDHAS10BYTES}'
      '  PExt80Rec = ^TExt80Rec;'
      '  TExt80Rec = packed record'
      '    MLo: UInt32;'
      '    MHi: UInt32;'
      '    SignExp: UInt16;'
      '  end;'
      '  {$ELSE  !EXTENDEDHAS10BYTES}'
      '  PExt64Rec = ^TExt64Rec;'
      '  TExt64Rec = packed record'
      '  case Integer of'
      '  0: (Bytes: array[0..7] of Byte;);'
      '  1: (Words: array[0..3] of UInt16;);'
      '  2: (DWords: array[0..1] of UInt32;);'
      '  3: (QWordVal: UInt64;);'
      '  end;'
      '  {$ENDIF !EXTENDEDHAS10BYTES}'
      'var'
      '  MHi: UInt32;'
      '  MLo: Byte;'
      '  Exp: Integer;'
      '  {$IFDEF EXTENDEDHAS10BYTES}'
      '  ExtVal : PExt80Rec;'
      '  {$ELSE  !EXTENDEDHAS10BYTES}'
      '  ExtVal : PExt64Rec;'
      '  {$ENDIF !EXTENDEDHAS10BYTES}'
      'begin'
      '  {$IFDEF EXTENDEDHAS10BYTES}'
      ''
      '  ExtVal := PExt80Rec(@Val);'
      
        '  Exp := Integer(ExtVal^.SignExp and $7fff) - ExtBias + RealBias' +
        ';'
      '  MHi := ExtVal^.MHi and $7fffffff;'
      '  MLo := Byte(ExtVal^.MLo shr 24);'
      '  if (ExtVal^.MLo and $ffffff) > $7fffff then'
      '  begin'
      '    Inc(MLo);'
      '    if MLo = 0 then'
      '    begin'
      '      Inc(MHi);'
      '      if MHi = $80000000 then'
      '      begin'
      '        MHi := 0;'
      '        Inc(Exp);'
      '      end;'
      '    end;'
      '  end;'
      '  if (ExtVal^.SignExp and $8000) <> 0 then'
      '    MHi := MHi or $80000000;'
      ''
      '  {$ELSE  !EXTENDEDHAS10BYTES}'
      ''
      '  ExtVal := PExt64Rec(@Val);'
      
        '  Exp := Integer((ExtVal^.Words[3] shr 4) and $7ff) - DoubleBias' +
        ' + RealBias;'
      '  MHi := UInt32(ExtVal^.QWordVal shr 21) and $7fffffff;'
      '  MLo := Byte(ExtVal^.DWords[0] shr 13);'
      '  if (ExtVal^.DWords[0] and $1fff) > $fff then'
      '  begin'
      '    Inc(MLo);'
      '    if MLo = 0 then'
      '    begin'
      '      Inc(MHi);'
      '      if MHi = $80000000 then'
      '      begin'
      '        MHi := 0;'
      '        Inc(Exp);'
      '      end;'
      '    end;'
      '  end;'
      '  if (ExtVal^.Bytes[7] and $80) <> 0 then'
      '    MHi := MHi or $80000000;'
      ''
      '  {$ENDIF !EXTENDEDHAS10BYTES}'
      ''
      '  if Exp < 0 then'
      '    Exp := 0'
      '  else if Exp > 255 then'
      '    Error(reOverflow);'
      '  PReal48Rec(Dest)^.Exp := Exp;'
      '  PReal48Rec(Dest)^.MLo :=  MLo;'
      '  PReal48Rec(Dest)^.MHi :=  MHi;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _Ext2Real;//( val : Extended ) : Real;'
      'asm'
      '// -> FST(0)  Value'
      '//  EAX Pointer to result'
      ''
      '        PUSH  EBX'
      ''
      '        SUB   ESP,12'
      '        FSTP  tbyte ptr [ESP]'
      ''
      '        POP   EBX     // EBX is low half of fraction'
      '        POP   EDX     // EDX is high half of fraction'
      '        POP   ECX     // CX is exponent and sign'
      ''
      '        SHR   EBX,24  // set carry to last bit shifted out'
      '        ADC   BL,0    // if bit was 1, round up'
      '        ADC   EDX,0'
      '        ADC   CX,0'
      '        JO    @@overflow'
      ''
      '        ADD   EDX,EDX // shift fraction 1 bit left'
      '        ADD   CX,CX   // shift sign bit into carry'
      '        RCR   EDX,1   // attach sign bit to fraction'
      '        SHR   CX,1    // restore exponent, deleting sign'
      ''
      '        SUB   CX,ExtBias-RealBias // adjust exponent'
      '        JLE   @@underflow'
      '        TEST  CH,CH     // CX must be in 1..255'
      '        JG    @@overflow'
      ''
      '        MOV   [EAX],CL'
      '        MOV   [EAX+1],BL'
      '        MOV   [EAX+2],EDX'
      ''
      '        POP   EBX'
      '        RET'
      ''
      '@@underflow:'
      '        XOR   ECX,ECX'
      '        MOV   [EAX],ECX'
      '        MOV   [EAX+4],CX'
      '        POP   EBX'
      '        RET'
      ''
      '@@overflow:'
      '        POP   EBX'
      '        MOV   AL,8'
      '        JMP   Error'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IFNDEF EXTENDEDHAS10BYTES}'
      'function _Ext80ToDouble(Val: Pointer {PExtended80}): Double;'
      'begin'
      '  Result := Double(PExtended80Rec(Val)^);'
      'end;'
      ''
      
        'procedure _DoubleToExt80(Dest: Pointer {PExtended80}; Val: Doubl' +
        'e);'
      'begin'
      '  PExtended80Rec(Dest)^ := TExtended80Rec(Val);'
      'end;'
      '{$ENDIF EXTENDEDHAS10BYTES}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      '// Result := Double(Ext80(Dividend) / Ext80(Divisor));'
      'function _CompDiv(Dividend, Divisor: Comp): Double;'
      'var'
      '  Sign: Boolean;'
      '  Exp: Integer;'
      '  A, B, R: UInt64;'
      '  T, D: Int64;'
      '  J: Integer;'
      '  procedure RoundToDoubleRN;'
      '  var'
      '    HalfBit: UInt64;'
      '    MaskBits: UInt64;'
      '  begin'
      '    HalfBit  := $0000000000000400;'
      '    MaskBits := $fffffffffffff800;'
      
        '    if (Exp < -$3fe) and (Exp > $3fe - 53) then // for Denormal ' +
        'values'
      '    begin'
      
        '      //  $3BCE exp = -$3FE - 52 => MaskBits = 0x80000000_000000' +
        '00'
      
        '      //  $3C00 exp = -$3FE -  1 => MaskBits = 0xffffffff_fffff0' +
        '00'
      '      HalfBit  := HalfBit  shl (-$3FE - Exp);'
      '      MaskBits := MaskBits shl (-$3FE - Exp);'
      '    end;'
      '    if (R and HalfBit) <> 0 then'
      '    begin'
      
        '      if ((R and not MaskBits) <> HalfBit) or ((R and (HalfBit s' +
        'hl 1)) <> 0) then'
      '        Inc(R, HalfBit);'
      '      R := R and MaskBits;'
      '      if R = 0 then'
      '      begin'
      '        R := $8000000000000000;'
      '        Inc(Exp);'
      
        '        // if (Exp > $3FFF) ... // exp=$4000, R=$80..00; infinit' +
        'e'
      '      end;'
      '    end'
      '    else'
      '      R := R and MaskBits;'
      '  end;'
      'begin'
      '  Sign := Dividend < 0;'
      '  if Sign then'
      '    A := UInt64(- PInt64(@Dividend)^)'
      '  else'
      '    A := PUInt64(@Dividend)^;'
      '  if Divisor < 0 then'
      '  begin'
      '    B := UInt64(- PInt64(@Divisor)^);'
      '    Sign := not Sign;'
      '  end'
      '  else'
      '    B := PUInt64(@Divisor)^;'
      '  Exp := 0;'
      '  //'
      '  // Exceptions'
      '  if B = 0 then'
      '  begin'
      '    ErrorAt(Byte(reZeroDivide), ReturnAddress);'
      '    R := $7FF0000000000000;'
      '    if Sign then'
      '      R := $FFF0000000000000;'
      '    PUInt64(@Result)^ := R;'
      '    Exit;'
      '  end;'
      '  if A = 0 then'
      '    Exit(0);'
      '  //'
      '  // Normalize A'
      '  if (A and $FFFFFFFF00000000) = 0 then'
      '  begin'
      '    A := A shl 32;'
      '    Dec(Exp, 32);'
      '  end;'
      '  if (A and $FFFF000000000000) = 0 then'
      '  begin'
      '    A := A shl 16;'
      '    Dec(Exp, 16);'
      '  end;'
      '  if (A and $FF00000000000000) = 0 then'
      '  begin'
      '    A := A shl 8;'
      '    Dec(Exp, 8);'
      '  end;'
      '  while (A and $8000000000000000) = 0 do'
      '  begin'
      '    A := A shl 1;'
      '    Dec(Exp);'
      '  end;'
      '  //'
      '  // Normalize B'
      '  if (B and $FFFFFFFF00000000) = 0 then'
      '  begin'
      '    B := B shl 32;'
      '    Inc(Exp, 32);'
      '  end;'
      '  if (B and $FFFF000000000000) = 0 then'
      '  begin'
      '    B := B shl 16;'
      '    Inc(Exp, 16);'
      '  end;'
      '  if (B and $FF00000000000000) = 0 then'
      '  begin'
      '    B := B shl 8;'
      '    Inc(Exp, 8);'
      '  end;'
      '  while (B and $8000000000000000) = 0 do'
      '  begin'
      '    B := B shl 1;'
      '    Inc(Exp);'
      '  end;'
      '  //'
      '  // short cut for A=B case'
      '  if A = B then'
      '  begin'
      '    R := $8000000000000000;'
      '    Inc(Exp);'
      '  end'
      '  else'
      '  begin'
      '    // make 0 <= A < B'
      '    if A >= B then'
      '    begin'
      '      A := A shr 1;'
      '      Inc(Exp);'
      '    end;'
      '    //'
      '    // A = 0. a0 a1 a2 ... a63'
      '    // B = 0. b0 b1 b2 ... b63'
      '    // R = 0. r0 r1 r2 ... r63'
      '    // 0 <= A < B'
      '    // R := A div B;'
      '    // 0 <= R < 1'
      '    //'
      '    D := Int64(B shr 1);'
      '    T := Int64(A) - D;'
      '    R := 0;'
      '    for J := 1 to 64 do'
      '    begin'
      '      R := R shl 1;'
      '      D := D shr 1;'
      '      if T < 0 then'
      '        Inc(T, D)'
      '      else'
      '      begin'
      '        Inc(R);'
      '        Dec(T, D);'
      '      end;'
      '    end;'
      '  end;'
      '  //'
      '  // Special result case'
      '  if R = 0 then'
      '  begin'
      '    if Sign then'
      '      R := $8000000000000000;'
      '  end'
      '  else'
      '  begin'
      '    // Normalize result in R'
      '    while (R and $8000000000000000) = 0 do'
      '    begin'
      '      R := R shl 1;'
      '      Dec(Exp);'
      '    end;'
      '    // -62 <= Exp <= +32'
      '    //'
      '    // Round 64 bit fraction to 1+52 bit'
      '    RoundToDoubleRN;'
      '    // Build floating point value'
      
        '    R := (R shr 11) and $000FFFFFFFFFFFFF; // exclude msb=1 for ' +
        'economized form'
      
        '    Inc(Exp, $3ff - 1); // $3ff is bias for 2^0, -1 for 0.1xxxxx' +
        ' to 1.xxxxx'
      '    if Sign then'
      '      Inc(Exp, $800);'
      '    R := R or (UInt64(Exp) shl 52);'
      '  end;'
      '  PUInt64(@Result)^ := R;'
      'end;'
      '{$ENDIF !X86ASMRTL}'
      ''
      'const'
      
        '  ovtInstanceSize = -2 * SizeOf(Pointer); {Offset of instance si' +
        'ze in OBJECTs}'
      '  ovtVmtPtrOffs   = -1 * SizeOf(Pointer);'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      '// Returning Pointer(NativeInt(-1)) indicates failure.'
      '// Otherwise, successful and Return Self.'
      '// AllocFlag indicates an object which was allocated.'
      
        'function _ObjSetup(Self: Pointer; var VmtPtrAndAllocFlag: Pointe' +
        'r): Pointer;'
      'var'
      '  Size: NativeInt;'
      '  VmtPtrOffs: NativeInt;'
      '  VmtPtr: Pointer;'
      'begin'
      '  Result := Self;'
      '  VmtPtr := VmtPtrAndAllocFlag;'
      '  if VmtPtr = nil then'
      '    Exit; // Successful, not allocated'
      '  if Result = nil then'
      '  begin'
      '    Size := PNativeInt(PByte(VmtPtr) + ovtInstanceSize)^;'
      '    if Size = 0 then'
      '    begin'
      '      VmtPtrAndAllocFlag := nil;'
      '      Exit; // Successful, not allocated'
      '    end;'
      '    Result := _GetMem(Size);'
      '    if Result = nil then'
      '    begin'
      '      Result := Pointer(PByte(-1));'
      '      VmtPtrAndAllocFlag := nil;'
      '      Exit; // Failure, not allocated'
      '    end;'
      '    FillChar(Result^, Size, 0);'
      '    // VmtPtrAndAllocFlag is already non-zero = allocated'
      '  end'
      '  else'
      '    VmtPtrAndAllocFlag := nil; // not allocated'
      '  VmtPtrOffs := PNativeInt(PByte(VmtPtr) + ovtVmtPtrOffs)^;'
      '  if VmtPtrOffs >= 0 then'
      '  begin'
      '    // store vmt in object at this offset'
      '    PPointer(PByte(Result) + VmtPtrOffs)^ := VmtPtr;'
      '  end;'
      '  // Successful, VmtPtrAndAllocFlag is non-zero if allocated'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure       _ObjSetup;'
      'asm //StackAlignSafe'
      
        '{       FUNCTION _ObjSetup( self: ^OBJECT; vmt: ^VMT): ^OBJECT; ' +
        '}'
      '{     ->EAX     Pointer to self (possibly nil)  }'
      '{       EDX     Pointer to vmt  (possibly nil)  }'
      '{     <-EAX     Pointer to self                 }'
      '{       EDX     <> 0: an object was allocated   }'
      '{       Z-Flag  Set: failure, Cleared: Success  }'
      ''
      
        '        CMP     EDX,1           { is vmt = 0, indicating a call ' +
        '        }'
      
        '        JAE     @@skip1         { from a constructor?           ' +
        '        }'
      
        '        RET                     { return immediately with Z-flag' +
        ' cleared}'
      ''
      '@@skip1:'
      '        PUSH    ECX'
      
        '        TEST    EAX,EAX         { is self already allocated?    ' +
        '        }'
      '        JNE     @@noAlloc'
      '        MOV     EAX,[EDX].ovtInstanceSize'
      '        TEST    EAX,EAX'
      '        JE      @@zeroSize'
      '        PUSH    EDX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    _GetMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EDX'
      '        TEST    EAX,EAX'
      '        JZ      @@fail'
      ''
      '        {       Zero fill the memory }'
      ''
      '        PUSH    EDI'
      '        MOV     ECX,[EDX].ovtInstanceSize'
      '        MOV     EDI,EAX'
      '        PUSH    EAX'
      '        XOR     EAX,EAX'
      '        SHR     ECX,2'
      '        REP     STOSD'
      '        MOV     ECX,[EDX].ovtInstanceSize'
      '        AND     ECX,3'
      '        REP     STOSB'
      '        POP     EAX'
      '        POP     EDI'
      ''
      '        MOV     ECX,[EDX].ovtVmtPtrOffs'
      '        TEST    ECX,ECX'
      '        JL      @@skip'
      
        '        MOV     [EAX+ECX],EDX   { store vmt in object at this of' +
        'fset    }'
      '@@skip:'
      
        '        TEST    EAX,EAX         { clear zero flag               ' +
        '        }'
      '        POP     ECX'
      '        RET'
      ''
      '@@fail:'
      '        XOR     EDX,EDX'
      '        POP     ECX'
      '        RET'
      ''
      '@@zeroSize:'
      '        XOR     EDX,EDX'
      
        '        CMP     EAX,1   { clear zero flag - we were successful (' +
        'kind of)}'
      '        POP     ECX'
      '        RET'
      ''
      '@@noAlloc:'
      '        MOV     ECX,[EDX].ovtVmtPtrOffs'
      '        TEST    ECX,ECX'
      '        JL      @@exit'
      
        '        MOV     [EAX+ECX],EDX   { store vmt in object at this of' +
        'fset    }'
      '@@exit:'
      
        '        XOR     EDX,EDX         { clear allocated flag          ' +
        '        }'
      
        '        TEST    EAX,EAX         { clear zero flag               ' +
        '        }'
      '        POP     ECX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF (Not DEFined(X86ASMRTL))}'
      
        'procedure _ObjCopy(Dest, Source: Pointer; VmtPtrOffs: NativeInt)' +
        ';'
      'var'
      '  VmtPtr: Pointer;'
      '  Size: NativeInt;'
      'begin'
      '  VmtPtr := PPointer(PByte(Dest) + VmtPtrOffs)^;'
      '  Size := PNativeInt(PByte(VmtPtr) + ovtInstanceSize)^;'
      '  Move(Source^, Dest^, Size);'
      '  PPointer(PByte(Dest) + VmtPtrOffs)^ := VmtPtr;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _ObjCopy;'
      'asm'
      
        '{       PROCEDURE _ObjCopy( dest, src: ^OBJECT; vmtPtrOff: Nativ' +
        'eInt);  }'
      '{     ->EAX     Pointer to destination          }'
      '{       EDX     Pointer to source               }'
      '{       ECX     Offset of vmt in those objects. }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EDX'
      '        MOV     EDI,EAX'
      ''
      
        '        LEA     EAX,[EDI+ECX]   { remember pointer to dest vmt p' +
        'ointer  }'
      
        '        MOV     EDX,[EAX]       { fetch dest vmt pointer        ' +
        '}'
      ''
      '        MOV     EBX,[EDX].ovtInstanceSize'
      ''
      '        MOV     ECX,EBX { copy size DIV 4 dwords        }'
      '        SHR     ECX,2'
      '        REP     MOVSD'
      ''
      '        MOV     ECX,EBX { copy size MOD 4 bytes }'
      '        AND     ECX,3'
      '        REP     MOVSB'
      ''
      
        '        MOV     [EAX],EDX       { restore dest vmt              ' +
        '}'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '// _Fail is a helper function used by Fail standard procedure.'
      '// It can be used in old style object constructor.'
      
        '// -> Self = Pointer to self. (possibly nil or invlaid pointer i' +
        'f AllocFlag=0)'
      '//    AllocFlag <> 0: Object must be deallocated'
      '// <- Returns nil'
      'function _Fail(Self: Pointer; AllocFlag: NativeInt): Pointer;'
      'begin'
      '  if AllocFlag <> 0 then'
      '    FreeMem(Self);'
      '  Result := nil;'
      'end;'
      ''
      '{$IF defined(CPUX86) or defined(CPUX64)}'
      ''
      '{$IFDEF ASSEMBLER}'
      
        'function _GetCPUID(FunctionID: UInt32; SubFunctionID: UInt32 = 0' +
        '): TCPUIDRec;'
      'asm'
      '{$IFDEF CPUX86}'
      '        PUSH    EDI'
      '        PUSH    EBX'
      '        PUSH    ECX'
      ''
      '        MOV     EDI,Result'
      '//      MOV     EAX,FunctionID'
      '        MOV     ECX,SubFunctionID'
      '        CPUID'
      '        MOV     [EDI].TCPUIDRec.&EAX,EAX'
      '        MOV     [EDI].TCPUIDRec.&EBX,EBX'
      '        MOV     [EDI].TCPUIDRec.&ECX,ECX'
      '        MOV     [EDI].TCPUIDRec.&EDX,EDX'
      ''
      '//  TCPUIDRec = record'
      '//   EAX, EBX, ECX, EDX: UInt32;'
      '//  end platform;'
      ''
      '        POP     ECX'
      '        POP     EBX'
      '        POP     EDI'
      '{$ENDIF CPUX86}'
      '{$IFDEF CPUX64}'
      '        .NOFRAME'
      '        MOV     R10,RBX'
      ''
      '        MOV     R9,Result'
      '        MOV     EAX,FunctionID'
      '        MOV     ECX,SubFunctionID'
      '        CPUID'
      '        MOV     [R9].TCPUIDRec.&EAX,EAX'
      '        MOV     [R9].TCPUIDRec.&EBX,EBX'
      '        MOV     [R9].TCPUIDRec.&ECX,ECX'
      '        MOV     [R9].TCPUIDRec.&EDX,EDX'
      ''
      '        MOV     RBX,R10'
      '{$ENDIF CPUX64}'
      'end;'
      ''
      '{$ELSE !ASSEMBLER}'
      ''
      
        'function _GetCPUID(FunctionID: UInt32; SubFunctionID: UInt32 = 0' +
        '): TCPUIDRec;'
      '{$IFDEF CPUX86}'
      'begin'
      '  Result.EAX := 0;'
      '  Result.EBX := 0;'
      '  Result.ECX := 0;'
      '  Result.EDX := 0;'
      'end;'
      '{$ENDIF CPUX86}'
      '{$IFDEF CPUX64}'
      '  external librtlhelpername name '#39'_system_GetCPUID'#39';'
      '{$ENDIF CPUX64}'
      '{$ENDIF ASSEMBLER}'
      ''
      'var'
      '  IsCPUIDAvailableFlag: Boolean = False;'
      ''
      'function IsCPUIDAvailable: Boolean; inline;'
      '{$IF defined(CPUX86) and not defined(MACOS)}'
      'begin'
      '  Result := IsCPUIDAvailableFlag;'
      'end;'
      '{$ENDIF CPUX86 and !MACOS}'
      '{$IF defined(CPUX64) or defined(MACOS)}'
      'begin'
      '  Result := True; // All X64 CPU have CPUID inst.'
      '                  // All macOS hardware have CPUID inst.'
      'end;'
      '{$ENDIF CPUX64 or MACOS}'
      ''
      '{$IF defined(CPUX86) and not defined(MACOS)}'
      'procedure InitializeCPUIDAvailable;'
      '{$IFDEF ASSEMBLER}'
      'begin'
      '  IsCPUIDAvailableFlag := False;'
      '  asm'
      '        PUSH    EBX'
      '        PUSHFD'
      '        POP     EAX'
      '        MOV     ECX, EAX'
      '        XOR     EAX, $200000    // flip CPUID bit in EFLAGS'
      '        PUSH    EAX'
      '        POPFD'
      '        PUSHFD'
      '        POP     EAX'
      '        XOR     EAX, ECX    // zero = NO CPUID instruction.'
      '        JZ      @@Exit'
      
        '        MOV     IsCPUIDAvailableFlag, True                      ' +
        '                                               '
      '@@Exit:'
      '        POP     EBX'
      '  end;'
      'end;'
      '{$ELSE !ASSEMBLER}'
      '  {$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF ASSEMBLER}'
      '{$ENDIF CPUX86 and !MACOS}'
      ''
      
        'function GetCPUID(FunctionID: UInt32; SubFunctionID: UInt32 = 0)' +
        ': TCPUIDRec;'
      'begin'
      '  if IsCPUIDAvailable then'
      '    Result := _GetCPUID(FunctionID, SubFunctionID)'
      '  else'
      '  begin'
      '    Result.EAX := 0;'
      '    Result.EBX := 0;'
      '    Result.ECX := 0;'
      '    Result.EDX := 0;'
      '  end;'
      'end;'
      ''
      '// GetBrifSSEType checks only SSE and SSE2 availability.'
      '// To check full SSE information, use Math unit.'
      '// $00000000: No SSE'
      '// $00000001: SSE supported'
      '// $00000002: SSE2 supported'
      ''
      '{$IFDEF CPUX86}'
      'function GetBriefSSEType: Cardinal;'
      'begin'
      '  Result := $00000000; // No SSE'
      
        '  if (CPUIDTable[1].EDX and $02000000) <> 0 then // EDX 25 bits ' +
        '- SSE bit'
      '    Result := Result or $00000001; // SSE supported'
      
        '  if (CPUIDTable[1].EDX and $04000000) <> 0 then // EDX 26 bits ' +
        '- SSE2 bit'
      '    Result := Result or $00000002; // SSE2 supported'
      'end;'
      '{$ENDIF CPUX86}'
      ''
      'procedure InitializeCPUID;'
      'var'
      '  I: Integer;'
      'begin'
      '{$IF defined(CPUX86) and not defined(MACOS)}'
      '  InitializeCPUIDAVailable;'
      '{$ENDIF CPUX86 and !MACOS}'
      '  for I := Low(CPUIDTable) to High(CPUIDTable) do'
      '    CPUIDTable[I] := GetCPUID(I);'
      'end;'
      '{$ENDIF Defined(CPUX86) or Defined(CPUX64)}'
      ''
      'procedure _InitializeControlWord;'
      'begin'
      '{$IF defined(IOS) and defined(CPUX86)} // iOS Simulator'
      '  TestSSE := $3; // All Intel Mac supports SSE2.'
      
        '  FPUExceptionMaskBits := (Default8087CW and $003F) or ((Default' +
        'MXCSR and $1F80) shr 7) or $8000;'
      
        '{$ELSEIF defined(CPUX86) and defined(ASSEMBLER)} // Win32 or OSX' +
        '32'
      '  TestSSE := GetBriefSSEType;'
      '  DefaultMXCSR := GetMXCSR and $FFC0;  // Remove flag bits;'
      '{$ELSEIF defined(CPUX64) and defined(MSWINDOWS)} // Win64'
      '  TestSSE := $3; // SSE & SSE2 are available on X64'
      '  Default8087CW := Get8087CW and $1F3F; // Remove reserved bits.'
      '{$ELSEIF defined(CPUX64) and defined(ARITH_USE_LIBM)} // Linux64'
      '  TestSSE := $3; // SSE & SSE2 are available on X64'
      '  FPExceptionMaskBits := DefaultFPEnv;'
      '{$ENDIF}'
      'end;'
      ''
      '{$IFDEF LINUX64}'
      'var'
      '  OldInitializeControlWordAtThreadAttached: Pointer;'
      ''
      'procedure InitializeControlWordAtThreadAttached;'
      'type'
      '  ThreadInitProcType = procedure;'
      'begin'
      '  if OldInitializeControlWordAtThreadAttached <> nil then'
      
        '    ThreadInitProcType(OldInitializeControlWordAtThreadAttached)' +
        ';'
      '  _InitializeControlWord;'
      'end;'
      ''
      'procedure _InitializeThreadInitProc;'
      'begin'
      '  OldInitializeControlWordAtThreadAttached := ThreadInitProc;'
      '  ThreadInitProc := @InitializeControlWordAtThreadAttached;'
      'end;'
      ''
      '{$ENDIF LINUX64}'
      ''
      'procedure _FpuInit;'
      
        '{$IF ((defined(LINUX) or defined(MACOS) or defined(ANDROID)) and' +
        ' defined(CPUARM)) } // ARM macOS, iOS, or Android'
      'const'
      
        '  ValidMask = $07C0009F; // AHP, DefaultNan, Flush-to-Zero, Roun' +
        'dMode, All exception events'
      'begin'
      '  SetFPSCR(DefaultFPSCR and ValidMask);'
      '  FPSCRExceptionEnableBits := DefaultFPSCR and femALLEXCEPT;'
      'end;'
      '{$ELSEIF defined(IOS) and defined(CPUX86)} // iOS/32 Simulator'
      'begin'
      
        '  FPUExceptionMaskBits := (Default8087CW and $003F) or ((Default' +
        'MXCSR and $1F80) shr 7) or $8000;'
      '  Set8087CW(Default8087CW);'
      '  SetMXCSR(DefaultMXCSR);'
      'end;'
      '{$ELSEIF defined(CPUX86)} // Win32 and OSX'
      'asm'
      '        FNINIT'
      '        FWAIT'
      '{$IFDEF PIC}'
      '        CALL    GetGOT'
      '        MOV     EAX,[EAX].OFFSET Default8087CW'
      '        FLDCW   [EAX]'
      '{$IFDEF IOS}'
      '        CALL    GetGOT'
      '        MOV     EAX,[EAX].OFFSET DefaultMXCSR'
      '        LDMXCSR   [EAX]'
      '{$ENDIF}'
      '{$ELSE}'
      '        FLDCW   Default8087CW'
      '{$ENDIF}'
      'end;'
      '{$ELSEIF defined(CPUX64) and defined(MSWINDOWS)} // Windows/64'
      'asm'
      '        LDMXCSR DefaultMXCSR'
      'end;'
      '{$ELSEIF defined(CPUX64) and (defined(LINUX) or defined(MACOS))}'
      'var'
      '  SavedRoundMode: UInt32;'
      'begin'
      '  SavedRoundMode := FGetRound;'
      ''
      '  fpu_init;'
      '  fedisableexcept(femALLEXCEPT);'
      ''
      '  FSetRound(SavedRoundMode);'
      'end;'
      '{$ELSE}'
      'begin'
      '  Error(rePlatformNotImplemented);'
      'end;'
      '{$ENDIF}'
      ''
      'procedure _BoundErr;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  ErrorAt(Byte(reRangeError), ReturnAddress);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        MOV     AL,reRangeError'
      '        JMP     Error'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _IntOver;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  ErrorAt(Byte(reIntOverflow), ReturnAddress);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        MOV     AL,reIntOverflow'
      '        JMP     Error'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _IntDivByZero;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  ErrorAt(Byte(reDivByZero), ReturnAddress);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        MOV     AL,reDivByZero'
      '        JMP     Error'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IFDEF POSIX}'
      '{$IFDEF USE_LIBICU}'
      '{$IFDEF LINUX}'
      'function InternalCompareTextICU(const S1, S2: string): Boolean;'
      '{$ELSE !LINUX}'
      'function InternalCompareText(const S1, S2: string): Boolean;'
      '{$ENDIF LINUX}'
      'begin'
      '  Result := u_strcasecmp(PUChar(S1), PUChar(S2), 0) = 0;'
      'end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IF not Defined(USE_LIBICU) or Defined(LINUX)}'
      '{$IFDEF LINUX}'
      
        'function InternalCompareTextICONV(const S1, S2: string): Boolean' +
        ';'
      '{$ELSE !LINUX}'
      'function InternalCompareText(const S1, S2: string): Boolean;'
      '{$ENDIF LINUX}'
      '{$IFDEF LINUX}'
      'var'
      '  I: Integer;'
      '  US1, US2: UCS4String;'
      '  LCompareLocale: Pointer;'
      'begin'
      '  if Length(S1) <> Length(S2) then'
      '    Exit(False);'
      ''
      '  // Convert to UCS4'
      '  US1 := UnicodeStringToUCS4String(S1);'
      '  US2 := UnicodeStringToUCS4String(S2);'
      ''
      '  // Convert to upper case for case insensitivity'
      '  LCompareLocale := UTF8CompareLocale;'
      '  for I := 0 to Length(US1) - 1 do'
      
        '    US1[I] := UCS4Char(towupper_l(wint_t(US1[I]), LCompareLocale' +
        '));'
      '  for I := 0 to Length(US2) - 1 do'
      
        '    US2[I] := UCS4Char(towupper_l(wint_t(US2[I]), LCompareLocale' +
        '));'
      ''
      '  // Clear error info and compare strings'
      '  SetLastError(0);'
      
        '  Result := (wcscoll_l(pwchar_t(@US1[0]), pwchar_t(@US2[0]), LCo' +
        'mpareLocale) = 0) and'
      '            (GetLastError = 0);'
      'end;'
      '{$ENDIF LINUX}'
      '{$IFDEF MACOS}'
      'var'
      '  StringRef1: CFStringRef;'
      '  StringRef2: CFStringRef;'
      '  Range: CFRange;'
      'begin'
      '  Result := False;'
      
        '  StringRef1 := CFStringCreateWithCharacters(nil, @S1[Low(string' +
        ')], Length(S1));'
      '  if StringRef1 <> nil then'
      '  try'
      
        '    StringRef2 := CFStringCreateWithCharacters(nil, @S2[Low(stri' +
        'ng)], Length(S2));'
      '    if StringRef2 <> nil then'
      '    try'
      '      Range.location := 0;'
      '      Range.length := Length(S1);'
      
        '      Result := CFStringCompareWithOptionsAndLocale(StringRef1, ' +
        'StringRef2,'
      
        '                  Range, kCFCompareCaseInsensitive, UTF8CompareL' +
        'ocale) = 0;'
      '    finally'
      '      CFRelease(StringRef2);'
      '    end;'
      '  finally'
      '    CFRelease(StringRef1);'
      '  end;'
      'end;'
      '{$ENDIF MACOS}'
      '{$ENDIF not Defined(USE_LIBICU) or Defined(LINUX)}'
      ''
      '{$IFDEF LINUX}'
      'function InternalCompareText(const S1, S2: string): Boolean;'
      'begin'
      '  if IsICUAvailable then'
      '    Result := InternalCompareTextICU(S1, S2)'
      '  else'
      '    Result := InternalCompareTextICONV(S1, S2)'
      'end;'
      '{$ENDIF LINUX}'
      '{$ENDIF POSIX}'
      ''
      
        'function InternalUTF8ShortStringCompare(const Str1: _PShortStr; ' +
        'const Str2: string): Boolean; overload;'
      'var'
      '  LStr1: string;'
      'begin'
      '  LStr1 := UTF8ToString(Str1^);'
      '{$IFDEF MSWINDOWS}'
      
        '  Result := CompareString(UTF8CompareLocale, NORM_IGNORECASE, PC' +
        'har(LStr1),'
      '    Length(LStr1), PChar(Str2), Length(Str2)) = CSTR_EQUAL;'
      '{$ELSEIF defined(POSIX)}'
      '  Result := InternalCompareText(LStr1, Str2);'
      '{$ELSE}'
      '  Error(rePlatformNotImplemented);'
      '{$ENDIF}'
      'end;'
      ''
      
        'function InternalUTF8ShortShortCompare(const Str1, Str2: _PShort' +
        'Str): Boolean; overload;'
      '{$IF defined(MSWINDOWS)}'
      'var'
      '  Len1, Len2: Integer;'
      '  LStr1, LStr2: array[0..255] of WideChar;'
      'begin'
      
        '  Len1 := MultiByteToWideChar(CP_UTF8, 0, @Str1^[1], Length(Str1' +
        '^), LStr1, Length(LStr1));'
      
        '  Len2 := MultiByteToWideChar(CP_UTF8, 0, @Str2^[1], Length(Str2' +
        '^), LStr2, Length(LStr2));'
      
        '  Result := CompareString(UTF8CompareLocale, NORM_IGNORECASE, LS' +
        'tr1, Len1, LStr2, Len2) = CSTR_EQUAL;'
      'end;'
      '{$ELSEIF defined(POSIX)}'
      'begin'
      
        '  Result := InternalCompareText(UTF8ToUnicodeString(Str1^), UTF8' +
        'ToUnicodeString(Str2^));'
      'end;'
      '{$ELSE}'
      'begin'
      '  Error(rePlatformNotImplemented);'
      'end;'
      '{$ENDIF}'
      ''
      'function UTF8IdentToString(const Name: _PShortStr): string;'
      'var'
      '  L: NativeInt;'
      '  D: PChar;'
      '  C: Char;'
      'begin'
      '  L := Byte(Name^[0]);'
      '  SetLength(Result, L);'
      '  D := Pointer(Result);'
      '  while L > 0 do'
      '  begin'
      '    C := Char(Name^[L]);'
      '    if Byte(C) >= $80 then'
      '      Break;'
      '    D[L - 1] := C;'
      '    Dec(L);'
      '  end;'
      '  if L > 0 then'
      '    Result := UTF8ToString(Name^);'
      'end;'
      ''
      
        'function UTF8IdentStringCompare(const Name1: _PShortStr; const N' +
        'ame2: string): Boolean;'
      'var'
      '  L: Byte;'
      '  S: PByte;'
      '  D: PChar;'
      '  CS: Word;'
      '  CD: Word;'
      'begin'
      '  L := Byte(Name1^[0]);'
      '  S := PByte(@Name1^[1]);'
      '  D := PChar(Name2);'
      '  CS := S^;'
      '  CD := Word(D^);'
      
        '  while (L > 0) and (CD <> 0) and (CD and $FF80 = 0) and (CS and' +
        ' $80 = 0) and (CS or $20 = CD or $20) do'
      '  begin'
      '    Inc(D);'
      '    Inc(S);'
      '    Dec(L);'
      '    CS := S^;'
      '    CD := Word(D^);'
      '  end;'
      '  if CD <> 0 then'
      '    if (CD and $FF80 = 0) and (CS and $80 = 0) then'
      '      Result := False'
      '    else'
      '      Result := InternalUTF8ShortStringCompare(Name1, Name2)'
      '  else'
      '    Result := L = 0;'
      'end;'
      ''
      
        'function UTF8IdentIdentCompare(const Name1, Name2: _PShortStr): ' +
        'Boolean;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  PName1, PName2: PByte;'
      '  I: Integer;'
      'begin'
      '  if Length(Name1^) <> Length(Name2^) then'
      '    Exit(False);'
      '  I := Length(Name1^) div 4;'
      
        '                                                                ' +
        '                                                 '
      '  PName1 := PByte(@Name1^[1]);'
      '  PName2 := PByte(@Name2^[1]);'
      '  while I > 0 do'
      '  begin'
      
        '    if ((PCardinal(PName1)^ and $80808080) <> 0) or ((PCardinal(' +
        'PName2)^ and $80808080) <> 0) then'
      '      Exit(InternalUTF8ShortShortCompare(Name1, Name2));'
      
        '    if ((PCardinal(PName1)^ xor PCardinal(PName2)^) and $5F5F5F5' +
        'F) <> 0 then'
      '      Exit(False);'
      '    Inc(PName1, 4);'
      '    Inc(PName2, 4);'
      '    Dec(I);'
      '  end;'
      '  I := Length(Name1^) and 3;'
      '  while I > 0 do'
      '  begin'
      '    if ((PName1^ and $80) <> 0) or ((PName1^ and $80) <> 0) then'
      '      Exit(InternalUTF8ShortShortCompare(Name1, Name2));'
      '    if (PName1^ xor PName2^) and $5F <> 0 then'
      '      Exit(False);'
      '    Inc(PName1);'
      '    Inc(PName2);'
      '    Dec(I);'
      '  end;'
      '  Result := True;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm //StackAligned'
      '        { ->    EAX Name1        }'
      '        {       EDX Name2        }'
      '        { <-    True if Same     }'
      '        MOV     CH,[EAX]'
      '        MOV     CL,[EDX]'
      '        CMP     CH,CL'
      '        JE      @@DoCompare'
      '        XOR     EAX,EAX'
      '        RET'
      ''
      '@@DoCompare:'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        MOVZX   ECX,CL'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    ECX'
      '        MOV     ESI,EAX'
      '        MOV     EDI,EDX'
      '        INC     ESI'
      '        INC     EDI'
      '        SHR     ECX,2'
      '        JZ      @@CharLoop'
      ''
      '@@Loop:'
      '        MOV     EAX,[ESI]'
      '        TEST    EAX,$80808080'
      '        JNZ     @@Utf8Compare'
      '        MOV     EDX,[EDI]'
      '        TEST    EDX,$80808080'
      '        JNZ     @@UTF8Compare'
      '        XOR     EAX,EDX'
      '        AND     EAX,$5F5F5F5F'
      '        JNZ     @@NotEqual'
      '        ADD     ESI,4'
      '        ADD     EDI,4'
      '        DEC     ECX'
      '        JNZ     @@Loop'
      ''
      '@@CharLoop:'
      '        MOV     ECX,[ESP]'
      '        AND     ECX,3'
      '        JZ      @@Equal'
      ''
      '@@Loop2:'
      '        MOV     AL,[ESI]'
      '        TEST    AL,$80'
      '        JNZ     @@Utf8Compare'
      '        MOV     DL,[EDI]'
      '        TEST    DL,$80'
      '        JNZ     @@Utf8Compare'
      '        XOR     AL,DL'
      '        AND     AL,$5F'
      '        JNZ     @@NotEqual'
      '        INC     ESI'
      '        INC     EDI'
      '        DEC     ECX'
      '        JNZ     @@Loop2'
      ''
      '@@Equal:'
      '        POP     ECX'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EDX'
      '        POP     EAX'
      '        MOV     EAX,1'
      '        JMP     @@Exit'
      ''
      '@@Utf8Compare:'
      '        POP     ECX'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EDX'
      '        POP     EAX'
      '        JMP     InternalUTF8ShortShortCompare'
      ''
      '@@NotEqual:'
      '        POP     ECX'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EDX'
      '        POP     EAX'
      '        XOR     EAX,EAX'
      '@@Exit:'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function UTF8IdentLength(const Name: string): Integer;'
      'var'
      '  S: PWord;'
      'begin'
      '  S := Pointer(Name);'
      '  if S = nil then'
      '    Exit(0);'
      '  while (S^ <> 0) and (S^ and $FF80 = 0) do'
      '    Inc(S);'
      '  if S^ = 0 then'
      '    Result := PStrRec(PByte(Name) - SizeOf(StrRec)).length'
      '  else'
      '    Result := UnicodeToUtf8(nil, 0, Pointer(Name), Cardinal(-1))'
      
        '      {$IF not(defined(ANDROID) or defined(LINUX))} - 1 {$ENDIF}' +
        ';'
      'end;'
      ''
      'type'
      '  PPTypeInfo = ^PTypeInfo;'
      '  PTypeInfo = ^TTypeInfo;'
      '  TTypeInfo = packed record'
      '    Kind: TTypeKind;'
      '    Name: _ShortStr;'
      '   {TypeData: TTypeData}'
      '  end;'
      ''
      '  // 32 bit = 8 bytes, 64bit = 16 bytes'
      '  TFieldInfo = packed record'
      '    TypeInfo: PPTypeInfo;'
      '    case Integer of'
      '    0: ( Offset: Cardinal );'
      '    1: ( _Dummy: NativeUInt );'
      '  end;'
      ''
      '  TRecordInitializer = procedure(Rec: Pointer);'
      '  TRecordFinalizer = procedure(Rec: Pointer);'
      
        '  TRecordAssignOperator = procedure(Dest: Pointer; const Src: Po' +
        'inter);'
      ''
      '  PRecordOperatorTable = ^TRecordOperatorTable;'
      '  TRecordOperatorTable = packed record'
      '    Count: Byte;'
      '    case Integer of'
      '    0: ( Operators: array[0..3{Count}] of Pointer );'
      '    1: ( RecFlags: UIntPtr;'
      '         Initializer: TRecordInitializer;'
      '         Finalizer: TRecordFinalizer;'
      '         AssignOperator: TRecordAssignOperator );'
      '  end;'
      ''
      '  PFieldTable = ^TFieldTable;'
      '  TFieldTable = packed record'
      '    X: Word;'
      '    Size: Cardinal;'
      '    Count: Cardinal;'
      '    Fields: array [0..0] of TFieldInfo;'
      '    { case Kind of }'
      '    { tkMRecord: ( OperatorTable: TRecordOperatorTable ); }'
      '  end;'
      ''
      'function TObject.ClassType: TClass;'
      'begin'
      '  Result := PPointer(Self)^;'
      'end;'
      ''
      'class function TObject.ClassInfo: Pointer;'
      'begin'
      '  Result := PPointer(@PByte(Self)[vmtTypeInfo])^;'
      'end;'
      ''
      'class function TObject.ClassName: string;'
      'begin'
      
        '  Result := UTF8IdentToString(_PShortStr(PPointer(@PByte(Self)[v' +
        'mtClassName])^));'
      'end;'
      ''
      'class function TObject.QualifiedClassName: string;'
      'var'
      '  LScope: string;'
      'begin'
      '  LScope := UnitScope;'
      '  if LScope = '#39#39' then'
      '    Result := ClassName'
      '  else'
      '    Result := LScope + '#39'.'#39' + ClassName;'
      'end;'
      ''
      'class function TObject.ClassNameIs(const Name: string): Boolean;'
      'begin'
      
        '  Result := UTF8IdentStringCompare(_PShortStr(PPointer(@PByte(Se' +
        'lf)[vmtClassName])^), Name);'
      'end;'
      ''
      'class function TObject.ClassParent: TClass;'
      'begin'
      '  Result := PPointer(@PByte(Self)[vmtParent])^;'
      '  if Result <> nil then'
      '    Result := PPointer(Result)^;'
      'end;'
      ''
      'class function TObject.InstanceSize: Integer;'
      'begin'
      '  Result := PInteger(@PByte(Self)[vmtInstanceSize])^;'
      'end;'
      ''
      'class function TObject.NewInstance: TObject;'
      'begin'
      '  Result := InitInstance(_GetMem(InstanceSize));'
      '{$IFDEF AUTOREFCOUNT}'
      '  Result.FRefCount := 1;'
      '{$ENDIF}'
      'end;'
      ''
      'procedure TObject.FreeInstance;'
      'begin'
      '  CleanupInstance;'
      '  _FreeMem(Pointer(Self));'
      'end;'
      ''
      '{$IFDEF CPP_ABI_SUPPORT}'
      'procedure TObject.CPP_ABI_1;'
      'begin'
      'end;'
      ''
      'procedure TObject.CPP_ABI_2;'
      'begin'
      'end;'
      ''
      'procedure TObject.CPP_ABI_3;'
      'begin'
      'end;'
      '{$ENDIF CPP_ABI_SUPPORT}'
      ''
      
        'class operator TMethod.Equal(const Left, Right: TMethod): Boolea' +
        'n;'
      'begin'
      
        '  Result := (Left.Data = Right.Data) and (Left.Code = Right.Code' +
        ');'
      'end;'
      ''
      
        'class operator TMethod.NotEqual(const Left, Right: TMethod): Boo' +
        'lean;'
      'begin'
      '  Result := not (Left = Right);'
      'end;'
      ''
      
        'class operator TMethod.GreaterThan(const Left, Right: TMethod): ' +
        'Boolean;'
      'begin'
      '  Result := (UIntPtr(Left.Data) > UIntPtr(Right.Data)) or'
      
        '    ((Left.Data = Right.Data) and (UIntPtr(Left.Code) > UIntPtr(' +
        'Right.Code)));'
      'end;'
      ''
      
        'class operator TMethod.GreaterThanOrEqual(const Left, Right: TMe' +
        'thod): Boolean;'
      'begin'
      '  Result := (Left > Right) or (Left = Right);'
      'end;'
      ''
      
        'class operator TMethod.LessThan(const Left, Right: TMethod): Boo' +
        'lean;'
      'begin'
      '  Result := (UIntPtr(Left.Data) < UIntPtr(Right.Data)) or'
      
        '    ((Left.Data = Right.Data) and (UIntPtr(Left.Code) < UIntPtr(' +
        'Right.Code)));'
      'end;'
      ''
      
        'class operator TMethod.LessThanOrEqual(const Left, Right: TMetho' +
        'd): Boolean;'
      'begin'
      '  Result := (Left < Right) or (Left = Right);'
      'end;'
      ''
      'constructor TObject.Create;'
      'begin'
      'end;'
      ''
      'destructor TObject.Destroy;'
      'begin'
      'end;'
      ''
      'procedure TObject.Free;'
      'begin'
      
        '// under ARC, this method isn'#39't actually called since the compil' +
        'er translates'
      
        '// the call to be a mere nil assignment to the instance variable' +
        ', which then calls _InstClear'
      '{$IFNDEF AUTOREFCOUNT}'
      '  if Self <> nil then'
      '    Destroy;'
      '{$ENDIF}'
      'end;'
      ''
      'procedure TObject.DisposeOf;'
      'type'
      
        '  TDestructorProc = procedure (Instance: Pointer; OuterMost: Sho' +
        'rtInt);'
      'begin'
      '{$IFDEF AUTOREFCOUNT}'
      '  if Self <> nil then'
      '  begin'
      
        '    Self.__ObjAddRef; // Ensure the instance remains alive throu' +
        'ghout the disposal process'
      '    try'
      '      if __SetDisposed(Self) then'
      '      begin'
      '        _BeforeDestruction(Self, 1);'
      
        '        TDestructorProc(PPointer(PByte(PPointer(Self)^) + vmtDes' +
        'troy)^)(Self, 0);'
      '      end;'
      '    finally'
      
        '      Self.__ObjRelease; // This will deallocate the instance if' +
        ' the above process cleared all other references.'
      '    end;'
      '  end;'
      '{$ELSE}'
      '  Free;'
      '{$ENDIF}'
      'end;'
      ''
      'class function TObject.GetInterfaceTable: PInterfaceTable;'
      'begin'
      '  Result := PPointer(@PByte(Self)[vmtIntfTable])^;'
      'end;'
      ''
      'class function TObject.InitInstance(Instance: Pointer): TObject;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  IntfTable: PInterfaceTable;'
      '  ClassPtr: TClass;'
      '  I: Integer;'
      '{$IFDEF MANAGED_RECORD}'
      '  InitTable: PTypeInfo;'
      '  NeedInitializerInvoke: Boolean;'
      '{$ENDIF}'
      ''
      '  {$IFDEF MANAGED_RECORD}'
      
        '  procedure InvokeRecordInitializerFromBase(ClassPtr: TClass; In' +
        'stance: Pointer);'
      '  var'
      '    InitTable: PTypeInfo;'
      '    FT: PFieldTable;'
      '    ROps: PRecordOperatorTable;'
      '  begin'
      '    while True do'
      '    begin'
      '      InitTable := PPointer(@PByte(ClassPtr)[vmtInitTable])^;'
      '      ClassPtr := ClassPtr.ClassParent;'
      '      if ClassPtr = nil then'
      '        Break;'
      
        '      if (InitTable <> nil) and (InitTable.Kind = tkMRecord) the' +
        'n'
      '      begin'
      '        InvokeRecordInitializerFromBase(ClassPtr, Instance);'
      '        Break;'
      '      end;'
      '    end;'
      '    if (InitTable <> nil) and (InitTable.Kind = tkMRecord) then'
      '    begin'
      
        '      FT := PFieldTable(@PByte(InitTable)[Byte(PTypeInfo(InitTab' +
        'le).Name[0])]);'
      '      ROps := @FT.Fields[FT.Count];'
      
        '      if (ROps.Count > roiRecFlags) and ((ROps.RecFlags and 1) <' +
        '> 0) then'
      '        InvokeRecordInitializer(Instance, InitTable);'
      '    end;'
      '  end;'
      '  {$ENDIF}'
      ''
      'begin'
      '  FillChar(Instance^, InstanceSize, 0);'
      '  {$IFDEF MANAGED_RECORD}'
      '  NeedInitializerInvoke := False;'
      '  {$ENDIF}'
      '  PPointer(Instance)^ := Pointer(Self);'
      '  ClassPtr := Self;'
      '  repeat'
      '    IntfTable := ClassPtr.GetInterfaceTable;'
      '    if IntfTable <> nil then'
      '      for I := 0 to IntfTable.EntryCount-1 do'
      '        with IntfTable.Entries[I] do'
      '        begin'
      '          if VTable <> nil then'
      '            PPointer(@PByte(Instance)[IOffset])^ := VTable;'
      '        end;'
      '    {$IFDEF MANAGED_RECORD}'
      '    InitTable := PPointer(@PByte(ClassPtr)[vmtInitTable])^;'
      '    if (InitTable <> nil) and (InitTable.Kind = tkMRecord) then'
      '      NeedInitializerInvoke := True;'
      '    {$ENDIF}'
      '    ClassPtr := ClassPtr.ClassParent;'
      '  until ClassPtr = nil;'
      '  {$IFDEF MANAGED_RECORD}'
      '  if NeedInitializerInvoke then'
      '    InvokeRecordInitializerFromBase(Self, Instance);'
      '  {$ENDIF}'
      '  Result := Instance;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        MOV     EBX,EAX'
      '        MOV     EDI,EDX'
      '        MOV     EAX,EDX'
      '        MOV     EDX,[EBX].vmtInstanceSize'
      '        XOR     ECX,ECX'
      '        CALL    _FillChar'
      '        MOV     [EDI],EBX'
      '        MOV     EAX,EDI'
      '        MOV     EDX,ESP'
      '@@0:    MOV     ECX,[EBX].vmtIntfTable'
      '        TEST    ECX,ECX'
      '        JE      @@1'
      '        PUSH    ECX'
      '@@1:    MOV     EBX,[EBX].vmtParent'
      '        TEST    EBX,EBX'
      '        JE      @@2'
      '        MOV     EBX,[EBX]'
      '        JMP     @@0'
      '@@2:    CMP     ESP,EDX'
      '        JE      @@5'
      '@@3:    POP     EBX'
      '        MOV     ECX,[EBX].TInterfaceTable.EntryCount'
      '        ADD     EBX,4'
      '@@4:    MOV     ESI,[EBX].TInterfaceEntry.VTable'
      '        TEST    ESI,ESI'
      '        JE      @@4a'
      '        MOV     EDI,[EBX].TInterfaceEntry.IOffset'
      '        MOV     [EAX+EDI],ESI'
      '@@4a:   ADD     EBX,TYPE TInterfaceEntry'
      '        DEC     ECX'
      '        JNE     @@4'
      '        CMP     ESP,EDX'
      '        JNE     @@3'
      '@@5:'
      '        {$IFDEF MANAGED_RECORD}'
      '        MOV     EBX,EAX'
      '        MOV     ESI,EAX'
      '        MOV     EDI,ESP'
      
        '        { ESI=EAX=Instance, EBX=address of VMT, EDI=end of Class' +
        'Ptr array }'
      '        { Make vmtInitTable table on the stack }'
      '@@6:    MOV     EBX,[EBX]'
      '        MOV     EDX,[EBX].vmtInitTable'
      '        MOV     EBX,[EBX].vmtParent'
      '        TEST    EDX,EDX'
      '        JE      @@7'
      '        MOVZX   ECX,BYTE PTR [EDX]'
      '        CMP     CL,tkMRecord'
      '        JNE     @@7'
      '        MOVZX   ECX,[EDX+1]       // name length'
      
        '        LEA     EAX,[EDX+ECX+2+8] // address of destructive fiel' +
        'ds'
      
        '        MOV     ECX,[EDX+ECX+2+4] // number of destructive field' +
        's'
      '        LEA     ECX,[EAX+ECX*8]   // ECX: PRecordOperatorTable'
      '        //CMP     [ECX].TRecordOperatorTable.Count,roiRecFlags'
      '        CMP     BYTE PTR [ECX],roiRecFlags'
      '        JBE     @@7'
      
        '        //MOV     EAX,[ECX].TRecordOperatorTable.RecFlags // EAX' +
        ': UIntPtr = RecFlags'
      '        MOV     EAX,[ECX+1+4*roiRecFlags]'
      '        TEST    EAX,1 // Need to invoke record initialier'
      '        JZ      @@7'
      '        PUSH    EDX'
      '@@7:    TEST    EBX,EBX'
      '        JNE     @@6'
      
        '        { ESI=Instance, ESP=top of ClassPtr array, EDI=end of Cl' +
        'assPtr array }'
      '        { Call InvokeRecordInitializer from base class }'
      '        MOV     EAX,ESI'
      '        CMP     ESP,EDI'
      '        JE      @@9'
      '@@8:    POP     EDX'
      '        {$IFDEF ALIGN_STACK}'
      '        MOV     EBX,ESP'
      '        AND     ESP,NOT 16'
      '        {$ENDIF}'
      '        CALL    InvokeRecordInitializer'
      '        {$IFDEF ALIGN_STACK}'
      '        MOV     ESP,EBX'
      '        {$ENDIF}'
      '        MOV     EAX,ESI'
      '        CMP     ESP,EDI'
      '        JNE     @@8'
      '@@9:    { EAX=Instance }'
      '        {$ENDIF MANAGED_RECORD}'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF}'
      ''
      'procedure TObject.CleanupInstance;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  ClassPtr: TClass;'
      '  InitTable: Pointer;'
      'begin'
      '{$IFDEF WEAKREF}'
      '  _CleanupInstance(Self);'
      '{$ENDIF WEAKREF}'
      '  ClassPtr := ClassType;'
      '  repeat'
      '    InitTable := PPointer(@PByte(ClassPtr)[vmtInitTable])^;'
      '    if InitTable <> nil then'
      '      _FinalizeRecord(Self, InitTable);'
      '    ClassPtr := ClassPtr.ClassParent;'
      '  until ClassPtr = nil;'
      '  TMonitor.Destroy(Self);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        MOV     EBX,EAX'
      '        MOV     ESI,EAX'
      '        MOV     EDI,EAX'
      '{$IFDEF WEAKREF}'
      '        CALL    _CleanupInstance'
      '{$ENDIF}'
      '        MOV     EAX,ESI'
      '@@loop2:'
      '        MOV     ESI,[ESI]'
      '        MOV     EDX,[ESI].vmtInitTable'
      '        MOV     ESI,[ESI].vmtParent'
      '        TEST    EDX,EDX'
      '        JE      @@skip2'
      '        CALL    _FinalizeRecord'
      '        MOV     EAX,EBX'
      '@@skip2:'
      '        TEST    ESI,ESI'
      '        JNE     @@loop2'
      ''
      '        MOV     EAX,EBX'
      '        CALL    TMonitor.Destroy;'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure InvokeImplGetter(const Self: TObject; ImplGetter: Nati' +
        'veUInt; var Result: IInterface);'
      'const'
      '{$IF SizeOf(Pointer) = 4}'
      '  PROPSLOT_MASK    = $FF000000;'
      '  PROPSLOT_FIELD   = $FF000000;'
      '  PROPSLOT_VIRTUAL = $FE000000;'
      '{$ELSEIF SizeOf(Pointer) = 8}'
      '  PROPSLOT_MASK    = $FF00000000000000;'
      '  PROPSLOT_FIELD   = $FF00000000000000;'
      '  PROPSLOT_VIRTUAL = $FE00000000000000;'
      '{$ELSE}'
      '  {$MESSAGE Fatal '#39'Unknown pointer size'#39'}'
      '{$ENDIF}'
      '{$IFDEF PUREPASCAL}'
      'type'
      '{$IF defined(MSWINDOWS) or defined(OSX32)}'
      
        '  TGetProc = procedure (const Self: TObject; var Result: IInterf' +
        'ace);'
      '{$ELSE}'
      '  TGetProc = function (const Self: TObject): IInterface;'
      '{$ENDIF}'
      'var'
      '  GetProc: TGetProc;'
      'begin'
      '  if (ImplGetter and PROPSLOT_MASK) = PROPSLOT_FIELD then'
      
        '    Result := IInterface(PPointer(PByte(Self) + (ImplGetter and ' +
        'not PROPSLOT_MASK))^)'
      '  else'
      '  begin'
      '    if (ImplGetter and PROPSLOT_MASK) = PROPSLOT_VIRTUAL then'
      
        '      GetProc := PPointer(PNativeInt(Self)^ + SmallInt(ImplGette' +
        'r))^'
      '    else'
      '      GetProc := Pointer(ImplGetter);'
      '{$IF defined(MSWINDOWS) or defined(OSX32)}'
      '    GetProc(Self, Result);'
      '{$ELSE}'
      '    Result := GetProc(Self);'
      '{$ENDIF}'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        XCHG    EDX,ECX'
      '        CMP     ECX,PROPSLOT_FIELD'
      '        JAE     @@isField'
      '        CMP     ECX,PROPSLOT_VIRTUAL'
      '        JB      @@isStaticMethod'
      ''
      '        {       the GetProc is a virtual method }'
      
        '        MOVSX   ECX,CX                  { sign extend slot offs ' +
        '}'
      
        '        ADD     ECX,[EAX]               { vmt   + slotoffs      ' +
        '}'
      
        '        JMP     dword ptr [ECX]         { call vmt[slot]        ' +
        '}'
      ''
      '@@isStaticMethod:'
      '        JMP     ECX'
      ''
      '@@isField:'
      '        AND     ECX,not PROPSLOT_MASK'
      '        ADD     ECX,EAX'
      '        MOV     EAX,EDX'
      '        MOV     EDX,[ECX]'
      '        JMP     _IntfCopy'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function TObject.GetDisposed: Boolean;'
      'begin'
      '{$IFDEF AUTOREFCOUNT}'
      '  Result := FRefCount and objDisposedFlag <> 0;'
      '{$ELSE}'
      '  Result := False;'
      '{$ENDIF}'
      'end;'
      ''
      'procedure TObject.CheckDisposed;'
      'begin'
      '{$IFDEF AUTOREFCOUNT}'
      '  if Disposed then'
      '    ErrorAt(Byte(reObjectDisposed), ReturnAddress);'
      '{$ENDIF AUTOREFCOUNT}'
      'end;'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      'class procedure TObject.__MarkDestroying(const Obj);'
      'var'
      '  LRef: Integer;'
      'begin'
      '  repeat'
      '    LRef := TObject(Obj).FRefCount;'
      
        '  until AtomicCmpExchange(TObject(Obj).FRefCount, LRef or objDes' +
        'troyingFlag, LRef) = LRef;'
      'end;'
      ''
      'class function TObject.__SetDisposed(const Obj): Boolean;'
      'var'
      '  LRef: Integer;'
      'begin'
      '  repeat'
      '    LRef := TObject(Obj).FRefCount;'
      
        '  until AtomicCmpExchange(TObject(Obj).FRefCount, LRef or objDis' +
        'posedFlag, LRef) = LRef;'
      '  Result := LRef and objDisposedFlag = 0;'
      'end;'
      ''
      'function TObject.__ObjAddRef: Integer;'
      'begin'
      '  Result := AtomicIncrement(FRefCount);'
      'end;'
      ''
      'function TObject.__ObjRelease: Integer;'
      'begin'
      '  Result := AtomicDecrement(FRefCount) and not objDisposedFlag;'
      '  if Result = 0 then'
      '  begin'
      '    __MarkDestroying(Self);'
      '    if __SetDisposed(Self) then'
      '      Destroy'
      '    else'
      '      FreeInstance;'
      '  end;'
      'end;'
      '{$ENDIF AUTOREFCOUNT}'
      ''
      'function TObject.Equals(Obj: TObject): Boolean;'
      'begin'
      '  Result := Obj = Self;'
      'end;'
      ''
      'function TObject.GetHashCode: Integer;'
      'begin'
      '{$IFDEF CPU64BITS}'
      
        '  Result := Integer(IntPtr(Self)) xor Integer(IntPtr(Self) shr 3' +
        '2);'
      '{$ELSE !CPU64BITS}'
      '  Result := Integer(IntPtr(Self));'
      '{$ENDIF !CPU64BITS}'
      'end;'
      ''
      
        'function TObject.GetInterface(const IID: TGUID; out Obj): Boolea' +
        'n;'
      'var'
      '  InterfaceEntry: PInterfaceEntry;'
      'begin'
      '  Pointer(Obj) := nil;'
      '  InterfaceEntry := GetInterfaceEntry(IID);'
      '  if InterfaceEntry <> nil then'
      '    if InterfaceEntry^.IOffset <> 0 then'
      '    begin'
      
        '      Pointer(Obj) := Pointer(PByte(Self) + InterfaceEntry^.IOff' +
        'set);'
      '      if Pointer(Obj) <> nil then IInterface(Obj)._AddRef;'
      '    end'
      '    else'
      
        '      InvokeImplGetter(Self, InterfaceEntry^.ImplGetter, IInterf' +
        'ace(Obj))'
      '  else if ObjCastGUID = IID then'
      '    Pointer(Obj) := Pointer(Self);'
      '  Result := Pointer(Obj) <> nil;'
      'end;'
      ''
      
        'class function TObject.GetInterfaceEntry(const IID: TGUID): PInt' +
        'erfaceEntry;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  ClassPtr: TClass;'
      '  IntfTable: PInterfaceTable;'
      '  I: Integer;'
      'begin'
      '  ClassPtr := Self;'
      '  repeat'
      '    IntfTable := ClassPtr.GetInterfaceTable;'
      '    if IntfTable <> nil then'
      '    begin'
      '      Result := @IntfTable.Entries[0];'
      '      for I := 0 to IntfTable.EntryCount-1 do'
      '      begin'
      '        if Result^.IID = IID then Exit;'
      '        Inc(Result);'
      '      end;'
      '    end;'
      '    ClassPtr := ClassPtr.ClassParent;'
      '  until ClassPtr = nil;'
      '  Result := nil;'
      'end;'
      '{$ELSE}'
      'asm'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        MOV     EBX,EAX'
      '@@1:    MOV     EAX,[EBX].vmtIntfTable'
      '        TEST    EAX,EAX'
      '        JE      @@4'
      '        MOV     ECX,[EAX].TInterfaceTable.EntryCount'
      '        ADD     EAX,4'
      '@@2:    MOV     ESI,[EDX].Integer[0]'
      '        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[0]'
      '        JNE     @@3'
      '        MOV     ESI,[EDX].Integer[4]'
      '        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[4]'
      '        JNE     @@3'
      '        MOV     ESI,[EDX].Integer[8]'
      '        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[8]'
      '        JNE     @@3'
      '        MOV     ESI,[EDX].Integer[12]'
      '        CMP     ESI,[EAX].TInterfaceEntry.IID.Integer[12]'
      '        JE      @@5'
      '@@3:    ADD     EAX,type TInterfaceEntry'
      '        DEC     ECX'
      '        JNE     @@2'
      '@@4:    MOV     EBX,[EBX].vmtParent'
      '        TEST    EBX,EBX'
      '        JE      @@4a'
      '        MOV     EBX,[EBX]'
      '        JMP     @@1'
      '@@4a:   XOR     EAX,EAX'
      '@@5:    POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF}'
      ''
      'type'
      '  PClassData = ^TClassData;'
      '  TClassData = record'
      '    ClassType: TClass;'
      '    ParentInfo: Pointer;'
      '    PropCount: SmallInt;'
      '    UnitName: _ShortStr;'
      '  end;'
      ''
      'class function TObject.UnitName: string;'
      'var'
      '  LClassInfo: Pointer;'
      '  S: _PShortStr;'
      'begin'
      '  LClassInfo := ClassInfo;'
      '  if LClassInfo <> nil then'
      '  begin'
      
        '    S := @PClassData(PByte(LClassInfo) + 2 + PByte(PByte(LClassI' +
        'nfo) + 1)^).UnitName;'
      '    Result := UTF8IdentToString(S);'
      '    if S^[1] = '#39'@'#39' then'
      '      Delete(Result, 1, Pos('#39':'#39', Result))'
      '  end else'
      '    Result := '#39#39';'
      'end;'
      ''
      'class function TObject.UnitScope: string;'
      'var'
      '  LClassInfo: Pointer;'
      '  S: _PShortStr;'
      'begin'
      '  LClassInfo := ClassInfo;'
      '  if LClassInfo <> nil then'
      '  begin'
      
        '    S := @PClassData(PByte(LClassInfo) + 2 + PByte(PByte(LClassI' +
        'nfo) + 1)^).UnitName;'
      '    Result := UTF8IdentToString(S);'
      '    if S^[1] = '#39'@'#39' then'
      '      Result := Copy(Result, 2, Pos('#39':'#39', Result) - 2);'
      '  end else'
      '    Result := '#39#39';'
      'end;'
      ''
      
        'function _IsClass(const Child: TObject; Parent: TClass): Boolean' +
        ';'
      'begin'
      '  Result := (Child <> nil) and Child.InheritsFrom(Parent);'
      'end;'
      ''
      
        'function _AsClass(const Child: TObject; Parent: TClass): TObject' +
        ';'
      'begin'
      '  Result := Child;'
      '  if (Child <> nil) and not (Child is Parent) then'
      '    ErrorAt(Byte(reInvalidCast), ReturnAddress);'
      'end;'
      ''
      '                                                        '
      
        'function _IntfAsClass(const Intf: IInterface; Parent: TClass): T' +
        'Object;'
      '{$IF DEFINED(PUREPASCAL) or DEFINED(PIC)}'
      'var'
      '  Temp: Pointer;'
      'begin'
      '  Temp := nil;'
      '  _IntfCast(IInterface(Temp), Intf, ObjCastGUID);'
      '  Result := _AsClass(TObject(Temp), Parent);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX'
      '        PUSH    0'
      '        MOV     EDX, EAX'
      '        LEA     ECX, ObjCastGUID'
      '        MOV     EAX, ESP'
      '        CALL    _IntfCast'
      '        POP     EAX'
      '        POP     EDX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        JMP    _AsClass'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL or !PIC}'
      ''
      
        'function _SafeIntfAsClass(const Intf: IInterface; Parent: TClass' +
        '): TObject;'
      'begin'
      
        '  if (Intf <> nil) and (Intf.QueryInterface(ObjCastGUID, Pointer' +
        '(Result)) = S_OK) and (Result is Parent) then'
      '    Exit;'
      '  Result := nil;'
      'end;'
      ''
      
        'function _IntfIsClass(const Intf: IInterface; Parent: TClass): B' +
        'oolean;'
      'begin'
      '  Result := _SafeIntfAsClass(Intf, Parent) <> nil;'
      'end;'
      ''
      
        'function _GetHelperDelegate(const Instance: TObject; HelperClass' +
        ': TClass): TObject;'
      'begin'
      
        '  Result := TClassHelperBaseClass(HelperClass)._Create(Instance)' +
        ';'
      'end;'
      ''
      
        'function _GetHelperIntf(const Instance: TObject; HelperClass: TC' +
        'lass): IInterface;'
      'var'
      '  IntfTable: PInterfaceTable;'
      '  P: PInterfaceEntry;'
      'begin'
      '  IntfTable := HelperClass.GetInterfaceTable;'
      '  if IntfTable <> nil then'
      '  begin'
      '    if IntfTable.EntryCount > 0 then'
      '    begin'
      '      P := @IntfTable.Entries[0];'
      '      if Instance.GetInterfaceEntry(P.IID) <> nil then'
      '      begin'
      '        Result := TClassHelperBase(Instance);'
      '        Exit;'
      '      end;'
      '    end;'
      '  end;'
      
        '  Result := TClassHelperBase(_GetHelperDelegate(Instance, Helper' +
        'Class));'
      'end;'
      ''
      
        'function GetDynaMethod(vmt: TClass; selector: SmallInt): Pointer' +
        ';'
      '{$IFDEF PUREPASCAL}'
      'type'
      '  TDynaMethodTable = record'
      '    Count: Word;'
      '    Selectors: array[0..9999999] of SmallInt;'
      '    {Addrs: array[0..0] of Pointer;}'
      '  end;'
      '  PDynaMethodTable = ^TDynaMethodTable;'
      'var'
      '  dynaTab: PDynaMethodTable;'
      '  Parent: Pointer;'
      '  Addrs: PPointer;'
      '  I: Cardinal;'
      'begin'
      '  while True do'
      '  begin'
      '    dynaTab := PPointer(@PByte(vmt)[vmtDynamicTable])^;'
      '    if dynaTab <> nil then'
      '    begin'
      '      for I := 0 to dynaTab.Count - 1 do'
      '        if dynaTab.Selectors[I] = selector then'
      '        begin'
      
        '          Addrs := PPointer(PByte(@dynaTab.Selectors) + dynaTab.' +
        'Count * SizeOf(dynaTab.Selectors[0]));'
      
        '          Result := PPointer(PByte(Addrs) + I * SizeOf(Pointer))' +
        '^;'
      '          Exit;'
      '        end;'
      '    end;'
      '    Parent := PPointer(@PByte(vmt)[vmtParent])^;'
      '    if Parent = nil then Break;'
      '    vmt := PPointer(Parent)^;'
      '  end;'
      '  Result := nil;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      
        '{       function        GetDynaMethod(vmt: TClass; selector: Sma' +
        'llint) : Pointer;       }'
      '        { ->    EAX     vmt of class            }'
      '        {       EDX     dynamic method index    }'
      '        { <-    EAX     pointer to routine      }'
      '        {       trashes ECX, EDX                }'
      '        PUSH    EDI'
      ''
      '        XCHG    EAX, EDX'
      '        JMP     @@haveVMT'
      '@@outerLoop:'
      '        MOV     EDX,[EDX]'
      '@@haveVMT:'
      '        MOV     EDI,[EDX].vmtDynamicTable'
      '        TEST    EDI,EDI'
      '        JE      @@parent'
      '        MOVZX   ECX,word ptr [EDI]'
      '        PUSH    ECX'
      '        ADD     EDI,2'
      '        REPNE   SCASW'
      '        JE      @@found'
      '        POP     ECX'
      '@@parent:'
      '        MOV     EDX,[EDX].vmtParent'
      '        TEST    EDX,EDX'
      '        JNE     @@outerLoop'
      '        XOR     EAX, EAX'
      '        JMP     @@exit'
      ''
      '@@found:'
      '        POP     EAX'
      '        ADD     EAX,EAX'
      '        SUB     EAX,ECX'
      '        MOV     EAX,[EDI+EAX*2-4]'
      ''
      '@@exit:'
      '        POP     EDI'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IF defined(X86ASMRTL)}'
      'procedure _CallDynaInst;'
      'asm'
      '        { ->    EAX     vmt of class                 }'
      '        {       ESI     dynamic method index         }'
      '        {       trashes: ESI but compiler knows that }'
      ''
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        XCHG    ESI, EDX'
      '        MOV     EAX,[EAX]'
      '        CALL    GetDynaMethod { Safe to call unaligned }'
      '        MOV     EDX, EAX'
      '        XCHG    ESI, EDX'
      '        POP     ECX'
      '        POP     EAX'
      '        TEST    ESI, ESI'
      '        JE      @@Abstract'
      '        JMP     ESI'
      ''
      '@@Abstract:'
      '{$IFNDEF ALIGN_STACK}'
      '        POP     ECX'
      '{$ENDIF}'
      '        JMP     _AbstractError'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF defined(X86ASMRTL)}'
      'procedure _CallDynaClass;'
      'asm'
      '        { ->    EAX     vmt of class                 }'
      '        {       ESI     dynamic method index         }'
      '        {       trashes: ESI but compiler knows that }'
      ''
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        XCHG    ESI, EDX'
      '        CALL    GetDynaMethod { Safe to call unaligned }'
      '        MOV     EDX, EAX'
      '        XCHG    ESI, EDX'
      '        POP     ECX'
      '        POP     EAX'
      '        TEST    ESI, ESI'
      '        JE      @@Abstract'
      '        JMP     ESI'
      ''
      '@@Abstract:'
      '{$IFNDEF ALIGN_STACK}'
      '        POP     ECX'
      '{$ENDIF}'
      '        JMP     _AbstractError'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      
        'function _FindDynaInst(const Self: TObject; Selector: SmallInt):' +
        ' Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := GetDynaMethod(PPointer(Self)^, Selector);'
      '  if Result = nil then'
      '    _AbstractError;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     vmt of class                 }'
      '        {       EDX     dynamic method index         }'
      '        { <-    EAX     pointer to method            }'
      ''
      '        MOV     EAX,[EAX]'
      '        CALL    GetDynaMethod { Safe to call unaligned }'
      '        TEST    EAX, EAX'
      '        JNE     @@exit'
      '{$IFNDEF ALIGN_STACK}'
      '        POP     ECX'
      '{$ENDIF}'
      '        JMP     _AbstractError'
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'function _FindDynaClass(Vmt: TClass; Selector: SmallInt): Pointe' +
        'r;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := GetDynaMethod(Pointer(Vmt), Selector);'
      '  if Result = nil then'
      '    _AbstractError;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     vmt of class                 }'
      '        {       EDX     dynamic method index         }'
      '        { <-    EAX     pointer to method            }'
      ''
      '        CALL    GetDynaMethod { Safe to call unaligned }'
      '        TEST    EAX, EAX'
      '        JNE     @@exit'
      '{$IFNDEF ALIGN_STACK}'
      '        POP     ECX'
      '{$ENDIF}'
      '        JMP     _AbstractError'
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'class function TObject.InheritsFrom(AClass: TClass): Boolean;'
      'var'
      '  P: Pointer;'
      'begin'
      '  P := Pointer(Self);'
      '  while True do'
      '  begin'
      '    if P = Pointer(AClass) then'
      '      Break;'
      '    P := PPointer(@PByte(P)[vmtParent])^;'
      '    if P = nil then'
      '      Exit(Boolean(P));'
      '    P := PPointer(P)^;'
      '  end;'
      '  Result := True;'
      'end;'
      ''
      'function TObject.SafeCallException(ExceptObject: TObject;'
      '  ExceptAddr: Pointer): HResult;'
      'begin'
      '  Result := E_UNEXPECTED;'
      'end;'
      ''
      'function TObject.ToString: string;'
      'begin'
      '  Result := ClassName;'
      'end;'
      ''
      'procedure TObject.DefaultHandler(var Message);'
      'begin'
      'end;'
      ''
      'procedure TObject.AfterConstruction;'
      'begin'
      'end;'
      ''
      'procedure TObject.BeforeDestruction;'
      'begin'
      '{$IFDEF AUTOREFCOUNT}'
      
        '  if ((RefCount and objDestroyingFlag) = 0) and (RefCount = 0) t' +
        'hen'
      '    Error(reInvalidPtr);'
      '{$ENDIF}'
      'end;'
      ''
      'procedure TObject.Dispatch(var Message);'
      '{$IFDEF PUREPASCAL}'
      'type'
      
        '  //THandlerProc = procedure(Self: Pointer; var Message) { of ob' +
        'ject };'
      '  THandlerProc = procedure(var Message) of object;'
      'var'
      '  MsgID: Word;'
      '  Addr: Pointer;'
      '  M: THandlerProc;'
      'begin'
      '  MsgID := TDispatchMessage(Message).MsgID;'
      '  if (MsgID <> 0) and (MsgID < $C000) then'
      '  begin'
      '    Addr := GetDynaMethod(PPointer(Self)^, MsgID);'
      '    if Addr <> nil then'
      '    begin'
      '      //THandlerProc(Addr)(Self, Message)'
      '      TMethod(M).Data := Self;'
      '      TMethod(M).Code := Addr;'
      '      M(Message);'
      '    end'
      '    else'
      '      Self.DefaultHandler(Message);'
      '  end'
      '  else'
      '    Self.DefaultHandler(Message);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        PUSH    EDX'
      '        MOV     DX,[EDX]'
      '        OR      DX,DX'
      '        JE      @@default'
      '        CMP     DX,0C000H'
      '        JAE     @@default'
      '        PUSH    EAX'
      '{$IFDEF ALIGN_STACK}'
      '        PUSH    EAX'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EAX,[EAX]'
      '        CALL    GetDynaMethod'
      '        MOV     ECX, EAX'
      '{$IFDEF ALIGN_STACK}'
      '        POP     EAX'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EAX'
      '        TEST    ECX, ECX'
      '        JE      @@default'
      '        POP     EDX'
      '        JMP     ECX'
      ''
      '@@default:'
      '        POP     EDX'
      '        MOV     ECX,[EAX]'
      
        '        JMP     DWORD PTR [ECX] + VMTOFFSET TObject.DefaultHandl' +
        'er'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'class function TObject.MethodAddress(const Name: _ShortStr): Poi' +
        'nter;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  LMethTablePtr: Pointer;'
      '  LMethCount: Word;'
      '  LMethEntry: PMethRec;'
      '  LSelf: TClass;'
      'begin'
      '  Result := nil;'
      ''
      '  LSelf := Pointer(Self);'
      '  repeat'
      '    { Obtain the method table and count }'
      '    LMethTablePtr := PPointer(@PByte(LSelf)[vmtMethodTable])^;'
      '    if LMethTablePtr <> nil then'
      '    begin'
      '      LMethCount := PWord(LMethTablePtr)^;'
      '      Inc(PWord(LMethTablePtr), 1);'
      '    end else'
      '      LMethCount := 0;'
      ''
      
        '    { Search for the method if we have more than one. Also teste' +
        'd for a correct table ptr }'
      '    if LMethCount > 0 then'
      '    begin'
      '      LMethEntry := LMethTablePtr;'
      ''
      '      while LMethCount > 0 do'
      '      begin'
      '        if (LMethEntry^.nameLen = Byte(Name[0])) and'
      
        '           (UTF8IdentIdentCompare(_PShortStr(@LMethEntry^.nameLe' +
        'n), @Name)) then'
      '        begin'
      '          Result := LMethEntry.methAddr;'
      '          Exit;'
      '        end else'
      '        begin'
      '          Dec(LMethCount);'
      
        '          LMethEntry := Pointer(PByte(LMethEntry) + LMethEntry.r' +
        'ecSize);'
      '        end;'
      '      end;'
      '    end;'
      ''
      '    { Go to the parent class }'
      '    LSelf := LSelf.ClassParent;'
      '  until LSelf = nil;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '        { ->    EAX     Pointer to class        }'
      '        {       EDX     Pointer to name         }'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        { STACK ALIGN = 16 }'
      '        XOR     ECX,ECX'
      '        XOR     EDI,EDI'
      '        MOV     BL,[EDX]'
      '        JMP     @@haveVMT'
      
        '@@outer:                                { upper 16 bits of ECX a' +
        're 0 !  }'
      '        MOV     EAX,[EAX]'
      '@@haveVMT:'
      '        MOV     ESI,[EAX].vmtMethodTable'
      '        TEST    ESI,ESI'
      '        JE      @@parent'
      
        '        MOV     DI,[ESI]                { EDI := method count   ' +
        '        }'
      '        TEST    EDI,EDI'
      '        JZ      @@parent'
      '        ADD     ESI,2'
      
        '@@inner:                                { upper 16 bits of ECX a' +
        're 0 !  }'
      
        '        MOV     CL,[ESI+6]              { compare length of stri' +
        'ngs     }'
      '        CMP     CL,BL'
      '        JE      @@cmpChar'
      
        '@@cont:                                 { upper 16 bits of ECX a' +
        're 0 !  }'
      
        '        MOV     CX,[ESI]                { fetch length of method' +
        ' desc   }'
      
        '        ADD     ESI,ECX                 { point ESI to next meth' +
        'od      }'
      '        DEC     EDI'
      '        JNZ     @@inner'
      '@@parent:'
      
        '        MOV     EAX,[EAX].vmtParent     { fetch parent vmt      ' +
        '        }'
      '        TEST    EAX,EAX'
      '        JNE     @@outer'
      
        '        JMP     @@exit                  { return NIL            ' +
        '        }'
      ''
      '@@notEqual:'
      
        '        MOV     BL,[EDX]                { restore BL to length o' +
        'f name  }'
      '        JMP     @@cont'
      ''
      '@@utf8Cmp:'
      '        { STACK ALIGN = 16 }'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF}'
      '        LEA     EAX,[ESI+6]'
      '        CALL    InternalUTF8ShortShortCompare'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF}'
      '        XOR     ECX,ECX'
      '        TEST    AL,AL'
      '        POP     EDX'
      '        POP     EAX'
      '        JZ      @@notEqual'
      '        JMP     @@foundIt'
      ''
      
        '@@cmpChar:                              { upper 16 bits of ECX a' +
        're 0 !  }'
      
        '        MOV     CH,0                    { upper 24 bits of ECX a' +
        're 0 !  }'
      '@@cmpCharLoop:'
      
        '        MOV     BL,[ESI+ECX+6]          { case insensitive strin' +
        'g cmp   }'
      '        TEST    BL,$80'
      '        JNZ     @@utf8Cmp'
      
        '        XOR     BL,[EDX+ECX+0]          { last char is compared ' +
        'first   }'
      '        TEST    BL,$80'
      '        JNZ     @@utf8Cmp'
      '        AND     BL,$DF'
      '        JNE     @@notEqual'
      
        '        DEC     ECX                     { ECX serves as counter ' +
        '        }'
      '        JNZ     @@cmpCharLoop'
      ''
      '@@foundIt:'
      '        { found it }'
      '        MOV     EAX,[ESI+2]'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'class function TObject.MethodAddress(const Name: string): Pointe' +
        'r;'
      'begin'
      '  Result := MethodAddress(UTF8EncodeToShortString(Name));'
      'end;'
      ''
      'class function TObject.MethodName(Address: Pointer): string;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  LMethTablePtr: Pointer;'
      '  LMethCount: Word;'
      '  LMethEntry: PMethRec;'
      '  LSelf: TClass;'
      'begin'
      '  Result := '#39#39';'
      ''
      '  LSelf := Pointer(Self);'
      '  repeat'
      '    { Obtain the method table and count }'
      '    LMethTablePtr := PPointer(@PByte(LSelf)[vmtMethodTable])^;'
      '    if LMethTablePtr <> nil then'
      '    begin'
      '      LMethCount := PWord(LMethTablePtr)^;'
      '      Inc(PWord(LMethTablePtr), 1);'
      '    end else'
      '      LMethCount := 0;'
      ''
      
        '    { Search for the method if we have more than one. Also teste' +
        'd for a correct table ptr }'
      '    if LMethCount > 0 then'
      '    begin'
      '      LMethEntry := LMethTablePtr;'
      ''
      '      while LMethCount > 0 do'
      '      begin'
      '        if LMethEntry^.methAddr = Address then'
      '        begin'
      
        '          Result := UTF8IdentToString(_PShortStr(@LMethEntry.nam' +
        'eLen));'
      '          Exit;'
      '        end else'
      '        begin'
      '          Dec(LMethCount);'
      
        '          LMethEntry := Pointer(PByte(LMethEntry) + LMethEntry.r' +
        'ecSize);'
      '        end;'
      '      end;'
      '    end;'
      ''
      '    { Go to the parent class }'
      '    LSelf := LSelf.ClassParent;'
      '  until LSelf = nil;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm     //StackAlignSafe'
      '        { ->    EAX     Pointer to class        }'
      '        {       EDX     Address                 }'
      '        {       ECX     Pointer to result       }'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBX'
      '        MOV     EDI,ECX'
      '        XOR     EBX,EBX'
      '        XOR     ECX,ECX'
      '        JMP     @@haveVMT'
      '@@outer:'
      '        MOV     EAX,[EAX]'
      '@@haveVMT:'
      
        '        MOV     ESI,[EAX].vmtMethodTable { fetch pointer to meth' +
        'od table }'
      '        TEST    ESI,ESI'
      '        JE      @@parent'
      '        MOV     CX,[ESI]'
      '        TEST    ECX,ECX'
      '        JZ      @@parent'
      '        ADD     ESI,2'
      '@@inner:'
      '        CMP     EDX,[ESI+2]'
      '        JE      @@found'
      '        MOV     BX,[ESI]'
      '        ADD     ESI,EBX'
      '        DEC     ECX'
      '        JNZ     @@inner'
      '@@parent:'
      '        MOV     EAX,[EAX].vmtParent'
      '        TEST    EAX,EAX'
      '        JNE     @@outer'
      '        LEA     ESI,@@emptyStr'
      '{$IFDEF PIC}'
      '        CALL    GetGOT'
      '        ADD     ESI, EAX'
      '{$ENDIF PIC}'
      '        JMP     @@exit'
      ''
      '@@emptyStr:'
      '        DB      0'
      ''
      '@@found:'
      '        ADD     ESI,6'
      '@@exit:'
      '        MOV     EAX,ESI'
      '        MOV     EDX,EDI'
      '        POP     EBX'
      '        POP     EDI'
      '        POP     ESI'
      '        JMP     UTF8IdentToString'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function TObject.FieldAddress(const Name: _ShortStr): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  LFieldTablePtr: Pointer;'
      '  LFldCount: Word;'
      '  LName: _PShortStr;'
      '  LClass: TClass;'
      'begin'
      '  Result := nil;'
      ''
      '  LClass := PPointer(Self)^;'
      '  repeat'
      '    { Obtain the field table and count }'
      '    LFieldTablePtr := PPointer(@PByte(LClass)[vmtFieldTable])^;'
      '    if LFieldTablePtr <> nil then'
      '    begin'
      '      LFldCount := PWord(LFieldTablePtr)^;'
      '      Inc(PWord(LFieldTablePtr), 1);  { Count: Word }'
      '      Inc(PPointer(LFieldTablePtr), 1); { ClassTab: Pointer }'
      '    end else'
      '      LFldCount := 0;'
      ''
      
        '    { Search for the field if we have more than one. Also tested' +
        ' for a correct table ptr }'
      '    if LFldCount > 0 then'
      '    begin'
      '      while LFldCount > 0 do'
      '      begin'
      
        '        LName := _PShortStr(PByte(LFieldTablePtr) + SizeOf(Word)' +
        ' + SizeOf(UInt32));'
      ''
      '        if (LName^[0] = Name[0]) and'
      '           (UTF8IdentIdentCompare(LName, @Name)) then'
      '        begin'
      
        '          Result := Pointer(PByte(Self) + PUInt32(LFieldTablePtr' +
        ')^);'
      '          Exit;'
      '        end else'
      '        begin'
      '          Dec(LFldCount);'
      
        '          { Skip 1 word, 1 Pointer, the length of the name (1 By' +
        'te) and the characters of the name }'
      
        '          Inc(PByte(LFieldTablePtr), SizeOf(Word) + SizeOf(UInt3' +
        '2) + Byte(LName^[0]) + 1);'
      '        end;'
      '      end;'
      '    end;'
      ''
      '    { Go to the parent class }'
      '    LClass := LClass.ClassParent;'
      '  until LClass = nil;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to instance     }'
      '        {       EDX     Pointer to name         }'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        XOR     ECX,ECX'
      '        XOR     EDI,EDI'
      '        MOV     BL,[EDX]'
      
        '        PUSH    EAX                     { save instance pointer ' +
        '        }'
      ''
      '@@outer:'
      
        '        MOV     EAX,[EAX]               { fetch class pointer   ' +
        '        }'
      '        MOV     ESI,[EAX].vmtFieldTable'
      '        TEST    ESI,ESI'
      '        JE      @@parent'
      
        '        MOV     DI,[ESI]                { fetch count of fields ' +
        '        }'
      '        TEST    EDI,EDI'
      
        '        JZ      @@parent                { fieldExTab ref only   ' +
        '        }'
      
        '        ADD     ESI,6                   { count:U2 + classTab:P ' +
        '        }'
      '@@inner:'
      
        '        MOV     CL,[ESI+6]              { compare string lengths' +
        '        }'
      '        CMP     CL,BL'
      '        JE      @@cmpChar'
      '@@cont:'
      
        '        LEA     ESI,[ESI+ECX+7]         { point ESI to next fiel' +
        'd       }'
      '        DEC     EDI'
      '        JNZ     @@inner'
      '@@parent:'
      
        '        MOV     EAX,[EAX].vmtParent     { fetch parent VMT      ' +
        '        }'
      '        TEST    EAX,EAX'
      '        JNE     @@outer'
      
        '        POP     EDX                     { forget instance, retur' +
        'n Nil   }'
      '        JMP     @@exit'
      ''
      '@@notEqual:'
      
        '        MOV     BL,[EDX]                { restore BL to length o' +
        'f name  }'
      
        '        MOV     CL,[ESI+6]              { ECX := length of field' +
        ' name   }'
      '        JMP     @@cont'
      ''
      '@@utf8Cmp:'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        LEA     EAX,[ESI+6]'
      '        CALL    InternalUTF8ShortShortCompare'
      '        XOR     ECX,ECX'
      '        TEST    AL,AL'
      '        POP     EDX'
      '        POP     EAX'
      '        JZ      @@notEqual'
      '        JMP     @@foundIt'
      ''
      '@@cmpChar:'
      
        '        MOV     BL,[ESI+ECX+6]         { case insensitive string' +
        ' cmp    }'
      '        TEST    BL,$80'
      '        JNZ     @@utf8Cmp'
      
        '        XOR     BL,[EDX+ECX+0]         { starting with last char' +
        '        }'
      '        TEST    BL,$80'
      '        JNZ     @@utf8Cmp'
      '        AND     BL,$DF'
      '        JNE     @@notEqual'
      
        '        DEC     ECX                     { ECX serves as counter ' +
        '        }'
      '        JNZ     @@cmpChar'
      ''
      '@@foundIt:'
      '        { found it }'
      
        '        MOV     EAX,[ESI]               { result is field offset' +
        ' plus ...   }'
      '        POP     EDX'
      
        '        ADD     EAX,EDX                 { instance pointer      ' +
        '        }'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      ''
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function TObject.FieldAddress(const Name: string): Pointer;'
      'begin'
      '  Result := FieldAddress(UTF8EncodeToShortString(Name));'
      'end;'
      ''
      
        'function _ClassCreate(InstanceOrVMT: Pointer; Alloc: ShortInt): ' +
        'Pointer;'
      '{$IF defined(PUREPASCAL)}'
      'begin'
      '  if Alloc >= 0 then'
      '    InstanceOrVMT := Pointer(TClass(InstanceOrVMT).NewInstance);'
      '  Result := TObject(InstanceOrVMT);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX = pointer to VMT      }'
      '        { <-    EAX = pointer to instance }'
      '        PUSH    EDX'
      '        PUSH    ECX'
      '        PUSH    EBX'
      '        TEST    DL,DL'
      '        JL      @@noAlloc'
      '        CALL    DWORD PTR [EAX] + VMTOFFSET TObject.NewInstance'
      '@@noAlloc:'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      '        XOR     EDX,EDX'
      '        LEA     ECX,[ESP+16]'
      '        MOV     EBX,FS:[EDX]'
      '        MOV     [ECX].TExcFrame.next,EBX'
      '        MOV     [ECX].TExcFrame.hEBP,EBP'
      '        MOV     [ECX].TExcFrame.desc,offset @desc'
      
        '        MOV     [ECX].TexcFrame.ConstructedObject,EAX   { trick:' +
        ' remember copy to instance }'
      '        MOV     FS:[EDX],ECX'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '        POP     EBX'
      '        POP     ECX'
      '        POP     EDX'
      '        RET'
      ''
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      '@desc:'
      '        JMP     _HandleAnyException'
      ''
      
        '  {       destroy the object                                    ' +
        '                  }'
      ''
      '        MOV     EAX,[ESP+8+9*4]'
      '        MOV     EAX,[EAX].TExcFrame.ConstructedObject'
      '        TEST    EAX,EAX'
      '        JE      @@skip'
      '        MOV     ECX,[EAX]'
      '        MOV     DL,$81'
      '        PUSH    EAX'
      '        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.Destroy'
      '        POP     EAX'
      '        CALL    _ClassDestroy'
      '@@skip:'
      '  {       reraise the exception   }'
      '        CALL    _RaiseAgain'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _ClassDestroy(const Instance: TObject);'
      'begin'
      '  Instance.FreeInstance;'
      'end;'
      ''
      'function _AfterConstruction(const Instance: TObject): TObject;'
      'begin'
      '  try'
      '    Instance.AfterConstruction;'
      '    Result := Instance;'
      '{$IFDEF AUTOREFCOUNT}'
      '    AtomicDecrement(Instance.FRefCount);'
      '{$ENDIF}'
      '  except'
      '    _BeforeDestruction(Instance, 1);'
      '    raise;'
      '  end;'
      'end;'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _BeforeDestruction(const Instance: TObject; OuterMost:' +
        ' ShortInt);'
      'begin'
      '  if OuterMost > 0 then'
      '    Instance.BeforeDestruction;'
      'end;'
      '{$ELSE !X86ASMRTL}'
      
        'function _BeforeDestruction(const Instance: TObject; OuterMost: ' +
        'ShortInt): TObject;'
      '// Must preserve DL on return!'
      'asm //StackAlignSafe'
      '       { ->  EAX  = pointer to instance }'
      '       {      DL  = dealloc flag        }'
      
        '       { <-  EAX  = pointer to instance }  //  Result := Instanc' +
        'e;'
      '        TEST    DL,DL'
      
        '        JG      @@outerMost                //  if OuterMost > 0 ' +
        'then Exit;'
      '        RET'
      '@@outerMost:'
      '{$IFDEF ALIGN_STACK}'
      
        '        PUSH    ECX     // 4 byte adjustment, and ECX is conveni' +
        'ent'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      
        '        MOV     EDX,[EAX]                  //  Instance.BeforeDe' +
        'struction;'
      
        '        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.BeforeDestru' +
        'ction'
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      
        '        POP     ECX     // 4 byte adjustment, and ECX is conveni' +
        'ent'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{ TMonitor }'
      ''
      'const'
      
        '  monFlagsMask          = NativeInt($01); // 1bits for special f' +
        'lags.'
      '  monMonitorMask        = not monFlagsMask;'
      '{$IFDEF WEAKREF}'
      '  monWeakReferencedFlag = NativeInt($01);'
      '{$ENDIF WEAKREF}'
      ''
      
        'function ExtractMonitorFromRawValue(const RawMonitorValue: PMoni' +
        'tor): PMonitor; inline;'
      'begin'
      
        '  Result := PMonitor(NativeInt(RawMonitorValue) and monMonitorMa' +
        'sk);'
      'end;'
      ''
      
        'function ExtractFlagsFromRawValue(const RawMonitorValue: PMonito' +
        'r): NativeInt; inline;'
      'begin'
      '  Result := NativeInt(RawMonitorValue) and monFlagsMask;'
      'end;'
      ''
      
        'function RawMonitorValue(const Monitor: PMonitor; const Flags: N' +
        'ativeInt): PMonitor; inline;'
      'begin'
      '  Result := PMonitor(NativeInt(Monitor) or Flags);'
      'end;'
      ''
      '{ TMonitor.TSpinWait }'
      ''
      'procedure TMonitor.TSpinWait.Reset;'
      'begin'
      '  FCount := 0;'
      'end;'
      ''
      'procedure TMonitor.TSpinWait.SpinCycle;'
      'var'
      '  SpinCount: Integer;'
      'begin'
      '  if (FCount > YieldThreshold) or (CPUCount <= 1) then'
      '  begin'
      '    if FCount >= YieldThreshold then'
      '      SpinCount := FCount - 10'
      '    else'
      '      SpinCount := FCount;'
      '    if SpinCount mod Sleep1Threshold = Sleep1Threshold - 1 then'
      '      Sleep(1)'
      
        '    else if SpinCount mod Sleep0Threshold = Sleep0Threshold - 1 ' +
        'then'
      '      Sleep(0)'
      '    else'
      '      Yield;'
      '  end else'
      '    Spin(4 shl FCount);'
      '  Inc(FCount);'
      '  if FCount < 0 then'
      '    FCount := 10;'
      'end;'
      ''
      '{ TMonitor.TSpinLock }'
      ''
      'procedure TMonitor.TSpinLock.Enter;'
      'var'
      '  LLock: Integer;'
      '  Wait: TSpinWait;'
      'begin'
      '  Wait.Reset;'
      '  while True do'
      '  begin'
      '    LLock := FLock;'
      '    if LLock = 0 then'
      '    begin'
      '      if AtomicCmpExchange(FLock, 1, LLock) = LLock then'
      '        System.Exit;'
      '    end;'
      '    Wait.SpinCycle;'
      '  end;'
      'end;'
      ''
      'procedure TMonitor.TSpinLock.Exit;'
      'begin'
      '  AtomicExchange(FLock, 0);'
      'end;'
      ''
      'class procedure TMonitor.Spin(Iterations: Integer);'
      
        '{$IF (defined(CPUX86) or defined(CPUX64)) and defined(ASSEMBLER)' +
        '}'
      'asm'
      '    TEST Iterations, Iterations'
      '    JLE  @Done'
      '@Loop:'
      '    PAUSE'
      '    DEC  Iterations'
      '    JNZ  @Loop'
      '@Done:'
      'end;'
      '{$ELSE}'
      'begin'
      '  while Iterations > 0 do'
      '  begin'
      '    YieldProcessor;'
      '    Dec(Iterations);'
      '  end;'
      'end;'
      '{$ENDIF}'
      ''
      'class function TMonitor.GetCacheLineSize: Integer;'
      '{$IFDEF MSWINDOWS}'
      '{$POINTERMATH ON}'
      'var'
      '  ProcInfo, CurInfo: PSystemLogicalProcessorInformation;'
      '  Len: DWORD;'
      'begin'
      '  Len := 0;'
      
        '  if (GetProcAddress(GetModuleHandle(kernel), '#39'GetLogicalProcess' +
        'orInformation'#39') <> nil) and'
      
        '    not GetLogicalProcessorInformation(nil, Len) and (GetLastErr' +
        'or = ERROR_INSUFFICIENT_BUFFER) then'
      '  begin'
      '    GetMem(ProcInfo, Len);'
      '    try'
      '      GetLogicalProcessorInformation(ProcInfo, Len);'
      '      CurInfo := ProcInfo;'
      '      while Len > 0 do'
      '      begin'
      
        '        if (CurInfo.Relationship = RelationCache) and (CurInfo.C' +
        'ache.Level = 1) then'
      '          System.Exit(CurInfo.Cache.LineSize);'
      '        Inc(CurInfo);'
      '        Dec(Len, SizeOf(CurInfo^));'
      '      end;'
      '    finally'
      '      FreeMem(ProcInfo);'
      '    end;'
      '  end;'
      '  Result := 64; // Use a reasonable default cache line size.'
      'end;'
      '{$POINTERMATH OFF}'
      '{$ELSEIF defined(ANDROID)}'
      'begin'
      '  Result := 64;'
      'end;'
      '{$ELSEIF defined(MACOS)}'
      'var'
      '  LineSize: UInt64;'
      '  Size: Integer;'
      'begin'
      '  Size := SizeOf(LineSize);'
      
        '  if sysctlbyname('#39'hw.cachelinesize'#39', @LineSize, @Size, nil, 0) ' +
        '= 0 then'
      '    Result := LineSize'
      '  else'
      '    Result := 64;'
      'end;'
      '{$ELSEIF defined(POSIX)}'
      '                                                       '
      'begin'
      '  Result := 64;'
      'end;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown Platform'#39'}'
      '{$ENDIF}'
      ''
      'class procedure TMonitor.CheckMonitorSupport;'
      'begin'
      '  if MonitorSupport = nil then'
      '    Error(reNoMonitorSupport);'
      'end;'
      ''
      'function TMonitor.CheckOwningThread: TThreadID;'
      'begin'
      '  Result := FOwningThread;'
      '  if Result <> GetCurrentThreadId then'
      '    Error(reMonitorNotLocked)'
      'end;'
      ''
      'class function TMonitor.Create: PMonitor;'
      'begin'
      '  if CacheLineSize = 0 then'
      '    AtomicExchange(CacheLineSize, GetCacheLineSize);'
      '  if (CPUCount > 1) and (FDefaultSpinCount = 0) then'
      '    AtomicExchange(FDefaultSpinCount, 1000);'
      '  if CacheLineSize > SizeOf(Result^) then'
      '    Result := SysAllocMem(CacheLineSize)'
      '  else'
      '    Result := SysAllocMem(SizeOf(Result^));'
      '  Result.FSpinCount := FDefaultSpinCount;'
      'end;'
      ''
      'class procedure TMonitor.Destroy(const AObject: TObject);'
      'var'
      '  MonitorFld: PPMonitor;'
      '  Monitor: PMonitor;'
      'begin'
      '  MonitorFld := GetFieldAddress(AObject);'
      '{$IFDEF WEAKREF}'
      
        '  Monitor := PMonitor(NativeInt(MonitorFld^) and monMonitorMask)' +
        ';'
      '{$ELSE  WEAKREF}'
      '  Monitor := MonitorFld^;'
      '{$ENDIF WEAKREF}'
      '  if Monitor <> nil then'
      '  begin'
      '    MonitorFld^ := nil;'
      '    Monitor.Destroy;'
      '  end;'
      'end;'
      ''
      'procedure TMonitor.Destroy;'
      'begin'
      '  if (MonitorSupport <> nil) and (FLockEvent <> nil) then'
      '    MonitorSupport.FreeSyncObject(FLockEvent);'
      '  SysFreeMem(@Self);'
      'end;'
      ''
      'class procedure TMonitor.Enter(const AObject: TObject);'
      'begin'
      '  CheckMonitorSupport;'
      '  GetMonitor(AObject).Enter(INFINITE);'
      'end;'
      ''
      
        'class function TMonitor.Enter(const AObject: TObject; Timeout: C' +
        'ardinal): Boolean;'
      'begin'
      '  CheckMonitorSupport;'
      '  Result := GetMonitor(AObject).Enter(Timeout);'
      'end;'
      ''
      'function TMonitor.DequeueWaiter: PWaitingThread;'
      'begin'
      '  FQueueLock.Enter;'
      '  try'
      '    Result := FWaitQueue;'
      '    if (Result = nil) or (Result.Next = Result) then'
      '    begin'
      '      FWaitQueue := nil;'
      '      System.Exit;'
      '    end else'
      '    begin'
      '      Result := FWaitQueue.Next;'
      '      FWaitQueue.Next := FWaitQueue.Next.Next;'
      '    end;'
      '  finally'
      '    FQueueLock.Exit;'
      '  end;'
      'end;'
      ''
      'function TMonitor.Enter(Timeout: Cardinal): Boolean;'
      'label'
      '  TryAgain;'
      'var'
      '  Done: Boolean;'
      '  LockCount: Integer;'
      '  StartCount, EndCount: Cardinal;'
      '  SpinCount: Integer;'
      '  SpinWait: TSpinWait;'
      'begin'
      '  SpinCount := FSpinCount;'
      '// Return here if signaled and lock wasn'#39't acquired'
      'TryAgain:'
      '  Result := TryEnter;'
      '  if not Result and (Timeout <> 0) then'
      '  begin'
      '    Done := False;'
      '    // Get the spin count'
      '    if SpinCount > 0 then'
      '    begin'
      '      StartCount := GetTickCount;'
      '      SpinWait.Reset;'
      '      while SpinCount > 0 do'
      '      begin'
      
        '        if (Timeout <> INFINITE) and ((GetTickCount - StartCount' +
        ') >= Timeout) then'
      '        begin'
      '          Result := False;'
      '          System.Exit;'
      '        end;'
      '        // if there are already waiters, don'#39't bother spinning'
      '        if FLockCount > 1 then'
      '          Break;'
      '        // Try to get the lock'
      '        if FLockCount = 0 then'
      '          if AtomicCmpExchange(FLockCount, 1, 0) = 0 then'
      '          begin'
      '            FOwningThread := GetCurrentThreadId;'
      '            FRecursionCount := 1;'
      '            Result := True;'
      '            System.Exit;'
      '          end;'
      '        SpinWait.SpinCycle;'
      '        Dec(SpinCount);'
      '        // Keep trying until the spin count expires'
      '      end;'
      '      // Adjust the timeout in case the spin-lock expired above.'
      '      if Timeout <> INFINITE then'
      '      begin'
      '        EndCount := GetTickCount;'
      '        if EndCount - StartCount >= Timeout then'
      '        begin'
      '          Result := False;'
      '          System.Exit;'
      '        end;'
      '        Dec(Timeout, EndCount - StartCount);'
      '      end;'
      '    end;'
      '    // Before we can block, we add our count to the lock'
      '    while True do'
      '    begin'
      '      LockCount := FLockCount;'
      '      if LockCount = 0 then'
      '        goto TryAgain;'
      
        '      if AtomicCmpExchange(FLockCount, LockCount + 2, LockCount)' +
        ' = LockCount then'
      '        Break;'
      '    end;'
      '    while True do'
      '    begin'
      '      StartCount := GetTickCount;'
      '      // We'#39're not the owner, so blocking is needed'
      '      // GetEvent does a "safe" allocation of the Event'
      
        '      Result := MonitorSupport.WaitOrSignalObject(nil, GetEvent,' +
        ' Timeout) = WAIT_OBJECT_0;'
      '      if Timeout <> INFINITE then'
      '      begin'
      '        EndCount := GetTickCount;'
      '        if EndCount - StartCount < Timeout then'
      '          Dec(Timeout, EndCount - StartCount)'
      '        else'
      '          Timeout := 0;'
      '      end;'
      '      if Result then'
      '      begin'
      
        '        // Event was signaled, so try to acquire the lock since ' +
        'this could be a spurious condition'
      '        while True do'
      '        begin'
      '          LockCount := FLockCount;'
      '          if LockCount and 1 <> 0 then'
      '            Break;'
      
        '          if AtomicCmpExchange(FLockCount, (LockCount - 2) or 1,' +
        ' LockCount) = LockCount then'
      '          begin'
      '            Done := True;'
      '            Break;'
      '          end;'
      '        end;'
      '      end else'
      '      begin'
      '        // We timed out, remove our presence from the lock count'
      '        repeat'
      '          LockCount := FLockCount;'
      
        '        until AtomicCmpExchange(FLockCount, LockCount - 2, LockC' +
        'ount) = LockCount;'
      '        Done := True;'
      '      end;'
      '      if Done then'
      '        Break;'
      '    end;'
      '    if Result then'
      '    begin'
      '      FOwningThread := GetCurrentThreadId;'
      '      FRecursionCount := 1;'
      '    end;'
      '  end;'
      'end;'
      ''
      'procedure TMonitor.Exit;'
      'var'
      '  LockCount: Integer;'
      'begin'
      '  CheckOwningThread;'
      '  Dec(FRecursionCount);'
      '  if FRecursionCount = 0 then'
      '  begin'
      '    FOwningThread := 0;'
      '    while True do'
      '    begin'
      '      LockCount := FLockCount;'
      
        '      if AtomicCmpExchange(FLockCount, LockCount - 1, LockCount)' +
        ' = LockCount then'
      '      begin'
      
        '        // if LockCount is <> 0 after we dropped our lock, there' +
        ' were waiters, so signal them'
      '        if LockCount and not 1 <> 0 then'
      '          MonitorSupport.WaitOrSignalObject(GetEvent, nil, 0);'
      '        Break;'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      'class procedure TMonitor.Exit(const AObject: TObject);'
      'begin'
      '  CheckMonitorSupport;'
      '  GetMonitor(AObject).Exit;'
      'end;'
      ''
      'function TMonitor.GetEvent: Pointer;'
      'var'
      '  SleepTime: Integer;'
      '  Event: Pointer;'
      'begin'
      '  SleepTime := 1;'
      '  Result := FLockEvent;'
      '  if Result = nil then'
      '    while True do'
      '    begin'
      '      Event := MonitorSupport.NewSyncObject;'
      '      Result := AtomicCmpExchange(FLockEvent, Event, nil);'
      '      if Result = nil then'
      
        '        // We won!  Nobody else was trying to allocate the Event' +
        '.'
      '        Result := Event'
      '      else if Event <> nil then'
      
        '        // Oh Well. We tried. Close the handle if someone got to' +
        ' it first.'
      '        MonitorSupport.FreeSyncObject(Event);'
      
        '      // Check if we actually were able to allocate the event wi' +
        'thout fail'
      '      if Result <> nil then'
      '        System.Exit;'
      
        '      // We failed to allocate the event, so wait a bit to see i' +
        'f one becomes available'
      '      Sleep(SleepTime);'
      
        '      // Don'#39't let it run-away, so return to a reasonable value ' +
        'and keep trying'
      '      if SleepTime > 512 then'
      '        SleepTime := 1'
      '      else'
      '        // Next time wait a little longer'
      '        SleepTime := SleepTime shl 1;'
      '    end;'
      'end;'
      ''
      '{$IFOPT O-}{$O+}{$DEFINE OPTIMIZATIONOFF}{$ENDIF}'
      
        'function GetMonitorFieldAddress(const AObject: TObject): PPMonit' +
        'or; inline;'
      'begin'
      
        '  Result := PPMonitor(PByte(AObject) + AObject.InstanceSize - hf' +
        'FieldSize + hfMonitorOffset);'
      'end;'
      '{$IFDEF OPTIMIZATIONOFF}{$O-}{$UNDEF OPTIMIZATIONOFF}{$ENDIF}'
      ''
      
        'class function TMonitor.GetFieldAddress(const AObject: TObject):' +
        ' PPMonitor;'
      'begin'
      '  Result := GetMonitorFieldAddress(AObject);'
      'end;'
      ''
      
        'class function TMonitor.GetMonitor(const AObject: TObject): PMon' +
        'itor;'
      '{$IFDEF WEAKREF}'
      'var'
      '  MonitorFld: PPMonitor;'
      '  Monitor: PMonitor;'
      '  [Volatile] RawValue: PMonitor;'
      'begin'
      '  MonitorFld := GetFieldAddress(AObject);'
      '  RawValue := MonitorFld^;'
      '  Result := ExtractMonitorFromRawValue(RawValue);'
      '  if Result = nil then'
      '  begin'
      '    Monitor := TMonitor.Create;'
      '    repeat'
      '      AtomicCmpExchange(MonitorFld^,'
      
        '                        RawMonitorValue(Monitor, ExtractFlagsFro' +
        'mRawValue(RawValue)),'
      '                        RawValue);'
      '      RawValue := MonitorFld^;'
      '      Result := ExtractMonitorFromRawValue(RawValue);'
      '    until (Result <> nil);'
      '    if Result <> Monitor then'
      '      SysFreeMem(Monitor);'
      '  end;'
      'end;'
      '{$ELSE  WEAKREF}'
      'var'
      '  MonitorFld: PPMonitor;'
      '  Monitor: PMonitor;'
      'begin'
      '  MonitorFld := GetFieldAddress(AObject);'
      '  Result := MonitorFld^;'
      '  if Result = nil then'
      '  begin'
      '    Monitor := TMonitor.Create;'
      
        '    Result := AtomicCmpExchange(Pointer(MonitorFld^), Monitor, n' +
        'il);'
      '    if Result = nil then'
      '      Result := Monitor'
      '    else'
      '      SysFreeMem(Monitor);'
      '  end;'
      'end;'
      '{$ENDIF WEAKREF}'
      ''
      'procedure TMonitor.Pulse;'
      'var'
      '  WaitingThread: PWaitingThread;'
      'begin'
      '  WaitingThread := DequeueWaiter;'
      '  if WaitingThread <> nil then'
      
        '    MonitorSupport.WaitOrSignalObject(WaitingThread.WaitEvent, n' +
        'il, 0);'
      'end;'
      ''
      'class procedure TMonitor.Pulse(const AObject: TObject);'
      'begin'
      '  CheckMonitorSupport;'
      '  GetMonitor(AObject).Pulse;'
      'end;'
      ''
      'procedure TMonitor.PulseAll;'
      'var'
      '  WaitingThread: PWaitingThread;'
      'begin'
      '  WaitingThread := DequeueWaiter;'
      '  while WaitingThread <> nil do'
      '  begin'
      
        '    MonitorSupport.WaitOrSignalObject(WaitingThread.WaitEvent, n' +
        'il, 0);'
      '    WaitingThread := DequeueWaiter;'
      '  end;'
      'end;'
      ''
      'class procedure TMonitor.PulseAll(const AObject: TObject);'
      'begin'
      '  CheckMonitorSupport;'
      '  GetMonitor(AObject).PulseAll;'
      'end;'
      ''
      
        'procedure TMonitor.QueueWaiter(var WaitingThread: TWaitingThread' +
        ');'
      'begin'
      '  FQueueLock.Enter;'
      '  try'
      '    if FWaitQueue = nil then'
      '    begin'
      '      FWaitQueue := @WaitingThread;'
      '      WaitingThread.Next := @WaitingThread;'
      '    end else'
      '    begin'
      '      WaitingThread.Next := FWaitQueue.Next;'
      '      FWaitQueue.Next := @WaitingThread;'
      '      FWaitQueue := @WaitingThread;'
      '    end;'
      '  finally'
      '    FQueueLock.Exit;'
      '  end;'
      'end;'
      ''
      
        'procedure TMonitor.RemoveWaiter(var WaitingThread: TWaitingThrea' +
        'd);'
      'var'
      '  Last, Walker: PWaitingThread;'
      'begin'
      '  // Perform a check, lock, check'
      '  if FWaitQueue <> nil then'
      '  begin'
      '    FQueueLock.Enter;'
      '    try'
      '      if FWaitQueue <> nil then'
      '      begin'
      '        Last := FWaitQueue;'
      '        Walker := Last.Next;'
      '        while Walker <> FWaitQueue do'
      '        begin'
      '          if Walker = @WaitingThread then'
      '          begin'
      '            Last.Next := Walker.Next;'
      '            Break;'
      '          end;'
      '          Last := Walker;'
      '          Walker := Walker.Next;'
      '        end;'
      
        '        if (Walker = FWaitQueue) and (Walker = @WaitingThread) t' +
        'hen'
      '          if Walker.Next = Walker then'
      '            FWaitQueue := nil'
      '          else'
      '          begin'
      '            FWaitQueue := Walker.Next;'
      '            Last.Next := FWaitQueue;'
      '          end;'
      '      end;'
      '    finally'
      '      FQueueLock.Exit;'
      '    end;'
      '  end;'
      'end;'
      ''
      'class procedure TMonitor.SetDefaultSpinCount(AValue: Integer);'
      'begin'
      '  AtomicExchange(FDefaultSpinCount, AValue);'
      'end;'
      ''
      
        'class procedure TMonitor.SetSpinCount(const AObject: TObject; AS' +
        'pinCount: Integer);'
      'var'
      '  Monitor: PMonitor;'
      'begin'
      '  if CPUCount > 1 then'
      '  begin'
      '    Monitor := GetMonitor(AObject);'
      '    AtomicExchange(Monitor.FSpinCount, ASpinCount);'
      '  end;'
      'end;'
      ''
      
        'class function TMonitor.TryEnter(const AObject: TObject): Boolea' +
        'n;'
      'begin'
      '  CheckMonitorSupport;'
      '  Result := GetMonitor(AObject).TryEnter;'
      'end;'
      ''
      'function TMonitor.TryEnter: Boolean;'
      'begin'
      
        '  if FOwningThread = GetCurrentThreadId then  // check for recur' +
        'sion'
      '  begin'
      
        '    // Only the owning thread can increment this value so no nee' +
        'd to guard it'
      '    Inc(FRecursionCount);'
      '    Result := True;'
      '  // check to see if we can gain ownership'
      
        '  end else if (FLockCount = 0) and (AtomicCmpExchange(FLockCount' +
        ', 1, 0) = 0) then'
      '  begin'
      '    //  Yep, got it.  Now claim ownership'
      '    FOwningThread := GetCurrentThreadId;'
      '    FRecursionCount := 1;'
      '    Result := True;'
      '  end else'
      '    Result := False;'
      'end;'
      ''
      
        'function TMonitor.Wait(ALock: PMonitor; Timeout: Cardinal): Bool' +
        'ean;'
      'var'
      '  RecursionCount: Integer;'
      '  WaitingThread: TWaitingThread;'
      'begin'
      '  WaitingThread.Next := nil;'
      '  WaitingThread.Thread := ALock.CheckOwningThread;'
      '  // This event should probably be cached someplace.'
      
        '  // Probably not on the instance since this is a per-thread-per' +
        '-instance resource'
      '  WaitingThread.WaitEvent := MonitorSupport.NewWaitObject;'
      '  try'
      '    // Save the current recursion count for later'
      '    RecursionCount := ALock.FRecursionCount;'
      '    // Add the current thread to the waiting queue'
      '    QueueWaiter(WaitingThread);'
      
        '    // Set it back to almost released so the next Exit call actu' +
        'ally drops the lock'
      '    ALock.FRecursionCount := 1;'
      '    // Now complete the exit and signal any waiters'
      '    ALock.Exit;'
      '    // Get in line for someone to do a Pulse or PulseAll'
      
        '    Result := MonitorSupport.WaitOrSignalObject(nil, WaitingThre' +
        'ad.WaitEvent, Timeout) = WAIT_OBJECT_0;'
      '    // Got to get the lock back and block waiting for it.'
      '    ALock.Enter(INFINITE);'
      '    // Remove any dangling waiters from the list'
      '    RemoveWaiter(WaitingThread);'
      
        '    // Lets restore the recursion to return to the proper nestin' +
        'g level'
      '    ALock.FRecursionCount := RecursionCount;'
      '  finally'
      '    MonitorSupport.FreeWaitObject(WaitingThread.WaitEvent);'
      '  end;'
      'end;'
      ''
      
        'class function TMonitor.Wait(const AObject: TObject; Timeout: Ca' +
        'rdinal): Boolean;'
      'var'
      '  Monitor: PMonitor;'
      'begin'
      '  CheckMonitorSupport;'
      '  Monitor := GetMonitor(AObject);'
      '  Result := Monitor.Wait(Monitor, Timeout);'
      'end;'
      ''
      
        'class function TMonitor.Wait(const AObject, ALock: TObject; Time' +
        'out: Cardinal): Boolean;'
      'begin'
      '  CheckMonitorSupport;'
      
        '  Result := GetMonitor(AObject).Wait(GetMonitor(ALock), Timeout)' +
        ';'
      'end;'
      ''
      
        'function MonitorEnter(const AObject: TObject; Timeout: Cardinal ' +
        '= INFINITE): Boolean;'
      'begin'
      '  Result := TMonitor.Enter(AObject, Timeout);'
      'end;'
      ''
      'function MonitorTryEnter(const AObject: TObject): Boolean;'
      'begin'
      '  Result := TMonitor.TryEnter(AObject);'
      'end;'
      ''
      'procedure MonitorExit(const AObject: TObject);'
      'begin'
      '  TMonitor.Exit(AObject);'
      'end;'
      ''
      
        'function MonitorWait(const AObject: TObject; Timeout: Cardinal):' +
        ' Boolean;'
      'begin'
      '  Result := TMonitor.Wait(AObject, AObject, Timeout);'
      'end;'
      ''
      
        'function MonitorWait(const AObject: TObject; const ALock: TObjec' +
        't; Timeout: Cardinal): Boolean;'
      'begin'
      '  Result := TMonitor.Wait(AObject, ALock, Timeout);'
      'end;'
      ''
      'procedure MonitorPulse(const AObject: TObject);'
      'begin'
      '  TMonitor.Pulse(AObject);'
      'end;'
      ''
      'procedure MonitorPulseAll(const AObject: TObject);'
      'begin'
      '  TMonitor.PulseAll(AObject);'
      'end;'
      ''
      '// Note: MemoryBarrier is now standard procedure.'
      '                                                             '
      '(*'
      'procedure MemoryBarrier;'
      '{$IF defined(CPUX64)}'
      'asm'
      '      MFENCE'
      'end;'
      '{$ELSEIF defined(CPUX86)}'
      'asm'
      '      PUSH EAX'
      '      XCHG [ESP],EAX'
      '      POP  EAX'
      'end;'
      '{$ELSE}'
      'begin'
      '  Error(rePlatformNotImplemented);'
      'end;'
      '{$ENDIF}'
      '*)'
      ''
      '                                                              '
      'procedure YieldProcessor;'
      
        '{$IF (defined(CPUX86) or defined(CPUX64)) and defined(ASSEMBLER)' +
        '}'
      'asm'
      '  PAUSE'
      'end;'
      '{$ELSE}'
      'begin'
      'end;'
      '{$ENDIF}'
      ''
      '{'
      
        '  The following NotifyXXXX routines are used to "raise" special ' +
        'exceptions'
      
        '  as a signaling mechanism to an interested debugger.  If the de' +
        'bugger sets'
      
        '  the DebugHook flag to 1 or 2, then all exception processing is' +
        ' tracked by'
      
        '  raising these special exceptions.  The debugger *MUST* respond' +
        ' to the'
      
        '  debug event with DBG_CONTINUE so that normal processing will o' +
        'ccur.'
      '}'
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      'const'
      
        '  excRaise      = 0; { an exception is being raised by the user ' +
        '(could be a reraise) }'
      '  excCatch      = 1; { an exception is about to be caught }'
      
        '  excFinally    = 2; { a finally block is about to be executed b' +
        'ecause of an exception }'
      
        '  excUnhandled  = 3; { no user exception handler was found (the ' +
        'app will die) }'
      ''
      'procedure _DbgExcNotify('
      '  NotificationKind: Integer;'
      '  ExceptionObject: Pointer;'
      '  ExceptionName: _PShortStr;'
      '  ExceptionLocation: Pointer;'
      '  HandlerAddr: Pointer); cdecl;'
      'begin'
      '{$IF Defined(DEBUG) and Defined(ASSEMBLER)}'
      '  {'
      
        '    This code is just for debugging the exception handling syste' +
        'm.  The debugger'
      
        '    needs _DbgExcNotify, however to place breakpoints in, so the' +
        ' function itself'
      '    cannot be removed.'
      '  }'
      '  asm'
      '{$IFDEF ALIGN_STACK}'
      '    SUB  ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '    PUSH EAX'
      '    PUSH EDX'
      '  end;'
      '  if Assigned(ExcNotificationProc) then'
      
        '    ExcNotificationProc(NotificationKind, ExceptionObject, Excep' +
        'tionName, ExceptionLocation, HandlerAddr);'
      '  asm'
      '    POP EDX'
      '    POP EAX'
      '{$IFDEF ALIGN_STACK}'
      '    ADD  ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '  end;'
      '{$ENDIF DEBUG}'
      'end;'
      ''
      '{'
      
        '  The following functions are used by the debugger for the evalu' +
        'ator.  If you'
      
        '  change them IN ANY WAY, the debugger will cease to function co' +
        'rrectly.'
      '}'
      'procedure _DbgEvalMarker;'
      'begin'
      'end;'
      ''
      'procedure _DbgEvalExcept(E: TObject);'
      'begin'
      'end;'
      ''
      'procedure _DbgEvalEnd;'
      'begin'
      'end;'
      ''
      '{'
      
        '  This function is used by the debugger to provide a soft landin' +
        'g spot'
      
        '  when evaluating a function call that may raise an unhandled ex' +
        'ception.'
      
        '  The return address of _DbgEvalMarker is pushed onto the stack ' +
        'so that'
      '  the unwinder will transfer control to the except block.'
      '}'
      'procedure _DbgEvalFrame;'
      'begin'
      '  try'
      '    _DbgEvalMarker;'
      '  except on E: TObject do'
      '    _DbgEvalExcept(E);'
      '  end;'
      '  _DbgEvalEnd;'
      'end;'
      ''
      '{'
      
        '  These export names need to match the names that will be genera' +
        'ted into'
      
        '  the .symtab section, so that the debugger can find them if sta' +
        'bs'
      '  debug information is being generated.'
      '}'
      
        '{$IF defined(ANDROID) or defined(LINUX)}    // We can not use ma' +
        'ngles with @ in android'
      'exports'
      '  _DbgExcNotify   name  '#39'_DbgExcNotify'#39';'
      '{$ELSE !(ANDROID or LINUX)}'
      'exports'
      '  _DbgExcNotify   name  '#39'@DbgExcNotify'#39';'
      '{$ENDIF !(ANDROID or LINUX)}'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      ''
      
        '{ tell the debugger that the next raise is a re-raise of the cur' +
        'rent non-Delphi'
      '  exception }'
      
        '                                                                ' +
        ' '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure       NotifyReRaise;'
      'asm'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '{     ->EAX     Pointer to exception object }'
      '{       EDX     location of exception       }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    0                   { handler addr }'
      '        PUSH    EDX                 { location of exception }'
      '        MOV     ECX, [EAX]'
      '        PUSH    [ECX].vmtClassName  { exception name }'
      '        PUSH    EAX                 { exception object }'
      '        PUSH    excRaise            { notification kind }'
      '        CALL    _DbgExcNotify'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 28'
      '{$ELSE !ALIGN_STACK}'
      '        ADD     ESP, 20'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PC_MAPPED_EXCEPTIONS}'
      '        CMP     BYTE PTR DebugHook,1'
      '        JBE     @@1'
      '        PUSH    0'
      '        PUSH    0'
      '        PUSH    cContinuable'
      '        PUSH    cDelphiReRaise'
      '        CALL    RaiseExceptionProc'
      '@@1:'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IF defined(TABLE_BASED_EXCEPTIONS)}'
      'procedure NotifyReRaise(Obj: TObject; Address: Pointer);'
      'begin'
      '{$IFDEF MSWINDOWS}'
      '  if DebugHook > 1 then'
      '    RaiseExceptionProc(cDelphiReRaise, cContinuable, 0, nil);'
      '{$ENDIF MSWINDOWS}'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      
        '{$IF defined(SJLJ_BASED_EXCEPTIONS) or defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      'procedure NotifyReRaise(const Obj: TObject; Address: Pointer);'
      'begin'
      '  _DbgExcNotify(excRaise, Obj,'
      '     _PShortStr(PPointer(PNativeInt(Obj)^ + vmtClassName)^),'
      '     Address, nil);'
      'end;'
      
        '{$ENDIF SJLJ_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS or Defined' +
        '(ZCX_BASED_EXCEPTIONS_MACOS)}'
      ''
      '{ tell the debugger about the raise of a non-Delphi exception }'
      '{$IFDEF MSWINDOWS}'
      
        '                                                                ' +
        '            '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure       NotifyNonDelphiException;'
      'asm'
      '{     ->EAX     Pointer to exception object }'
      '{       EDX     Context record              }'
      '        CMP     BYTE PTR DebugHook,0'
      '        JE      @@1'
      '        PUSH    EAX'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        PUSH    ESP'
      '        PUSH    2'
      '        PUSH    cContinuable'
      '        PUSH    cNonDelphiException'
      '        CALL    RaiseExceptionProc'
      '        ADD     ESP,8'
      '        POP     EAX'
      '@@1:'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      
        'procedure NotifyNonDelphiException(ExceptionObject: Pointer; Con' +
        'textRecord: PContext);'
      'var'
      '  Params: array[0..1] of Pointer;'
      'begin'
      '  if DebugHook <> 0 then'
      '  begin'
      '    Params[0] := ContextRecord;'
      '    Params[1] := ExceptionObject;'
      
        '    RaiseExceptionProc(cNonDelphiException, cContinuable, 2, @Pa' +
        'rams);'
      '  end;'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '{$ENDIF MSWINDOWS}'
      ''
      
        '{ Tell the debugger where the handler for the current exception ' +
        'is located }'
      '                                                                '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure NotifyExcept;'
      'asm'
      '{$IFDEF POSIX}'
      '{     ->EAX     Pointer to exception object }'
      '{       EDX     handler addr                }'
      '        PUSH    EAX'
      '        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX                 { handler addr }'
      '        PUSH    0                   { location of exception }'
      '        MOV     ECX, [EAX]'
      '        PUSH    [ECX].vmtClassName  { exception name }'
      '        PUSH    EAX                 { exception object }'
      '        PUSH    excCatch            { notification kind }'
      '        CALL    _DbgExcNotify'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 24'
      '{$ELSE !ALIGN_STACK}'
      '        ADD     ESP, 20'
      '{$ENDIF ALIGN_STACK}'
      ''
      '        POP     EAX'
      '{$ELSE !POSIX}'
      '        PUSH    ESP'
      '        PUSH    1'
      '        PUSH    cContinuable'
      
        '        PUSH    cDelphiExcept           { our magic exception co' +
        'de }'
      '        CALL    RaiseExceptionProc'
      '        ADD     ESP,4'
      '        POP     EAX'
      '{$ENDIF !POSIX}'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure NotifyExcept(HandlerAddress: NativeUInt);'
      'begin'
      
        '  RaiseExceptionProc(cDelphiExcept, cContinuable, 1, @HandlerAdd' +
        'ress);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '  '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure NotifyOnExcept;'
      'asm'
      '{     ->EAX     Pointer to exception object }'
      '{       EDX     handler addr                }'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX                 { handler addr }'
      '        PUSH    0                   { location of exception }'
      '        MOV     ECX, [EAX]'
      '        PUSH    [ECX].vmtClassName  { exception name }'
      '        PUSH    EAX                 { exception object }'
      '        PUSH    excCatch            { notification kind }'
      '        CALL    _DbgExcNotify'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 28'
      '{$ELSE !ALIGN_STACK}'
      '        ADD     ESP, 20'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PC_MAPPED_EXCEPTIONS}'
      '{     ->EAX     Pointer to exception object             }'
      '{       EBX     exception descriptor table entry        }'
      '{       preserves EAX                                   }'
      '        CMP     BYTE PTR DebugHook,1'
      '        JBE     @@1'
      '        PUSH    EAX'
      '        PUSH    [EBX].TExcDescEntry.handler'
      '        JMP     NotifyExcept'
      '@@1:'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure NotifyOnExcept(HandlerAddress: NativeUInt);'
      'begin'
      '  if DebugHook > 1 then'
      '    NotifyExcept(HandlerAddress);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF MSWINDOWS}'
      
        '                                                                ' +
        '   '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure NotifyAnyExcept;'
      'asm'
      '        CMP     BYTE PTR DebugHook,1'
      '        JBE     @@1'
      '        PUSH    EAX'
      '        PUSH    EBX'
      '        JMP     NotifyExcept'
      '@@1:'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure NotifyAnyExcept(HandlerAddress: NativeUInt);'
      'begin'
      '  if DebugHook > 1 then'
      '    NotifyExcept(HandlerAddress);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '{$ENDIF}'
      ''
      '                                                            '
      '{$IFDEF MSWINDOWS}'
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure       CheckJmp;'
      'asm'
      '        TEST    ECX,ECX'
      '        JE      @@3'
      '        MOV     EAX,[ECX + 1]'
      '        CMP     BYTE PTR [ECX],0E9H { near jmp }'
      '        JE      @@1'
      '        CMP     BYTE PTR [ECX],0EBH { short jmp }'
      '        JNE     @@3'
      '        MOVSX   EAX,AL'
      '        INC     ECX'
      '        INC     ECX'
      '        JMP     @@2'
      '@@1:'
      '        ADD     ECX,5'
      '@@2:'
      '        ADD     ECX,EAX'
      '@@3:'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$ENDIF MSWINDOWS}'
      ''
      '{ Notify debugger of a finally during an exception unwind }'
      
        '                                                                ' +
        '       '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure NotifyExceptFinally;'
      'asm'
      '{     ->EAX     Pointer to exception object }'
      '{       EDX     handler addr                }'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX                 { handler addr }'
      '        PUSH    0                   { location of exception }'
      '        PUSH    0                   { exception name }'
      '        PUSH    0                   { exception object }'
      '        PUSH    excFinally          { notification kind }'
      '        CALL    _DbgExcNotify'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 28'
      '{$ELSE !ALIGN_STACK}'
      '        ADD     ESP, 20'
      '{$ENDIF ALIGN_STACK}'
      '{$ELSE !PC_MAPPED_EXCEPTIONS}'
      '{     ->ECX     Pointer to exception object }'
      '{       preserves: EAX, ECX and EDX.        }'
      '        CMP     BYTE PTR DebugHook,1'
      '        JBE     @@1'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        PUSH    ECX'
      '        CALL    CheckJmp'
      '        PUSH    ECX'
      
        '        PUSH    ESP                     { pass pointer to argume' +
        'nts }'
      '        PUSH    1                       { there is 1 argument }'
      
        '        PUSH    cContinuable            { continuable execution ' +
        '}'
      
        '        PUSH    cDelphiFinally          { our magic exception co' +
        'de }'
      '        CALL    RaiseExceptionProc'
      '        POP     ECX'
      '        POP     ECX'
      '        POP     EDX'
      '        POP     EAX'
      '@@1:'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '                                                       '
      'procedure NotifyExceptFinally(TargetIp: NativeUInt);'
      'begin'
      '  if DebugHook > 1 then'
      
        '    RaiseExceptionProc(cDelphiFinally, cContinuable, 1, @TargetI' +
        'p);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      ''
      
        '{ Tell the debugger that the current exception is handled and cl' +
        'eaned up.'
      '  Also indicate where execution is about to resume. }'
      '{$IFDEF MSWINDOWS}'
      
        '                                                                ' +
        '   '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure       NotifyTerminate;'
      'asm'
      '        CMP     BYTE PTR DebugHook,1'
      '        JBE     @@1'
      '        PUSH    EDX'
      '        PUSH    ESP'
      '        PUSH    1'
      '        PUSH    cContinuable'
      
        '        PUSH    cDelphiTerminate        { our magic exception co' +
        'de }'
      '        CALL    RaiseExceptionProc'
      '        POP     EDX'
      '@@1:'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure NotifyTerminate(TargetIp: NativeUInt);'
      'begin'
      '  if DebugHook > 1 then'
      
        '    RaiseExceptionProc(cDelphiTerminate, cContinuable, 1, @Targe' +
        'tIp);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '{$ENDIF MSWINDOWS}'
      ''
      
        '{ Tell the debugger that there was no handler found for the curr' +
        'ent exception'
      '  and we are about to go to the default handler }'
      
        '                                                                ' +
        '   '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure       NotifyUnhandled;'
      'asm'
      '{     ->EAX     Pointer to exception object }'
      '{       EDX     location of exception       }'
      '{$IFDEF MSWINDOWS}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        CMP     BYTE PTR DebugHook,1'
      '        JBE     @@1'
      '        PUSH    ESP'
      '        PUSH    2'
      '        PUSH    cContinuable'
      '        PUSH    cDelphiUnhandled'
      '        CALL    RaiseExceptionProc'
      '@@1:'
      '        POP     EDX'
      '        POP     EAX'
      '{$ELSE !MSWINDOWS}'
      '        PUSH    EAX'
      '        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    0                   { handler addr }'
      '        PUSH    EDX                 { location of exception }'
      '        MOV     ECX, [EAX]'
      '        PUSH    [ECX].vmtClassName  { exception name }'
      '        PUSH    EAX                 { exception object }'
      '        PUSH    excUnhandled        { notification kind }'
      '        CALL    _DbgExcNotify'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 24'
      '{$ELSE !ALIGN_STACK}'
      '        ADD     ESP, 20'
      '{$ENDIF ALIGN_STACK}'
      ''
      '        POP     EAX'
      '{$ENDIF !MSWINDOWS}'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure NotifyUnhandled(ExceptObject, ExceptAddr: Pointer);'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Params: array[0..1] of Pointer;'
      'begin'
      '  if DebugHook <> 0 then'
      '  begin'
      '    Params[0] := ExceptAddr;'
      '    Params[1] := ExceptObject;'
      
        '    RaiseExceptionProc(cDelphiUnhandled, cContinuable, 2, @Param' +
        's);'
      '  end;'
      'end;'
      '{$ELSE !MSWINDOWS}'
      'var'
      '  Obj: Pointer;'
      'begin'
      '  Obj := Pointer(TRaisedException(ExceptObject).ExceptObject);'
      '  _DbgExcNotify(excUnhandled, Obj,'
      
        '                _PShortStr(PPointer(PNativeInt(Obj)^ + vmtClassN' +
        'ame)^),'
      '                ExceptAddr, nil);'
      'end;'
      '{$ENDIF !MSWINDOWS}'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      'procedure NotifyUnhandled(ExceptObject, ExceptAddr: Pointer);'
      'begin'
      'end;'
      '{$ENDIF}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '//  MaybeCooptException'
      
        '//    If a Delphi exception is thrown from C++, a TRaisedExcepti' +
        'on object'
      
        '//    will not be allocated yet on this side.  We need to keep t' +
        'hings sane,'
      
        '//    so we have to intercept such exceptions from the C++ side,' +
        ' and convert'
      
        '//    them so that they appear to have been thrown from this RTL' +
        '.  If we'
      
        '//    throw a Delphi exception, then we set the private_2 member' +
        ' of'
      
        '//    _Unwind_Exception to 0.  If C++ throws it, it sets it to t' +
        'he address'
      
        '//    of the throw point.  We use this to distinguish the two ca' +
        'ses, and'
      
        '//    adjust data structures as appropriate.  On entry to this f' +
        'unction,'
      
        '//    EDX is the private_2 member, as set from SysRaiseException' +
        ', and'
      '//    EAX is the exception object in question.'
      '//'
      'procedure MaybeCooptException;'
      'asm'
      
        '        // If this exception is from C++, then private_2 will be' +
        ' a'
      
        '        // throw address.  If not, then it will be zero.  privat' +
        'e_1'
      
        '        // will be either the exception object itself, or a TRai' +
        'sedException.'
      '        OR      EDX, EDX            // From C++?'
      '        JZ      @@ExcAllocated'
      ''
      
        '        // We'#39've decided that the exception is from C++, but it ' +
        'is a'
      
        '        // Delphi exception object.  We will coopt the exception' +
        ' now'
      
        '        // by installing a TRaisedException into the unwinder ex' +
        'ception,'
      
        '        // and setting private_2 to 0.  Then the exception will ' +
        'look'
      '        // like it was truly thrown from this RTL.'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    AllocateException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '@@ExcAllocated:'
      'end;'
      ''
      'function LinkException(Exc: PRaisedException): PRaisedException;'
      'asm //StackAlignSafe'
      
        '        PUSH    EDX     // preserve EDX because of HandleOnExcep' +
        'tion'
      '        PUSH    EAX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysInit.@GetTLS'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EDX'
      '        MOV     ECX, [EAX].ExceptionList'
      '        MOV     [EDX].TRaisedException.Prev, ECX'
      '        MOV     [EAX].ExceptionList, EDX'
      '        MOV     EAX, EDX'
      '        POP     EDX'
      'end;'
      ''
      'function UnlinkException: PRaisedException;'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysInit.@GetTLS'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EDX, [EAX].ExceptionList'
      '        MOV     EDX, [EDX].TRaisedException.Prev'
      '        MOV     [EAX].ExceptionList, EDX'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'const // for TExceptionRecord.ExceptionFlags'
      '  EXCEPTION_NONCONTINUABLE  = $0001; // Noncontinuable exception'
      '  EXCEPTION_UNWINDING       = $0002; // Unwind is in progress'
      
        '  EXCEPTION_EXIT_UNWIND     = $0004; // Exit unwind is in progre' +
        'ss'
      
        '  EXCEPTION_STACK_INVALID   = $0008; // Stack out of limits or u' +
        'naligned'
      
        '  EXCEPTION_NESTED_CALL     = $0010; // Nested exception handler' +
        ' call'
      
        '  EXCEPTION_TARGET_UNWIND   = $0020; // Execute termination hand' +
        'ler for it'
      
        '  EXCEPTION_COLLIDED_UNWIND = $0040; // unwind through unwind di' +
        'spatcher'
      '  EXCEPTION_UNWIND          = ( EXCEPTION_UNWINDING or'
      '                                EXCEPTION_EXIT_UNWIND or'
      '                                EXCEPTION_TARGET_UNWIND or'
      '                                EXCEPTION_COLLIDED_UNWIND);'
      ''
      
        'function FindOnExceptionDescEntry(DispatcherContext: PDispatcher' +
        'Context;'
      '  ExceptionClass: Pointer; ExcDesc: PExcDesc): PExcDescEntry;'
      'var'
      '  ExcDescEntry: PExcDescEntry;'
      '  DescIndex: Integer;'
      '  ClassPtr1, TabClassPtr: Pointer;'
      '  Name1, Name2: _PAnsiChr;'
      'begin'
      '  for DescIndex := 0 to ExcDesc^.DescCount - 1 do'
      '  begin'
      '    ExcDescEntry := @ExcDesc.DescTable[DescIndex];'
      '    Result := ExcDescEntry;'
      '    if ExcDescEntry^.VTable = 0 then'
      '      Exit;'
      '    if ExceptionClass <> nil then'
      '    begin'
      '      ClassPtr1 := ExceptionClass;'
      '      while True do'
      '      begin'
      
        '        TabClassPtr := PPointer(DispatcherContext.ImageBase + UI' +
        'ntPtr(ExcDescEntry^.VTable))^;'
      '        if TabClassPtr = ClassPtr1 then'
      '          Exit;'
      '        if PInteger(PByte(TabClassPtr) + vmtInstanceSize)^ ='
      '           PInteger(PByte(ClassPtr1) + vmtInstanceSize)^ then'
      '        begin'
      
        '          Name1 := PPAnsiChar(PByte(TabClassPtr) + vmtClassName)' +
        '^;'
      '          Name2 := PPAnsiChar(PByte(ClassPtr1) + vmtClassName)^;'
      '          if (Name1^ = Name2^) and'
      '             (_AStrCmp(_PAnsiChr(PByte(Name1) + 1),'
      
        '                       _PAnsiChr(PByte(Name2) + 1), PByte(Name1)' +
        '^) = 0) then'
      '            Exit;'
      '        end;'
      '        ClassPtr1 := PPointer(PByte(ClassPtr1) + vmtParent)^;'
      '        if ClassPtr1 = nil then'
      '          Break;'
      '        ClassPtr1 := PPointer(ClassPtr1)^;'
      '      end;'
      '    end;'
      '  end;'
      '  Result := nil;'
      'end;'
      ''
      'function _DelphiExceptionHandler('
      '  ExceptionRecord: PExceptionRecord;'
      '  EstablisherFrame: NativeUInt;'
      '  ContextRecord: _PContext;'
      
        '  DispatcherContext: Pointer{PDispatcherContext}): LongInt{TExce' +
        'ptionDisposition};'
      'var'
      '  ImageBase: NativeUInt;'
      '  ControlPcRVA: NativeUInt;'
      '  ExceptionPointers: TExceptionPointers;'
      '  ScopeIndex: Integer;'
      '  TargetIpRVA: NativeUInt;'
      '  ExceptionObject: Pointer;'
      '  ExceptionClass: Pointer;'
      '  ExceptionAddress: Pointer;'
      '  ExcDescEntry: PExcDescEntry;'
      '  ExcDesc: PExcDesc;'
      '  ExcScope: PExcScope;'
      '  ExcData: PExcData;'
      '  TargetIp: NativeUInt;'
      '  FilterRes: LongWord;'
      '  JITCheckVal: Byte;'
      '  LocalRaiseFrame: TRaiseFrame;'
      '  PrevRaiseFramePtr: PRaiseFrame;'
      '  ThisRaiseFramePtr: PRaiseFrame;'
      '  RaiseFramePtr: PRaiseFrame;'
      'begin'
      '  Result := DISPOSITION_CONTINUE_SEARCH;'
      
        '  ExcData := PExcData(PDispatcherContext(DispatcherContext).Hand' +
        'lerData);'
      '  ImageBase := PDispatcherContext(DispatcherContext).ImageBase;'
      
        '  ControlPcRVA := PDispatcherContext(DispatcherContext).ControlP' +
        'c - ImageBase;'
      
        '  if (ExceptionRecord.ExceptionFlags and EXCEPTION_UNWIND) = 0 t' +
        'hen'
      '  begin'
      '    for ScopeIndex := 0 to ExcData^.ScopeCount - 1 do'
      '    begin'
      '      ExcScope := @ExcData^.ScopeTable[ScopeIndex];'
      '      if (ControlPcRVA >= UIntPtr(ExcScope^.BeginOffset)) and'
      '         (ControlPcRVA < UIntPtr(ExcScope^.EndOffset)) and'
      
        '         (ExcScope^.TableOffset <> 0) then // safecall, catch_an' +
        'y or catch_table'
      '      begin'
      '        _FpuInit;'
      '        if ExcScope^.TableOffset > 2 then'
      '        begin'
      '          // catch_table'
      
        '          if ExceptionRecord.ExceptionCode = cDelphiException th' +
        'en'
      
        '            ExceptionClass := PPointer(ExceptionRecord.ExceptObj' +
        'ect)^'
      '          else'
      '          begin'
      '            if not Assigned(ExceptClsProc) then'
      '              Continue;'
      
        '            ExceptionClass := TExceptClsProc(ExceptClsProc)(Exce' +
        'ptionRecord);'
      '            if ExceptionClass = nil then'
      '              Continue;'
      '          end;'
      
        '          ExcDesc := PExcDesc(ImageBase + UIntPtr(ExcScope^.Tabl' +
        'eOffset));'
      '          ExcDescEntry := FindOnExceptionDescEntry('
      
        '                            PDispatcherContext(DispatcherContext' +
        '),'
      '                            ExceptionClass, ExcDesc);'
      '          if ExcDescEntry = nil then'
      '            Continue;'
      
        '          TargetIp := ImageBase + UIntPtr(ExcDescEntry^.Handler)' +
        ';'
      '        end'
      '        else if ExcScope^.TableOffset = 1 then'
      '          // safecall'
      
        '          TargetIp := ImageBase  + NativeUInt(ExcScope^.EndOffse' +
        't)'
      '        else'
      '          // ExcScope^.TableOffset = 2 // catch_any'
      
        '          TargetIp := ImageBase  + NativeUInt(ExcScope^.TargetOf' +
        'fset);'
      ''
      '        if ExceptionRecord.ExceptionCode = cDelphiException then'
      '        begin'
      '          ExceptionObject := ExceptionRecord.ExceptObject;'
      '          ExceptionAddress := ExceptionRecord.ExceptAddr;'
      '          JITCheckVal := 1;'
      '        end'
      '        else'
      '        begin'
      '          if not Assigned(ExceptObjProc) then'
      '            Continue;'
      
        '          ExceptionObject := TExceptObjProc(ExceptObjProc)(Excep' +
        'tionRecord);'
      '          if ExceptionObject = nil then'
      '            Continue;'
      '          ExceptionAddress := ExceptionRecord.ExceptionAddress;'
      '          JITCheckVal := 1;'
      '{$IFDEF WIN64}'
      
        '          if (ExceptionRecord.ExceptionCode and cCppExceptionMas' +
        'k) = cCppException then'
      '{$ELSE !WIN64}'
      '          if ExceptionRecord.ExceptionCode <> cCppException then'
      '{$ENDIF WIN64}'
      '          begin'
      
        '            NotifyNonDelphiException(ExceptionObject, ContextRec' +
        'ord);'
      '            JITCheckVal := 0;'
      '          end;'
      '        end;'
      '        if (JITEnable > JITCheckVal) and (DebugHook <= 0) then'
      '        begin'
      '          ExceptionPointers.ExceptionRecord := ExceptionRecord;'
      '          ExceptionPointers.ContextRecord := ContextRecord;'
      
        '          FilterRes := UnhandledExceptionFilter(@ExceptionPointe' +
        'rs);'
      '          if FilterRes = EXCEPTION_CONTINUE_SEARCH then'
      '            Continue;'
      '        end;'
      '        ExceptionRecord.ExceptionFlags :='
      '          ExceptionRecord.ExceptionFlags or EXCEPTION_UNWINDING;'
      
        '        if ExcScope^.TableOffset >= 2 then // catch_any or catch' +
        '_table'
      '          RaiseFramePtr := AllocateRaiseFrame'
      '        else'
      '          // Make the RaiseList entry on the stack'
      '          RaiseFramePtr := @LocalRaiseFrame;'
      '        RaiseFramePtr^.ExceptAddr := ExceptionAddress;'
      '        RaiseFramePtr^.ExceptObject := ExceptionObject;'
      '        LinkRaiseFrame(RaiseFramePtr);'
      '        RtlUnwindEx(EstablisherFrame, TargetIp,'
      '                    ExceptionRecord,'
      '                    IntPtr(ExceptionObject),'
      
        '                    PDispatcherContext(DispatcherContext).Contex' +
        'tRecord,'
      
        '                    PDispatcherContext(DispatcherContext).Histor' +
        'yTable);'
      '      end;'
      '    end;'
      '  end'
      '  else'
      '  begin'
      
        '    TargetIpRVA := PDispatcherContext(DispatcherContext).TargetI' +
        'p - ImageBase;'
      '    for ScopeIndex := 0 to ExcData^.ScopeCount - 1 do'
      '    begin'
      '      ExcScope := @ExcData^.ScopeTable[ScopeIndex];'
      '      if (ControlPcRVA >= NativeUInt(ExcScope^.BeginOffset)) and'
      '         (ControlPcRVA < NativeUInt(ExcScope^.EndOffset)) then'
      '      begin'
      
        '        if (TargetIpRVA >= NativeUInt(ExcScope^.BeginOffset)) an' +
        'd'
      '           (TargetIpRVA < NativeUInt(ExcScope^.EndOffset)) and'
      
        '           ((ExceptionRecord.ExceptionFlags and EXCEPTION_TARGET' +
        '_UNWIND) <> 0) then'
      '          Exit;'
      '        if ExcScope^.TableOffset < 2 then'
      '        begin // finally or safecall'
      '          ThisRaiseFramePtr := RaiseListPtr;'
      '          try'
      '            case ExcScope^.TableOffset of'
      '            0: // finally block'
      '              begin'
      
        '                //if TargetIpRVA = NativeUInt(ExcScope^.TargetOf' +
        'fset) then'
      '                //  Exit; // DISPOSITION_CONTINUE_SEARCH'
      
        '                PDispatcherContext(DispatcherContext).ControlPc ' +
        ':= ImageBase + NativeUInt(ExcScope^.EndOffset);'
      
        '                TargetIp := ImageBase + NativeUInt(ExcScope^.Tar' +
        'getOffset);'
      '                NotifyExceptFinally(TargetIp);'
      
        '                ExceptionPointers.ExceptionRecord := ExceptionRe' +
        'cord;'
      
        '                ExceptionPointers.ContextRecord := ContextRecord' +
        ';'
      
        '                _TDelphiFinallyHandlerProc(TargetIp)(@ExceptionP' +
        'ointers, EstablisherFrame);'
      
        '                PDispatcherContext(DispatcherContext).ContextRec' +
        'ord.MxCsr := GetMXCSR;'
      
        '                PDispatcherContext(DispatcherContext).ContextRec' +
        'ord.FltSave.ControlWord := Get8087CW;'
      '              end;'
      '            1: // safecall / handle auto exception'
      '              begin'
      
        '                TargetIp := ImageBase + NativeUInt(ExcScope^.Tar' +
        'getOffset);'
      
        '                PDispatcherContext(DispatcherContext).ControlPc ' +
        ':='
      '                  ImageBase + NativeUInt(ExcScope^.EndOffset);'
      
        '                ExceptionPointers.ExceptionRecord := ExceptionRe' +
        'cord;'
      
        '                ExceptionPointers.ContextRecord := ContextRecord' +
        ';'
      
        '                ExceptionObject := ThisRaiseFramePtr^.ExceptObje' +
        'ct;'
      
        '                ExceptionAddress := ThisRaiseFramePtr^.ExceptAdd' +
        'r;'
      
        '                TargetIp := _TDelphiSafeCallCatchHandlerProc(Tar' +
        'getIp)('
      
        '                              @ExceptionPointers, EstablisherFra' +
        'me,'
      
        '                              ExceptionObject, ExceptionAddress)' +
        ';'
      
        '                PDispatcherContext(DispatcherContext).ControlPc ' +
        ':= TargetIp;'
      
        '                // safecall handler doesn'#39't need to call _DoneEx' +
        'cept.'
      '                if ThisRaiseFramePtr^.ExceptObject <> nil then'
      '                begin'
      '                  ThisRaiseFramePtr^.ExceptObject.Free;'
      '                  ThisRaiseFramePtr^.ExceptObject := nil;'
      '                end;'
      '              end;'
      '            end;'
      '          finally'
      '            PrevRaiseFramePtr := nil;'
      '            RaiseFramePtr := RaiseListPtr;'
      '            while RaiseFramePtr <> nil do'
      '            begin'
      '              if RaiseFramePtr = ThisRaiseFramePtr then'
      '              begin'
      '                if (PrevRaiseFramePtr <> nil) or'
      
        '                   (ExcScope^.TableOffset = 1) then // 1=safecal' +
        'l'
      '                begin'
      
        '                  // We come here if an finalization handler has' +
        ' thrown yet'
      
        '                  // another exception we need to destroy the ex' +
        'ception'
      '                  // object and unlink the raise list.'
      '                  if PrevRaiseFramePtr = nil then'
      '                    RaiseListPtr := nil'
      '                  else'
      
        '                    PrevRaiseFramePtr^.NextRaise := RaiseFramePt' +
        'r^.NextRaise;'
      '                  if RaiseFramePtr^.ExceptObject <> nil then'
      '                  begin'
      '                    RaiseFramePtr^.ExceptObject.Free;'
      '                    RaiseFramePtr^.ExceptObject := nil;'
      '                  end;'
      '                  ReleaseRaiseFrame(RaiseFramePtr);'
      '                end;'
      '                Break;'
      '              end;'
      '              PrevRaiseFramePtr := RaiseFramePtr;'
      '              RaiseFramePtr := RaiseFramePtr^.NextRaise;'
      '            end; // while RaiseFramePtr...'
      '          end; // try-finally...'
      '        end // ExcScope^.TableOffset < 2'
      '        else'
      '        begin // ExcScope^.TableOffset >= 2'
      
        '          // If current handler is target(termination) catch han' +
        'dler,'
      
        '          // Invoke NotifyAnyExcept or NotifyOnExcept, and exit ' +
        'loop.'
      
        '          if ((ExceptionRecord.ExceptionFlags and EXCEPTION_TARG' +
        'ET_UNWIND) <> 0) then'
      '          begin'
      '            TargetIp := 0;'
      '            if ExcScope^.TableOffset = 2 then // catch_any'
      
        '              TargetIp := ImageBase + NativeUInt(ExcScope^.Targe' +
        'tOffset)'
      '            else // catch_table'
      '            begin'
      
        '              if ExceptionRecord.ExceptionCode = cDelphiExceptio' +
        'n then'
      
        '                ExceptionClass := PPointer(ExceptionRecord.Excep' +
        'tObject)^'
      '              else'
      '              begin'
      '                if Assigned(ExceptClsProc) then'
      
        '                  ExceptionClass := TExceptClsProc(ExceptClsProc' +
        ')(ExceptionRecord)'
      '                else'
      '                  ExceptionClass := nil;'
      '              end;'
      '              if ExceptionClass <> nil then'
      '              begin'
      
        '                ExcDesc := PExcDesc(ImageBase + NativeUInt(ExcSc' +
        'ope^.TableOffset));'
      '                ExcDescEntry := FindOnExceptionDescEntry('
      
        '                                  PDispatcherContext(DispatcherC' +
        'ontext),'
      '                                  ExceptionClass, ExcDesc);'
      '                if ExcDescEntry <> nil then'
      
        '                  TargetIp := ImageBase + UIntPtr(ExcDescEntry^.' +
        'Handler);'
      '              end;'
      '            end; // if ExcScope^.TableOffset'
      '            if (TargetIp <> 0) and'
      
        '               (TargetIp = PDispatcherContext(DispatcherContext)' +
        '.TargetIp) then'
      '            begin'
      '              if ExcScope^.TableOffset = 2 then // catch_any'
      '                NotifyAnyExcept(TargetIp)'
      '              else'
      '                NotifyOnExcept(TargetIp);'
      '              Break;'
      '            end;'
      '          end; // if ExceptionRecord.ExceptionFlags'
      '        end; // if ExcScope^.TableOffset'
      '      end; // if ControlPcRVA...'
      '    end; // for ScopeIndex...'
      '  end;'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure _HandleFinallyInternal; forward;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      '{'
      
        ' When an exception is to be handled unconditionally by some bit ' +
        'of user code,'
      
        ' there is still some book-keeping that needs to be done.  There ' +
        'is special'
      
        ' handling that needs to be done if the exception is from C++, ei' +
        'ther a Delphi'
      
        ' exception, or a pure C++ exception.  We have to restore some in' +
        'ternal state'
      
        ' as well, and we have to notify the debugger.  Once we'#39've done t' +
        'hose things,'
      
        ' we return to the exception handling fragment in the user code t' +
        'hat called us.'
      '}'
      
        '                                                                ' +
        '       '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure _HandleAnyException;'
      'asm //StackAlignSafe'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      
        '        CMP     ECX, UW_EXC_CLASS_BORLANDCPP    // C++ exception' +
        '?'
      
        '        JNE     @@handleIt                      // nope, handle ' +
        'it'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        // C++ exceptions aren'#39't wanted here.  Retoss them as is'
      '        // We won'#39't return from this.'
      '        CALL    SysRaiseCPPException'
      ''
      '@@handleIt:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        CALL    UnblockOSExceptions'
      '        POP     EDX'
      '        POP     EAX'
      ''
      '{$IFDEF ALIGN_STACK}'
      
        '        // We'#39'll just increase our alignment adjustment from abo' +
        've'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      
        '        // If the exception is a Delphi exception thrown from C+' +
        '+, coopt it.'
      '        CALL    MaybeCooptException'
      ''
      '        OR      [EAX].TRaisedException.Flags, excIsBeingHandled'
      '        CALL    LinkException'
      '        MOV     ESI, EBX'
      '        MOV     EDX, [ESP] // EDX = return address'
      '        CALL    NotifyExcept'
      '        MOV     EBX, ESI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '        {'
      
        '         When _HandleAnyException was called, the stack was adju' +
        'sted to align'
      
        '         it per the Mach ABI.  The unwinder will have reset the ' +
        'stack pointer'
      
        '         to the prologue result, and the generated code in the c' +
        'aller will'
      
        '         have further adjusted for dynamic arrays.  Thus the ali' +
        'gnment adjustment'
      
        '         made by the compiler will always have been 12 bytes.  T' +
        'he code generator'
      
        '         could dispose of that in the user code, on return, but ' +
        'it saves a little'
      '         space, and it'#39's easy to do from here.'
      '        }'
      '//        RET   12'
      '{$ENDIF ALIGN_STACK}'
      '        // End of routine - we return to user code now.'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFNDEF  PC_MAPPED_EXCEPTIONS}'
      '        { ->    [ESP+ 4] excPtr: PExceptionRecord       }'
      '        {       [ESP+ 8] errPtr: PExcFrame              }'
      '        {       [ESP+12] ctxPtr: Pointer                }'
      '        {       [ESP+16] dspPtr: Pointer                }'
      '        { <-    EAX return value - always one           }'
      ''
      '        MOV     EAX,[ESP+4]'
      
        '        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInP' +
        'rogress'
      '        JNE     @@exit'
      ''
      
        '        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiExce' +
        'ption'
      '        MOV     EDX,[EAX].TExceptionRecord.ExceptObject'
      '        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr'
      '        JE      @@DelphiException'
      '        CLD'
      '        CALL    _FpuInit'
      '        MOV     EDX,ExceptObjProc'
      '        TEST    EDX,EDX'
      '        JE      @@exit'
      '        CALL    EDX'
      '        TEST    EAX,EAX'
      '        JE      @@exit'
      '        MOV     EDX,[ESP+12]'
      '        MOV     ECX,[ESP+4]'
      
        '        CMP     [ECX].TExceptionRecord.ExceptionCode,cCppExcepti' +
        'on'
      '        JE      @@CppException'
      '        CALL    NotifyNonDelphiException'
      '        CMP     BYTE PTR JITEnable,0'
      '        JBE     @@CppException'
      '        CMP     BYTE PTR DebugHook,0'
      
        '        JA      @@CppException                     // Do not JIT' +
        ' if debugging'
      '        LEA     ECX,[ESP+4]'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        CALL    UnhandledExceptionFilter'
      '        CMP     EAX,EXCEPTION_CONTINUE_SEARCH'
      '        POP     EAX'
      '        JE      @@exit'
      '        MOV     EDX,EAX'
      '        MOV     EAX,[ESP+4]'
      '        MOV     ECX,[EAX].TExceptionRecord.ExceptionAddress'
      '        JMP     @@GoUnwind'
      ''
      '@@CppException:'
      '        MOV     EDX,EAX'
      '        MOV     EAX,[ESP+4]'
      '        MOV     ECX,[EAX].TExceptionRecord.ExceptionAddress'
      ''
      '@@DelphiException:'
      '        CMP     BYTE PTR JITEnable,1'
      '        JBE     @@GoUnwind'
      
        '        CMP     BYTE PTR DebugHook,0                { Do not JIT' +
        ' if debugging }'
      '        JA      @@GoUnwind'
      '        PUSH    EAX'
      '        LEA     EAX,[ESP+8]'
      '        PUSH    EDX'
      '        PUSH    ECX'
      '        PUSH    EAX'
      '        CALL    UnhandledExceptionFilter'
      '        CMP     EAX,EXCEPTION_CONTINUE_SEARCH'
      '        POP     ECX'
      '        POP     EDX'
      '        POP     EAX'
      '        JE      @@exit'
      ''
      '@@GoUnwind:'
      '        OR      [EAX].TExceptionRecord.ExceptionFlags,cUnwinding'
      ''
      '        PUSH    EBX'
      '        XOR     EBX,EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        MOV     EBX,FS:[EBX]'
      
        '        PUSH    EBX                     { Save pointer to topmos' +
        't frame }'
      
        '        PUSH    EAX                     { Save OS exception poin' +
        'ter     }'
      
        '        PUSH    EDX                     { Save exception object ' +
        '        }'
      
        '        PUSH    ECX                     { Save exception address' +
        '        }'
      ''
      '        MOV     EDX,[ESP+8+8*4]'
      ''
      '        PUSH    0'
      '        PUSH    EAX'
      '        PUSH    offset @@returnAddress'
      '        PUSH    EDX'
      '        CALL    RtlUnwindProc'
      '@@returnAddress:'
      ''
      '        MOV     EDI,[ESP+8+8*4]'
      ''
      '        {       Make the RaiseList entry on the stack }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        PUSH    [EAX].RaiseListPtr'
      '        MOV     [EAX].RaiseListPtr,ESP'
      ''
      '        MOV     EBP,[EDI].TExcFrame.hEBP'
      '        MOV     EBX,[EDI].TExcFrame.desc'
      '        MOV     [EDI].TExcFrame.desc,offset @@exceptFinally'
      ''
      '        ADD     EBX,TExcDesc.instructions'
      '        CALL    NotifyAnyExcept'
      '        JMP     EBX'
      ''
      '@@exceptFinally:'
      '        JMP     _HandleFinallyInternal'
      ''
      '@@destroyExcept:'
      
        '        {       we come here if an exception handler has thrown ' +
        'yet another exception }'
      
        '        {       we need to destroy the exception object and pop ' +
        'the raise list. }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        MOV     ECX,[EAX].RaiseListPtr'
      '        MOV     EDX,[ECX].TRaiseFrame.NextRaise'
      '        MOV     [EAX].RaiseListPtr,EDX'
      ''
      '        MOV     EAX,[ECX].TRaiseFrame.ExceptObject'
      '        JMP     TObject.Free'
      ''
      '@@exit:'
      '        MOV     EAX,1'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}  { not PC_MAPPED_EXCEPTIONS }'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '{'
      '  Common code between the Win32 and PC mapped exception handling'
      
        '  scheme.  This function takes a pointer to an object, and an ex' +
        'ception'
      
        '  '#39'on'#39' descriptor table and finds the matching handler descripto' +
        'r.'
      ''
      
        '  For support of Linux, we assume that EBX has been loaded with ' +
        'the GOT'
      
        '  that pertains to the code which is handling the exception curr' +
        'ently.'
      
        '  If this function is being called from code which is not PIC, t' +
        'hen'
      '  EBX should be zero on entry.'
      ''
      
        '  N.B. For the Mac, it is critical that this code never calls ou' +
        't of'
      
        '  the System unit, as we do not align the stack around calls to ' +
        'it.'
      '}'
      'procedure FindOnExceptionDescEntry;'
      'asm'
      '{ ->    EAX raised object: Pointer                }'
      '{       EDX descriptor table: ^TExcDesc           }'
      '{       EBX GOT of user code, or 0 if not an SO   }'
      '{ <-    EAX matching descriptor: ^TExcDescEntry   }'
      '        PUSH    EBP'
      '        MOV     EBP, ESP'
      
        '        SUB     ESP, 8                          { Room for vtabl' +
        'e temp, and adjustor }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV [EBP - 8], EBX      { Store the potential GOT }'
      
        '        MOV EAX, [EAX]          { load vtable of exception objec' +
        't }'
      '        MOV     EBX,[EDX].TExcDesc.cnt'
      
        '        LEA     ESI,[EDX].TExcDesc.excTab       { point ECX to e' +
        'xc descriptor table }'
      
        '        MOV     [EBP - 4], EAX                  { temp for vtabl' +
        'e of exception object }'
      ''
      '@@innerLoop:'
      '        MOV     EAX,[ESI].TExcDescEntry.vTable'
      
        '        TEST    EAX,EAX                         { catch all clau' +
        'se?                     }'
      
        '        JE      @@found                         { yes: This is t' +
        'he handler              }'
      
        '        ADD     EAX, [EBP - 8]                  { add in the adj' +
        'ustor (could be 0) }'
      
        '        MOV     EDI,[EBP - 4]                   { load vtable of' +
        ' exception object       }'
      '        JMP     @@haveVMT'
      ''
      '@@vtLoop:'
      '        MOV     EDI,[EDI]'
      '@@haveVMT:'
      '        MOV     EAX,[EAX]'
      '        CMP     EAX,EDI'
      '        JE      @@found'
      ''
      '        MOV     ECX,[EAX].vmtInstanceSize'
      '        CMP     ECX,[EDI].vmtInstanceSize'
      '        JNE     @@parent'
      ''
      '        MOV     EAX,[EAX].vmtClassName'
      '        MOV     EDX,[EDI].vmtClassName'
      ''
      '        XOR     ECX,ECX'
      '        MOV     CL,[EAX]'
      '        CMP     CL,[EDX]'
      '        JNE     @@parent'
      ''
      '        INC     EAX'
      '        INC     EDX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    _AStrCmp'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        JE      @@found'
      ''
      '@@parent:'
      
        '        MOV     EDI,[EDI].vmtParent             { load vtable of' +
        ' parent         }'
      '        MOV     EAX,[ESI].TExcDescEntry.vTable'
      
        '        ADD     EAX, [EBP - 8]                  { add in the adj' +
        'ustor (could be 0) }'
      '        TEST    EDI,EDI'
      '        JNE     @@vtLoop'
      ''
      '        ADD     ESI,8'
      '        DEC     EBX'
      '        JNZ     @@innerLoop'
      ''
      '        { Didn'#39't find a handler. }'
      '        XOR     ESI, ESI'
      ''
      '@@found:'
      '        MOV     EAX, ESI'
      '@@done:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        MOV     ESP, EBP'
      '        POP     EBP'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure       _HandleOnExceptionPIC;'
      'asm'
      '        { ->    EAX obj : Exception object }'
      '        {       [RA]  desc: ^TExcDesc }'
      '        { <-    Doesn'#39't return }'
      ''
      '        // Mark the exception as being handled'
      '        OR      [EAX].TRaisedException.Flags, excIsBeingHandled'
      ''
      '        MOV     ESI, EBX                      // Save the GOT'
      
        '        MOV     EDX, [ESP]                    // Get the addr of' +
        ' the TExcDesc'
      '        PUSH    EAX                           // Save the object'
      '        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      '        CALL    FindOnExceptionDescEntry'
      '        OR      EAX, EAX'
      '        JE      @@NotForMe'
      ''
      
        '        MOV     EBX, ESI                      // Set back to use' +
        'r'#39's GOT'
      '        MOV     EDX, EAX'
      
        '        POP     EAX                           // Get the object ' +
        'back'
      
        '        POP     ECX                           // Ditch the retur' +
        'n addr'
      ''
      '        CALL    LinkException'
      ''
      '        // Get the Pascal object itself.'
      '        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      ''
      '        MOV     EDX, [EDX].TExcDescEntry.handler'
      '        ADD     EDX, EBX                      // adjust for GOT'
      '        CALL    NotifyOnExcept'
      ''
      
        '        MOV     EBX, ESI                      // Make sure of us' +
        'er'#39's GOT'
      '{$IFDEF ALIGN_STACK}'
      '        {'
      
        '         When _HandleOnExceptionPIC was called, the stack was ad' +
        'justed to align'
      
        '         it per the Mach ABI.  The unwinder will have reset the ' +
        'stack pointer'
      
        '         to the prologue result, and the generated code in the c' +
        'aller will'
      
        '         have further adjusted for dynamic arrays.  Thus the ali' +
        'gnment adjustment'
      
        '         made by the compiler will always have been 12 bytes.  W' +
        'e have to'
      '         discard that alignment here.'
      '        }'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      
        '        JMP     EDX                           // Back to the use' +
        'r code'
      '        // never returns'
      '@@NotForMe:'
      
        '        POP     EAX                           // Get the excepti' +
        'on object'
      ''
      '        // Mark that we'#39're reraising this exception, so that the'
      
        '        // compiler generated exception handler for the '#39'except ' +
        'on'#39' clause'
      '        // will not get confused'
      '        OR      [EAX].TRaisedException.Flags, excIsBeingReRaised'
      ''
      
        '        JMP     SysRaiseException             // Should be using' +
        ' resume here'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '{'
      
        ' N.B.  On the Mac, the stack alignment code in _HandleOnExceptio' +
        'n is fine tuned.'
      ' On first read, it may seem incorrect.'
      '}'
      
        '                                                                ' +
        '      '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure       _HandleOnException;'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'asm //StackAlignSafe'
      '        { ->    EAX obj : Exception object }'
      '        {       [RA]  desc: ^TExcDesc }'
      '        { <-    Doesn'#39't return }'
      ''
      
        '        CMP     ECX, UW_EXC_CLASS_BORLANDCPP    // C++ exception' +
        '?'
      
        '        JNE     @@handleIt                      // nope, handle ' +
        'it'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      
        '        // C++ exceptions aren'#39't wanted here.  Retoss them as is' +
        '.'
      '        // We won'#39't return from this.'
      '        CALL    SysRaiseCPPException'
      ''
      '@@handleIt:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      
        '        // If the exception is a Delphi exception thrown from C+' +
        '+, coopt it.'
      '        CALL    MaybeCooptException'
      ''
      '        // Mark the exception as being handled'
      '        OR      [EAX].TRaisedException.Flags, excIsBeingHandled'
      ''
      '{$IFDEF ALIGN_STACK}'
      
        '        MOV     EDX, [ESP + 12]               // Get the addr of' +
        ' the TExcDesc'
      '{$ELSE !ALIGN_STACK}'
      
        '        MOV     EDX, [ESP]                    // Get the addr of' +
        ' the TExcDesc'
      '{$ENDIF !ALIGN_STACK}'
      
        '        // STACK: 16 - no alignment required by FindOnExceptionD' +
        'escEntry'
      
        '        // N.B.  We have to make sure that FindOnExceptionDescEn' +
        'try'
      '        // never calls out of System.pas.'
      '        PUSH    EAX                           // Save the object'
      '        PUSH    EBX                           // Save EBX'
      '        XOR     EBX, EBX                      // No GOT'
      '        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      '        CALL    FindOnExceptionDescEntry'
      '        POP     EBX                           // Restore EBX'
      
        '        OR      EAX, EAX                      // Is the exceptio' +
        'n for me?'
      '        JE      @@NotForMe'
      ''
      '        MOV     EDX, EAX'
      
        '        POP     EAX                           // Get the object ' +
        'back'
      '{$IFDEF ALIGN_STACK}'
      
        '        ADD     ESP, 16                       // Ditch the align' +
        'ment _and_ return addr'
      
        '        // STACK ALIGNMENT: 16, since we ditched the return addr' +
        ' as well'
      '{$ELSE !ALIGN_STACK}'
      
        '        POP     ECX                           // Ditch the retur' +
        'n addr'
      '{$ENDIF !ALIGN_STACK}'
      ''
      '        CALL    LinkException'
      ''
      '        // Get the Pascal object itself.'
      '        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      ''
      '        MOV     EDX, [EDX].TExcDescEntry.handler'
      
        '        CALL    NotifyOnExcept                // Tell the debugg' +
        'er about it'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        {'
      
        '         When _HandleOnException was called, the stack was adjus' +
        'ted to align'
      
        '         it per the Mach ABI.  The unwinder will have reset the ' +
        'stack pointer'
      
        '         to the prologue result, and the generated code in the c' +
        'aller will'
      
        '         have further adjusted for dynamic arrays.  Thus the ali' +
        'gnment adjustment'
      
        '         made by the compiler will always have been 12 bytes.  W' +
        'e have to'
      '         discard that alignment here.'
      '        }'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      
        '        JMP     EDX                           // Back to the use' +
        'r code'
      '        // never returns'
      '@@NotForMe:'
      
        '        POP     EAX                           // Get the excepti' +
        'on object'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      ''
      '        // Mark that we'#39're reraising this exception, so that the'
      
        '        // compiler generated exception handler for the '#39'except ' +
        'on'#39' clause'
      '        // will not get confused'
      '        OR      [EAX].TRaisedException.Flags, excIsBeingReRaised'
      
        '        JMP     SysRaiseException             // Should be using' +
        ' resume here'
      'end;'
      '{$ELSE !PC_MAPPED_EXCEPTIONS}'
      
        '                                                                ' +
        '      '
      'asm'
      '        { ->    [ESP+ 4] excPtr: PExceptionRecord       }'
      '        {       [ESP+ 8] errPtr: PExcFrame              }'
      '        {       [ESP+12] ctxPtr: Pointer                }'
      '        {       [ESP+16] dspPtr: Pointer                }'
      '        { <-    EAX return value - always one           }'
      ''
      '        MOV     EAX,[ESP+4]'
      
        '        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInP' +
        'rogress'
      '        JNE     @@exit'
      ''
      
        '        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiExce' +
        'ption'
      '        JE      @@DelphiException'
      '        CLD'
      '        CALL    _FpuInit'
      '        MOV     EDX,ExceptClsProc'
      '        TEST    EDX,EDX'
      '        JE      @@exit'
      '        CALL    EDX'
      '        TEST    EAX,EAX'
      '        JNE     @@common'
      '        JMP     @@exit'
      ''
      '@@DelphiException:'
      '        MOV     EAX,[EAX].TExceptionRecord.ExceptObject'
      
        '        MOV     EAX,[EAX]                       { load vtable of' +
        ' exception object       }'
      ''
      '@@common:'
      '        MOV     EDX,[ESP+8]'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        MOV     ECX,[EDX].TExcFrame.desc'
      '        MOV     EBX,[ECX].TExcDesc.cnt'
      
        '        LEA     ESI,[ECX].TExcDesc.excTab       { point ECX to e' +
        'xc descriptor table }'
      
        '        MOV     EBP,EAX                         { load vtable of' +
        ' exception object }'
      ''
      '@@innerLoop:'
      '        MOV     EAX,[ESI].TExcDescEntry.vTable'
      
        '        TEST    EAX,EAX                         { catch all clau' +
        'se?                     }'
      
        '        JE      @@doHandler                     { yes: go execut' +
        'e handler               }'
      
        '        MOV     EDI,EBP                         { load vtable of' +
        ' exception object       }'
      '        JMP     @@haveVMT'
      ''
      '@@vtLoop:'
      '        MOV     EDI,[EDI]'
      '@@haveVMT:'
      '        MOV     EAX,[EAX]'
      '        CMP     EAX,EDI'
      '        JE      @@doHandler'
      ''
      '        MOV     ECX,[EAX].vmtInstanceSize'
      '        CMP     ECX,[EDI].vmtInstanceSize'
      '        JNE     @@parent'
      ''
      '        MOV     EAX,[EAX].vmtClassName'
      '        MOV     EDX,[EDI].vmtClassName'
      ''
      '        XOR     ECX,ECX'
      '        MOV     CL,[EAX]'
      '        CMP     CL,[EDX]'
      '        JNE     @@parent'
      ''
      '        INC     EAX'
      '        INC     EDX'
      '        CALL    _AStrCmp'
      '        JE      @@doHandler'
      ''
      '@@parent:'
      
        '        MOV     EDI,[EDI].vmtParent             { load vtable of' +
        ' parent         }'
      '        MOV     EAX,[ESI].TExcDescEntry.vTable'
      '        TEST    EDI,EDI'
      '        JNE     @@vtLoop'
      ''
      '        ADD     ESI,8'
      '        DEC     EBX'
      '        JNZ     @@innerLoop'
      ''
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        JMP     @@exit'
      ''
      '@@doHandler:'
      '        MOV     EAX,[ESP+4+4*4]'
      
        '        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiExce' +
        'ption'
      '        MOV     EDX,[EAX].TExceptionRecord.ExceptObject'
      '        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr'
      '        JE      @@haveObject'
      '        CALL    ExceptObjProc'
      '        MOV     EDX,[ESP+12+4*4]'
      '        CALL    NotifyNonDelphiException'
      '        CMP     BYTE PTR JITEnable,0'
      '        JBE     @@NoJIT'
      '        CMP     BYTE PTR DebugHook,0'
      
        '        JA      @@noJIT                 { Do not JIT if debuggin' +
        'g }'
      '        LEA     ECX,[ESP+4+4*4]'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        CALL    UnhandledExceptionFilter'
      '        CMP     EAX,EXCEPTION_CONTINUE_SEARCH'
      '        POP     EAX'
      '        JE      @@exit'
      ''
      '@@noJIT:'
      '        MOV     EDX,EAX'
      '        MOV     EAX,[ESP+4+4*4]'
      '        MOV     ECX,[EAX].TExceptionRecord.ExceptionAddress'
      '        JMP     @@GoUnwind'
      ''
      '@@haveObject:'
      '        CMP     BYTE PTR JITEnable,1'
      '        JBE     @@GoUnwind'
      '        CMP     BYTE PTR DebugHook,0'
      '        JA      @@GoUnwind'
      '        PUSH    EAX'
      '        LEA     EAX,[ESP+4+5*4]'
      '        PUSH    EDX'
      '        PUSH    ECX'
      '        PUSH    EAX'
      '        CALL    UnhandledExceptionFilter'
      '        CMP     EAX,EXCEPTION_CONTINUE_SEARCH'
      '        POP     ECX'
      '        POP     EDX'
      '        POP     EAX'
      '        JE      @@exit'
      ''
      '@@GoUnwind:'
      '        XOR     EBX,EBX'
      '        MOV     EBX,FS:[EBX]'
      
        '        PUSH    EBX                     { Save topmost frame    ' +
        ' }'
      
        '        PUSH    EAX                     { Save exception record ' +
        ' }'
      
        '        PUSH    EDX                     { Save exception object ' +
        ' }'
      
        '        PUSH    ECX                     { Save exception address' +
        ' }'
      ''
      '        MOV     EDX,[ESP+8+8*4]'
      '        OR      [EAX].TExceptionRecord.ExceptionFlags,cUnwinding'
      ''
      
        '        PUSH    ESI                     { Save handler entry    ' +
        ' }'
      ''
      '        PUSH    0'
      '        PUSH    EAX'
      '        PUSH    offset @@returnAddress'
      '        PUSH    EDX'
      '        CALL    RtlUnwindProc'
      '@@returnAddress:'
      ''
      
        '        POP     EBX                     { Restore handler entry ' +
        ' }'
      ''
      '        MOV     EDI,[ESP+8+8*4]'
      ''
      '        {       Make the RaiseList entry on the stack }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        PUSH    [EAX].RaiseListPtr'
      '        MOV     [EAX].RaiseListPtr,ESP'
      ''
      '        MOV     EBP,[EDI].TExcFrame.hEBP'
      '        MOV     [EDI].TExcFrame.desc,offset @@exceptFinally'
      '        MOV     EAX,[ESP].TRaiseFrame.ExceptObject'
      '        CALL    NotifyOnExcept'
      '        JMP     [EBX].TExcDescEntry.handler'
      ''
      '@@exceptFinally:'
      '        JMP     _HandleFinallyInternal'
      ''
      '@@destroyExcept:'
      
        '        {       we come here if an exception handler has thrown ' +
        'yet another exception }'
      
        '        {       we need to destroy the exception object and pop ' +
        'the raise list. }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        MOV     ECX,[EAX].RaiseListPtr'
      '        MOV     EDX,[ECX].TRaiseFrame.NextRaise'
      '        MOV     [EAX].RaiseListPtr,EDX'
      ''
      '        MOV     EAX,[ECX].TRaiseFrame.ExceptObject'
      '        JMP     TObject.Free'
      ''
      '@@exit:'
      '        MOV     EAX,1'
      'end;'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '  '
      
        '{$IF defined(STACK_BASED_EXCEPTIONS) or defined(PC_MAPPED_EXCEPT' +
        'IONS)}'
      'procedure _HandleFinally;'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'asm //StackAlignSafe'
      '{$IFDEF PIC}'
      '        MOV     ESI, EBX'
      '{$ENDIF PIC}'
      
        '        CMP     ECX, UW_EXC_CLASS_BORLANDCPP    // C++ exception' +
        '?'
      
        '        JNE     @@handleIt                      // nope, handle ' +
        'it'
      '        // unwinding a C++ exception.  We handle that specially.'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        PUSH    ECX'
      '        MOV     EDX, [ESP+12]'
      '        CALL    EDX'
      '        POP     ECX'
      '        POP     EDX'
      '        POP     EAX'
      '        CALL    SysRaiseCPPException'
      ''
      '@@handleIt:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4 { RA, XX, and 2 PUSHes to come = 16}'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        CALL    UnblockOSExceptions'
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8 { RA, prev XX, XX XX = 16 }'
      '{$ENDIF ALIGN_STACK}'
      ''
      
        '        // If the exception is a Delphi exception thrown from C+' +
        '+, coopt it.'
      '        CALL    MaybeCooptException'
      ''
      '{$IFDEF ALIGN_STACK}'
      
        '        MOV     EDX, [ESP + 12] { get the return address; stack ' +
        'still aligned }'
      '{$ELSE !ALIGN_STACK}'
      '        MOV     EDX, [ESP]'
      '{$ENDIF !ALIGN_STACK}'
      '        CALL    NotifyExceptFinally'
      '        PUSH    EAX'
      '{$IFDEF PIC}'
      '        MOV     EBX, ESI'
      '{$ENDIF PIC}'
      '        {'
      
        '          Mark the current exception with the EBP of the handler' +
        '.  If'
      
        '          an exception is raised from the finally block, then th' +
        'is'
      
        '          exception will be orphaned.  We will catch this later,' +
        ' when'
      
        '          we clean up the next except block to complete executio' +
        'n.'
      '          See DoneExcept.'
      '        }'
      '        MOV [EAX].TRaisedException.HandlerEBP, EBP'
      
        '        { Note: This call appears misalligned when ALIGN_STACK i' +
        's'
      
        '          defined, but the finally handler fixes up the stack up' +
        'on'
      
        '          entry.  This is due to the fact that the code generate' +
        'd for'
      
        '          the finally block deals with both the normal flow, and' +
        ' the'
      
        '          exception case.  In the normal flow, we push the addre' +
        'ss of'
      
        '          a label to simulate a return address, prior to enterin' +
        'g the'
      
        '          finally block.  This push mis-aligns the stack, and th' +
        'e'
      
        '          finally block compensates.  We'#39'll be skipping that pus' +
        'h,'
      
        '          so the return address that we pushed above mirrors the' +
        ' effect. }'
      '        CALL    EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      
        '        { We have to make it look like we'#39've arrived here and se' +
        'tup'
      
        '          a basic EBP frame, in order for the unwind that we wil' +
        'l now'
      
        '          cause to succeed properly.  We popped the saved EAX, n' +
        'ow'
      
        '          we have to get rid of stuff up to the original return ' +
        'address. }'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        {'
      
        '          We executed the finally handler without adverse reacti' +
        'ons.'
      '          It'#39's safe to clear the marker now.'
      '        }'
      '        MOV [EAX].TRaisedException.HandlerEBP, $FFFFFFFF'
      '        PUSH    EBP'
      '        MOV     EBP, ESP'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      
        '        CALL    SysRaiseException             // Should be using' +
        ' resume here'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        { ->    [ESP+ 4] excPtr: PExceptionRecord       }'
      '        {       [ESP+ 8] errPtr: PExcFrame              }'
      '        {       [ESP+12] ctxPtr: Pointer                }'
      '        {       [ESP+16] dspPtr: Pointer                }'
      '        { <-    EAX return value - always one           }'
      ''
      '        MOV     EAX,[ESP+4]'
      
        '        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInP' +
        'rogress'
      '        JE      @@exit'
      ''
      '        PUSH    EBX'
      '        XOR     EBX,EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        {       Make exception frame    }'
      ''
      '        PUSH    EBP'
      '        PUSH    offset @@exceptFinally'
      '        PUSH    dword ptr FS:[EBX]'
      '        MOV     FS:[EBX],ESP'
      ''
      '        MOV     EBX,FS:[EBX]'
      '        MOV     EDX,[EAX].TExceptionRecord.ExceptObject'
      '        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr'
      
        '        PUSH    EBX                     { Save pointer to topmos' +
        't frame }'
      
        '        PUSH    EAX                     { Save OS exception poin' +
        'ter     }'
      
        '        PUSH    EDX                     { Save exception object ' +
        '        }'
      
        '        PUSH    ECX                     { Save exception address' +
        '        }'
      ''
      
        '        MOV     EDI,[ESP+8+11*4]        { Load errPtr:PExcFrame ' +
        '        }'
      ''
      '        {       Make the RaiseList entry on the stack   }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        PUSH    [EAX].RaiseListPtr'
      '        MOV     [EAX].RaiseListPtr,ESP'
      ''
      '        MOV     ECX,[EDI].TExcFrame.desc'
      '        MOV     EBP,[EDI].TExcFrame.hEBP'
      '        MOV     [EDI].TExcFrame.desc,offset @@exceptFinally'
      '        ADD     ECX,TExcDesc.instructions'
      '        CALL    NotifyExceptFinally'
      '        CALL    ECX'
      ''
      '        CALL    SysInit.@GetTLS'
      '        MOV     ECX,[EAX].RaiseListPtr'
      '        MOV     EDX,[ECX].TRaiseFrame.NextRaise'
      '        MOV     [EAX].RaiseListPtr,EDX'
      
        '        ADD     ESP,5*4                 { Remove local RaiseList' +
        '        }'
      ''
      '        {       Remove exception frame  }'
      ''
      '        XOR     EAX,EAX'
      '        POP     EDX'
      '        POP     ECX'
      '        POP     ECX'
      '        MOV     FS:[EAX],EDX'
      ''
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        JMP     @@exit'
      ''
      '@@exceptFinally:'
      '        JMP     _HandleFinallyInternal'
      ''
      '@@destroyExcept:'
      
        '        {       we come here if an finalization handler has thro' +
        'wn yet  }'
      
        '        {       another exception we need to destroy the excepti' +
        'on      }'
      
        '        {       object and pop the raise list.                  ' +
        '        }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        MOV     ECX,[EAX].RaiseListPtr'
      '        MOV     EDX,[ECX].TRaiseFrame.NextRaise'
      '        MOV     [EAX].RaiseListPtr,EDX'
      ''
      '        MOV     EAX,[ECX].TRaiseFrame.ExceptObject'
      '        JMP     TObject.Free'
      ''
      '@@exit:'
      '        MOV     EAX,1'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$ENDIF STACK_BASED_EXCEPTIONS or PC_MAPPED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '          '
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure       _HandleFinallyInternal;'
      'asm'
      '        { ->    [ESP+ 4] excPtr: PExceptionRecord       }'
      '        {       [ESP+ 8] errPtr: PExcFrame              }'
      '        {       [ESP+12] ctxPtr: Pointer                }'
      '        {       [ESP+16] dspPtr: Pointer                }'
      '        { <-    EAX return value - always one           }'
      ''
      '        MOV     EAX,[ESP+4]'
      '        MOV     EDX,[ESP+8]'
      
        '        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInP' +
        'rogress'
      '        JE      @@exit'
      '        MOV     ECX,[EDX].TExcFrame.desc'
      '        MOV     [EDX].TExcFrame.desc,offset @@exit'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        MOV     EBP,[EDX].TExcFrame.hEBP'
      '        ADD     ECX,TExcDesc.instructions'
      '        CALL    NotifyExceptFinally'
      '        CALL    ECX'
      ''
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      ''
      '@@exit:'
      '        MOV     EAX,1'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '        '
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure _HandleAutoException;'
      'asm'
      '        { ->    [ESP+ 4] excPtr: PExceptionRecord       }'
      '        {       [ESP+ 8] errPtr: PExcFrame              }'
      '        {       [ESP+12] ctxPtr: Pointer                }'
      '        {       [ESP+16] dspPtr: Pointer                }'
      '        { <-    EAX return value - always one           }'
      ''
      '        MOV     EAX,[ESP+4]'
      
        '        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInP' +
        'rogress'
      '        JNE     @@exit'
      ''
      
        '        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiExce' +
        'ption'
      '        CLD'
      '        CALL    _FpuInit'
      '        JE      @@DelphiException'
      '        CMP     BYTE PTR JITEnable,0'
      '        JBE     @@DelphiException'
      '        CMP     BYTE PTR DebugHook,0'
      '        JA      @@DelphiException'
      ''
      '@@DoUnhandled:'
      '        LEA     EAX,[ESP+4]'
      '        PUSH    EAX'
      '        CALL    UnhandledExceptionFilter'
      '        CMP     EAX,EXCEPTION_CONTINUE_SEARCH'
      '        JE      @@exit'
      '        MOV     EAX,[ESP+4]'
      '        JMP     @@GoUnwind'
      ''
      '@@DelphiException:'
      '        CMP     BYTE PTR JITEnable,1'
      '        JBE     @@GoUnwind'
      '        CMP     BYTE PTR DebugHook,0'
      '        JA      @@GoUnwind'
      '        JMP     @@DoUnhandled'
      ''
      '@@GoUnwind:'
      '        OR      [EAX].TExceptionRecord.ExceptionFlags,cUnwinding'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        MOV     EDX,[ESP+8+3*4]'
      ''
      '        PUSH    0'
      '        PUSH    EAX'
      '        PUSH    offset @@returnAddress'
      '        PUSH    EDX'
      '        CALL    RtlUnwindProc'
      ''
      '@@returnAddress:'
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        MOV     EAX,[ESP+4]'
      '        MOV     EBX,8000FFFFH'
      
        '        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiExce' +
        'ption'
      '        JNE     @@done'
      ''
      '        MOV     EDX,[EAX].TExceptionRecord.ExceptObject'
      '        MOV     ECX,[EAX].TExceptionRecord.ExceptAddr'
      '        MOV     EAX,[ESP+8]'
      '        MOV     EAX,[EAX].TExcFrame.SelfOfMethod'
      '        TEST    EAX,EAX'
      '        JZ      @@freeException'
      '        MOV     EBX,[EAX]'
      
        '        CALL    DWORD PTR [EBX] + VMTOFFSET TObject.SafeCallExce' +
        'ption'
      '        MOV     EBX,EAX'
      '@@freeException:'
      '        MOV     EAX,[ESP+4]'
      '        MOV     EAX,[EAX].TExceptionRecord.ExceptObject'
      '        CALL    TObject.Free'
      ''
      '@@done:'
      '        XOR     EAX,EAX'
      '        MOV     ESP,[ESP+8]'
      '        POP     ECX'
      '        MOV     FS:[EAX],ECX'
      '        POP     EDX'
      '        POP     EBP'
      '        LEA     EDX,[EDX].TExcDesc.instructions'
      '        POP     ECX'
      '        JMP     EDX'
      '@@exit:'
      '        MOV     EAX,1'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure _HandleAutoException;'
      'asm'
      '        // EAX = TObject reference, or nil'
      '        // [ESP] = ret addr'
      ''
      '{$IFDEF ALIGN_STACK}'
      '         SUB      ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        CALL    UnblockOSExceptions'
      ''
      '        CALL    CurrentException'
      '        MOV     EDX, [ESP]'
      
        '        // If the exception is a Delphi exception thrown from C+' +
        '+, coopt it.'
      '        CALL    MaybeCooptException'
      '        CALL    LinkException'
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      ''
      '//  The compiler wants the stack to look like this:'
      '//  ESP+4->  HRESULT'
      '//  ESP+0->  ret addr'
      '//'
      '//  Make it so.'
      '//'
      '        POP     EDX'
      '        PUSH    8000FFFFH'
      '        PUSH    EDX'
      ''
      '        PUSH    ESI'
      '        PUSH    EAX'
      '        OR      EAX, EAX    // Was this a method call?'
      '        JE      @@Done'
      ''
      '        CALL    CurrentException'
      '        MOV     EDX, [EAX].TRaisedException.ExceptObject'
      '        MOV     ECX, [EAX].TRaisedException.ExceptionAddr;'
      '        MOV     EAX, [ESP]'
      '        MOV     ESI, [EAX]'
      
        '        CALL    DWORD PTR [ESI] + VMTOFFSET TObject.SafeCallExce' +
        'ption;'
      '        MOV     [ESP+12], EAX'
      '@@Done:'
      '        CALL    _DoneExcept'
      '        POP     EAX'
      '        POP     ESI'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      
        'function GetRaiseFrame(var UnwindException: _Unwind_Exception): ' +
        'PRaiseFrame; inline;'
      'begin'
      
        '  Result := PRaiseFrame((PByte(@UnwindException) + SizeOf(_Unwin' +
        'd_Exception)) - SizeOf(TRaiseFrame));'
      'end;'
      ''
      
        'function GetThrownObject(var UnwindException: _Unwind_Exception)' +
        ': Pointer; inline;'
      'begin'
      
        '  Result := Pointer(GetRaiseFrame(UnwindException).ExceptObject)' +
        ';'
      'end;'
      ''
      
        'function _HandleAutoException(const Self: TObject; var UnwindExc' +
        'eption: _Unwind_Exception): HResult;'
      'var'
      '  CurRaiseFrame: PRaiseFrame;'
      '  ExceptObject: Pointer;'
      '  ExceptAddr: Pointer;'
      'begin'
      '  Result := HResult($8000FFFF); { E_UNEXPECTED }'
      '  CurRaiseFrame := GetRaiseFrame(UnwindException);'
      '  ExceptObject := CurRaiseFrame^.ExceptObject;'
      '  ExceptAddr := CurRaiseFrame^.ExceptAddr;'
      '  if Assigned(Self) then'
      '    Result := Self.SafeCallException(ExceptObject, ExceptAddr);'
      '  _DoneExcept(UnwindException);'
      'end;'
      '{$ENDIF}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '                                                        '
      
        '                                                                ' +
        ' '
      'procedure       _RaiseAtExcept;'
      'asm //StackAlignSafe'
      '        { ->    EAX     Pointer to exception object     }'
      '        { ->    EDX     Purported addr of exception     }'
      '        { Be careful: EBX is not set up in PIC mode. }'
      
        '        { Outward bound calls must go through an exported fn, li' +
        'ke SysRaiseException }'
      '        OR      EAX, EAX'
      '        JNE     @@GoAhead'
      '        MOV     EAX, 216'
      '        JMP     _RunError'
      ''
      '@@GoAhead:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    BlockOSExceptions'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBP'
      '        MOV     EBP, ESP'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    NotifyReRaise'
      '        CALL    AllocateException'
      '{$IFDEF PIC}'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     EBX, EAX'
      '        POP     EAX'
      '        MOV     EDX, [EBX].RaiseExceptObjProc'
      '        MOV     EDX, [EDX]'
      '{$ELSE !PIC}'
      '        MOV     EDX,RaiseExceptObjProc'
      '{$ENDIF !PIC}'
      '        TEST    EDX,EDX'
      '        JZ      @@DoRaise'
      '{$IFDEF ALIGN_STACK}'
      '        MOV     [ESP],EAX'
      '        CALL    EDX'
      '        MOV     EAX,[ESP]'
      '{$ELSE}'
      '        PUSH    EAX'
      '        CALL    EDX'
      '        POP     EAX'
      '{$ENDIF ALIGN_STACK}'
      '@@DoRaise:'
      '        CALL    SysRaiseException'
      '        {'
      
        '          This can only return if there was a terrible error.  I' +
        'n this event,'
      '          we have to bail out.'
      '        }'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '        POP     EBP'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     _Run0Error'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '                                                 '
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure _RaiseAtExcept(Obj: TObject; Address: Pointer);'
      'var'
      '  Params: Array[0..6] of NativeUInt;'
      '  ExceptionRecord: TExceptionRecord;'
      '  //CurRaiseFrame: PRaiseFrame;'
      'begin'
      '  if Obj = nil then'
      '    _RunError(216); // reAccessViolation'
      ''
      '  Params[0] := UIntPtr(Address);'
      '  Params[1] := UIntPtr(Pointer(Obj));'
      '  Params[2] := 0 {EBX};'
      '  Params[3] := 0 {ESI};'
      '  Params[4] := 0 {EDI};'
      '  Params[5] := 0 {EBP};'
      '  Params[6] := 0 {ESP};'
      ''
      '  if RaiseExceptObjProc <> nil then'
      '  begin'
      '    //CurRaiseFrame := RaiseListPtr;'
      '    ExceptionRecord.ExceptionCode := cDelphiException;'
      '    ExceptionRecord.ExceptionFlags := cNonContinuable;'
      '    ExceptionRecord.ExceptionRecord := nil;'
      '//  if CurRaiseFrame <> nil then'
      
        '//    ExceptionRecord.ExceptionRecord := CurRaiseFrame^.Exceptio' +
        'nRecord;'
      '    ExceptionRecord.ExceptionAddress := Address;'
      '    ExceptionRecord.NumberParameters := 7;'
      '    ExceptionRecord.ExceptionInformation[0] := Params[0];'
      '    ExceptionRecord.ExceptionInformation[1] := Params[1];'
      '    ExceptionRecord.ExceptionInformation[2] := Params[2];'
      '    ExceptionRecord.ExceptionInformation[3] := Params[3];'
      '    ExceptionRecord.ExceptionInformation[4] := Params[4];'
      '    ExceptionRecord.ExceptionInformation[5] := Params[5];'
      '    ExceptionRecord.ExceptionInformation[6] := Params[6];'
      '    TRaiseExceptObjProc(RaiseExceptObjProc)(@ExceptionRecord);'
      '  end;'
      
        '  RaiseExceptionProc(cDelphiException, cNonContinuable, 7, @Para' +
        'ms);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '                                                                '
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure       _RaiseExcept;'
      'asm'
      '        { ->    EAX     Pointer to exception object     }'
      '        MOV     EDX, [ESP]'
      '        JMP     _RaiseAtExcept'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure       _RaiseExcept;'
      'asm'
      
        '  { When making changes to the way Delphi Exceptions are raised,' +
        ' }'
      
        '  { please realize that the C++ Exception handling code reraises' +
        ' }'
      
        '  { some exceptions as Delphi Exceptions.  Of course we want to ' +
        ' }'
      
        '  { keep exception raising compatible between Delphi and C++, so' +
        ' }'
      
        '  { when you make changes here, consult with the relevant C++   ' +
        ' }'
      
        '  { exception handling engineer. The C++ code is in xx.cpp, in  ' +
        ' }'
      
        '  { the RTL sources, in function tossAnException.               ' +
        ' }'
      ''
      '  { ->    EAX     Pointer to exception object     }'
      '  {       [ESP]   Error address           }'
      ''
      '        OR      EAX, EAX'
      '        JNE     @@GoAhead'
      '        MOV     EAX, 216'
      '        CALL    _RunError'
      '@@GoAhead:'
      '        POP     EDX'
      ''
      '        PUSH    ESP'
      '        PUSH    EBP'
      '        PUSH    EDI'
      '        PUSH    ESI'
      '        PUSH    EBX'
      
        '        PUSH    EAX                             { pass class arg' +
        'ument           }'
      
        '        PUSH    EDX                             { pass address a' +
        'rgument         }'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      
        '        CALL    _InstAddRef                     { EAX still cont' +
        'ains the exception object reference }'
      '{$ENDIF}'
      ''
      
        '        MOV     EAX,ESP                         { Need these val' +
        'ues later }'
      
        '        PUSH    ESP                             { pass pointer t' +
        'o arguments             }'
      
        '        PUSH    7                               { there are seve' +
        'n arguments               }'
      
        '        PUSH    cNonContinuable                 { we can'#39't conti' +
        'nue execution   }'
      
        '        PUSH    cDelphiException                { our magic exce' +
        'ption code              }'
      
        '        PUSH    EDX                             { pass the user'#39 +
        's return address        }'
      
        '        MOV     EDX,RaiseExceptObjProc          { has this been ' +
        'hooked? }'
      '        TEST    EDX,EDX'
      '        JZ      @@2'
      ''
      '        PUSH    [EAX + 6 * 4]'
      '        PUSH    [EAX + 5 * 4]'
      '        PUSH    [EAX + 4 * 4]'
      '        PUSH    [EAX + 3 * 4]'
      '        PUSH    [EAX + 2 * 4]'
      '        PUSH    [EAX + 1 * 4]                   { object }'
      '        PUSH    [EAX + 0 * 4]                   { address }'
      
        '        PUSH    7                               { how many of th' +
        'e above }'
      
        '        PUSH    [EAX + 0 * 4]                   { the address go' +
        'es here again }'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        CALL    RaiseList'
      '        MOV     ECX,EAX'
      '        POP     EDX'
      '        POP     EAX'
      '        TEST    ECX,ECX'
      '        JZ      @@1'
      '        MOV     ECX,[ECX].TRaiseFrame.ExceptionRecord'
      '@@1:    PUSH    ECX'
      '        PUSH    cNonContinuable'
      '        PUSH    cDelphiException'
      '        MOV     EAX,ESP'
      '        CALL    EDX'
      
        '        ADD     ESP,12 * 4                      { Cleanup 12 DWO' +
        'RDS from the stack }'
      '@@2:'
      '        JMP     RaiseExceptionProc'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      'procedure _RaiseExcept(Obj: TObject);'
      'begin'
      '  _RaiseAtExcept(Obj, ReturnAddress);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      ''
      '{$I Unwind.inc}'
      ''
      'procedure _RaiseAtExcept(const Obj: TObject; Address: Pointer);'
      'var'
      '  RaiseFramePtr: PRaiseFrame;'
      '  ExceptionRecord: TExceptionRecord;'
      'begin'
      '  NotifyReRaise(Obj, Address);'
      '  if RaiseExceptObjProc <> nil then'
      '  begin'
      '    ExceptionRecord.ExceptObject := Obj;'
      '    TRaiseExceptObjProc(RaiseExceptObjProc)(@ExceptionRecord);'
      '  end;'
      '  RaiseFramePtr := AllocateRaiseFrame;'
      '  RaiseFramePtr.ExceptObject := Obj;'
      '  RaiseFramePtr.ExceptAddr := Address;'
      
        '  RaiseFramePtr.UnwindException.exception_class := DelphiExcepti' +
        'onPersonality;'
      '{$IFDEF SJLJ_BASED_EXCEPTIONS}'
      '  RaiseFramePtr.UnwindException.private_1 := UIntPtr(Obj);'
      '  RaiseFramePtr.UnwindException.private_2 := 0;'
      '{$ENDIF SJLJ_BASED_EXCEPTIONS}'
      '{$IFDEF ZCX_BASED_EXCEPTIONS}'
      '  RaiseFramePtr.UnwindException.private_1 := 0; // UIntPtr(Obj);'
      '  RaiseFramePtr.UnwindException.private_2 := 0;'
      '{$ENDIF ZCX_BASED_EXCEPTIONS}'
      '{$IFDEF LINUX64}'
      '  RaiseFramePtr.UnwindException.exception_cleanup := nil;'
      '{$ENDIF LINUX64}'
      '  LinkRaiseFrame(RaiseFramePtr);'
      '{$IF defined(CPUX64) and defined(Linux)} // Linux64'
      
        '  // Initialize FPU hardware. x87 is stack machine, so we need t' +
        'o initialize x87 FPU at this point.'
      '  _FpuInit;'
      '{$ENDIF Linux64}'
      '  _Unwind_RaiseException(RaiseFramePtr.UnwindException);'
      '  _UnhandledException;'
      'end;'
      ''
      'procedure _RaiseExcept(const Obj: TObject);'
      'begin'
      '  _RaiseAtExcept(Obj, ReturnAddress);'
      'end;'
      ''
      'const'
      
        '  // Heavily borrowed from llvm/examples/ExceptionDemo/Exception' +
        'Demo.cpp'
      '  // DWARF Constants'
      '  DW_EH_PE_absptr   = $00;'
      '  DW_EH_PE_uleb128  = $01;'
      '  DW_EH_PE_udata2   = $02;'
      '  DW_EH_PE_udata4   = $03;'
      '  DW_EH_PE_udata8   = $04;'
      '  DW_EH_PE_sleb128  = $09;'
      '  DW_EH_PE_sdata2   = $0A;'
      '  DW_EH_PE_sdata4   = $0B;'
      '  DW_EH_PE_sdata8   = $0C;'
      '  DW_EH_PE_pcrel    = $10;'
      '  DW_EH_PE_textrel  = $20;'
      '  DW_EH_PE_datarel  = $30;'
      '  DW_EH_PE_funcrel  = $40;'
      '  DW_EH_PE_aligned  = $50;'
      '  DW_EH_PE_indirect = $80;'
      '  DW_EH_PE_omit     = $FF;'
      ''
      'type'
      '  PUIntPtr = ^UIntPtr;'
      '  PIntPtr = ^IntPtr;'
      '  PInt16 = ^Int16;'
      '  PUInt16 = ^UInt16;'
      '  PInt32 = ^Int32;'
      '  TScanResults = record'
      '    FTypeIndex: Int64;'
      '    FActionRecord: PByte;'
      '    FLanguageSpecificData: PByte;'
      '    FLandingPad: UIntPtr;'
      '    FAdjustedPtr: Pointer;'
      '    FReason: _Unwind_Reason_Code;'
      '  end;'
      ''
      '/// Read a uleb128 encoded value and advance pointer'
      '/// See Variable Length Data Appendix C in:'
      '/// @link http://dwarfstd.org/Dwarf4.pdf @unlink'
      
        '/// @param data reference variable holding memory pointer to dec' +
        'ode from'
      '/// @returns decoded value'
      'function ReadULEB128(var Data: PByte): UIntPtr;'
      'var'
      '  Shift: UIntPtr;'
      '  B: Byte;'
      'begin'
      '  Result := 0;'
      '  Shift := 0;'
      '  repeat'
      '    B := Data^; Inc(Data);'
      '    Result := Result or UIntPtr(B and $7F) shl Shift;'
      '    Inc(Shift, 7);'
      '  until B and $80 = 0;'
      'end;'
      ''
      '/// Read a sleb128 encoded value and advance pointer'
      '/// See Variable Length Data Applendix C in:'
      '/// @link http://dwarfstd.org/Dwarf4.pdf @unlink'
      
        '/// @param data reference variable holding memory pointer to dec' +
        'ode from'
      '/// @returns decoded value'
      'function ReadSLEB128(var Data: PByte): IntPtr;'
      'var'
      '  Shift: UIntPtr;'
      '  B: Byte;'
      '  Res: UIntPtr;'
      'begin'
      '  Res := 0;'
      '  Shift := 0;'
      '  repeat'
      '    B := Data^; Inc(Data);'
      '    Res := Res or UIntPtr(B and $7F) shl Shift;'
      '    Inc(Shift, 7);'
      '  until B and $80 = 0;'
      '  if (B and $40 <> 0) and (Shift < (SizeOf(Res) shl 3)) then'
      '    Res := Res or UIntPtr(-1) shl Shift;'
      '  Result := IntPtr(Res);'
      'end;'
      ''
      '/// Read a pointer encoded value and advance pointer'
      '/// See Variable Length Data in:'
      '/// @link http://dwarfstd.org/Dwarf3.pdf @unlink'
      
        '/// @param data reference variable holding memory pointer to dec' +
        'ode from'
      '/// @param encoding dwarf encoding type'
      '/// @returns decoded value'
      
        'function ReadEncodedPointer(var Data: PByte; Encoding: UInt8): U' +
        'IntPtr;'
      'var'
      '  P: PByte;'
      'begin'
      '  Result := 0;'
      '  if Encoding = DW_EH_PE_omit then'
      '    Exit;'
      '  P := Data;'
      '  // first get value'
      '  case Encoding and $0F of'
      '    DW_EH_PE_absptr:'
      '      begin'
      '        Result := PUIntPtr(P)^;'
      '        Inc(P, SizeOf(UIntPtr));'
      '      end;'
      '    DW_EH_PE_uleb128:'
      '      Result := ReadULEB128(P);'
      '    DW_EH_PE_sleb128:'
      '      Result := UIntPtr(ReadSLEB128(P));'
      '    DW_EH_PE_udata2:'
      '      begin'
      '        Result := PUInt16(P)^;'
      '        Inc(P, SizeOf(UInt16));'
      '      end;'
      '    DW_EH_PE_udata4:'
      '      begin'
      '        Result := PUInt32(P)^;'
      '        Inc(P, SizeOf(UInt32));'
      '      end;'
      '    DW_EH_PE_udata8:'
      '      begin'
      '        Result := UIntPtr(PUInt64(P)^);'
      '        Inc(P, SizeOf(UInt64));'
      '      end;'
      '    DW_EH_PE_sdata2:'
      '      begin'
      '        Result := UIntPtr(PInt16(P)^);'
      '        Inc(P, SizeOf(Int16));'
      '      end;'
      '    DW_EH_PE_sdata4:'
      '      begin'
      '        Result := UIntPtr(PInt32(P)^);'
      '        Inc(P, SizeOf(Int32));'
      '      end;'
      '    DW_EH_PE_sdata8:'
      '      begin'
      '        Result := UIntPtr(PInt64(P)^);'
      '        Inc(P, SizeOf(Int64));'
      '      end;'
      '    else'
      '      Halt;'
      '  end;'
      '  // then add relative offset'
      '  case Encoding and $70 of'
      '    DW_EH_PE_absptr: begin end;'
      '    DW_EH_PE_pcrel:'
      '      if Result <> 0 then'
      '        Result := Result + UIntPtr(Data);'
      '    DW_EH_PE_textrel,'
      '    DW_EH_PE_datarel,'
      '    DW_EH_PE_funcrel,'
      '    DW_EH_PE_aligned: begin end;'
      '  else'
      '    Halt;'
      '  end;'
      '  // then apply indirection'
      
        '  if (Result <> 0) and (Encoding and DW_EH_PE_indirect <> 0) the' +
        'n'
      '    Result := PUIntPtr(Result)^;'
      '  Data := P;'
      'end;'
      ''
      
        '{$IF Defined(CPUARM) and (Defined(ZCX_BASED_EXCEPTIONS) or Defin' +
        'ed(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)' +
        ') and not Defined(LINUX32) and not Defined(ANDROID64)}'
      'function GetCXXClassName(const P: UIntPtr): PUTF8Char; cdecl;'
      '  external librtlhelpername name '#39'get_cxx_class_name'#39';'
      '{$ENDIF}'
      ''
      
        '{$IF Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTI' +
        'ONS) or Defined(ZCX_BASED_EXCEPTIONS_MACOS)}'
      'function isDelphiType(TypeID: UIntPtr): Boolean;'
      'var'
      '  P, Q: PByte;'
      'begin'
      '  if TypeID = 0 then'
      '    Exit(False);'
      '  P := PByte(TypeID);'
      '  Q := P - sizeof(UIntPtr);'
      
        '  Result := (UIntPtr(P) = PUIntPtr(Q)^) and (TTypeKind(PByte(P)^' +
        ') = tkClass);'
      'end;'
      '{$ENDIF}'
      ''
      
        'function GetShimTypeInfo(TypeIndex: UInt64; ClassInfo: PByte; Ty' +
        'peEncoding: UInt8;'
      '  out OnClass: TClass; out cxxName: PUTF8Char): Boolean;'
      'type'
      '  PClass = ^TClass;'
      '  {$POINTERMATH ON}'
      '  PCardinal = ^Cardinal;'
      '  {$POINTERMATH OFF}'
      'var'
      '  P: UIntPtr;'
      'begin'
      '  OnClass := nil;'
      '  cxxName := nil;'
      '  Result := False;'
      '  if ClassInfo = nil then'
      '    Halt;'
      '  case TypeEncoding and $0F of'
      '    DW_EH_PE_absptr: TypeIndex := TypeIndex * SizeOf(Pointer);'
      '    DW_EH_PE_udata2,'
      '    DW_EH_PE_sdata2: TypeIndex := TypeIndex * 2;'
      '    DW_EH_PE_udata4,'
      '    DW_EH_PE_sdata4: TypeIndex := TypeIndex * 4;'
      '    DW_EH_PE_udata8,'
      '    DW_EH_PE_sdata8: TypeIndex := TypeIndex * 8;'
      '  else'
      '    // this should not happen.   Indicates corrupted eh_table.'
      '    Halt;'
      '  end;'
      '  Dec(ClassInfo, TypeIndex);'
      
        '{$IF Defined(CPUARM32) and (Defined(ZCX_BASED_EXCEPTIONS) or Def' +
        'ined(ZCX_BASED_EXCEPTIONS_MACOS))}'
      '  P := UintPtr(ClassInfo);'
      '  if PCardinal(P)^ <> 0 then'
      '  begin'
      '    P := PCardinal((P + PCardinal(P)^) )^;'
      '{$ELSE}'
      '  P := ReadEncodedPointer(ClassInfo, TypeEncoding);'
      '  if P <> 0 then'
      '  begin'
      '{$ENDIF}'
      '    Result := True;'
      
        '    if isDelphiType(PUIntPtr(P + (vmtTypeInfo - vmtSelfPtr))^) t' +
        'hen'
      '      OnClass := PClass(P)^ //Delphi native way'
      '    else'
      '    begin'
      
        '      {$IF Defined(CPUARM) and (Defined(ZCX_BASED_EXCEPTIONS) or' +
        ' Defined(SJLJ_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIONS_' +
        'MACOS)) and not Defined(LINUX32) and not Defined(ANDROID64)}'
      '      cxxName := GetCXXClassName(P);'
      '      {$ENDIF}'
      '      if cxxName = nil then'
      '        OnClass := PClass(P)^; //Delphi native way'
      '    end;'
      '  end;'
      'end;'
      ''
      '{$IF Defined(ZCX_BASED_EXCEPTIONS)}'
      '{$IF Defined(LINUX)}'
      '// Use libgcc_s'
      '{$ELSEIF Defined(ANDROID64)}'
      '// Use libgcc'
      '{$ELSEIF Defined(ANDROID32)}'
      
        'function _Unwind_GetLanguageSpecificData(context: PUnwind_Contex' +
        't): Pointer;'
      'type'
      '  {$POINTERMATH ON}'
      '  PUInt32     = ^UInt32;'
      '  {$POINTERMATH OFF}'
      'var'
      '  ucbp: PUnwind_Exception;'
      '  ptr: PUInt32;'
      'begin'
      
        '  ucbp := PUnwind_Exception(_Unwind_GetGR (context, UNWIND_POINT' +
        'ER_REG));'
      '  ptr := PUInt32(ucbp.ehtp);'
      '  Inc(ptr, 1); // Skip personality'
      
        '  Inc(ptr, ((ptr^ shr 24) and $FF + 1));                        ' +
        '                            '
      '  Result := Pointer(ptr);'
      'end;'
      'exports _Unwind_GetLanguageSpecificData;'
      ''
      
        'function _Unwind_GetRegionStart(context: PUnwind_Context): UIntP' +
        'tr;'
      'var'
      '  ucbp: PUnwind_Exception;'
      'begin'
      
        '  ucbp := PUnwind_Exception(_Unwind_GetGR (context, UNWIND_POINT' +
        'ER_REG));'
      '  Result := ucbp.fnstart;'
      'end;'
      'exports _Unwind_GetRegionStart;'
      '{$ELSE }'
      '{$MESSAGE ERROR '#39'Unknown Platform'#39'}'
      '{$ENDIF}'
      '{$ENDIF Defined(ZCX_BASED_EXCEPTIONS)}'
      ''
      
        'function CanHandleException(const Exception: TObject; HandlerTyp' +
        'e: TClass): Boolean; overload;'
      'var'
      '  InstClass: TClass;'
      '  HandlerSize: Integer;'
      '  HandlerName: _PShortStr;'
      'begin'
      '  InstClass := Exception.ClassType;'
      '  HandlerSize := HandlerType.InstanceSize;'
      
        '  HandlerName := _PShortStr(PPointer(PByte(HandlerType) + vmtCla' +
        'ssName)^);'
      '  repeat'
      '    if (InstClass.InstanceSize = HandlerSize) and'
      
        '      (PByte(PPointer(PByte(InstClass) + vmtClassName)^)^ = PByt' +
        'e(HandlerName)^) and'
      
        '      (_AStrCmp(@_PShortStr(PPointer(PByte(InstClass) + vmtClass' +
        'Name)^)^[1], @HandlerName^[1], PByte(HandlerName)^) = 0) then'
      '        Exit(True);'
      '    InstClass := InstClass.ClassParent;'
      '  until InstClass = nil;'
      '  Result := False;'
      'end;'
      ''
      'function GetMangledClassName(C: TClass) : _ShortStr;'
      'var'
      '  LClassInfo: Pointer;'
      '  S, RR: _ShortStr;'
      '  Count, Start: Integer;'
      ''
      'begin'
      '  Result := '#39'N'#39';'
      ''
      '  LClassInfo := C.ClassInfo;'
      '  if LClassInfo <> nil then'
      '  begin'
      
        '    S := PClassData(PByte(LClassInfo) + 2 + PByte(PByte(LClassIn' +
        'fo) + 1)^).UnitName;'
      '    if S[1] = '#39'@'#39' then'
      '      S := Copy(S, 2, Pos(_ShortStr('#39':'#39'), S) - 2);'
      '    // 1 based string system use'
      '    Count := 1;'
      '    Start := Count;'
      '    while (Count <= Length(S)) do'
      '    begin'
      '      if S[Count] = '#39'.'#39' then'
      '      begin'
      '        RR := Copy(S, Start, Count - Start);'
      '        Result := Result + _Str0Long(Length(RR)) + RR;'
      '        Inc(Count);'
      '        Start := Count;'
      '      end'
      '      else'
      '        Inc(Count);'
      '    end;'
      '    if Start < Length(S) then'
      '    begin'
      '      RR := Copy(S, Start, MAXINT);'
      '      Result := Result + _Str0Long(Length(RR)) + RR;'
      '    end;'
      '  end;'
      ''
      '  S := _PShortStr(PPointer(PByte(C) + vmtClassName)^)^;'
      '  Result := Result + _Str0Long(Length(S)) + S + '#39'E'#39';'
      'end;'
      ''
      
        'function CanHandleException(const Exception: TObject; cxxName: P' +
        'UTF8Char): Boolean; overload;'
      ''
      
        '  function _AStrIEqual(const Left, Right: _PAnsiChr; Len: Native' +
        'Int): Boolean;'
      '  var'
      '    L, R: PByte;'
      '  begin'
      '    L := PByte(Left);'
      '    R := PByte(Right);'
      ''
      '    while len > 0 do'
      '    begin'
      '      if L^ <> R^ then'
      '      begin'
      '        if ((L^ or $20) <> (R^ or $20)) or (L^ > $80) then'
      '          Exit(False);'
      '      end;'
      '      Inc(L);'
      '      Inc(R);'
      '      Dec(len);'
      '    end;'
      '    Result := True;'
      '  end;'
      ''
      'var'
      '  InstClass: TClass;'
      '  InstMangledName: _ShortStr;'
      '  cxxNameLength: Integer;'
      'begin'
      '  Result := False;'
      '  if cxxName = nil then'
      '    exit;'
      '  // Delphi object has "N6System8Sysutils6EAbortE"'
      '  if cxxName^ <> '#39'N'#39' then'
      '    exit;'
      ''
      '  cxxNameLength := _PCharLen(cxxName);'
      '  InstClass := Exception.ClassType;'
      ''
      '  repeat'
      '    InstMangledName := GetMangledClassName(InstClass);'
      '    if (Length(InstMangledName) = cxxNameLength) and'
      
        '      _AStrIEqual(@InstMangledName[1], cxxName, cxxNameLength) t' +
        'hen'
      '        Exit(True);'
      '    InstClass := InstClass.ClassParent;'
      '  until InstClass = nil;'
      'end;'
      ''
      
        'function ScanEHTable(Actions: _Unwind_Action; DelphiException: B' +
        'oolean; var UnwindException: _Unwind_Exception;'
      '  Context: PUnwind_Context): TScanResults;'
      'var'
      '  LSDA, ClassInfo, CallSiteTableStart,'
      '  CallSiteTableEnd, ActionTableStart, CallSitePtr,'
      '  Action, ActionRecord: PByte;'
      '  OnClass: TClass;'
      '  IP, ClassInfoOffset: UIntPtr;'
      '  Temp: PByte;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '  lpStart: PByte;'
      '  FuncStart,'
      '  Start, Length: UIntPtr;'
      '  IpOffset: UIntPtr;'
      '  CallSiteEncoding: UInt8;'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '  LandingPad, ActionEntry: UIntPtr;'
      '  lpStartEncoding, ttypeEncoding: UInt8;'
      '  ttypeIndex, ActionOffset: Int64;'
      '  CallSiteTableLength: UInt32;'
      '  RaiseFrame: PRaiseFrame;'
      '  cxxName: PUTF8Char;'
      '  HasFilter: Boolean;'
      'begin'
      '  FillChar(Result, SizeOf(Result), 0);'
      '  Result.FReason := _URC_FATAL_PHASE1_ERROR;'
      '  // Do some consistency checking'
      '  if Actions and _UA_SEARCH_PHASE <> 0 then'
      '  begin'
      '    // Check for phase 1 errors'
      
        '    if Actions and (_UA_CLEANUP_PHASE or _UA_HANDLER_FRAME or _U' +
        'A_FORCE_UNWIND) <> 0 then'
      '      Exit;'
      '  end else if Actions and _UA_CLEANUP_PHASE <> 0 then'
      '  begin'
      
        '    if Actions and (_UA_HANDLER_FRAME or _UA_FORCE_UNWIND) = (_U' +
        'A_HANDLER_FRAME or _UA_FORCE_UNWIND) then'
      '    begin'
      '      Result.FReason := _URC_FATAL_PHASE2_ERROR;'
      '      Exit;'
      '    end'
      '  end else'
      '    Exit;'
      '  LSDA := PByte(_Unwind_GetLanguageSpecificData(Context));'
      '  if LSDA = nil then'
      '  begin'
      '    Result.FReason := _URC_CONTINUE_UNWIND;'
      '    Exit;'
      '  end;'
      '  Result.FLanguageSpecificData := LSDA;'
      
        '  // Get the current instruction pointer and offset it before ne' +
        'xt'
      '  // instruction in the current frame which threw the exception.'
      '  IP := _Unwind_GetIP(Context) - 1;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '  // Get beginning current frame'#39's code (as defined by the'
      '  // emitted dwarf code)'
      '  FuncStart := _Unwind_GetRegionStart(Context);'
      '  IpOffset := IP - FuncStart;'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '{$IFDEF SJLJ_BASED_EXCEPTIONS}'
      '  // Under SjLj, _Unwind_GetRegionStart returns 0 always.'
      '  // FuncStart is 0 always'
      '//  FuncStart := 0; // Not used in ARM'
      '  if IP = UIntPtr(-1) then'
      '  begin'
      '    Result.FReason := _URC_CONTINUE_UNWIND;'
      '    Exit;'
      '  end else if IP = 0 then'
      '    Halt(1);'
      '{$ENDIF SJLJ_BASED_EXCEPTIONS}'
      '  ClassInfo := nil;'
      '  lpStartEncoding := LSDA^; Inc(LSDA);'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '  lpStart := PByte(ReadEncodedPointer(LSDA, lpStartEncoding));'
      '  if lpStart = nil then'
      '    lpStart := PByte(FuncStart);'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '{$IFDEF SJLJ_BASED_EXCEPTIONS}'
      
        '  ReadEncodedPointer(LSDA, lpStartEncoding); //  Discard lpStart' +
        ' for ARM'
      '{$ENDIF SJLJ_BASED_EXCEPTIONS}'
      '  ttypeEncoding := LSDA^; Inc(LSDA);'
      '  if ttypeEncoding <> DW_EH_PE_omit then'
      '  begin'
      '    ClassInfoOffset := ReadULEB128(LSDA);'
      '    ClassInfo := LSDA + ClassInfoOffset;'
      '  end;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '  CallSiteEncoding := LSDA^;'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '  Inc(LSDA);'
      '  CallSiteTableLength := UInt32(ReadULEB128(LSDA));'
      '  CallSiteTableStart := LSDA;'
      '  CallSiteTableEnd := CallSiteTableStart + CallSiteTableLength;'
      '  ActionTableStart := CallSiteTableEnd;'
      '  CallSitePtr := CallSiteTableStart;'
      '  while True do'
      '  begin'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '    Start := ReadEncodedPointer(CallSitePtr, CallSiteEncoding);'
      '    Length := ReadEncodedPointer(CallSitePtr, CallSiteEncoding);'
      
        '    LandingPad := ReadEncodedPointer(CallSitePtr, CallSiteEncodi' +
        'ng);'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '{$IFDEF SJLJ_BASED_EXCEPTIONS}'
      '    LandingPad := ReadULEB128(CallSitePtr);'
      '{$ENDIF SJLJ_BASED_EXCEPTIONS}'
      '    ActionEntry := ReadULEB128(CallSitePtr);'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      
        '    if (Start <= IpOffset) and (IpOffset < (Start + Length)) the' +
        'n'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '{$IFDEF SJLJ_BASED_EXCEPTIONS}'
      '    Dec(IP);'
      '    if IP = 0 then'
      '{$ENDIF SJLJ_BASED_EXCEPTIONS}'
      '    begin'
      '{$IFDEF SJLJ_BASED_EXCEPTIONS}'
      '      Inc(LandingPad);'
      '{$ENDIF SJLJ_BASED_EXCEPTIONS}'
      '      if LandingPad = 0 then'
      '      begin'
      '        Result.FReason := _URC_CONTINUE_UNWIND;'
      '        Exit;'
      '      end;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '      LandingPad := UIntPtr(lpStart) + LandingPad;'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '      if ActionEntry = 0 then'
      '      begin'
      
        '        if (Actions and _UA_CLEANUP_PHASE <> 0) and (Actions and' +
        ' _UA_HANDLER_FRAME = 0) then'
      '        begin'
      '          Result.FTypeIndex := 0;'
      '          Result.FLandingPad := LandingPad;'
      '          Result.FReason := _URC_HANDLER_FOUND;'
      '          Exit;'
      '        end;'
      '        Result.FReason := _URC_CONTINUE_UNWIND;'
      '        Exit;'
      '      end;'
      '      Action := ActionTableStart + (ActionEntry - 1);'
      '      while True do'
      '      begin'
      '        ActionRecord := Action;'
      '        ttypeIndex := ReadSLEB128(Action);'
      '        if ttypeIndex <> 0 then'
      '        begin'
      
        '          HasFilter := GetShimTypeInfo(UInt64(ttypeIndex), Class' +
        'Info, ttypeEncoding, OnClass, cxxName);'
      '          if (not HasFilter) or (not DelphiException) then'
      '          begin'
      
        '            // Found except (no "on" clause) catches everything,' +
        ' including foreign exceptions'
      
        '            // If this is a type 1 search save state and return ' +
        '_URC_HANDLER_FOUND'
      
        '            // If this is a type 2 search save state and return ' +
        '_URC_HANDLER_FOUND'
      
        '            // If this is a type 3 search !_UA_FORCE_UNWIND, we ' +
        'should have found this in phase 1!'
      
        '            // If this is a type 3 search _UA_FORCE_UNWIND, igno' +
        're handler and continue scan'
      
        '            if (Actions and _UA_SEARCH_PHASE <> 0) or (Actions a' +
        'nd _UA_HANDLER_FRAME <> 0) then'
      '            begin'
      '              Result.FTypeIndex := ttypeIndex;'
      '              Result.FActionRecord := ActionRecord;'
      '              Result.FLandingPad := LandingPad;'
      
        '              Result.FAdjustedPtr := GetThrownObject(UnwindExcep' +
        'tion);'
      '              Result.FReason := _URC_HANDLER_FOUND;'
      '              Exit;'
      '            end else if (Actions and _UA_FORCE_UNWIND = 0) then'
      '              Halt;'
      '          end else if DelphiException then'
      '          begin'
      '            RaiseFrame := GetRaiseFrame(UnwindException);'
      
        '            if (RaiseFrame = nil) or (RaiseFrame.ExceptObject = ' +
        'nil) then'
      '              Halt;'
      
        '            if ((OnClass <> nil) and CanHandleException(RaiseFra' +
        'me.ExceptObject, OnClass)) or'
      
        '               ((cxxName <> nil) and CanHandleException(RaiseFra' +
        'me.ExceptObject, cxxName)) then'
      '            begin'
      '              // Found a matching handler'
      
        '              // If this is a type 1 search save state and retur' +
        'n _URC_HANDLER_FOUND'
      
        '              // If this is a type 3 search and !_UA_FORCE_UNWIN' +
        'D, we should have found this in phase 1!'
      
        '              // If this is a type 3 search and _UA_FORCE_UNWIND' +
        ', ignore handler and continue scan'
      '              if Actions and _UA_SEARCH_PHASE <> 0 then'
      '              begin'
      '                // Save state and return _URC_HANDLER_FOUND'
      '                Result.FTypeIndex := ttypeIndex;'
      '                Result.FActionRecord := ActionRecord;'
      '                Result.FLandingPad := LandingPad;'
      
        '                Result.FAdjustedPtr := GetThrownObject(UnwindExc' +
        'eption);'
      '                Result.FReason := _URC_HANDLER_FOUND;'
      '                Exit;'
      '              end else if Actions and _UA_FORCE_UNWIND = 0 then'
      '                // It looks like the exception table has changed'
      '                //    on us.  Likely stack corruption!'
      '                Halt;'
      '            end;'
      '          end else'
      '          begin'
      
        '            // For not-Delphi exception (C++ exception maybe) wi' +
        'th no "on" clause.'
      '            // TBD.'
      '          end'
      '        end else'
      '        begin'
      '          // Found a cleanup'
      
        '          // If this is a type 1 search, ignore it and continue ' +
        'scan'
      
        '          // If this is a type 2 search, ignore it and continue ' +
        'scan'
      
        '          // If this is a type 3 search, save state and return _' +
        'URC_HANDLER_FOUND'
      
        '          if (Actions and _UA_CLEANUP_PHASE <> 0) and (Actions a' +
        'nd _UA_HANDLER_FRAME = 0) then'
      '          begin'
      '            // Save state and return _URC_HANDLER_FOUND'
      '            Result.FTypeIndex := ttypeIndex;'
      '            Result.FActionRecord := ActionRecord;'
      '            Result.FLandingPad := LandingPad;'
      
        '            Result.FAdjustedPtr := GetThrownObject(UnwindExcepti' +
        'on);'
      '            Result.FReason := _URC_HANDLER_FOUND;'
      '            Exit;'
      '          end;'
      '        end;'
      '        Temp := Action;'
      '        ActionOffset := ReadSLEB128(Temp);'
      '        if ActionOffset = 0 then'
      '        begin'
      '          Result.FReason := _URC_CONTINUE_UNWIND;'
      '          Exit;'
      '        end;'
      '        Inc(Action, ActionOffset);'
      '      end;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '    end else if IpOffset < Start then'
      '    begin'
      '      Result.FReason := _URC_CONTINUE_UNWIND;'
      '      Exit;'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure SetRegisters(var UnwindException: _Unwind_Exception; C' +
        'ontext: PUnwind_Context; var Results: TScanResults);'
      'begin'
      '  _Unwind_SetGR(Context, 0, UIntPtr(@UnwindException));'
      '{$IF Defined(CPUARM) or Defined(CPUX64)}'
      '  _Unwind_SetGR(Context, 1, UIntPtr(Results.FTypeIndex));'
      '{$ELSEIF Defined(CPUX86_LLVM) or Defined(CPUX86)}'
      '  _Unwind_SetGR(Context, 2, UIntPtr(Results.FTypeIndex));'
      '{$ELSE}'
      '  {$MESSAGE ERROR '#39'Unknown Architecture'#39'}'
      '{$ENDIF}'
      '  _Unwind_SetIP(Context, Results.FLandingPad);'
      'end;'
      ''
      
        '// The personality routine for DWARF exception information is ba' +
        'sed on the code from libc++abi'
      ''
      'type'
      '  TCPPExceptionDestructor = procedure(obj: UIntPtr);'
      '  _CXA_EXCEPTION = packed record'
      
        '{$IF Defined(LONGINT64) or ((not Defined(MACOS)) and Defined(CPU' +
        'ARM32) and (not Defined(SJLJ_BASED_EXCEPTIONS))) }'
      '    referenceCount: NativeUInt;'
      '{$ENDIF}'
      '    exceptionType: UIntPtr;'
      '    exceptionDestructor: TCPPExceptionDestructor;'
      '    unexpectedHandler: UIntPtr;'
      '    terminateHandler: UIntPtr;'
      '    nextException: UIntPtr;'
      '    handlerCount: Int32;'
      ''
      
        '{$IF (not Defined(MACOS)) and Defined(CPUARM32) and (not Defined' +
        '(SJLJ_BASED_EXCEPTIONS)) }'
      '    nextPropagatingException: UIntPtr;'
      '    propagationCount: Integer;'
      '{$ELSE}'
      '    handlerSwitchValue: Int32;'
      '    actionRecord: UIntPtr;'
      '    languageSpecificData: UIntPtr;'
      '    catchTemp: UIntPtr;'
      '    adjustedPtr: UIntPtr;'
      '{$ENDIF}'
      
        '{$IF not (Defined(LONGINT64) or ((not Defined(MACOS)) and Define' +
        'd(CPUARM32) and (not Defined(SJLJ_BASED_EXCEPTIONS))))}'
      '    referenceCount: NativeUInt;'
      '{$ENDIF}'
      '    unwindHeader: _Unwind_Exception;'
      '  end;'
      '  TCXA_EXCEPTION = _CXA_EXCEPTION;'
      '  PCXA_EXCEPTION = ^TCXA_EXCEPTION;'
      ''
      
        '{$IF     Defined(MACOS) or (Defined(LINUX) and (Defined(CPUX86) ' +
        'or Defined(CPUX64)))}'
      '{$I ex.inc}'
      '{$ELSEIF Defined(ANDROID) and Defined(CPUARM)}'
      '// ZCX_BASED_EXCEPTIONS'
      '  {$IF     defined(ANDROID32)}'
      '{$I ex.android.arm.inc}'
      '  {$ELSEIF defined(ANDROID64)}'
      '{$I ex.android.arm64.inc}'
      '  {$ELSE }'
      '{$MESSAGE ERROR '#39'Definition error.'#39'}'
      '  {$ENDIF}'
      '{$ELSEIF Defined(LINUX) and Defined(CPUARM32)}'
      '{$I ex.linux.arm.inc}'
      '{$ELSEIF Defined(LINUX) and Defined(CPUARM64)}'
      '{$I ex.android.arm64.inc}'
      '{$ELSE }'
      '{$MESSAGE ERROR '#39'Missing architecture'#39'}'
      '{$ENDIF}'
      ''
      
        '{$ENDIF !PC_MAPPED_EXCEPTIONS & !STACK_BASED_EXCEPTIONS & !TABLE' +
        '_BASED_EXCEPTIONS & !SJLJ_BASED_EXCEPTIONS} // ZCX_BASED_EXCEPTI' +
        'ONS'
      ''
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      
        'procedure _DestroyException(var UnwindException: _Unwind_Excepti' +
        'on);'
      'var'
      '  CurRaiseFrame: PRaiseFrame;'
      '  ExceptObject: TObject;'
      '  ExceptAddr: Pointer;'
      '  RaiseFramePtr: PRaiseFrame;'
      '  OriginalFramePtr: PRaiseFrame;'
      '  ExceptionFrame: Pointer;'
      '  LHandlerSwitchValue: Integer;'
      '  LActionRecord: PByte;'
      '  LLanguageSpecificData: PByte;'
      '  LCatchTemp: Pointer;'
      '  LAdjustedPtr: Pointer;'
      'begin'
      '  // CurRaiseFrame^.ExceptObject is'
      
        '  //     nil -> re-raised exception was thrown by another domain' +
        '.'
      '  //            Pop and destroy old frame on the top.'
      '  // not nil -> re-raised exception was thrown by same domain.'
      '  //            Pop and Destroy old frame on the 2nd.'
      '  // CurRaiseFrame^.NextRaise is'
      
        '  //     nil -> re-raised exception will be catched in another d' +
        'omain.'
      '  //            Pop and destroy old frame on the top.'
      
        '  // not nil -> re-raised exception will be catched in the same ' +
        'domain.'
      '  //            Pop and Destroy old frame on the 2nd.'
      '  // Pop and save top of exception object list'
      '  CurRaiseFrame := PopRaiseFrame;'
      '  ExceptObject := CurRaiseFrame^.ExceptObject;'
      '  ExceptAddr := CurRaiseFrame^.ExceptAddr;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '  ExceptionFrame := CurRaiseFrame^.ExceptionFramePtr;'
      '  LHandlerSwitchValue := CurRaiseFrame^.HandlerSwitchValue;'
      '  LActionRecord := CurRaiseFrame^.ActionRecord;'
      '  LLanguageSpecificData := CurRaiseFrame^.LanguageSpecificData;'
      '  LCatchTemp := CurRaiseFrame^.CatchTemp;'
      '  LAdjustedPtr := CurRaiseFrame^.AdjustedPtr;'
      '{$ENDIF}'
      '                                                       '
      '//  CurRaiseFrame^.ExceptObject := nil;'
      '  OriginalFramePtr := CurRaiseFrame;'
      '  ReleaseRaiseFrame(CurRaiseFrame);'
      ''
      '  if Assigned(RaiseListPtr) and Assigned(ExceptObject) then'
      '  begin'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '    // Peek top exception.'
      
        '    while (RaiseListPtr <> Nil) and (PRaiseFrame(RaiseListPtr).E' +
        'xceptionFramePtr = ExceptionFrame) do'
      '    begin'
      '      // Pop and release top of exception object list'
      '      CurRaiseFrame := PopRaiseFrame;'
      ''
      '      if CurRaiseFrame^.ExceptObject <> nil then'
      '      begin'
      '        CurRaiseFrame^.ExceptObject.Free;'
      '        CurRaiseFrame^.ExceptObject := nil;'
      '      end;'
      '      ReleaseRaiseFrame(CurRaiseFrame);'
      '    end;'
      '{$ELSE}'
      '    // Pop and release top of exception object list'
      '    CurRaiseFrame := PopRaiseFrame;'
      '    // Destroy exception object'
      '    if CurRaiseFrame^.ExceptObject <> nil then'
      '    begin'
      '      CurRaiseFrame^.ExceptObject.Free;'
      '      CurRaiseFrame^.ExceptObject := nil;'
      '    end;'
      '    ReleaseRaiseFrame(CurRaiseFrame);'
      '{$ENDIF}'
      '    // Restore saved exception object list'
      '    RaiseFramePtr := AllocateRaiseFrame;'
      '    RaiseFramePtr.ExceptAddr := ExceptAddr;'
      '    RaiseFramePtr.ExceptObject := ExceptObject;'
      
        '{$IF Defined(ZCX_BASED_EXCEPTIONS) or Defined(ZCX_BASED_EXCEPTIO' +
        'NS_MACOS)}'
      '    RaiseFramePtr.ExceptionFramePtr := ExceptionFrame;'
      ''
      '    RaiseFramePtr.HandlerSwitchValue := LHandlerSwitchValue;'
      '    RaiseFramePtr.ActionRecord := LActionRecord;'
      '    RaiseFramePtr.LanguageSpecificData := LLanguageSpecificData;'
      '    RaiseFramePtr.CatchTemp := LCatchTemp;'
      '    RaiseFramePtr.AdjustedPtr := LAdjustedPtr;'
      '{$ENDIF}'
      
        '                                                                ' +
        '              '
      '    RaiseFramePtr.PrevRaise := OriginalFramePtr;'
      '    LinkRaiseFrame(RaiseFramePtr);'
      '  end;'
      'end;'
      ''
      'procedure _DoneExcept(var UnwindException: _Unwind_Exception);'
      'var'
      '  CurRaiseFrame: PRaiseFrame;'
      'begin'
      '  CurRaiseFrame := PopRaiseFrame;'
      '  // Destroy exception object'
      '  if CurRaiseFrame^.ExceptObject <> nil then'
      '  begin'
      '     CurRaiseFrame^.ExceptObject.Free;'
      '     CurRaiseFrame^.ExceptObject := nil;'
      '  end;'
      '  if (CurRaiseFrame^.PrevRaise <> nil) and'
      
        '     ((CurRaiseFrame^.PrevRaise)^.NextRaise = CurRaiseFrame) the' +
        'n'
      '  begin'
      '    (CurRaiseFrame^.PrevRaise)^.ExceptObject := nil;'
      '    CurRaiseFrame^.PrevRaise := nil;'
      '  end;'
      '  ReleaseRaiseFrame(CurRaiseFrame);'
      'end;'
      ''
      
        'procedure _DoneExceptUCB(var UnwindException: _Unwind_Control_Bl' +
        'ock);'
      'var'
      '  Dummy: _Unwind_Exception;'
      'begin'
      '  _DoneExcept(Dummy);'
      'end;'
      ''
      'procedure _UnhandledException;'
      'type'
      '  TExceptProc = procedure (const Obj: TObject; Addr: Pointer);'
      'var'
      '  ExceptionObject: TObject;'
      '  ExceptionAddress: Pointer;'
      'begin'
      '  ExceptionObject := ExceptObject;'
      '  ExceptionAddress := ExceptAddr;'
      '  NotifyUnhandled(ExceptionObject, ExceptionAddress);'
      '  if Assigned(ExceptProc) then'
      '    TExceptProc(ExceptProc)(ExceptionObject, ExceptionAddress);'
      '  RunErrorAt(217, ExceptionAddress); // reControlBreak'
      'end;'
      '{$ENDIF ZCX_BASED_EXCEPTIONS or ZCX_BASED_EXCEPTIONS_MACOS}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '{'
      
        '  Used in the PC mapping exception implementation to handle exce' +
        'ptions in constructors.'
      '}'
      'procedure       _ClassHandleException;'
      'asm'
      '  {'
      '  EAX = Ptr to TRaisedException'
      '  EDX = self'
      '  ECX = top flag'
      '  }'
      '        PUSH     ECX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL     LinkException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        MOV      EAX,EDX'
      '        POP      EDX'
      '        TEST     DL, DL'
      '        JE       _RaiseAgain'
      '        MOV      ECX,[EAX]'
      '        MOV      DL,$81'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH     EAX'
      '        CALL     DWORD PTR [ECX] + VMTOFFSET TObject.Destroy'
      '        POP      EAX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        CALL     _ClassDestroy'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        JMP      _RaiseAgain'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '                                                               '
      'procedure       _RaiseAgain;'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    CurrentException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      
        '// The following notifies the debugger of a reraise of exception' +
        's.  This will'
      '// be supported in a later release, but is disabled for now.'
      '//        PUSH    EAX'
      '//        MOV     EDX, [EAX].TRaisedException.ExceptionAddr'
      '//        MOV     EAX, [EAX].TRaisedException.ExceptObject'
      
        '//        CALL    NotifyReRaise                   { Tell the deb' +
        'ugger }'
      '//        POP     EAX'
      '        TEST    [EAX].TRaisedException.Flags, excIsBeingHandled'
      '        JZ      @@DoIt'
      '        OR      [EAX].TRaisedException.Flags, excIsBeingReRaised'
      '@@DoIt:'
      '        PUSH    EAX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    UnlinkException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EAX'
      
        '        MOV     EDX, [ESP]                      { Get the user'#39's' +
        ' addr }'
      '        JMP     SysRaiseException'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'asm'
      '        { ->    [ESP        ] return address to user program }'
      '        {       [ESP+ 4     ] raise list entry (4 dwords)    }'
      '        {       [ESP+ 4+ 4*4] saved topmost frame            }'
      '        {       [ESP+ 4+ 5*4] saved registers (4 dwords)     }'
      '        {       [ESP+ 4+ 9*4] return address to OS           }'
      '        { ->    [ESP+ 4+10*4] excPtr: PExceptionRecord       }'
      '        {       [ESP+ 8+10*4] errPtr: PExcFrame              }'
      ''
      
        '        { Point the error handler of the exception frame to some' +
        'thing harmless }'
      ''
      '        MOV     EAX,[ESP+8+10*4]'
      '        MOV     [EAX].TExcFrame.desc,offset @@exit'
      ''
      '        { Pop the RaiseList }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        MOV     EDX,[EAX].RaiseListPtr'
      '        MOV     ECX,[EDX].TRaiseFrame.NextRaise'
      '        MOV     [EAX].RaiseListPtr,ECX'
      ''
      
        '        { Destroy any objects created for non-delphi exceptions ' +
        '}'
      ''
      '        MOV     EAX,[EDX].TRaiseFrame.ExceptionRecord'
      
        '        AND     [EAX].TExceptionRecord.ExceptionFlags,NOT cUnwin' +
        'ding'
      
        '        CMP     [EAX].TExceptionRecord.ExceptionCode,cDelphiExce' +
        'ption'
      '        JE      @@delphiException'
      '        MOV     EAX,[EDX].TRaiseFrame.ExceptObject'
      '{$IFDEF AUTOREFCOUNT}'
      '        OR      EAX,EAX'
      '        JE      @@Notify'
      '        MOV     ECX,[EAX]'
      '        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease'
      '{$ELSE}'
      '        CALL    TObject.Free'
      '{$ENDIF}'
      '@@Notify:'
      '        CALL    NotifyReRaise'
      ''
      '@@delphiException:'
      ''
      '        XOR     EAX,EAX'
      '        ADD     ESP,5*4'
      '        MOV     EDX,FS:[EAX]'
      '        POP     ECX'
      '        MOV     EDX,[EDX].TExcFrame.next'
      '        MOV     [ECX].TExcFrame.next,EDX'
      ''
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '@@exit:'
      '        MOV     EAX,1'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IF defined(TABLE_BASED_EXCEPTIONS) or'
      '     defined(SJLJ_BASED_EXCEPTIONS)  or'
      '     defined(ZCX_BASED_EXCEPTIONS) or'
      '     defined(ZCX_BASED_EXCEPTIONS_MACOS) }'
      'var'
      '  CurRaiseFrame: PRaiseFrame;'
      '  ExceptObject: TObject;'
      '  ExceptAddr: Pointer;'
      'begin'
      '  CurRaiseFrame := RaiseListPtr;'
      '  ExceptObject := CurRaiseFrame^.ExceptObject;'
      '  ExceptAddr := CurRaiseFrame^.ExceptAddr;'
      '  CurRaiseFrame^.ExceptObject := nil;'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '  NotifyReRaise(ExceptObject, ExceptAddr);'
      '{$ENDIF }'
      '  _RaiseAtExcept(ExceptObject, ExceptAddr);'
      'end;'
      
        '{$ENDIF !PC_MAPPED_EXCEPTIONS & !STACK_BASED_EXCEPTIONS & !TABLE' +
        '_BASED_EXCEPTIONS & !SJLJ_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '{'
      
        '  This is implemented slow and dumb.  The theory is that it is r' +
        'are'
      
        '  to throw an exception past an except handler, and that the pen' +
        'alty'
      
        '  can be particularly high here.  Partly it'#39's done the dumb way ' +
        'for'
      '  the sake of maintainability.  It could be inlined.'
      '}'
      'procedure       _DestroyException;'
      'var'
      '  Exc: PRaisedException;'
      '  RefCount: Integer;'
      '  ExcObj: Pointer;'
      '  ExcAddr: Pointer;'
      'begin'
      '  asm'
      '        CMP     ECX, UW_EXC_CLASS_BORLANDCPP'
      '        JNE     @@notCPP'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    SysRaiseCPPException'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '@@notCPP:'
      '    MOV     Exc, EAX'
      '  end;'
      ''
      '  if (Exc^.Flags and excIsBeingReRaised) = 0 then'
      '  begin'
      '    RefCount := Exc^.RefCount;'
      '    ExcObj := Pointer(Exc^.ExceptObject);'
      '    ExcAddr := Exc^.ExceptionAddr;'
      '    Exc^.RefCount := 1;'
      '    FreeException;'
      '    _DoneExcept;'
      '    Exc := AllocateException(ExcObj, ExcAddr);'
      '    Exc^.RefCount := RefCount;'
      '  end;'
      ''
      
        '  Exc^.Flags := Exc^.Flags and not (excIsBeingReRaised or excIsB' +
        'eingHandled);'
      ''
      '  SysRaiseException(Exc);'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      
        'procedure _DestroyException(ExceptionPointers: PExceptionPointer' +
        's; EstablisherFrame: NativeUInt);'
      'var'
      '  CurRaiseFrame: PRaiseFrame;'
      '  ExceptObject: Pointer;'
      '  ExceptAddr: Pointer;'
      '  RaiseFramePtr: PRaiseFrame;'
      'begin'
      '  // CurRaiseFrame^.ExceptObject is'
      '  //     nil -> re-raised exception was thrown by another'
      
        '  //            domain (DLL / EXE). Pop and destroy old frame on' +
        ' the top.'
      '  // not nil -> re-raised exception was thrown by same'
      '  //            domain. Pop and Destroy old frame on the 2nd.'
      '  // CurRaiseFrame^.NextRaise is'
      '  //     nil -> re-raised exception will be catched in another'
      
        '  //            domain (DLL / EXE). Pop and destroy old frame on' +
        ' the top.'
      '  // not nil -> re-raised exception will be catched in the same'
      '  //            domain. Pop and Destroy old frame on the 2nd.'
      '  // Pop and save top of exception object list'
      '  CurRaiseFrame := PopRaiseFrame;'
      '  ExceptObject := CurRaiseFrame^.ExceptObject;'
      '  ExceptAddr := CurRaiseFrame^.ExceptAddr;'
      '  CurRaiseFrame^.ExceptObject := nil;'
      '  ReleaseRaiseFrame(CurRaiseFrame);'
      ''
      '  if Assigned(RaiseListPtr) and Assigned(ExceptObject) then'
      '  begin'
      '    // Pop and release top of exception object list'
      '    CurRaiseFrame := PopRaiseFrame;'
      '    // Destroy exception object'
      '    if CurRaiseFrame^.ExceptObject <> nil then'
      '       TObject(CurRaiseFrame^.ExceptObject).Free;'
      '    ReleaseRaiseFrame(CurRaiseFrame);'
      ''
      '    // Restore saved exception object list'
      '    RaiseFramePtr := AllocateRaiseFrame;'
      '    RaiseFramePtr.ExceptAddr := ExceptAddr;'
      '    RaiseFramePtr.ExceptObject := ExceptObject;'
      '    LinkRaiseFrame(RaiseFramePtr);'
      '  end;'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '{$IF Defined(SJLJ_BASED_EXCEPTIONS)}'
      
        'procedure _DestroyException(var UnwindException: _Unwind_Excepti' +
        'on);'
      'var'
      '  CurRaiseFrame: PRaiseFrame;'
      '  ExceptObject: TObject;'
      '  ExceptAddr: Pointer;'
      '  RaiseFramePtr: PRaiseFrame;'
      '  OriginalFramePtr: PRaiseFrame;'
      'begin'
      '  // CurRaiseFrame^.ExceptObject is'
      
        '  //     nil -> re-raised exception was thrown by another domain' +
        '.'
      '  //            Pop and destroy old frame on the top.'
      '  // not nil -> re-raised exception was thrown by same domain.'
      '  //            Pop and Destroy old frame on the 2nd.'
      '  // CurRaiseFrame^.NextRaise is'
      
        '  //     nil -> re-raised exception will be catched in another d' +
        'omain.'
      '  //            Pop and destroy old frame on the top.'
      
        '  // not nil -> re-raised exception will be catched in the same ' +
        'domain.'
      '  //            Pop and Destroy old frame on the 2nd.'
      '  // Pop and save top of exception object list'
      '  CurRaiseFrame := PopRaiseFrame;'
      '  ExceptObject := CurRaiseFrame^.ExceptObject;'
      '  ExceptAddr := CurRaiseFrame^.ExceptAddr;'
      '                                                       '
      '//  CurRaiseFrame^.ExceptObject := nil;'
      '  OriginalFramePtr := CurRaiseFrame;'
      '  ReleaseRaiseFrame(CurRaiseFrame);'
      ''
      '  if Assigned(RaiseListPtr) and Assigned(ExceptObject) then'
      '  begin'
      '    // Pop and release top of exception object list'
      '    CurRaiseFrame := PopRaiseFrame;'
      '    // Destroy exception object'
      '    if CurRaiseFrame^.ExceptObject <> nil then'
      '    begin'
      '      CurRaiseFrame^.ExceptObject.Free;'
      '      CurRaiseFrame^.ExceptObject := nil;'
      '    end;'
      '    ReleaseRaiseFrame(CurRaiseFrame);'
      ''
      '    // Restore saved exception object list'
      '    RaiseFramePtr := AllocateRaiseFrame;'
      '    RaiseFramePtr.ExceptAddr := ExceptAddr;'
      '    RaiseFramePtr.ExceptObject := ExceptObject;'
      
        '                                                                ' +
        '              '
      '    RaiseFramePtr.PrevRaise := OriginalFramePtr;'
      '    LinkRaiseFrame(RaiseFramePtr);'
      '  end;'
      'end;'
      '{$ENDIF SJLJ_BASED_EXCEPTIONS}'
      ''
      '                                                               '
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure _DoneExcept;'
      'asm //StackAlignSafe'
      '{$IFDEF ALIGN_STACK}'
      '        {'
      
        '          We do one alignment call for the entire function as th' +
        'ere are no'
      '          other stack adjustments made in the function body.'
      '        }'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    FreeException'
      '        OR      EAX, EAX'
      '        JE      @@Done'
      '{$IFDEF AUTOREFCOUNT}'
      '        MOV     ECX,[EAX]'
      '        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease'
      '{$ELSE}'
      '        CALL    TObject.Free'
      '{$ENDIF}'
      '@@Done:'
      '        CALL    UnlinkException'
      '        {'
      '          Take a peek at the next exception object on the stack.'
      
        '          If its EBP marker is at an address lower than our curr' +
        'ent'
      
        '          EBP, then we know that it was orphaned when an excepti' +
        'on was'
      
        '          thrown from within the execution of a finally block.  ' +
        'We clean'
      
        '          it up now, so that we won'#39't leak exception records/obj' +
        'ects.'
      '        }'
      '        CALL    CurrentException'
      '        OR      EAX, EAX'
      '        JE      @@Done2'
      '        CMP     [EAX].TRaisedException.HandlerEBP, EBP'
      '        JA      @@Done2'
      '        CALL    FreeException'
      '        OR      EAX, EAX'
      '        JE      @@Done2'
      '{$IFDEF AUTOREFCOUNT}'
      '        MOV     ECX,[EAX]'
      '        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease'
      '{$ELSE}'
      '        CALL    TObject.Free'
      '{$ENDIF}'
      '@@Done2:'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure _DoneExcept;'
      'asm'
      '        { ->    [ESP+ 4+10*4] excPtr: PExceptionRecord       }'
      '        {       [ESP+ 8+10*4] errPtr: PExcFrame              }'
      ''
      '        { Pop the RaiseList }'
      ''
      '        CALL    SysInit.@GetTLS'
      '        MOV     EDX,[EAX].RaiseListPtr'
      '        MOV     ECX,[EDX].TRaiseFrame.NextRaise'
      '        MOV     [EAX].RaiseListPtr,ECX'
      ''
      '        { Destroy exception object }'
      ''
      '        MOV     EAX,[EDX].TRaiseFrame.ExceptObject'
      '{$IFDEF AUTOREFCOUNT}'
      '        OR      EAX,EAX'
      '        JE      @@Done'
      '        MOV     ECX,[EAX]'
      '        CALL    DWORD PTR [ECX] + VMTOFFSET TObject.__ObjRelease'
      '{$ELSE}'
      '        CALL    TObject.Free'
      '{$ENDIF}'
      '@@Done:'
      ''
      '        POP     EDX'
      '        MOV     ESP,[ESP+8+9*4]'
      '        XOR     EAX,EAX'
      '        POP     ECX'
      '        MOV     FS:[EAX],ECX'
      '        POP     EAX'
      '        POP     EBP'
      '        CALL    NotifyTerminate'
      '        JMP     EDX'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IF Defined(TABLE_BASED_EXCEPTIONS)}'
      'procedure _DoneExcept;'
      'var'
      '  TargetIp: NativeUInt;'
      '  CurRaiseFrame: PRaiseFrame;'
      'begin'
      '  CurRaiseFrame := PopRaiseFrame;'
      '  // Destroy exception object'
      '  if CurRaiseFrame^.ExceptObject <> nil then'
      '     CurRaiseFrame^.ExceptObject.Free;'
      '  ReleaseRaiseFrame(CurRaiseFrame);'
      '  TargetIp := UIntPtr(ReturnAddress);'
      '  NotifyTerminate(TargetIp);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '{$IF Defined(SJLJ_BASED_EXCEPTIONS)}'
      'procedure _DoneExcept(var UnwindException: _Unwind_Exception);'
      'var'
      '  CurRaiseFrame: PRaiseFrame;'
      'begin'
      '  CurRaiseFrame := PopRaiseFrame;'
      '  // Destroy exception object'
      '  if CurRaiseFrame^.ExceptObject <> nil then'
      '  begin'
      '     CurRaiseFrame^.ExceptObject.Free;'
      '     CurRaiseFrame^.ExceptObject := nil;'
      '  end;'
      '  if (CurRaiseFrame^.PrevRaise <> nil) and'
      
        '     ((CurRaiseFrame^.PrevRaise)^.NextRaise = CurRaiseFrame) the' +
        'n'
      '  begin'
      '    (CurRaiseFrame^.PrevRaise)^.ExceptObject := nil;'
      '    CurRaiseFrame^.PrevRaise := nil;'
      '  end;'
      '  ReleaseRaiseFrame(CurRaiseFrame);'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '   '
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure _TryFinallyExit;'
      'asm'
      '        XOR     EDX,EDX'
      '        MOV     ECX,[ESP+4].TExcFrame.desc'
      '        MOV     EAX,[ESP+4].TExcFrame.next'
      '        ADD     ECX,TExcDesc.instructions'
      '        MOV     FS:[EDX],EAX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB      ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    ECX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD      ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '@@1:    RET     12'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      
        'procedure _TryFinallyExit(EstablisherFrame: NativeUInt; TargetAd' +
        'dr: NativeUInt);'
      'var'
      '  Context: TContext;'
      'begin'
      '  RtlUnwindEx(EstablisherFrame, TargetAddr,'
      '              nil, 0,         // PExceptionRecord, ReturnValue'
      '              @Context, nil); // PContext, PUnwindHistoryTable'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure       MapToRunError(P: PExceptionRecord); stdcall;'
      'const'
      '  STATUS_ACCESS_VIOLATION         = $C0000005;'
      '  STATUS_ARRAY_BOUNDS_EXCEEDED    = $C000008C;'
      '  STATUS_FLOAT_DENORMAL_OPERAND   = $C000008D;'
      '  STATUS_FLOAT_DIVIDE_BY_ZERO     = $C000008E;'
      '  STATUS_FLOAT_INEXACT_RESULT     = $C000008F;'
      '  STATUS_FLOAT_INVALID_OPERATION  = $C0000090;'
      '  STATUS_FLOAT_OVERFLOW           = $C0000091;'
      '  STATUS_FLOAT_STACK_CHECK        = $C0000092;'
      '  STATUS_FLOAT_UNDERFLOW          = $C0000093;'
      '  STATUS_INTEGER_DIVIDE_BY_ZERO   = $C0000094;'
      '  STATUS_INTEGER_OVERFLOW         = $C0000095;'
      '  STATUS_PRIVILEGED_INSTRUCTION   = $C0000096;'
      '  STATUS_STACK_OVERFLOW           = $C00000FD;'
      '  STATUS_CONTROL_C_EXIT           = $C000013A;'
      'var'
      '  ErrCode: Byte;'
      'begin'
      '  case P.ExceptionCode of'
      
        '    STATUS_INTEGER_DIVIDE_BY_ZERO:  ErrCode := 200; { reDivByZer' +
        'o }'
      
        '    STATUS_ARRAY_BOUNDS_EXCEEDED:   ErrCode := 201; { reRangeErr' +
        'or }'
      
        '    STATUS_FLOAT_OVERFLOW:          ErrCode := 205; { reOverflow' +
        ' }'
      '    STATUS_FLOAT_INEXACT_RESULT,'
      '    STATUS_FLOAT_INVALID_OPERATION,'
      
        '    STATUS_FLOAT_STACK_CHECK:       ErrCode := 207; { reInvalidO' +
        'p }'
      
        '    STATUS_FLOAT_DIVIDE_BY_ZERO:    ErrCode := 200; { reZeroDivi' +
        'de }'
      
        '    STATUS_INTEGER_OVERFLOW:        ErrCode := 215; { reIntOverf' +
        'low}'
      '    STATUS_FLOAT_UNDERFLOW,'
      
        '    STATUS_FLOAT_DENORMAL_OPERAND:  ErrCode := 206; { reUnderflo' +
        'w }'
      
        '    STATUS_ACCESS_VIOLATION:        ErrCode := 216; { reAccessVi' +
        'olation }'
      
        '    STATUS_PRIVILEGED_INSTRUCTION:  ErrCode := 218; { rePrivInst' +
        'ruction }'
      
        '    STATUS_CONTROL_C_EXIT:          ErrCode := 217; { reControlB' +
        'reak }'
      
        '    STATUS_STACK_OVERFLOW:          ErrCode := 202; { reStackOve' +
        'rflow }'
      '  else                              ErrCode := 255;'
      '  end;'
      '  RunErrorAt(ErrCode, P.ExceptionAddress);'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '     '
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure       _ExceptionHandler;'
      'asm'
      '        MOV     EAX,[ESP+4]'
      ''
      
        '        TEST    [EAX].TExceptionRecord.ExceptionFlags,cUnwindInP' +
        'rogress'
      '        JNE     @@exit'
      '{$IFDEF MSWINDOWS}'
      '        CMP     BYTE PTR DebugHook,0'
      '        JA      @@ExecuteHandler'
      '        LEA     EAX,[ESP+4]'
      '        PUSH    EAX'
      '        CALL    UnhandledExceptionFilter'
      '        CMP     EAX,EXCEPTION_CONTINUE_SEARCH'
      '        //JNE     @@ExecuteHandler'
      '        //JMP     @@exit'
      '        JE      @@exit'
      '{$ENDIF MSWINDOWS}'
      ''
      '@@ExecuteHandler:'
      '        MOV     EAX,[ESP+4]'
      '        CLD'
      '        CALL    _FpuInit'
      '        MOV     EDX,[ESP+8]'
      ''
      '        PUSH    0'
      '        PUSH    EAX'
      '        PUSH    offset @@returnAddress'
      '        PUSH    EDX'
      '        CALL    RtlUnwindProc'
      ''
      '@@returnAddress:'
      '        MOV     EBX,[ESP+4]'
      
        '        CMP     [EBX].TExceptionRecord.ExceptionCode,cDelphiExce' +
        'ption'
      '        MOV     EDX,[EBX].TExceptionRecord.ExceptAddr'
      '        MOV     EAX,[EBX].TExceptionRecord.ExceptObject'
      '        JE      @@DelphiException2'
      ''
      '        MOV     EDX,ExceptObjProc'
      '        TEST    EDX,EDX'
      '        JE      MapToRunError'
      '        MOV     EAX,EBX'
      '        CALL    EDX'
      '        TEST    EAX,EAX'
      '        JE      MapToRunError'
      '        MOV     EDX,[EBX].TExceptionRecord.ExceptionAddress'
      ''
      '@@DelphiException2:'
      ''
      '        CALL    NotifyUnhandled'
      '        MOV     ECX,ExceptProc'
      '        TEST    ECX,ECX'
      '        JE      @@noExceptProc'
      
        '        CALL    ECX             { call ExceptProc(ExceptObject, ' +
        'ExceptAddr) }'
      ''
      '@@noExceptProc:'
      '        MOV     ECX,[ESP+4]'
      '        MOV     EAX,217'
      '        MOV     EDX,[ECX].TExceptionRecord.ExceptAddr'
      '        MOV     [ESP],EDX'
      '        JMP     _RunError'
      ''
      '@@exit:'
      '        XOR     EAX,EAX'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '                              '
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure  SetExceptionHandler(Context: PInitContext);'
      'asm'
      '        { ->    EAX   PInitContext'
      
        '        { ->    [EBP-type(TExcFrame)] TExcFrame local (returned ' +
        'in EAX) }'
      ''
      '        PUSH    EAX               { Save off Context pointer }'
      
        '        XOR     EDX,EDX           { using [EDX] saves some space' +
        ' over [0] }'
      '        LEA     EAX,[EBP-type(TExcFrame)]'
      
        '        MOV     ECX,FS:[EDX]      { ECX := head of chain        ' +
        '          }'
      
        '        MOV     FS:[EDX],EAX      { head of chain := @exRegRec  ' +
        '          }'
      ''
      '        MOV     [EAX].TExcFrame.next,ECX'
      '{$IFDEF PIC}'
      '        LEA     EDX,[EBX]._ExceptionHandler'
      '        MOV     [EAX].TExcFrame.desc,EDX'
      '{$ELSE}'
      '        MOV     [EAX].TExcFrame.desc,offset _ExceptionHandler'
      '{$ENDIF}'
      '        MOV     [EAX].TExcFrame.hEBP,EBP'
      '        POP     ECX               { Restore Context pointer }'
      '        MOV     [ECX].TInitContext.ExcFrame,EAX'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '                                '
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      'procedure       UnsetExceptionHandler(Context: PInitContext);'
      'asm'
      '        { ->    EAX   PInitContext }'
      ''
      '        MOV     EAX,[EAX].TInitContext.ExcFrame'
      '        XOR     EDX,EDX'
      '        TEST    EAX,EAX'
      '        JZ      @@exit'
      ''
      
        '        MOV     ECX,FS:[EDX]    { ECX := head of chain          ' +
        '}'
      
        '        CMP     EAX,ECX         { simple case: our record is fir' +
        'st      }'
      '        JNE     @@search'
      
        '        MOV     EAX,[EAX]       { head of chain := exRegRec.next' +
        '        }'
      '        MOV     FS:[EDX],EAX'
      '        JMP     @@exit'
      ''
      '@@loop:'
      '        MOV     ECX,[ECX]'
      '@@search:'
      
        '        CMP     ECX,-1          { at end of list?               ' +
        '        }'
      
        '        JE      @@exit          { yes - didn'#39't find it          ' +
        '}'
      
        '        CMP     [ECX],EAX       { is it the next one on the list' +
        '?       }'
      
        '        JNE     @@loop          { no - look at next one on list ' +
        '}'
      
        '@@unlink:                       { yes - unlink our record       ' +
        '        }'
      
        '        MOV     EAX,[EAX]       { get next record on list       ' +
        '        }'
      
        '        MOV     [ECX],EAX       { unlink our record             ' +
        '        }'
      '@@exit:'
      'end;'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      ''
      ''
      '{$IFDEF ANDROID}'
      
        'function AllocateExceptionFrame(const Obj: TObject; Address: Nat' +
        'iveUInt): NativeUInt;'
      'var'
      '  RaiseFramePtr: PRaiseFrame;'
      '  ExceptionRecord: TExceptionRecord;'
      'begin'
      ''
      '  if RaiseExceptObjProc <> nil then'
      '  begin'
      '    ExceptionRecord.ExceptObject := Obj;'
      '    TRaiseExceptObjProc(RaiseExceptObjProc)(@ExceptionRecord);'
      '  end;'
      '  RaiseFramePtr := AllocateRaiseFrame;'
      '  RaiseFramePtr.ExceptObject := Obj;'
      '  RaiseFramePtr.ExceptAddr := Pointer(Address);'
      
        '  RaiseFramePtr.UnwindException.exception_class := DelphiExcepti' +
        'onPersonality;'
      ''
      '  RaiseFramePtr.UnwindException.private_1 := 0;'
      '  RaiseFramePtr.UnwindException.private_2 := 0;'
      ''
      '  LinkRaiseFrame(RaiseFramePtr);'
      '  Result := NativeUInt(@RaiseFramePtr.UnwindException);'
      'end;'
      ''
      'function IsLeafFunction(IP: NativeUInt): Boolean;'
      '{$IFDEF CPUARM32}'
      'const'
      '  EXIDX_CANTUNWIND = 1;'
      'var'
      '  eitp: PExceptionIndexTable;'
      '  nrec: Integer;'
      '  ehtp: NativeUInt;'
      'begin'
      '  Result := False;'
      '  eitp := dl_unwind_find_exidx(IP, nrec);'
      '  if eitp = nil then Exit;'
      ''
      '  eitp := search_EIT_table (eitp, nrec, IP);'
      '  if eitp = nil then Exit;'
      '  if eitp.content = EXIDX_CANTUNWIND then Exit;'
      ''
      '  if (eitp.content and $80000000) <> 0 then'
      '  begin'
      '    ehtp := NativeUInt(@(eitp.content));'
      '    // Currently, only one case is checked.'
      '    // $80'
      '    // 00xxxxxx : ARM_EXIDX_CMD_DATA_POP'
      '    // B0 : ARM_EXIDX_CMD_FINISH'
      '    Result := (PCardinal(ehtp)^ and $FFC0FF00) = $8000B000;'
      '  end;'
      'end;'
      '{$ENDIF CPUARM32}'
      '{$IFDEF CPUARM64}'
      'begin'
      '  Result := False;'
      'end;'
      '{$ENDIF CPUARM64}'
      '{$ENDIF ANDROID}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Program Initialization and Finalization         }'
      '{ ----------------------------------------------------- }'
      ''
      'var'
      '  InitContext: TInitContext;'
      '{$IFDEF MSWINDOWS}'
      '  DLLThreadContext: TInitContext;'
      '{$ENDIF}'
      ''
      'type'
      '  TProc = procedure;'
      ''
      
        '{$IF (defined(POSIX) and defined(CPUX86)) and defined(ASSEMBLER)' +
        '}'
      'procedure CallProc(Proc: Pointer; GOT: Cardinal);'
      'asm'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBX'
      '        MOV     EBX,EDX'
      '{$IFDEF LINUX}'
      '        ADD     EAX,EBX'
      '{$ENDIF LINUX}'
      '        CALL    EAX'
      '        POP     EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF POSIX and CPUX86 and ASSEMBLER}'
      ''
      'procedure FinalizeUnits;'
      'var'
      '  Count: Integer;'
      '  Table: PUnitEntryTable;'
      '  P: Pointer;'
      'begin'
      '{$IF defined(EXTERNALLINKER)}'
      '  dbk_RTL_initialized := 0;'
      '{$ENDIF}'
      '  if InitContext.InitTable = nil then'
      '    exit;'
      '{$IFDEF LINUX64}'
      '  Count := InitContext.InitTable^.UnitCount;'
      '{$ELSE !LINUX64}'
      '  Count := InitContext.InitCount;'
      '{$ENDIF LINUX64}'
      '  Table := InitContext.InitTable^.UnitInfo;'
      '{$IF defined(LINUX) and not defined(EXTERNALLINKER)}'
      '  Inc(PByte(Table), InitContext.Module^.GOT);'
      '{$ENDIF}'
      '  try'
      '    while Count > 0 do'
      '    begin'
      '      Dec(Count);'
      '      InitContext.InitCount := Count;'
      '      P := Table^[Count].FInit;'
      '      if Assigned(P) and Assigned(Pointer(P^)) then'
      '      begin'
      '{$IF defined(MSWINDOWS)}'
      '        TProc(P)();'
      
        '{$ELSEIF (defined(POSIX) and defined(CPUX86)) and defined(ASSEMB' +
        'LER)}'
      '        CallProc(P, InitContext.Module^.GOT);'
      '{$ELSE}'
      '        TProc(P)();'
      '{$ENDIF}'
      '      end;'
      '    end;'
      '  except'
      '    FinalizeUnits;  { try to finalize the others }'
      '    raise;'
      '  end;'
      'end;'
      ''
      '{$IFDEF MSWINDOWS}'
      'const'
      
        '  errCaption: array[0..5] of _AnsiChr = ('#39'E'#39', '#39'r'#39', '#39'r'#39', '#39'o'#39', '#39'r'#39 +
        ', #0);'
      '{$ENDIF MSWINDOWS}'
      ''
      '{***********************************************************}'
      '{$IFDEF TRIAL_EDITION}'
      '{'
      '    This code is used as part of the timeout test for'
      
        '    applications built with trial editions of the product.  It p' +
        'rovides'
      
        '    the current local time in a format native to the platform in' +
        ' question.'
      ''
      
        '    The linker will generate a checksum of _InitUnitPrep that it' +
        ' will'
      
        '    place into linked units.  The code generated for _InitUnitPr' +
        'ep must'
      
        '    not contain fixups actually in the image, as this could alte' +
        'r the'
      
        '    code at load time, invalidating the checksum.  Take great ca' +
        're to'
      
        '    make sure that this code is entirely position independent on' +
        ' all'
      '    platforms and circumstances to avoid a serious problem!'
      '}'
      '{$IFDEF MSWINDOWS}'
      ''
      'function _InitUnitPrep: Int64;'
      'var'
      '  SystemTime: TSystemTime;'
      '  FileTime: TFileTime;'
      '  Days: Int64;'
      'begin'
      '  GetLocalTime(SystemTime);'
      '  SystemTimeToFileTime(SystemTime, FileTime);'
      ''
      '    // used to hack the result to force a failure for testing:'
      '  Days := 1000000000 div 100;'
      '  Days := Days * 3600;'
      '  Days := Days * 24;'
      '  Days := Days * 31;'
      '  Days := 0;'
      ''
      '  Result := Int64(FileTime) + Days;'
      '//  Dec(InitContext.InitTable^.UnitCount);'
      'end;'
      '{$ENDIF}'
      '{$IFDEF LINUX}'
      ''
      'function _InitUnitPrep: Integer;'
      'var'
      '  Days: Integer;'
      'begin'
      
        '  Days := 0;    // used to hack the result to force a failure fo' +
        'r testing'
      '    Result := _time(nil) + Days;'
      'end;'
      '{$ENDIF}'
      ''
      'resourcestring'
      '{$IFDEF POSIX}'
      '  SExpiredMsg ='
      
        '  '#39'This module was compiled with a trial version of Delphi.'#39'+#10' +
        '+'
      '  '#39'The trial period has expired.'#39'+#10;'
      '{$ENDIF}'
      '{$IFDEF MSWINDOWS}'
      '  SExpiredMsg ='
      
        '  '#39'This module was compiled with a trial version of Delphi.'#39'+#13' +
        '+#10+'
      '  '#39'The trial period has expired.'#39'+#13+#10;'
      '{$ENDIF}'
      'var'
      '  ExpiredMsg: _AnsiStr;'
      ''
      
        'function LoadResStringA(ResStringRec: PResStringRec; CodePage: W' +
        'ord): _AnsiStr; forward;'
      ''
      'procedure _Expired;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Dummy: Cardinal;'
      'begin'
      '  ExpiredMsg := LoadResStringA(@SExpiredMsg, CP_ACP);'
      '  Console'
      '  if IsConsole then'
      
        '    WriteFile(GetStdHandle(STD_ERROR_HANDLE), _PAnsiChr(ExpiredM' +
        'sg), Length(ExpiredMsg), Dummy, nil)'
      '  else'
      '    MessageBoxA(0, _PAnsiChr(ExpiredMsg), errCaption, 0);'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      '  ExpiredMsg := LoadResStringA(@SExpiredMsg, CP_ACP);'
      '  __write(2, _PAnsiChr(ExpiredMsg), Length(ExpiredMsg));'
      '{$ENDIF POSIX}'
      '  ExpiredMsg := '#39#39';'
      '  Halt(232);'
      'end;'
      ''
      '{$ENDIF} // TRIAL_EDITION'
      ''
      'procedure InitUnits;'
      'var'
      '  Count, I: Integer;'
      '  Table: PUnitEntryTable;'
      '  P: Pointer;'
      'begin'
      '{$IF defined(EXTERNALLINKER)}'
      '  dbk_RTL_initialized := 0;'
      '{$ENDIF}'
      '  if InitContext.InitTable = nil then'
      '    exit;'
      '  Count := InitContext.InitTable^.UnitCount;'
      '  I := 0;'
      '  Table := InitContext.InitTable^.UnitInfo;'
      '{$IF defined(LINUX) and not defined(EXTERNALLINKER)}'
      '  Inc(PByte(Table), InitContext.Module^.GOT);'
      '{$ENDIF}'
      '  try'
      '    while I < Count do'
      '    begin'
      '      P := Table^[I].Init;'
      '      Inc(I);'
      '      InitContext.InitCount := I;'
      '      if Assigned(P) and Assigned(Pointer(P^)) then'
      '      begin'
      '{$IF defined(MSWINDOWS)}'
      '        TProc(P)();'
      
        '{$ELSEIF (defined(POSIX) and defined(CPUX86)) and defined(ASSEMB' +
        'LER)}'
      '        CallProc(P, InitContext.Module^.GOT);'
      '{$ELSE}'
      '        TProc(P)();'
      '{$ENDIF}'
      '      end;'
      '    end;'
      '  except'
      '    FinalizeUnits;'
      '    raise;'
      '  end;'
      '{$IF defined(EXTERNALLINKER)}'
      '  dbk_RTL_initialized := 1;'
      '{$ENDIF}'
      'end;'
      ''
      
        'procedure _PackageLoad(const Table : PackageInfo; Module: PLibMo' +
        'dule);'
      'var'
      '  SavedContext: TInitContext;'
      'begin'
      '  SavedContext := InitContext;'
      '  InitContext.DLLInitState := 0;'
      '  InitContext.InitTable := Table;'
      '  InitContext.InitCount := 0;'
      '  InitContext.Module := Module;'
      '  InitContext.OuterContext := @SavedContext;'
      '  try'
      '    InitUnits;'
      '  finally'
      '    InitContext := SavedContext;'
      '  end;'
      'end;'
      ''
      ''
      
        'procedure _PackageUnload(const Table : PackageInfo; Module: PLib' +
        'Module);'
      'var'
      '  SavedContext: TInitContext;'
      'begin'
      '  SavedContext := InitContext;'
      '  InitContext.DLLInitState := 0;'
      '  InitContext.InitTable := Table;'
      '  InitContext.InitCount := Table^.UnitCount;'
      '  InitContext.Module := Module;'
      '  InitContext.OuterContext := @SavedContext;'
      '  try'
      '    FinalizeUnits;'
      '  finally'
      '    InitContext := SavedContext;'
      '  end;'
      'end;'
      ''
      '{$IF defined(LINUX) or defined(MACOS) or defined(ANDROID)}'
      
        'procedure       _StartExe(InitTable: PackageInfo; Module: PLibMo' +
        'dule; Argc: Integer; Argv: Pointer);'
      'begin'
      '  ArgCount := Argc;'
      '  ArgValues := Argv;'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      '{$IFDEF MSWINDOWS}'
      
        'procedure       _StartExe(InitTable: PackageInfo; Module: PLibMo' +
        'dule);'
      'begin'
      '  RaiseExceptionProc := @RaiseException;'
      '  RTLUnwindProc := @RTLUnwind;'
      '{$ENDIF MSWINDOWS}'
      '  InitContext.InitTable := InitTable;'
      '  InitContext.InitCount := 0;'
      '  InitContext.Module := Module;'
      '  MainInstance := Module.Instance;'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      '  SetExceptionHandler(@InitContext);'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '  InitContext.ExcFrame := Pointer(1);'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '  IsLibrary := False;'
      '  InitUnits;'
      'end;'
      ''
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF CPUX86}'
      '                                                             '
      'procedure       _StartLib;'
      'asm'
      '        { ->    EAX InitTable   }'
      '        {       EDX Module      }'
      '        {       ECX InitTLS     }'
      '        {       [ESP+4] DllProc }'
      '        {       [EBP+8] HInst   }'
      '        {       [EBP+12] Reason }'
      '        {       [EBP-(type TExcFrame)] TExcFrame local }'
      
        '        {       [EBP-(type TExcFrame)-(type TInitContext)] TInit' +
        'Context local }'
      ''
      '        { Push some desperately needed registers }'
      ''
      '        PUSH    ECX'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      
        '        { Setup EBX to point to InitContext or DLLThreadContext ' +
        'based on Reason }'
      ''
      '        MOV     EBX,offset InitContext'
      '        CMP     DWORD PTR [EBP+12],2    // DLL_THREAD_ATTACH'
      '        JL      @@notDLLThread'
      '        MOV     EBX,offset DLLThreadContext'
      ''
      
        '        { Save the current init context into the stackframe of o' +
        'ur caller }'
      ''
      '@@notDLLThread:'
      '        MOV     ESI,EBX'
      
        '        LEA     EDI,[EBP - (type TExcFrame) - (type TInitContext' +
        ')]'
      '        MOV     ECX,(type TInitContext)/4'
      '        REP     MOVSD'
      ''
      '        { Setup the current InitContext }'
      ''
      '        POP     [EBX].TInitContext.DLLSaveEDI'
      '        POP     [EBX].TInitContext.DLLSaveESI'
      '        POP     [EBX].TInitContext.DLLSaveEBX'
      '        MOV     [EBX].TInitContext.DLLSaveEBP,EBP'
      '        MOV     [EBX].TInitContext.InitTable,EAX'
      '        MOV     [EBX].TInitContext.Module,EDX'
      
        '        LEA     ECX,[EBP - (type TExcFrame) - (type TInitContext' +
        ')]'
      '        MOV     [EBX].TInitContext.OuterContext,ECX'
      ''
      '        { Get and save the current thread ID }'
      ''
      '        CALL    GetCurrentThreadID'
      '        MOV     [EBX].TInitContext.ThreadID,EAX'
      '        MOV     EAX,[EBX].TInitContext.InitTable'
      ''
      '        { Setup InitCount for FinalizeUnits call }'
      ''
      '        XOR     ECX,ECX'
      
        '        CMP     DWORD PTR [EBP+12],0    // Reason = DLL_PROCESS_' +
        'DETACH?'
      '        JNE     @@notShutDown'
      '        MOV     ECX,[EAX].PackageInfoTable.UnitCount'
      '@@notShutDown:'
      '        MOV     [EBX].TInitContext.InitCount,ECX'
      ''
      '        { Setup exception handler }'
      ''
      '        MOV     EAX, offset RaiseException'
      '        MOV     RaiseExceptionProc, EAX'
      '        MOV     EAX, offset RTLUnwind'
      '        MOV     RTLUnwindProc, EAX'
      ''
      
        '        MOV     EAX,EBX                 // Pass address of curre' +
        'nt context'
      '        CALL    SetExceptionHandler'
      ''
      '        MOV     EAX,[EBP+12]'
      '        INC     EAX'
      '        MOV     [EBX].TInitContext.DLLInitState,AL'
      '        DEC     EAX'
      ''
      '        { Init any needed TLS }'
      ''
      '        POP     ECX'
      '        MOV     EDX,[ECX]'
      '        MOV     [EBX].TInitContext.ExitProcessTLS,EDX'
      '        JE      @@skipTLSproc'
      '        CMP     AL,3                    // DLL_THREAD_DETACH'
      
        '        JGE     @@skipTLSproc           // call ExitThreadTLS pr' +
        'oc after DLLProc'
      '        CALL    dword ptr [ECX+EAX*4]   // Call TlsProc[Reason]'
      ''
      '@@skipTLSproc:'
      ''
      '        { Call any DllProc }'
      ''
      '        PUSH    ECX                     // TlsProc'
      '        MOV     ECX,[ESP+8]             // DLLProc'
      '        TEST    ECX,ECX'
      '        JE      @@noDllProc'
      '        MOV     EAX,[EBP+12]            // Reason'
      '        MOV     EDX,[EBP+16]            // Reserved'
      '        CALL    ECX'
      ''
      '@@noDllProc:'
      ''
      '        POP     ECX'
      '        MOV     EAX, [EBP+12]'
      '        CMP     AL,3                    // DLL_THREAD_DETACH'
      
        '        JL      @@afterDLLproc          // don'#39't free TLS on pro' +
        'cess shutdown'
      '        CALL    dword ptr [ECX+EAX*4]   // Call TlsProc[Reason]'
      ''
      '@@afterDLLProc:'
      ''
      '        { Set IsLibrary if there was no exe yet }'
      ''
      '        CMP     MainInstance,0'
      '        JNE     @@haveExe'
      '        MOV     IsLibrary,1'
      
        '        FNSTCW  Default8087CW           // save host exe'#39's FPU p' +
        'references'
      ''
      '@@haveExe:'
      ''
      '        MOV     EAX,[EBP+12]'
      '        DEC     EAX'
      '        JNE     _Halt0'
      '        CALL    InitUnits'
      '        RET     4'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF CPUX64}'
      '                                                     '
      
        'procedure _StartLib(ContextBuf: PInitContext; InitTable: Package' +
        'Info; Module: PLibModule; TlsProc: Pointer; DllProc: TDllProcEx;' +
        ' AHInst: HINST; Reason: LongWord; Reserved: Pointer);'
      'type'
      '  TlsProcType = array[0..3] of procedure;'
      '  PTlsProcType = ^TlsProcType;'
      'const'
      '  DLL_PROCESS_DETACH = 0;'
      '  DLL_PROCESS_ATTACH = 1;'
      '  DLL_THREAD_ATTACH  = 2;'
      '  DLL_THREAD_DETACH  = 3;'
      'var'
      '  Context: PInitContext;'
      '  TmpExitDllJmpBuf: __TExitDllJumpBuf;'
      'begin'
      '  Context := @InitContext;'
      '  if Reason >= DLL_THREAD_ATTACH then'
      '    Context := @DllThreadContext;'
      '  TmpExitDllJmpBuf := ContextBuf.ExitDllJmpBuf;'
      '  ContextBuf^ := Context^;'
      '  Context.ExitDllJmpBuf := TmpExitDllJmpBuf;'
      ''
      '  // Setup the current InitContext'
      '  Context.InitTable := InitTable;'
      '  Context.Module := Module;'
      '  Context.OuterContext := ContextBuf;'
      ''
      '  // Get and save the current thread ID'
      '  Context.ThreadID := GetCurrentThreadID;'
      ''
      '  // Setup InitCount for FinalizeUnits call'
      '  if Reason = DLL_PROCESS_DETACH then'
      '    Context.InitCount := Context.InitTable.UnitCount'
      '  else'
      '    Context.InitCount := 0;'
      ''
      '  // Setup exception handler'
      '  RaiseExceptionProc := @RaiseException;'
      '  RTLUnwindProc := @RTLUnwind;'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      '  SetExceptionHandler(@Context);'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '  Context^.ExcFrame := Pointer(1);'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '  Context.DLLInitState := Reason + 1;'
      ''
      '  // Init any needed TLS'
      
        '  Context.ExitProcessTLS := PTlsProcType(TlsProc)^[DLL_PROCESS_D' +
        'ETACH];'
      ''
      
        '  if (Reason = DLL_PROCESS_ATTACH) or (Reason = DLL_THREAD_ATTAC' +
        'H) then'
      '    PTlsProcType(TlsProc)^[Reason]();'
      ''
      '  // Call any DllProc'
      '  if Assigned(DllProc) then'
      '    DllProc(Reason, Reserved);'
      ''
      '  // don'#39't free TLS on process shutdown'
      '  if Reason = DLL_THREAD_DETACH then'
      '    PTlsProcType(TlsProc)^[Reason]();'
      ''
      '  // Set IsLibrary if there was no exe yet'
      '  if MainInstance = 0 then'
      '  begin'
      '    IsLibrary := True;'
      '    DefaultMXCSR := GetMXCSR;'
      '  end;'
      '  if Reason = DLL_PROCESS_ATTACH then'
      '    InitUnits'
      '  else'
      '    _Halt0;'
      'end;'
      '{$ENDIF CPUX64}'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF POSIX}'
      '{$IFDEF LINUX64}'
      'var'
      '  __InInitLib : Boolean = False;'
      '{$ENDIF LINUX64}'
      
        'procedure _StartLib(Context: PInitContext; Module: PLibModule; D' +
        'LLProc: TDLLProcEx);'
      'var'
      '  TempSwap: TInitContext;'
      'begin'
      '{$IFDEF LINUX64}'
      
        '  if PInitContext(Context)^.DLLInitState = 0 then // DLL_PROCESS' +
        '_DETACH = 0;'
      '    InitContext.DLLInitState := 0'
      '  else'
      '{$ENDIF LINUX64}'
      '  begin'
      '    // Context'#39's register save fields are already initialized.'
      
        '    // Save the current InitContext and activate the new Context' +
        ' by swapping them'
      '    TempSwap := InitContext;'
      '    InitContext := PInitContext(Context)^;'
      '    PInitContext(Context)^ := TempSwap;'
      ''
      '    InitContext.Module := Module;'
      '    InitContext.OuterContext := Context;'
      '{$IFDEF LINUX64}'
      
        '    __InInitLib := InitContext.DLLInitState = 1; // DLL_PROCESS_' +
        'ATTACH'
      '{$ENDIF LINUX64}'
      '  end;'
      ''
      
        '  // DLLInitState is initialized by SysInit to 0 for shutdown, 1' +
        ' for startup'
      '  // Inc DLLInitState to distinguish from package init:'
      '  // 0 for package, 1 for DLL shutdown, 2 for DLL startup'
      ''
      '  Inc(InitContext.DLLInitState);'
      ''
      '  if InitContext.DLLInitState = 1 then'
      '  begin'
      '    InitContext.InitTable := Module.InitTable;'
      '    if Assigned(InitContext.InitTable) then'
      
        '      InitContext.InitCount := InitContext.InitTable.UnitCount  ' +
        '// shutdown'
      '  end'
      '  else'
      '  begin'
      
        '    Module.InitTable := InitContext.InitTable;  // save for shut' +
        'down'
      '    InitContext.InitCount := 0;  // startup'
      '  end;'
      ''
      '  if Assigned(DLLProc) then'
      '    DLLProc(InitContext.DLLInitState-1,nil);'
      ''
      
        '  if MainInstance = 0 then        { Set IsLibrary if there was n' +
        'o exe yet }'
      '  begin'
      '    IsLibrary := True;'
      
        '{$IF (defined(CPUX86) or defined(CPUX64)) and defined(MSWINDOWS)' +
        '}'
      '    Default8087CW := Get8087CW;'
      '    DefaultMXCSR := GetMXCSR;'
      '{$ENDIF}'
      '  end;'
      ''
      '  if InitContext.DLLInitState = 1 then'
      '    _Halt0'
      '  else'
      '    InitUnits;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      ''
      
        '{ --------------------------------------------------------------' +
        '------- }'
      
        '{       Compiler helper for resource string and indirect pointer' +
        's       }'
      
        '{ --------------------------------------------------------------' +
        '------- }'
      ''
      
        'function LoadResStringA(ResStringRec: PResStringRec; CodePage: W' +
        'ord): _AnsiStr;'
      'var'
      '  S: String;'
      'begin'
      '  S := LoadResString(ResStringRec);'
      '  _LStrFromUStr(Result, S, CodePage);'
      'end;'
      ''
      'function LoadResStringW(ResStringRec: PResStringRec): _WideStr;'
      'begin'
      '  Result := _WideStr(LoadResString(ResStringRec));'
      'end;'
      ''
      
        'function LoadResStringU(ResStringRec: PResStringRec): UnicodeStr' +
        'ing;'
      'begin'
      '  Result := UnicodeString(LoadResString(ResStringRec));'
      'end;'
      ''
      'type'
      '  _PResStringInitTableElem = ^_TResStringInitTableElem;'
      '  _TResStringInitTableElem = record'
      '    const // stringKind'
      '      LString = 0;'
      '      WString = 1;'
      '      UString = 2;'
      '      StringKindMask = $0000FFFF;'
      '      CodePageMask   = $FFFF0000; // used for LString'
      '      CodePageShift  = 16;        // used for LString'
      '    var'
      '      variableAddress: Pointer;'
      '      resStringAddress: PResStringRec;'
      '      stringKind: NativeInt;'
      '  end;'
      '  _PResStringInitTable = ^_TResStringInitTable;'
      '  _TResStringInitTable = record'
      '    Count: NativeInt;'
      
        '    Table: array[1..(MaxInt div SizeOf(_TResStringInitTableElem)' +
        ' - 2)] of _TResStringInitTableElem;'
      '  end;'
      '  {$NODEFINE _PResStringInitTableElem}'
      '  {$NODEFINE _TResStringInitTableElem}'
      '  {$NODEFINE _PResStringInitTable}'
      '  {$NODEFINE _TResStringInitTable}'
      ''
      'type'
      
        '  _PResStringImportInitTableElem = ^_TResStringImportInitTableEl' +
        'em;'
      '  _TResStringImportInitTableElem = record'
      '    const // stringKind'
      '      LString = 0;'
      '      WString = 1;'
      '      UString = 2;'
      '      StringKindMask = $0000FFFF;'
      '      CodePageMask   = $FFFF0000; // used for LString'
      '      CodePageShift  = 16;        // used for LString'
      '    var'
      '      variableAddress: Pointer;'
      '      resStringIndirAddress: ^PResStringRec;'
      '      stringKind: NativeInt;'
      '  end;'
      '  _PResStringImportInitTable = ^_TResStringImportInitTable;'
      '  _TResStringImportInitTable = record'
      '    Count: NativeInt;'
      
        '    Table: array[1..(MaxInt div SizeOf(_TResStringImportInitTabl' +
        'eElem) - 2)] of _TResStringImportInitTableElem;'
      '  end;'
      '  {$NODEFINE _PResStringImportInitTableElem}'
      '  {$NODEFINE _TResStringImportInitTableElem}'
      '  {$NODEFINE _PResStringImportInitTable}'
      '  {$NODEFINE _TResStringImportInitTable}'
      ''
      '{$IFDEF PUREPASCAL}'
      'type'
      '  _PImportInitTableElem = ^_TImportInitTableElem;'
      '  _TImportInitTableElem = record'
      '    variableAddress: Pointer;'
      '    sourceIndirAddress: PPointer;'
      '    soruceOffset: NativeInt;'
      '  end;'
      '  _PImportInitTable = ^_TImportInitTable;'
      '  _TImportInitTable = record'
      '    Count: NativeInt;'
      
        '    Table: array[1..(MaxInt div SizeOf(_TImportInitTableElem) - ' +
        '2)] of _TImportInitTableElem;'
      '  end;'
      '  {$NODEFINE _PImportInitTableElem}'
      '  {$NODEFINE _TImportInitTableElem}'
      '  {$NODEFINE _PImportInitTable}'
      '  {$NODEFINE _TImportInitTable}'
      '{$ENDIF}'
      ''
      'type'
      '  _PWideStringInitTableElem = ^_TWideStringInitTableElem;'
      '  _TWideStringInitTableElem = record'
      '    variableAddress: Pointer;'
      '    stringAddress: Pointer;'
      '  end;'
      '  _PWideStringInitTable = ^_TWideStringInitTable;'
      '  _TWideStringInitTable = record'
      '    Count: NativeInt;'
      
        '    Table: array[1..(MaxInt div SizeOf(_TWideStringInitTableElem' +
        ') - 2)] of _TWideStringInitTableElem;'
      '  end;'
      '  {$NODEFINE _PWideStringInitTableElem}'
      '  {$NODEFINE _TWideStringInitTableElem}'
      '  {$NODEFINE _PWideStringInitTable}'
      '  {$NODEFINE _TWideStringInitTable}'
      ''
      
        '                                                                ' +
        '   '
      '                                                   '
      '//procedure _InitResStrings(InitTable: _PResStringInitTable);'
      'procedure _InitResStrings(InitTable: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: Integer;'
      '  P: _PResStringInitTableElem;'
      'begin'
      '  for I := 1 to _PResStringInitTable(InitTable)^.Count do'
      '  begin'
      '    P := @_PResStringInitTable(InitTable)^.Table[I];'
      
        '    case (P^.stringKind and _TResStringInitTableElem.StringKindM' +
        'ask) of'
      '      _TResStringInitTableElem.LString:'
      
        '        _PAnsiStr(P^.variableAddress)^ := LoadResStringA(P^.resS' +
        'tringAddress,'
      
        '            (P^.stringKind and _TResStringInitTableElem.CodePage' +
        'Mask) shr _TResStringInitTableElem.CodePageShift);'
      '      _TResStringInitTableElem.WString:'
      
        '        _PWideStr(P^.variableAddress)^ := LoadResStringW(P^.resS' +
        'tringAddress);'
      '      _TResStringInitTableElem.UString:'
      
        '        PUnicodeString(P^.variableAddress)^ := LoadResStringU(P^' +
        '.resStringAddress);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to init table               }'
      '        {                 record                            }'
      '        {                   cnt: Integer;                   }'
      '        {                   tab: array [1..cnt] record      }'
      '        {                      variableAddress: Pointer;    }'
      '        {                      resStringAddress: Pointer;   }'
      
        '        {                      stringKind: (LString, WString, US' +
        'tring) as Int32; }'
      '        {                   end;                            }'
      '        {                 end;                              }'
      '        { EBX = caller'#39's GOT for PIC callers, 0 for non-PIC }'
      ''
      '{$IFDEF MSWINDOWS}'
      '        PUSH    EBX'
      '        XOR     EBX,EBX'
      '{$ENDIF}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDI'
      '        PUSH    ESI'
      '        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt'
      '        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab'
      '@@loop:'
      
        '        MOV     EAX,[ESI+4]       // EAX := initTable.tab[i].res' +
        'StringAddress'
      '        ADD     EAX,EBX'
      
        '        MOV     EDX,[ESI]         // EDX := initTable.tab[i].var' +
        'iableAddress'
      '        ADD     EDX,EBX'
      
        '        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].str' +
        'ingKind'
      ''
      '        // Handle appropriate string kind.'
      '        TEST    CX,CX'
      '        JZ      @@lstring'
      '        DEC     ECX'
      '        JZ      @@wstring'
      '        DEC     ECX'
      '        JZ      @@ustring'
      '        INT     3'
      ''
      '@@lstring:'
      '        XCHG    ECX,EDX'
      '        SHR     EDX,16'
      '        CALL    LoadResStringA'
      '        JMP     @@doneLoad'
      ''
      '@@wstring:'
      '        CALL    LoadResStringW'
      '        JMP     @@doneLoad'
      ''
      '@@ustring:'
      '        CALL    LoadResStringU'
      ''
      '@@doneLoad:'
      '        ADD     ESI,12'
      '        DEC     EDI'
      '        JNZ     @@loop'
      ''
      '        POP     ESI'
      '        POP     EDI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '{$IFDEF MSWINDOWS}'
      '        POP     EBX'
      '{$ENDIF}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        '                                                                ' +
        '         '
      '                                                         '
      
        '//procedure _InitResStringImports(InitTable: _PResStringImportIn' +
        'itTable);'
      'procedure _InitResStringImports(InitTable: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: Integer;'
      '  P: _PResStringImportInitTableElem;'
      'begin'
      '  for I := 1 to _PResStringImportInitTable(InitTable)^.Count do'
      '  begin'
      '    P := @_PResStringImportInitTable(InitTable)^.Table[I];'
      
        '    case (P^.stringKind and _TResStringImportInitTableElem.Strin' +
        'gKindMask) of'
      '      _TResStringImportInitTableElem.LString:'
      
        '        _PAnsiStr(P^.variableAddress)^ := LoadResStringA(P^.resS' +
        'tringIndirAddress^,'
      
        '            (P^.stringKind and _TResStringImportInitTableElem.Co' +
        'dePageMask) shr _TResStringImportInitTableElem.CodePageShift);'
      '      _TResStringImportInitTableElem.WString:'
      
        '        _PWideStr(P^.variableAddress)^ := LoadResStringW(P^.resS' +
        'tringIndirAddress^);'
      '      _TResStringImportInitTableElem.UString:'
      
        '        PUnicodeString(P^.variableAddress)^ := LoadResStringU(P^' +
        '.resStringIndirAddress^);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to init table               }'
      '        {                 record                            }'
      '        {                   cnt: Integer;                   }'
      '        {                   tab: array [1..cnt] record      }'
      '        {                      variableAddress: Pointer;    }'
      
        '        {                      resStringAddress: ^Pointer; *** n' +
        'ote indirection  }'
      
        '        {                      stringKind: (LString, WString, US' +
        'tring) as Int32; }'
      '        {                   end;                            }'
      '        {                 end;                              }'
      '        { EBX = caller'#39's GOT for PIC callers, 0 for non-PIC }'
      ''
      '{$IFDEF MSWINDOWS}'
      '        PUSH    EBX'
      '        XOR     EBX,EBX'
      '{$ENDIF}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDI'
      '        PUSH    ESI'
      '        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt'
      '        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab'
      '@@loop:'
      
        '        MOV     EAX,[ESI+4]       // EAX := initTable.tab[i].res' +
        'StringAddress'
      
        '        MOV     EAX,[EBX+EAX]     // EAX := EAX^ (to do indirect' +
        'ion)'
      
        '        MOV     EDX,[ESI]         // EDX := initTable.tab[i].var' +
        'iableAddress'
      '{$IFNDEF MACOS}'
      '        ADD     EDX,EBX'
      '{$ENDIF MACOS}'
      
        '        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].str' +
        'ingKind'
      ''
      '        // Handle appropriate string kind.'
      '        TEST    CX,CX'
      '        JZ      @@lstring'
      '        DEC     ECX'
      '        JZ      @@wstring'
      '        DEC     ECX'
      '        JZ      @@ustring'
      '        INT     3'
      ''
      '@@lstring:'
      '        XCHG    ECX,EDX'
      '        SHR     EDX,16'
      '        CALL    LoadResStringA'
      '        JMP     @@doneLoad'
      ''
      '@@wstring:'
      '        CALL    LoadResStringW'
      '        JMP     @@doneLoad'
      ''
      '@@ustring:'
      '        CALL    LoadResStringU'
      ''
      '@@doneLoad:'
      '        ADD     ESI,12'
      '        DEC     EDI'
      '        JNZ     @@loop'
      ''
      '        POP     ESI'
      '        POP     EDI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '{$IFDEF MSWINDOWS}'
      '        POP     EBX'
      '{$ENDIF}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '                                                                '
      '                                                '
      '//procedure _InitImports(InitTable: _PImportInitTable);'
      'procedure _InitImports(InitTable: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: Integer;'
      '  P: _PImportInitTableElem;'
      'begin'
      '  for I := 1 to _PImportInitTable(InitTable)^.Count do'
      '  begin'
      '    P := @_PImportInitTable(InitTable)^.Table[I];'
      
        '    PPointer(P^.variableAddress)^ := Pointer(PByte(P^.sourceIndi' +
        'rAddress^) + P^.soruceOffset);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to init table               }'
      '        {                 record                            }'
      '        {                   cnt: Integer;                   }'
      '        {                   tab: array [1..cnt] record      }'
      '        {                      variableAddress: Pointer;    }'
      '        {                      sourceAddress: ^Pointer;     }'
      '        {                      sourceOffset: Integer;       }'
      '        {                   end;                            }'
      '        {                 end;                              }'
      '        { ->    EDX     Linux only, this points to          }'
      '        {               SysInit.ModuleIsCpp                 }'
      '        { EBX = caller'#39's GOT for PIC callers, 0 for non-PIC }'
      '{$IFDEF MACOS}'
      '                                                                '
      '        RET'
      '{$ENDIF MACOS}'
      '{$IFDEF MSWINDOWS}'
      '        PUSH    EBX'
      '        XOR     EBX,EBX'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDI'
      '        PUSH    ESI'
      '        MOV     EDI,[EBX+EAX]'
      '        LEA     ESI,[EBX+EAX+4]'
      '{$IFDEF LINUX}'
      '        {'
      
        '            The C++ linker may have already fixed these things u' +
        'p to valid'
      
        '            addresses.  In this case, we don'#39't want to do this p' +
        'ass.  If this'
      
        '            module'#39's init tab was linked with ilink, then SysIni' +
        't.ModuleIsCpp'
      '            will be set, and we'#39'll bail out.'
      '        }'
      '        CMP     BYTE PTR[EDX+EBX], 0  { SysInit.ModuleIsCpp }'
      '        JNE     @@exit'
      '{$ENDIF LINUX}'
      '@@loop:'
      '        MOV     EAX,[ESI+4]     { load address of import    }'
      '        MOV     EDX,[ESI]       { load address of variable  }'
      '        MOV     EAX,[EBX+EAX]   { load contents of import   }'
      '        ADD     EAX,[ESI+8]     { calc address of variable  }'
      '        MOV     [EBX+EDX],EAX   { store result              }'
      '        ADD     ESI,12'
      '        DEC     EDI'
      '        JNZ     @@loop'
      ''
      '@@exit:'
      ''
      '        POP     ESI'
      '        POP     EDI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '{$IFDEF MSWINDOWS}'
      '        POP     EBX'
      '{$ENDIF MSWINDOWS}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        '                                                                ' +
        '    '
      '{$IFDEF MSWINDOWS}'
      '//procedure _InitWideStrings(InitTable: _PWideStringInitTable);'
      'procedure _InitWideStrings(InitTable: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: Integer;'
      '  P: _PWideStringInitTableElem;'
      'begin'
      '  for I := 1 to _PWideStringInitTable(InitTable)^.Count do'
      '  begin'
      '    P := @_PWideStringInitTable(InitTable)^.Table[I];'
      
        '    _WStrAsg(_PWideStr(P^.variableAddress)^, _WideStr(P^.stringA' +
        'ddress));'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '     { ->    EAX     Pointer to init table               }'
      '     {                 record                            }'
      '     {                   cnt: Integer;                   }'
      '     {                   tab: array [1..cnt] record      }'
      '     {                      variableAddress: Pointer;    }'
      '     {                      stringAddress: ^Pointer;     }'
      '     {                   end;                            }'
      '     {                 end;                              }'
      ''
      '    PUSH    EBX'
      '    PUSH    ESI'
      '    MOV     EBX,[EAX]'
      '    LEA     ESI,[EAX+4]'
      '@@loop:'
      '    MOV     EDX,[ESI+4]     { load address of string    }'
      '    MOV     EAX,[ESI]       { load address of variable  }'
      '    CALL    _WStrAsg'
      '    ADD     ESI,8'
      '    DEC     EBX'
      '    JNZ     @@loop'
      ''
      '    POP     ESI'
      '    POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      ''
      'procedure _FinalizeResStrings(InitTable: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: Integer;'
      '  P: _PResStringInitTableElem;'
      'begin'
      '  for I := 1 to _PResStringInitTable(InitTable)^.Count do'
      '  begin'
      '    P := @_PResStringInitTable(InitTable)^.Table[I];'
      
        '    case (P^.stringKind and _TResStringInitTableElem.StringKindM' +
        'ask) of'
      '      _TResStringInitTableElem.LString:'
      '        _LStrClr(_PAnsiStr(P^.variableAddress)^);'
      '      _TResStringInitTableElem.WString:'
      '        _WStrClr(_PWideStr(P^.variableAddress)^);'
      '      _TResStringInitTableElem.UString:'
      '        _UStrClr(PUnicodeString(P^.variableAddress)^);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to init table               }'
      '        {                 record                            }'
      '        {                   cnt: Integer;                   }'
      '        {                   tab: array [1..cnt] record      }'
      '        {                      variableAddress: Pointer;    }'
      '        {                      resStringAddress: Pointer;   }'
      
        '        {                      stringKind: (LString, WString, US' +
        'tring) as Int32; }'
      '        {                   end;                            }'
      '        {                 end;                              }'
      '        { EBX = caller'#39's GOT for PIC callers, 0 for non-PIC }'
      '{$IFDEF MSWINDOWS}'
      '        PUSH    EBX'
      '        XOR     EBX,EBX'
      '{$ENDIF}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDI'
      '        PUSH    ESI'
      '        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt'
      '        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab'
      '@@loop:'
      
        '        MOV     EAX,[ESI]         // EAX := initTable.tab[i].var' +
        'iableAddress'
      '{$IFNDEF MACOS}'
      '        ADD     EDX,EBX'
      '{$ENDIF MACOS}'
      
        '        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].str' +
        'ingKind'
      '        // Handle appropriate string kind.'
      '        TEST    CX,CX'
      '        JZ      @@lstring'
      '        DEC     ECX'
      '        JZ      @@wstring'
      '        DEC     ECX'
      '        JZ      @@ustring'
      '        INT     3'
      '@@lstring:'
      '        CALL    _LStrClr'
      '        JMP     @@doneClr'
      '@@wstring:'
      '        CALL    _WStrClr'
      '        JMP     @@doneClr'
      '@@ustring:'
      '        CALL    _UStrClr'
      '@@doneClr:'
      '        ADD     ESI,12'
      '        DEC     EDI'
      '        JNZ     @@loop'
      ''
      '        POP     ESI'
      '        POP     EDI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '{$IFDEF MSWINDOWS}'
      '        POP     EBX'
      '{$ENDIF}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _FinalizeResStringImports(InitTable: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I: Integer;'
      '  P: _PResStringImportInitTableElem;'
      'begin'
      '  for I := 1 to _PResStringImportInitTable(InitTable)^.Count do'
      '  begin'
      '    P := @_PResStringImportInitTable(InitTable)^.Table[I];'
      
        '    case (P^.stringKind and _TResStringImportInitTableElem.Strin' +
        'gKindMask) of'
      '      _TResStringImportInitTableElem.LString:'
      '        _LStrClr(_PAnsiStr(P^.variableAddress)^);'
      '      _TResStringImportInitTableElem.WString:'
      '        _WStrClr(_PWideStr(P^.variableAddress)^);'
      '      _TResStringImportInitTableElem.UString:'
      '        _UStrClr(PUnicodeString(P^.variableAddress)^);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to init table               }'
      '        {                 record                            }'
      '        {                   cnt: Integer;                   }'
      '        {                   tab: array [1..cnt] record      }'
      '        {                      variableAddress: Pointer;    }'
      
        '        {                      resStringAddress: ^Pointer; *** n' +
        'ote indirection  }'
      
        '        {                      stringKind: (LString, WString, US' +
        'tring) as Int32; }'
      '        {                   end;                            }'
      '        {                 end;                              }'
      '        { EBX = caller'#39's GOT for PIC callers, 0 for non-PIC }'
      '{$IFDEF MSWINDOWS}'
      '        PUSH    EBX'
      '        XOR     EBX,EBX'
      '{$ENDIF}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDI'
      '        PUSH    ESI'
      '        MOV     EDI,[EBX+EAX]     // EDI := initTable.cnt'
      '        LEA     ESI,[EBX+EAX+4]   // ESI := @initTable.tab'
      '@@loop:'
      
        '        MOV     EAX,[ESI]         // EAX := initTable.tab[i].var' +
        'iableAddress'
      '{$IFNDEF MACOS}'
      '        ADD     EDX,EBX'
      '{$ENDIF MACOS}'
      
        '        MOV     ECX,[ESI+8]       // ECX := initTable.tab[i].str' +
        'ingKind'
      '        // Handle appropriate string kind.'
      '        TEST    CX,CX'
      '        JZ      @@lstring'
      '        DEC     ECX'
      '        JZ      @@wstring'
      '        DEC     ECX'
      '        JZ      @@ustring'
      '        INT     3'
      '@@lstring:'
      '        CALL    _LStrClr'
      '        JMP     @@doneClr'
      '@@wstring:'
      '        CALL    _WStrClr'
      '        JMP     @@doneClr'
      '@@ustring:'
      '        CALL    _UStrClr'
      '@@doneClr:'
      '        ADD     ESI,12'
      '        DEC     EDI'
      '        JNZ     @@loop'
      '        POP     ESI'
      '        POP     EDI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '{$IFDEF MSWINDOWS}'
      '        POP     EBX'
      '{$ENDIF}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IFDEF MSWINDOWS}'
      'procedure _FinalizeWideStrings(InitTable: Pointer);'
      'var'
      '  I: Integer;'
      '  P: _PWideStringInitTableElem;'
      'begin'
      '  for I := 1 to _PWideStringInitTable(InitTable)^.Count do'
      '  begin'
      '    P := @_PWideStringInitTable(InitTable)^.Table[I];'
      '    _WStrClr(_PWideStr(P^.variableAddress)^);'
      '  end;'
      'end;'
      '{$ENDIF}'
      ''
      '{$IFDEF CPU64BITS}'
      'var'
      '  runErrMsg: array[0..37] of _AnsiChr = ('
      '    '#39'R'#39', '#39'u'#39', '#39'n'#39', '#39't'#39', '#39'i'#39', '#39'm'#39', '#39'e'#39', '#39' '#39', // 0..7'
      '    '#39'e'#39', '#39'r'#39', '#39'r'#39', '#39'o'#39', '#39'r'#39', '#39' '#39', '#39' '#39', '#39' '#39', // 8..15'
      '    '#39' '#39', '#39' '#39', '#39'a'#39', '#39't'#39', '#39' '#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', // 16..23'
      '    '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', // 24..31'
      '    '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', #0);           // 32..37'
      '{$ELSE !CPU64BITS}'
      'var'
      '  runErrMsg: array[0..29] of _AnsiChr = ('
      '    '#39'R'#39', '#39'u'#39', '#39'n'#39', '#39't'#39', '#39'i'#39', '#39'm'#39', '#39'e'#39', '#39' '#39', // 0..7'
      '    '#39'e'#39', '#39'r'#39', '#39'r'#39', '#39'o'#39', '#39'r'#39', '#39' '#39', '#39' '#39', '#39' '#39', // 8..15'
      '    '#39' '#39', '#39' '#39', '#39'a'#39', '#39't'#39', '#39' '#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', // 16..23'
      '    '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', '#39'0'#39', #0);           // 24..29'
      '{$ENDIF !CPU64BITS}'
      ''
      'const'
      '  hexDigits: array[0..15] of _AnsiChr = ('
      '    '#39'0'#39', '#39'1'#39', '#39'2'#39', '#39'3'#39', '#39'4'#39', '#39'5'#39', '#39'6'#39', '#39'7'#39','
      '    '#39'8'#39', '#39'9'#39', '#39'A'#39', '#39'B'#39', '#39'C'#39', '#39'D'#39', '#39'E'#39', '#39'F'#39');'
      ''
      'procedure MakeErrorMessage;'
      'var'
      '  digit: Byte;'
      '  Temp: Integer;'
      '  Addr: NativeUInt;'
      'begin'
      '  digit := 16;'
      '  Temp := ExitCode;'
      '  repeat'
      '    runErrMsg[digit] := _AnsiChr(Ord('#39'0'#39') + (Temp mod 10));'
      '    Temp := Temp div 10;'
      '    Dec(digit);'
      '  until Temp = 0;'
      '{$IFDEF CPU64BITS}'
      '  digit := 36;'
      '{$ELSE !CPU64BITS}'
      '  digit := 28;'
      '{$ENDIF !CPU64BITS}'
      '  Addr := UIntPtr(ErrorAddr);'
      '  repeat'
      '    runErrMsg[digit] := hexDigits[Addr and $F];'
      '    Addr := Addr div 16;'
      '    Dec(digit);'
      '  until Addr = 0;'
      'end;'
      ''
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '{$IFDEF CPUX64}'
      'function _ExitDllSetJump(var Buf: __TExitDllJumpBuf): Integer;'
      'asm'
      '        // <- RCX = Context (16 bytes aligned)'
      '        // -> EAX = 0'
      '        .NOFRAME'
      '        MOV     RAX, [RSP]'
      '        LEA     RDX, [RSP+8]'
      '        MOV     [RCX].__TExitDllJumpBuf._RIP, RAX'
      '        MOV     [RCX].__TExitDllJumpBuf._RSP, RDX'
      '        MOV     [RCX].__TExitDllJumpBuf._RBX, RBX'
      '        MOV     [RCX].__TExitDllJumpBuf._RBP, RBP'
      '        {$IF DEFINED(MSWINDOWS)}'
      '        MOV     [RCX].__TExitDllJumpBuf._RSI, RSI'
      '        MOV     [RCX].__TExitDllJumpBuf._RDI, RDI'
      '        {$ENDIF}'
      '        MOV     [RCX].__TExitDllJumpBuf._R12, R12'
      '        MOV     [RCX].__TExitDllJumpBuf._R13, R13'
      '        MOV     [RCX].__TExitDllJumpBuf._R14, R14'
      '        MOV     [RCX].__TExitDllJumpBuf._R15, R15'
      '        {$IF DEFINED(MSWINDOWS)}'
      '        LEA     RAX, [RCX].__TExitDllJumpBuf.XmmBuf+$20'
      '        MOVAPD  [RAX-$20], XMM6'
      '        MOVAPD  [RAX-$10], XMM7'
      '        {$ELSE}'
      '        LEA     RAX, [RCX].__TExitDllJumpBuf.XmmBuf'
      '        {$ENDIF}'
      '        MOVAPD  [RAX], XMM8'
      '        MOVAPD  [RAX+$10], XMM9'
      '        MOVAPD  [RAX+$20], XMM10'
      '        MOVAPD  [RAX+$30], XMM11'
      '        MOVAPD  [RAX+$40], XMM12'
      '        MOVAPD  [RAX+$50], XMM13'
      '        MOVAPD  [RAX+$60], XMM14'
      '        MOVAPD  [RAX+$70], XMM15'
      '        XOR     EAX,EAX'
      'end;'
      '{$ENDIF CPUX64}'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '{$IFDEF CPUX64}'
      
        'procedure _ExitDllLongJump(var Buf: __TExitDllJumpBuf; Val: Inte' +
        'ger);'
      'asm'
      '        // <- RCX = Buf (16 bytes aligned)'
      '        // <- EDX = Val'
      '        // -> EAX = Val'
      '        .NOFRAME'
      '        XCHG    EAX, EDX'
      '        {$IF DEFINED(MSWINDOWS)}'
      '        LEA     RDX, [RCX].__TExitDllJumpBuf.XmmBuf+$20'
      '        MOVAPD  XMM6,  [RDX-$20]'
      '        MOVAPD  XMM7,  [RDX-$10]'
      '        {$ELSE}'
      '        LEA     RDX, [RCX].__TExitDllJumpBuf.XmmBuf'
      '        {$ENDIF}'
      '        MOVAPD  XMM8,  [RDX]'
      '        MOVAPD  XMM9,  [RDX+$10]'
      '        MOVAPD  XMM10, [RDX+$20]'
      '        MOVAPD  XMM11, [RDX+$30]'
      '        MOVAPD  XMM12, [RDX+$40]'
      '        MOVAPD  XMM13, [RDX+$50]'
      '        MOVAPD  XMM14, [RDX+$60]'
      '        MOVAPD  XMM15, [RDX+$70]'
      '        MOV     RBX, [RCX].__TExitDllJumpBuf._RBX'
      '        MOV     RBP, [RCX].__TExitDllJumpBuf._RBP'
      '        {$IF DEFINED(MSWINDOWS)}'
      '        MOV     RSI, [RCX].__TExitDllJumpBuf._RSI'
      '        MOV     RDI, [RCX].__TExitDllJumpBuf._RDI'
      '        {$ENDIF}'
      '        MOV     R12, [RCX].__TExitDllJumpBuf._R12'
      '        MOV     R13, [RCX].__TExitDllJumpBuf._R13'
      '        MOV     R14, [RCX].__TExitDllJumpBuf._R14'
      '        MOV     R15, [RCX].__TExitDllJumpBuf._R15'
      '        MOV     RSP, [RCX].__TExitDllJumpBuf._RSP'
      '        JMP     [RCX].__TExitDllJumpBuf._RIP'
      'end;'
      '{$ENDIF CPUX64}'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF ALPHA_EXITDLL}'
      
        '                                                                ' +
        '                            '
      '{$IF Defined(LINUX64)}'
      
        'function setjmp(var __Env: _jmp_buf): Integer; cdecl; external '#39 +
        'libc.so'#39' name '#39'setjmp'#39';'
      
        'function _setjmp(var __Env: __jmp_buf_tag): Integer; cdecl; exte' +
        'rnal '#39'libc.so'#39' name '#39'_setjmp'#39';'
      
        'procedure longjmp(var __Env: __jmp_buf_tag; __Val: Integer); cde' +
        'cl; external '#39'libc.so'#39' name '#39'longjmp'#39';'
      
        'procedure _longjmp(var __Env: __jmp_buf_tag; __Val: Integer); cd' +
        'ecl; external '#39'libc.so'#39' name '#39'_longjmp'#39';'
      '{$ENDIF Defined(LINUX64)}'
      '{$IF Defined(MACOS64)}'
      
        'function setjmp(var __Env: _jmp_buf): Integer; cdecl; external l' +
        'ibc name '#39'setjmp'#39';'
      
        'function _setjmp(var __Env: __jmp_buf_tag): Integer; cdecl; exte' +
        'rnal libc name '#39'_setjmp'#39';'
      
        'procedure longjmp(var __Env: __jmp_buf_tag; __Val: Integer); cde' +
        'cl; external libc name '#39'longjmp'#39';'
      
        'procedure _longjmp(var __Env: __jmp_buf_tag; __Val: Integer); cd' +
        'ecl; external libc name '#39'_longjmp'#39';'
      '{$ENDIF Defined(MACOS64)}'
      '{$NODEFINE setjmp}'
      '{$NODEFINE _setjmp}'
      '{$NODEFINE longjmp}'
      '{$NODEFINE _longjmp}'
      '{$ENDIF}'
      ''
      '{$IFDEF ALPHA_EXITDLL}'
      
        '                                                                ' +
        '                            '
      
        'function _ExitDllSetJump(var Buf: __TExitDllJumpBuf): Integer; i' +
        'nline;'
      'begin'
      '  Result := _setjmp(Buf.JmpBuf);'
      'end;'
      
        'procedure _ExitDllLongJump(var Buf: __TExitDllJumpBuf; Val: Inte' +
        'ger); inline;'
      'begin'
      '  _longjmp(Buf.JmpBuf, Val);'
      'end;'
      '{$ENDIF ALPHA_EXITDLL}'
      ''
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '{$IFDEF CPUX64}'
      'function _DllMain(Context: PInitContext): Integer;'
      'asm'
      '        .NOFRAME'
      '        LEA     RCX,[RCX].TInitContext.ExitDllJmpBuf'
      '        JMP     _ExitDllSetJump'
      'end;'
      '{$ENDIF CPUX64}'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IF defined(POSIX) and defined(EXTERNALLINKER)}'
      'function _DllMain(Context: PInitContext): Integer;'
      'begin'
      '  // 0 = do initialization and execute user code'
      '  // 1 = successful return'
      '  // 2 = failure return'
      
        '                                                                ' +
        '     '
      
        '                                                                ' +
        '                 '
      
        '                                                                ' +
        '        '
      
        '                                                                ' +
        '             '
      '  {$IFDEF ALPHA_EXITDLL}'
      '  Result := _ExitDllSetJump(Context^.ExitDllJmpBuf);'
      '  {$ELSE ALPHA_EXITDLL}'
      '  Result := 0;'
      '  {$ENDIF !ALPHA_EXITDLL}'
      'end;'
      '{$ENDIF POSIX and EXTERNALLINKER}'
      ''
      
        '                                                                ' +
        '                  '
      
        '                                                                ' +
        '             '
      
        '                                                                ' +
        '               '
      'procedure ExitDll(Context: PInitContext);'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      
        '// Note: ExitDll must not use any thread variables because TlsFr' +
        'ee'
      '// has been called already at DLL_PROCESS_DETACH'
      'var'
      '  ResultCode: Integer;'
      '  ExitDllJmpBuf: __TExitDllJumpBuf;'
      'begin'
      '  ExitDllJmpBuf := Context.ExitDllJmpBuf;'
      '  Context^ := Context.OuterContext^;'
      
        '  ResultCode := Ord(ExitCode <> 0) + 1; // ResultCode=0 for _Exi' +
        'tDllSetJump'
      '  ExitCode := 0;'
      '  _ExitDllLongJump(ExitDllJmpBuf, ResultCode);'
      'end;'
      '{$ELSEIF defined(ALPHA_EXITDLL)}'
      
        '                                                                ' +
        '      '
      'var'
      '  ResultCode: Integer;'
      '  ExitDllJmpBuf: __TExitDllJumpBuf;'
      'begin'
      '  ExitDllJmpBuf := Context.ExitDllJmpBuf;'
      '  Context^ := Context.OuterContext^;'
      
        '  ResultCode := Ord(ExitCode <> 0) + 1; // ResultCode=0 for _Exi' +
        'tDllSetJump'
      '  ExitCode := 0;'
      '{$IF Defined(LINUX64)}'
      '{$ELSEIF Defined(MACOS64)}'
      '{$ELSE}'
      '  _ExitDllLongJump(ExitDllJmpBuf, ResultCode);'
      '{$ENDIF}'
      'end;'
      '{$ELSE !TABLE_BASED_EXCEPTIONS}'
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      'asm'
      '        { ->    EAX  PInitContext }'
      ''
      '        { Restore the InitContext }'
      '        MOV     EDI,EAX'
      '        MOV     EBX,[EDI].TInitContext.DLLSaveEBX'
      '        MOV     EBP,[EDI].TInitContext.DLLSaveEBP'
      '        PUSH    [EDI].TInitContext.DLLSaveESI'
      '        PUSH    [EDI].TInitContext.DLLSaveEDI'
      ''
      '        MOV     ESI,[EDI].TInitContext.OuterContext'
      '        MOV     ECX,(type TInitContext)/4'
      '        REP     MOVSD'
      '        POP     EDI'
      '        POP     ESI'
      ''
      '{$IFDEF MSWINDOWS}'
      '        // Linux: See notes in legacy versions of this file.'
      '        { Return False if ExitCode <> 0, and set ExitCode to 0 }'
      '        XOR     EAX,EAX'
      '        XCHG    EAX, ExitCode'
      '        NEG     EAX'
      '        SBB     EAX,EAX'
      '        INC     EAX'
      '{$ENDIF MSWINDOWS}'
      ''
      '        LEAVE'
      '{$IFDEF MSWINDOWS}'
      '        RET     12'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF LINUX}'
      '        RET'
      '{$ENDIF LINUX}'
      'end;'
      '{$ELSE !CPUX86 or !ASSEMBLER}'
      'begin'
      '  Error(rePlatformNotImplemented);'
      'end;'
      '{$ENDIF !CPUX86 or !ASSEMBLER}'
      '{$ENDIF !TABLE_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '  '
      'procedure WriteErrorMessage;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  Dummy: Cardinal;'
      'begin'
      '  if IsConsole then'
      '  begin'
      '    with TTextRec(Output) do'
      '    begin'
      '      if (Mode = fmOutput) and (BufPos > 0) then'
      
        '        TTextIOFunc(InOutFunc)(TTextRec(Output));  // flush out ' +
        'text buffer'
      '    end;'
      '    // Leave #0 off end of runErrMsg'
      
        '    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), @runErrMsg, Sizeo' +
        'f(runErrMsg) - 1, Dummy, nil);'
      
        '    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), @sLineBreak[1], 2' +
        ', Dummy, nil);'
      '  end'
      '  else if not NoErrMsg then'
      '    MessageBoxA(0, runErrMsg, errCaption, 0);'
      'end;'
      '{$ELSEIF defined(POSIX)}'
      'var'
      '  c: _AnsiChr;'
      'begin'
      '  with TTextRec(Output) do'
      '  begin'
      '    if (Mode = fmOutput) and (BufPos > 0) then'
      
        '      TTextIOFunc(InOutFunc)(TTextRec(Output));  // flush out te' +
        'xt buffer'
      '  end;'
      '  __write(STDERR_FILENO, @runErrMsg, Sizeof(runErrMsg)-1);'
      '  c := sLineBreak[1];'
      '  __write(STDERR_FILENO, @c, 1);'
      'end;'
      '{$ELSE}'
      'begin'
      '   Error(rePlatformNotImplemented);'
      'end;'
      '{$ENDIF}'
      ''
      'var'
      '  RTLInitFailed: Boolean = False;'
      ''
      'procedure _Halt0;'
      'var'
      '  P: procedure;'
      
        '                                                                ' +
        '                           '
      
        '{$IF not (defined(PC_MAPPED_EXCEPTIONS) or defined(SJLJ_BASED_EX' +
        'CEPTIONS)) }'
      '  ExceptObject: TObject;'
      '{$ENDIF !(PC_MAPPED_EXCEPTIONS or SJLJ_BASED_EXCEPTIONS)}'
      'begin'
      '{$IFDEF LINUX64}'
      '  if __InInitLib then'
      '  begin'
      '    __InInitLib := False;'
      '    Exit;'
      '  end;'
      '{$ENDIF LINUX64}'
      '{$IFDEF ANDROID}'
      '  if System.DelphiActivity = nil then'
      '    Exit;'
      '{$ENDIF ANDROID}'
      '{$IF defined(LINUX) or defined(MACOS) or Defined(ANDROID)}'
      '  if (ExitCode <> 0) and CoreDumpEnabled then'
      '    __raise(SIGABRT);'
      ''
      '  if (InitContext.DLLInitState = 2) and (ExitCode <> 0) then'
      '    RTLInitFailed := True;'
      ''
      '  if (InitContext.DLLInitState = 1) and RTLInitFailed then'
      
        '    // RTL failed to initialized in library startup.  Units have' +
        ' already been'
      '    // finalized, don'#39't finalize them again.'
      '    ExitDll(@InitContext);'
      '{$ENDIF LINUX or MACOS or ANDROID}'
      ''
      '  { If there was some kind of runtime error, alert the user }'
      ''
      '  if ErrorAddr <> nil then'
      '  begin'
      '    MakeErrorMessage;'
      '    WriteErrorMessage;'
      '    ErrorAddr := nil;'
      '  end;'
      ''
      
        '  { For DLL_THREAD_ATTACH or DLL_THREAD_DETACH, just cleanup and' +
        ' exit }'
      '                                                             '
      '{$IFDEF MSWINDOWS}'
      '  if Assigned(DLLThreadContext.ExcFrame) and'
      '    (GetCurrentThreadId = DLLThreadContext.ThreadID) then'
      '  begin'
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      '    UnsetExceptionHandler(@DLLThreadContext);'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '    DLLThreadContext.ExcFrame := nil;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      '    ExitDll(@DLLThreadContext);'
      '  end;'
      '{$ENDIF MSWINDOWS}'
      ''
      '  if InitContext.DLLInitState = 0 then'
      '    while ExitProc <> nil do'
      '    begin'
      '      @P := ExitProc;'
      '      ExitProc := nil;'
      '      P;'
      '    end;'
      ''
      
        '  { This loop exists because we might be nested in PackageLoad c' +
        'alls when }'
      
        '  { Halt got called. We need to unwind these contexts.          ' +
        '          }'
      ''
      '  while True do'
      '  begin'
      ''
      
        '    { If we are a library, and we are starting up fine, there ar' +
        'e no units to finalize }'
      ''
      '    if (InitContext.DLLInitState = 2) and (ExitCode = 0) then'
      '      InitContext.InitCount := 0;'
      ''
      
        '    { Clear the exception stack to prevent handled exceptions fr' +
        'om being shown to the user }'
      
        '{$IF not (defined(PC_MAPPED_EXCEPTIONS) or defined(SJLJ_BASED_EX' +
        'CEPTIONS)) or defined(ZCX_BASED_EXCEPTIONS)}'
      '                                             '
      
        '                                                                ' +
        '                                        '
      
        '                                                                ' +
        '                             '
      
        '                                                                ' +
        '                       '
      
        '                                                                ' +
        '                      '
      
        '                                                                ' +
        '                           '
      '                                                             '
      ''
      
        '                                                                ' +
        '                 '
      ''
      '    if InitContext.DLLInitState = 0 then'
      '    begin'
      '      ExceptObject := TObject(AcquireExceptionObject);'
      '      while ExceptObject <> nil do'
      '      begin'
      '        ExceptObject.Free;'
      '        ExceptObject := TObject(AcquireExceptionObject);'
      '      end;'
      '    end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      '    { Undo any unit initializations accomplished so far }'
      ''
      '    FinalizeUnits;'
      ''
      '    if (InitContext.DLLInitState <= 1) or (ExitCode <> 0) then'
      '    begin'
      '      if InitContext.Module <> nil then'
      '        with InitContext do'
      '        begin'
      '          UnregisterModule(Module);'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '          SysUnregisterIPLookup(Module.CodeSegStart);'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      
        '          if (Module.ResInstance <> Module.Instance) and (Module' +
        '.ResInstance <> 0) then'
      '{$IFDEF MSWINDOWS}'
      '            FreeLibrary(Module.ResInstance);'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '            dlclose(Module.ResInstance);'
      '{$ENDIF POSIX}'
      '        end;'
      '    end;'
      ''
      '{$IFDEF STACK_BASED_EXCEPTIONS}'
      '    UnsetExceptionHandler(@InitContext);'
      '{$ENDIF STACK_BASED_EXCEPTIONS}'
      '{$IFDEF TABLE_BASED_EXCEPTIONS}'
      '    InitContext.ExcFrame := nil;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      '{$IFDEF MSWINDOWS}'
      '    if InitContext.DllInitState = 1 then'
      '      InitContext.ExitProcessTLS;'
      '{$ENDIF MSWINDOWS}'
      ''
      '    if InitContext.DllInitState <> 0 then'
      '{$IF Defined(LINUX64) or Defined(MACOS64)}'
      '      Exit;'
      '{$ELSE !LINUX64 and !MACOS64}'
      '      ExitDll(@InitContext);'
      '{$ENDIF LINUX64 or MACOS64}'
      ''
      '    if InitContext.OuterContext = nil then'
      '    begin'
      '      {'
      
        '        If an ExitProcessProc is set, we call it.  Note that at ' +
        'this'
      
        '        point the RTL is completely shutdown.  The only thing th' +
        'is is used'
      
        '        for right now is the proper semantic handling of signals' +
        ' under Linux.'
      '      }'
      '      if Assigned(ExitProcessProc) then'
      '        ExitProcessProc;'
      '{$IF Defined(MSWINDOWS)}'
      '      ExitProcess(ExitCode);'
      '{$ELSEIF Defined(POSIX)}'
      '  {$IFDEF ANDROID}'
      '      _exit(ExitCode);'
      '  {$ELSE  ANDROID}'
      '      __exit(ExitCode);'
      '  {$ENDIF ANDROID}'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF}'
      '      // never arrive hear.'
      '    end;'
      ''
      '    InitContext := InitContext.OuterContext^'
      '  end;'
      'end;'
      ''
      'procedure _Halt;'
      'begin'
      '  ExitCode := Code;'
      '  _Halt0;'
      'end;'
      ''
      '{$IFDEF MSWINDOWS}'
      'procedure DLLShutdown; stdcall;'
      'begin'
      '  try'
      '    if @DLLShutdownProc <> nil then'
      '      DLLShutdownProc;'
      '  except'
      '    // eat all exception.'
      '  end;'
      'end;'
      '{$ENDIF MSWINDOWS}'
      ''
      '                                                              '
      'procedure _Run0Error;'
      'begin'
      '  ErrorAddr := ReturnAddress;'
      '  Halt(0);'
      'end;'
      ''
      
        '                                                                ' +
        '              '
      'procedure _RunError(errorCode: Byte);'
      'begin'
      '  ErrorAddr := ReturnAddress;'
      '  Halt(errorCode);'
      'end;'
      ''
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      'procedure _UnhandledException;'
      'type'
      '  TExceptProc = procedure (Obj: TObject; Addr: Pointer);'
      'begin'
      '  if Assigned(ExceptProc) then'
      '    TExceptProc(ExceptProc)(ExceptObject, ExceptAddr)'
      '  else'
      '    RunErrorAt(230, ExceptAddr);'
      'end;'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      ''
      
        '{$IF Defined(TABLE_BASED_EXCEPTIONS) or Defined(SJLJ_BASED_EXCEP' +
        'TIONS)}'
      
        '                                                                ' +
        '                                '
      'procedure _UnhandledException;'
      'type'
      '  TExceptProc = procedure (const Obj: TObject; Addr: Pointer);'
      'var'
      '  ExceptionObject: TObject;'
      '  ExceptionAddress: Pointer;'
      'begin'
      '  ExceptionObject := ExceptObject;'
      '  ExceptionAddress := ExceptAddr;'
      '  NotifyUnhandled(ExceptionObject, ExceptionAddress);'
      '  if Assigned(ExceptProc) then'
      '    TExceptProc(ExceptProc)(ExceptionObject, ExceptionAddress);'
      '  RunErrorAt(217, ExceptionAddress); // reControlBreak'
      'end;'
      '{$ENDIF TABLE_BASED_EXCEPTIONS}'
      ''
      
        '                                                                ' +
        '    '
      '{$IF Defined(SJLJ_BASED_EXCEPTIONS)}'
      '//procedure _UnhandledException;'
      '//begin'
      '//end;'
      
        '{$ENDIF !PC_MAPPED_EXCEPTIONS & !TABLE_BASED_EXCEPTIONS & (PUREP' +
        'ASCAL or !CPUX86)}'
      ''
      ''
      ''
      
        'procedure _Assert(const Message, Filename: string; LineNumber: I' +
        'nteger);'
      'begin'
      '  if Assigned(AssertErrorProc) then'
      
        '    AssertErrorProc(Message, Filename, LineNumber, ReturnAddress' +
        ')'
      '  else'
      '    ErrorAt(Byte(reAssertionFailed), ReturnAddress);'
      'end;'
      ''
      'type'
      '  PThreadRec = ^TThreadRec;'
      '  TThreadRec = record'
      '    {'
      
        '      WARNING: Don'#39't change these fields without also changing t' +
        'hem in'
      '      the C++ RTL : winrtl/source/vcl/crtlvcl.cpp'
      '    }'
      '    Func: TThreadFunc;'
      '    Parameter: Pointer;'
      '  end;'
      ''
      
        '                                                                ' +
        '                             '
      '{$IFDEF MSWINDOWS}'
      'function ThreadWrapper(Parameter: Pointer): Integer; stdcall;'
      '{$ELSE}'
      'function ThreadWrapper(Parameter: Pointer): NativeInt; cdecl;'
      '{$ENDIF}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  ThreadRec: TThreadRec;'
      'begin'
      '  Result := 0; // supress warning'
      '  try'
      '    _FpuInit;'
      '{$IF Defined(LINUX64) and Defined(CPUX64)}'
      '    FPExceptionMaskBits := DefaultFPEnv;'
      '{$ENDIF LINUX64}'
      '    ThreadRec := PThreadRec(Parameter)^;'
      '    FreeMem(PThreadRec(Parameter));'
      '    Result := ThreadRec.Func(ThreadRec.Parameter);'
      '  except'
      '    _UnhandledException;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        { Mark the top of the stack with a signature }'
      '        PUSH    UNWINDFI_TOPOFSTACK'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    _FpuInit'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBP'
      '{$IFNDEF PC_MAPPED_EXCEPTIONS}'
      '        XOR     ECX,ECX'
      '        PUSH    offset _ExceptionHandler'
      '        MOV     EDX,FS:[ECX]'
      '        PUSH    EDX'
      '        MOV     FS:[ECX],ESP'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      
        '    // The signal handling code in SysUtils depends on being abl' +
        'e to'
      
        '    // discriminate between Delphi threads and foreign threads i' +
        'n order'
      
        '    // to choose the disposition of certain signals.  It does th' +
        'is by'
      
        '    // testing a TLS index.  However, we allocate TLS in a lazy ' +
        'fashion,'
      
        '    // so this test can fail unless we'#39've already allocated the ' +
        'TLS segment.'
      
        '    // So we force the allocation of the TLS index value by touc' +
        'hing a TLS'
      
        '    // value here.  So don'#39't remove this silly call to AreOSExce' +
        'ptionsBlocked.'
      '        CALL    AreOSExceptionsBlocked'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      '        MOV     EAX,Parameter'
      ''
      '        MOV     ECX,[EAX].TThreadRec.Parameter'
      '        MOV     EDX,[EAX].TThreadRec.Func'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    ECX'
      '        PUSH    EDX'
      '        CALL    _FreeMem'
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    EDX'
      ''
      '{$IFNDEF PC_MAPPED_EXCEPTIONS}'
      '        XOR     EDX,EDX'
      '        POP     ECX'
      '        MOV     FS:[EDX],ECX'
      '        POP     ECX'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      '        POP     EBP'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        { Ditch our TOS marker }'
      '        ADD     ESP, 4'
      '{$ENDIF PC_MAPPED_EXCEPTIONS}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      '{$IFDEF MSWINDOWS}'
      
        'function BeginThread(SecurityAttributes: Pointer; StackSize: Lon' +
        'gWord;'
      
        '  ThreadFunc: TThreadFunc; Parameter: Pointer; CreationFlags: Lo' +
        'ngWord;'
      '  var ThreadId: TThreadID): THandle;'
      'var'
      '  P: PThreadRec;'
      'begin'
      '  if Assigned(SystemThreadFuncProc) then'
      '    P := PThreadRec(SystemThreadFuncProc(ThreadFunc, Parameter))'
      '  else'
      '  begin'
      '    New(P);'
      '    P.Func := ThreadFunc;'
      '    P.Parameter := Parameter;'
      '  end;'
      ''
      '  IsMultiThread := TRUE;'
      ''
      
        '  Result := CreateThread(SecurityAttributes, StackSize, @ThreadW' +
        'rapper, P,'
      '    CreationFlags, ThreadID);'
      ''
      
        '  { P variable is supposed to be freed by the ThreadWrapper rout' +
        'ine.'
      
        '    If the call to CreateThread fails, then ThreadWrapper will n' +
        'ot be called'
      
        '    and P will not get freed. Check for failure now and free P i' +
        'f required.'
      '  }'
      '  if Result = 0 then'
      '    Dispose(P);'
      'end;'
      ''
      ''
      'procedure EndThread(ExitCode: Integer);'
      'begin'
      '  if Assigned(SystemThreadEndProc) then'
      '    SystemThreadEndProc(ExitCode);'
      '  ExitThread(ExitCode);'
      'end;'
      '{$ENDIF}'
      ''
      '{$IFDEF POSIX}'
      'function BeginThread(Attribute: PThreadAttr;'
      '                     ThreadFunc: TThreadFunc;'
      '                     Parameter: Pointer;'
      '                     var ThreadId: TThreadID): Integer;'
      'var'
      '  P: PThreadRec;'
      '  Thread: pthread_t;'
      'begin'
      '  if Assigned(BeginThreadProc) then'
      
        '    Result := BeginThreadProc(Attribute, ThreadFunc, Parameter, ' +
        'ThreadId)'
      '  else'
      '  begin'
      '    New(P);'
      '    P.Func := ThreadFunc;'
      '    P.Parameter := Parameter;'
      '    IsMultiThread := True;'
      ''
      
        '    Result := pthread_create(Thread, Ppthread_attr_t(Attribute),' +
        ' @ThreadWrapper, P);'
      '    if Result = 0 then'
      '      ThreadID := TThreadID(Thread);'
      ''
      
        '    { P variable is supposed to be freed by the ThreadWrapper ro' +
        'utine.'
      
        '      If the call to CreateThread fails, then ThreadWrapper will' +
        ' not be called'
      
        '      and P will not get freed. Check for failure now and free P' +
        ' if required.'
      '    }'
      '    if Result <> 0 then'
      '      Dispose(P);'
      '  end;'
      'end;'
      ''
      'procedure EndThread(ExitCode: Integer);'
      'begin'
      '  if Assigned(EndThreadProc) then'
      '    EndThreadProc(ExitCode);'
      
        '  // No "else" required since EndThreadProc does not (!!should n' +
        'ot!!) return.'
      '  pthread_detach(pthread_t(GetCurrentThreadID));'
      '  pthread_exit(ExitCode);'
      'end;'
      '{$ENDIF POSIX}'
      ''
      ''
      '{ STRING SUPPORT }'
      ''
      '{ ----------------------------------------------------- }'
      '{       internal functions & procedures for strings     }'
      '{ ----------------------------------------------------- }'
      ''
      '// S must be non-nil.'
      
        'function __StringLength(const S: UnicodeString): Integer; overlo' +
        'ad; inline;'
      'begin'
      
        '  Result := PInteger(PByte(S) - 4)^;                // StrRec.le' +
        'ngth'
      'end;'
      ''
      '// S must be non-nil.'
      '// Returns number of characters.'
      
        '// Note: On Windows, length field contains number of bytes and n' +
        'ot number'
      '//       of characters.'
      
        'function __StringLength(const S: _WideStr): Integer; overload; i' +
        'nline;'
      'begin'
      '{$IFDEF MSWINDOWS}'
      
        '  Result := PInteger(PByte(S) - 4)^ div 2;          // size fiel' +
        'd of BSTR'
      '{$ELSE}'
      
        '  Result := PInteger(PByte(S) - 4)^;                // StrRec.le' +
        'ngth'
      '{$ENDIF}'
      'end;'
      ''
      '// S must be non-nil'
      
        'function __StringLength(const S: _RawByteStr): Integer; overload' +
        '; inline;'
      'begin'
      
        '  Result := PInteger(PByte(S) - 4)^;                // StrRec.le' +
        'ngth'
      'end;'
      ''
      '// S must be non-nil'
      
        'function __StringLength(const S: Pointer): Integer; overload; in' +
        'line;'
      'begin'
      
        '  Result := PInteger(PByte(S) - 4)^;                // StrRec.le' +
        'ngth'
      'end;'
      ''
      '// S must be non-nil'
      
        'function __StringRefCnt(const S: UnicodeString): Integer; overlo' +
        'ad; inline;'
      'begin'
      
        '  Result := PInteger(PByte(S) - 8)^;                // StrRec.re' +
        'fCnt'
      'end;'
      ''
      '{$IFNDEF MSWINDOWS}'
      '// S must be non-nil'
      '// Note: On Windows, _WideStr doesn'#39't contain refCount field.'
      
        'function __StringRefCnt(const S: _WideStr): Integer; overload; i' +
        'nline;'
      'begin'
      
        '  Result := PInteger(PByte(S) - 8)^;                // StrRec.re' +
        'fCnt'
      'end;'
      '{$ENDIF}'
      ''
      '// S must be non-nil'
      
        'function __StringRefCnt(const S: _RawByteStr): Integer; overload' +
        '; inline;'
      'begin'
      
        '  Result := PInteger(PByte(S) - 8)^;                // StrRec.re' +
        'fCnt'
      'end;'
      ''
      '// S must be non-nil. Don'#39't use for Windows _WideStr.'
      
        'function __StringRefCnt(const S: Pointer): Integer; overload; in' +
        'line;'
      'begin'
      
        '  Result := PInteger(PByte(S) - 8)^;                // StrRec.re' +
        'fCnt'
      'end;'
      ''
      '// S must be non-nil'
      
        'function __StringCodePage(const S: UnicodeString): Word; overloa' +
        'd; inline;'
      'begin'
      
        '  Result := PWord(PByte(S) - 12)^;                  // StrRec.co' +
        'dePage'
      'end;'
      ''
      '{$IFNDEF MSWINDOWS}'
      '// S must be non-nil'
      '// Note: On Windows, _WideStr doesn'#39't contain codePage field.'
      
        'function __StringCodePage(const S: _WideStr): Word; overload; in' +
        'line;'
      'begin'
      
        '  Result := PWord(PByte(S) - 12)^;                  // StrRec.co' +
        'dePage'
      'end;'
      '{$ENDIF}'
      ''
      '// S must be non-nil'
      
        'function __StringCodePage(const S: _RawByteStr): Word; overload;' +
        ' inline;'
      'begin'
      
        '  Result := PWord(PByte(S) - 12)^;                  // StrRec.co' +
        'dePage'
      'end;'
      ''
      '// S must be non-nil. Don'#39't use for Windows _WideStr.'
      
        'function __StringCodePage(const S: Pointer): Word; overload; inl' +
        'ine;'
      'begin'
      
        '  Result := PWord(PByte(S) - 12)^;                  // StrRec.co' +
        'dePage'
      'end;'
      ''
      ''
      
        '{ ------------------------------------------------------------- ' +
        '}'
      
        '{       Compiler helper for string allocation and release       ' +
        '}'
      
        '{ ------------------------------------------------------------- ' +
        '}'
      ''
      'function _NewUnicodeString(CharLength: Integer): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      'begin'
      '  Result := nil;'
      '  if CharLength > 0 then'
      '  begin'
      
        '    // Allocate a memory with record and extra wide-null termina' +
        'tor.'
      
        '    if CharLength >= (MaxInt - SizeOf(StrRec)) div SizeOf(WideCh' +
        'ar) then _IntOver;'
      
        '    GetMem(P, SizeOf(StrRec) + (CharLength + 1) * SizeOf(WideCha' +
        'r));'
      '    Result := Pointer(PByte(P) + SizeOf(StrRec));'
      '    P.length := CharLength;'
      '    P.refCnt := 1;'
      '    P.elemSize := SizeOf(WideChar);'
      '    P.codePage := Word(DefaultUnicodeCodePage);'
      '    PWideChar(Result)[CharLength] := #0;'
      '  end;'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX     length                  }'
      '        { <-    EAX     pointer to new string   }'
      '        TEST    EAX,EAX'
      '        JLE     @@lengthLEZero  // length <= 0?'
      '        PUSH    EAX             // save length'
      '        ADD     EAX,EAX         // convert to bytes'
      '        JO      @@overflow'
      '        ADD     EAX,rOff+2      // + record + terminator'
      '        JO      @@overflow'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      '        CALL    _GetMem'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      '        ADD     EAX,rOff'
      
        '        POP     EDX                              // requested st' +
        'ring length'
      '        MOV     [EAX-skew].StrRec.refCnt,1'
      '        MOV     [EAX-skew].StrRec.length,EDX'
      
        '        MOV     word ptr [EAX+EDX*2],0           // wide null te' +
        'rminator'
      '        MOV     word ptr [EAX-skew].StrRec.elemSize,2'
      '{$IFDEF PIC}'
      '        PUSH    EBX'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        CALL    GetGOT'
      '        MOV     EDX, [EAX].OFFSET DefaultUnicodeCodePage'
      '        MOV     EDX, [EDX]'
      '        POP     ECX'
      '        POP     EAX'
      '        POP     EBX'
      '{$ELSE !PIC}'
      '        MOV     EDX, DefaultUnicodeCodePage'
      '{$ENDIF}'
      '        MOV     word ptr [EAX-skew].StrRec.codePage,DX'
      '        RET'
      '@@overflow:'
      '        {$IFDEF ALIGN_STACK}'
      '        POP     EAX'
      '        {$ENDIF ALIGN_STACK}'
      '        JMP     _IntOver'
      '@@lengthLEZero:'
      '        XOR     EAX,EAX'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      
        'function _NewAnsiString(CharLength: Integer; CodePage: Word): Po' +
        'inter;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      'begin'
      '  Result := nil;'
      '  if CharLength > 0 then'
      '  begin'
      
        '    // Alloc an extra null for strings with even length.  This h' +
        'as no actual'
      
        '    // cost since the allocator will round up the request to an ' +
        'even size'
      
        '    // anyway. All _WideStr allocations have even length, and ne' +
        'ed a double'
      '    // null terminator.'
      '    if CharLength >= MaxInt - SizeOf(StrRec) then _IntOver;'
      
        '    GetMem(P, CharLength + SizeOf(StrRec) + 1 + ((CharLength + 1' +
        ') and 1));'
      '    Result := Pointer(PByte(P) + SizeOf(StrRec));'
      '    P.length := CharLength;'
      '    P.refcnt := 1;'
      '    if CodePage = 0 then'
      '{$IFDEF NEXTGEN}'
      '      CodePage := Word(CP_UTF8);'
      '{$ELSE  NEXTGEN}'
      '      CodePage := Word(DefaultSystemCodePage);'
      '{$ENDIF NEXTGEN}'
      '    P.codePage := CodePage;'
      '    P.elemSize := 1;'
      
        '    PWideChar(Result)[CharLength div 2] := #0;  // length guaran' +
        'teed >= 2'
      '  end;'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX     length                  }'
      '        { <-    EAX pointer to new string       }'
      ''
      '        TEST    EAX,EAX'
      '        JLE     @@lengthLEZero'
      '        PUSH    EAX'
      
        '        ADD     EAX,rOff+2                      // one or two nu' +
        'lls (Ansi/Wide)'
      '        JO      @@overflow'
      
        '        AND     EAX, not 1                      // round up to e' +
        'ven length'
      '        PUSH    EDX'
      '        PUSH    EAX'
      '        CALL    _GetMem'
      
        '        POP     EDX                             // actual alloca' +
        'ted length (>= 2)'
      '        POP     ECX'
      
        '        MOV     word ptr [EAX+EDX-2],0          // double null t' +
        'erminator'
      '        ADD     EAX,rOff'
      
        '        POP     EDX                             // requested str' +
        'ing length'
      '        MOV     [EAX-skew].StrRec.length,EDX'
      '        MOV     [EAX-skew].StrRec.refCnt,1'
      '        TEST    ECX,ECX'
      '        JNE     @@NotDefault'
      '{$IFDEF PIC}'
      '        PUSH    EBX'
      '        PUSH    EAX'
      '        CALL    GetGOT'
      '        MOV     ECX,[EAX].OFFSET DefaultSystemCodePage'
      '        MOV     ECX, [ECX]'
      '        POP     EAX'
      '        POP     EBX'
      '{$ELSE !PIC}'
      '        MOV     ECX,DefaultSystemCodePage'
      '{$ENDIF !PIC}'
      '@@NotDefault:'
      '        MOV     EDX,ECX'
      '        MOV     word ptr [EAX-skew].StrRec.codePage,DX'
      '        MOV     word ptr [EAX-skew].StrRec.elemSize,1'
      '        RET'
      '@@overflow:'
      '        {$IFDEF ALIGN_STACK}'
      '        POP     EAX'
      '        {$ENDIF ALIGN_STACK}'
      '        JMP     _IntOver'
      '@@lengthLEZero:'
      '        XOR     EAX,EAX'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IFDEF MSWINDOWS}'
      'procedure WStrError;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  ErrorAt(byte(reOutOfMemory), ReturnAddress);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        MOV     AL,reOutOfMemory'
      '        JMP     Error'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      ''
      'function _NewWideString(CharLength: Integer): Pointer;'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '   Result := _NewUnicodeString(CharLength);'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     _NewUnicodeString'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := nil;'
      '  if CharLength <> 0 then'
      '  begin'
      '    Result := SysAllocStringLen(nil, CharLength);'
      '    if Result = nil then'
      '      WStrError;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     length                  }'
      '        { <-    EAX     pointer to new string   }'
      ''
      '        TEST    EAX,EAX'
      '        JE      @@1'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,4'
      '        {$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    0'
      '        CALL    SysAllocStringLen'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,4'
      '        {$ENDIF ALIGN_STACK}'
      '        TEST    EAX,EAX'
      '        JE      WStrError'
      '@@1:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      '   Result := _NewUnicodeString(CharLength);'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _UStrClr(var S): Pointer;'
      'var'
      '  P: PStrRec;'
      'begin'
      '  if Pointer(S) <> nil then'
      '  begin'
      '    P := Pointer(PByte(S) - SizeOf(StrRec));'
      '    Pointer(S) := nil;'
      '    if P.refCnt > 0 then'
      '    begin'
      '      if AtomicDecrement(P.refCnt) = 0 then'
      '        FreeMem(P);'
      '    end;'
      '  end;'
      '  Result := @S;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _UStrClr(var S);'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to str  }'
      '        { <-    EAX     pointer to str  }'
      ''
      
        '        MOV     EDX,[EAX]                       { fetch str     ' +
        '                }'
      
        '        TEST    EDX,EDX                         { if nil, nothin' +
        'g to do         }'
      '        JE      @@done'
      
        '        MOV     dword ptr [EAX],0               { clear str     ' +
        '                }'
      
        '        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt  ' +
        '                }'
      
        '        DEC     ECX                             { if < 0: litera' +
        'l str           }'
      '        JL      @@done'
      
        '   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec' +
        ' refCount       }'
      '        JNE     @@done'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      
        '        LEA     EAX,[EDX-skew]                  { if refCnt now ' +
        'zero, deallocate}'
      '        CALL    _FreeMem'
      '        POP     EAX'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      '@@done:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _LStrClr(var S): Pointer;'
      'var'
      '  P: PStrRec;'
      'begin'
      '  if Pointer(S) <> nil then'
      '  begin'
      '    P := Pointer(PByte(S) - SizeOf(StrRec));'
      '    Pointer(S) := nil;'
      '    if P.refCnt > 0 then'
      '    begin'
      '      if AtomicDecrement(P.refCnt) = 0 then'
      '        FreeMem(P);'
      '    end;'
      '  end;'
      '  Result := @S;'
      'end;'
      '{$ELSE X86ASMRTL}'
      '{$IFDEF CPUX86}'
      'procedure _LStrClr(var S);'
      'asm'
      '        { ->    EAX     pointer to str  }'
      '        { <-    EAX     pointer to str  }'
      ''
      
        '        MOV     EDX,[EAX]                       { fetch str     ' +
        '                }'
      
        '        TEST    EDX,EDX                         { if nil, nothin' +
        'g to do         }'
      '        JE      @@done'
      
        '        MOV     dword ptr [EAX],0               { clear str     ' +
        '                }'
      
        '        MOV     ECX,[EDX-skew].StrRec.refCnt    { fetch refCnt  ' +
        '                }'
      
        '        DEC     ECX                             { if < 0: litera' +
        'l str           }'
      '        JL      @@done'
      
        '   LOCK DEC     [EDX-skew].StrRec.refCnt        { threadsafe dec' +
        ' refCount       }'
      '        JNE     @@done'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      
        '        LEA     EAX,[EDX-skew]                  { if refCnt now ' +
        'zero, deallocate}'
      '        CALL    _FreeMem'
      '        POP     EAX'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      '@@done:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IFDEF POSIX}'
      '{$IF not defined(X86ASMRTL)}'
      'function _WStrClr(var S): Pointer;'
      'begin'
      '  Result := _UStrClr(S);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _WStrClr(var S);'
      'asm'
      '        JMP     _UStrClr;'
      'end;'
      '{$ENDIF X86ASMRTL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IF not defined(X86ASMRTL)}'
      'function _WStrClr(var S): Pointer;'
      'var'
      '  P: Pointer;'
      'begin'
      '  if Pointer(S) <> nil then'
      '  begin'
      '    P := Pointer(S);'
      '    Pointer(S) := nil;'
      '    SysFreeString(_WideStr(P));'
      '  end;'
      '  Result := @S;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _WStrClr(var S);'
      'asm'
      '        { ->    EAX     pointer to str  }'
      '        { <-    EAX     pointer to Str  }'
      ''
      '        MOV     EDX,[EAX]'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      '        MOV     DWORD PTR [EAX],0'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,4'
      '        {$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        CALL    SysFreeString'
      '        POP     EAX'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,4'
      '        {$ENDIF ALIGN_STACK}'
      '@@1:'
      'end;'
      '{$ENDIF X86ASMRTL}'
      '{$ENDIF MSWINDOWS}'
      ''
      ''
      'procedure _UStrArrayClr(var StrArray; Count: Integer);'
      'var'
      '  P: PPointer;'
      '  S: PStrRec;'
      'begin'
      '  P := @StrArray;'
      '  repeat'
      '    S := P^;'
      '    if S <> nil then'
      '    begin'
      '      P^ := nil;'
      '      Dec(S);'
      '      if (S.refCnt > 0) and (AtomicDecrement(S.refCnt) = 0) then'
      '        FreeMem(S);'
      '    end;'
      '    Inc(P);'
      '    Dec(Count);'
      '  until Count = 0;'
      'end;'
      ''
      ''
      'procedure _LStrArrayClr(var StrArray; Count: Integer);'
      'var'
      '  P: PPointer;'
      '  S: PStrRec;'
      'begin'
      '  P := @StrArray;'
      '  repeat'
      '    S := P^;'
      '    if S <> nil then'
      '    begin'
      '      P^ := nil;'
      '      Dec(S);'
      '      if (S.refCnt > 0) and (AtomicDecrement(S.refCnt) = 0) then'
      '        FreeMem(S);'
      '    end;'
      '    Inc(P);'
      '    Dec(Count);'
      '  until Count = 0;'
      'end;'
      ''
      ''
      'procedure _WStrArrayClr(var StrArray; Count: Integer);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _UStrArrayClr(StrArray, Count);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '        JMP     _UStrArrayClr'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  S: PPointer;'
      '  P: Pointer;'
      'begin'
      '  S := PPointer(@StrArray);'
      '  while Count > 0 do'
      '  begin'
      '    P := S^;'
      '    if P <> nil then'
      '    begin'
      '      S^ := nil;'
      '      SysFreeString(_WideStr(P));'
      '    end;'
      '    Inc(S);'
      '    Dec(Count);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to str      }'
      '        {       EDX cnt                 }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '@@1:    MOV     EAX,[EBX]'
      '        TEST    EAX,EAX'
      '        JE      @@2'
      '        MOV     DWORD PTR [EBX],0'
      '        PUSH    EAX'
      '        CALL    SysFreeString'
      '@@2:    ADD     EBX,4'
      '        DEC     ESI'
      '        JNE     @@1'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      ''
      ''
      'function _UStrAddRef(Str: Pointer): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      'begin'
      '  Result := Str;'
      '  if Str <> nil then'
      '  begin'
      '    P := Pointer(PByte(Str) - SizeOf(StrRec));'
      '    if P.refcnt >= 0 then'
      '      AtomicIncrement(P.refcnt);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     str     }'
      '        TEST    EAX,EAX'
      '        JE      @@exit'
      '        MOV     EDX,[EAX-skew].StrRec.refCnt'
      '        INC     EDX'
      '        JLE     @@exit'
      '   LOCK INC     [EAX-skew].StrRec.refCnt'
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function _LStrAddRef(Str: Pointer): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      'begin'
      '  Result := Str;'
      '  if Str <> nil then'
      '  begin'
      '    P := Pointer(PByte(Str) - SizeOf(StrRec));'
      '    if P.refcnt >= 0 then'
      '      AtomicIncrement(P.refcnt);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     str     }'
      '        TEST    EAX,EAX'
      '        JE      @@exit'
      '        MOV     EDX,[EAX-skew].StrRec.refCnt'
      '        INC     EDX'
      '        JLE     @@exit'
      '   LOCK INC     [EAX-skew].StrRec.refCnt'
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      '// Note: Windows version of _WideStr is single reference.'
      '//       Only _WStrAddRef for Windows of *StrAddRef versions has'
      '//       '#39'var'#39' parameter.'
      '{$IFDEF POSIX}'
      'function _WStrAddRef(Str: Pointer): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := _UStrAddRef(Str);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '        JMP     _UStrAddRef'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      'function _WStrAddRef(var Str: _WideStr): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      'begin'
      '  Result := Pointer(Str);'
      '  if Pointer(Str) <> nil then'
      '  begin'
      '    Len := __StringLength(Str);'
      
        '    Result := Pointer(SysAllocStringLen(PWideChar(Pointer(Str)),' +
        ' Len));'
      '    if Result = nil then'
      '      WStrError;'
      '    Pointer(Str) := Result;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to _WideStr     }'
      '        { <-    EAX     str                     }'
      '        MOV     EDX,[EAX]'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      '        PUSH    EAX'
      '        MOV     ECX,[EDX-4]'
      '        SHR     ECX,1'
      '        PUSH    ECX'
      '        PUSH    EDX'
      '        CALL    SysAllocStringLen'
      '        POP     EDX'
      '        TEST    EAX,EAX'
      '        JE      WStrError'
      '        MOV     [EDX],EAX'
      '@@1:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       internal string conversion                      }'
      '{ ----------------------------------------------------- }'
      ''
      ''
      
        'function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; ' +
        'const WCharSource: PWideChar; SrcChars: Integer; CodePage: Integ' +
        'er): Integer;'
      'begin'
      '  if CodePage = 0 then'
      '{$IFDEF NEXTGEN}'
      '    CodePage := CP_UTF8;'
      '{$ELSE  NEXTGEN}'
      '    CodePage := DefaultSystemCodePage;'
      '{$ENDIF NEXTGEN}'
      
        '  Result := LocaleCharsFromUnicode(CodePage, 0, WCharSource, Src' +
        'Chars, CharDest,'
      '    DestBytes, nil, nil);'
      'end;'
      ''
      
        'function CharFromWChar(CharDest: _PAnsiChr; DestBytes: Integer; ' +
        'const WCharSource: PWideChar; SrcChars: Integer): Integer;'
      'begin'
      
        '  Result := CharFromWChar(CharDest, DestBytes, WCharSource, SrcC' +
        'hars, DefaultSystemCodePage);'
      'end;'
      ''
      
        'function WCharFromChar(WCharDest: PWideChar; DestChars: Integer;' +
        ' const CharSource: _PAnsiChr; SrcBytes: Integer; CodePage: Integ' +
        'er): Integer;'
      'begin'
      
        '  Result := UnicodeFromLocaleChars(CodePage, 0, CharSource, SrcB' +
        'ytes, WCharDest,'
      '    DestChars);'
      'end;'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       basic string constructors                       }'
      '{ ----------------------------------------------------- }'
      ''
      
        'procedure _UStrFromPWCharLen(var Dest: UnicodeString; Source: PW' +
        'ideChar; CharLength: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Temp: Pointer;'
      'begin'
      '  Temp := Pointer(Dest);'
      '  if CharLength > 0 then'
      '  begin'
      '    Pointer(Dest) := _NewUnicodeString(CharLength);'
      '    if Source <> nil then'
      
        '      Move(Source^, Pointer(Dest)^, CharLength * SizeOf(WideChar' +
        '));'
      '  end'
      '  else'
      '    Pointer(Dest) := nil;'
      '  _UStrClr(Temp);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest         }'
      '        {       EDX     source                  }'
      '        {       ECX     length in characters    }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     EBX,EAX // EBX := addr of Dest (result) in EBX'
      '        MOV     ESI,EDX // ESI := source'
      '        MOV     EDI,ECX // EDI := length'
      ''
      '        { allocate new string }'
      ''
      '        MOV     EAX,EDI // EAX := length'
      ''
      '        CALL    _NewUnicodeString // EAX := new string (result)'
      '        MOV     ECX,EDI // ECX := length'
      '        MOV     EDI,EAX // EDI := result'
      ''
      '        TEST    ESI,ESI // nil source?'
      '        JE      @@noMove'
      ''
      '        MOV     EDX,EAX // EDX := result (dest for Move)'
      '        MOV     EAX,ESI // EAX := source (source for Move)'
      
        '        SHL     ECX,1   // ECX := ECX * 2 (turn length into char' +
        'acters)'
      '        CALL    Move'
      ''
      '        { assign the result to dest }'
      ''
      '@@noMove:'
      '        MOV     EAX,EBX'
      '        CALL    _LStrClr'
      '        MOV     [EBX],EDI'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _WStrFromPWCharLen(var Dest: _WideStr; Source: PWideCh' +
        'ar; CharLength: Integer);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  _UStrFromPWCharLen(UnicodeString(Pointer(Dest)), Source, CharL' +
        'ength);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '        JMP     _UStrFromPWCharLen'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Temp: Pointer;'
      'begin'
      '  if CharLength <= 0 then'
      '    _WStrClr(Dest)'
      '  else'
      '  begin'
      '    Temp := SysAllocStringLen(Source, CharLength);'
      '    if Temp = nil then'
      '      WStrError;'
      '  //  Temp := InterlockedExchangePointer(Pointer(Dest), Temp);'
      '  //  if Temp <> nil then'
      '  //    SysFreeString(_WideStr(Temp));'
      '    if Pointer(Dest) <> nil then'
      '      SysFreeString(Dest);'
      '    Pointer(Dest) := Temp;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)      }'
      '        {       EDX     Pointer to characters (source)    }'
      '        {       ECX     number of characters  (not bytes) }'
      '        TEST    ECX,ECX'
      '        JE      _WStrClr'
      ''
      '        PUSH    EAX'
      ''
      '        PUSH    ECX'
      '        PUSH    EDX'
      '        CALL    SysAllocStringLen'
      '        TEST    EAX,EAX'
      '        POP     EDX'
      '        JE      WStrError'
      ''
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      '        PUSH    [EDX].PWideChar'
      '        MOV     [EDX],EAX'
      ''
      '        CALL    SysFreeString'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,8'
      '        {$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      
        '  _UStrFromPWCharLen(UnicodeString(Pointer(Dest)), Source, CharL' +
        'ength);'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      
        '                                                                ' +
        '                                                                ' +
        '           '
      
        'procedure _LStrFromPCharLen(var Dest: _AnsiStr; Source: _PAnsiCh' +
        'r; Length: Integer; CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: _PAnsiChr;'
      'begin'
      '  P := _NewAnsiString(Length, CodePage);'
      '  if Source <> nil then'
      '    Move(Source^, P^, Length);'
      '  _LStrClr(Dest);'
      '  Pointer(Dest) := P;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '        { ->    EAX     pointer to dest }'
      '        {       EDX     source          }'
      '        {       ECX     length          }'
      '        {       [ESP+0] caller EBP      }'
      '        {       [ESP+4] return address  }'
      '        {       [ESP+8] CodePage        }'
      '{$IFDEF ALIGN_STACK}'
      '        // EBP is already pushed on the stack'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      ''
      '        { allocate new string }'
      ''
      '        MOV     EAX,EDI'
      '        MOVZX   EDX,CodePage'
      ''
      '        CALL    _NewAnsiString'
      '        MOV     ECX,EDI'
      '        MOV     EDI,EAX'
      ''
      '        TEST    ESI,ESI'
      '        JE      @@noMove'
      ''
      '        MOV     EDX,EAX'
      '        MOV     EAX,ESI'
      '        CALL    Move'
      ''
      '        { assign the result to dest }'
      ''
      '@@noMove:'
      '        MOV     EAX,EBX'
      '        CALL    _LStrClr'
      '        MOV     [EBX],EDI'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure InternalUStrFromPCharLen(var Dest: UnicodeString; Sour' +
        'ce: _PAnsiChr; Length: Integer; CodePage: Integer);'
      'var'
      '  DestLen: Integer;'
      '  Buffer: array[0..2047] of WideChar;'
      'begin'
      '  if Length <= 0 then'
      '  begin'
      '    _UStrClr(Dest);'
      '    Exit;'
      '  end;'
      '  if Length+1 < High(Buffer) then'
      '  begin'
      
        '    DestLen := WCharFromChar(Buffer, High(Buffer), Source, Lengt' +
        'h, CodePage);'
      '    if DestLen > 0 then'
      '    begin'
      '      _UStrFromPWCharLen(Dest, @Buffer, DestLen);'
      '      Exit;'
      '    end;'
      '  end;'
      ''
      '  DestLen := (Length + 1);'
      '  _UStrSetLength(Dest, DestLen);  // overallocate, trim later'
      
        '  DestLen := WCharFromChar(Pointer(Dest), DestLen, Source, Lengt' +
        'h, CodePage);'
      '  if DestLen < 0 then'
      '    DestLen := 0;'
      '  _UStrSetLength(Dest, DestLen);'
      
        '                                                                ' +
        '   '
      'end;'
      ''
      
        'procedure _UStrFromPCharLen(var Dest: UnicodeString; Source: _PA' +
        'nsiChr; Length: Integer);'
      'begin'
      
        '  InternalUStrFromPCharLen(Dest, Source, Length, DefaultSystemCo' +
        'dePage);'
      'end;'
      ''
      
        'procedure InternalWStrFromPCharLen(var Dest: _WideStr; Source: _' +
        'PAnsiChr; Length: Integer; CodePage: Integer);'
      'var'
      '  DestLen: Integer;'
      '  Buffer: array[0..2047] of WideChar;'
      'begin'
      '  if Length <= 0 then'
      '  begin'
      '    _WStrClr(Dest);'
      '    Exit;'
      '  end;'
      '  if Length+1 < High(Buffer) then'
      '  begin'
      
        '    DestLen := WCharFromChar(Buffer, High(Buffer), Source, Lengt' +
        'h, CodePage);'
      '    if DestLen > 0 then'
      '    begin'
      '      _WStrFromPWCharLen(Dest, @Buffer, DestLen);'
      '      Exit;'
      '    end;'
      '  end;'
      ''
      '  DestLen := (Length + 1);'
      '  _WStrSetLength(Dest, DestLen);  // overallocate, trim later'
      
        '  DestLen := WCharFromChar(PWideChar(Pointer(Dest)), DestLen, So' +
        'urce, Length, CodePage);'
      '  if DestLen < 0 then DestLen := 0;'
      '  _WStrSetLength(Dest, DestLen);'
      
        '                                                                ' +
        '   '
      'end;'
      ''
      
        'procedure _WStrFromPCharLen(var Dest: _WideStr; Source: _PAnsiCh' +
        'r; Length: Integer);'
      'begin'
      
        '  InternalWStrFromPCharLen(Dest, Source, Length, DefaultSystemCo' +
        'dePage);'
      'end;'
      ''
      
        'procedure _LStrFromPWCharLen(var Dest: _AnsiStr; Source: PWideCh' +
        'ar; Length: Integer; CodePage: Word);'
      'var'
      '  DestLen: Integer;'
      'begin'
      '  if Length <= 0 then'
      '  begin'
      '    _LStrClr(Dest);'
      '    Exit;'
      '  end;'
      ''
      '  if CodePage = 0 then'
      '{$IFDEF NEXTGEN}'
      '    CodePage := CP_UTF8;'
      '{$ELSE  NEXTGEN}'
      '    CodePage := DefaultSystemCodePage;'
      '{$ENDIF NEXTGEN}'
      ''
      '  DestLen := CharFromWChar(nil, 0, Source, Length, CodePage);'
      '  SetLength(Dest, DestLen);'
      '  if DestLen > 0 then'
      '  begin'
      
        '    CharFromWChar(Pointer(Dest), DestLen, Source, Length, CodePa' +
        'ge);'
      '    PStrRec(PByte(Dest) - SizeOf(StrRec)).codePage := CodePage;'
      '  end'
      '  else'
      '    _LStrClr(Dest);'
      'end;'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for string assignment           }'
      '{ ----------------------------------------------------- }'
      ''
      
        'procedure _UStrAsg(var Dest: UnicodeString; const Source: Unicod' +
        'eString); // globals (need copy)'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  S, D: Pointer;'
      '  P: PStrRec;'
      '  Len: Integer;'
      'begin'
      '  S := Pointer(Source);'
      '  if S <> nil then'
      '  begin'
      
        '    if __StringRefCnt(Source) < 0 then   // make copy of string ' +
        'literal'
      '    begin'
      '      Len := __StringLength(Source);'
      '      S := _NewUnicodeString(Len);'
      '      Move(Pointer(Source)^, S^, Len * SizeOf(WideChar));'
      '    end else'
      '    begin'
      '      P := PStrRec(PByte(S) - SizeOf(StrRec));'
      '      AtomicIncrement(P.refCnt);'
      '    end;'
      '  end;'
      '  D := Pointer(Dest);'
      '  Pointer(Dest) := S;'
      '  if D <> nil then'
      '  begin'
      '    P := Pointer(PByte(D) - SizeOf(StrRec));'
      '    if (P.refCnt > 0) and (AtomicDecrement(P.refCnt) = 0) then'
      '      FreeMem(P);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to dest   str       }'
      '        { ->    EDX pointer to source str       }'
      ''
      
        '        TEST    EDX,EDX                         { have a source?' +
        ' }'
      
        '        JE      @@sourceDone                    { no -> jump    ' +
        ' }'
      ''
      '        CMP     [EDX-skew].StrRec.refCnt,0'
      
        '        JGE     @@noLiteral                     { literal string' +
        ' -> jump not taken }'
      ''
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,4'
      '        {$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        MOV     EAX,[EDX-skew].StrRec.length'
      '        CALL    _NewUnicodeString'
      '        MOV     EDX,EAX'
      '        POP     EAX'
      '        PUSH    EDX'
      '        MOV     ECX,[EAX-skew].StrRec.length'
      
        '        SHL     ECX,1                           { length to byte' +
        's for move }'
      '        CALL    Move'
      '        POP     EDX'
      '        POP     EAX'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,4'
      '        {$ENDIF ALIGN_STACK}'
      '        JMP     @@sourceDone'
      ''
      '@@noLiteral:'
      '   LOCK INC     [EDX-skew].StrRec.refCnt'
      ''
      '@@sourceDone:'
      '        MOV     ECX,[EAX]'
      '        MOV     [EAX],EDX'
      '        TEST    ECX,ECX'
      '        JE      @@done'
      '        CMP     [ECX-skew].StrRec.refCnt,0'
      '        JLE     @@done'
      '   LOCK DEC     [ECX-skew].StrRec.refCnt'
      '        JNE     @@done'
      '        LEA     EAX,[ECX-skew].StrRec.codePage'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,12'
      '        {$ENDIF ALIGN_STACK}'
      '        CALL    _FreeMem'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,12'
      '        {$ENDIF ALIGN_STACK}'
      '@@done:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrLAsg(var Dest: UnicodeString; const Source: Unico' +
        'deString); // locals'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: Pointer;'
      '  S: PStrRec;'
      'begin'
      '  if Pointer(Source) <> nil then'
      '  begin'
      '    S := PStrRec(PByte(Source) - SizeOf(StrRec));'
      '    if S.refcnt >= 0 then'
      '      AtomicIncrement(S.refcnt);'
      '  end;'
      '  P := Pointer(Dest);'
      '  Pointer(Dest) := Pointer(Source);'
      '  if P <> nil then'
      '  begin'
      '    S := PStrRec(PByte(P) - SizeOf(StrRec));'
      '    if S.refCnt > 0 then'
      '      if AtomicDecrement(S.refCnt) = 0 then'
      '        FreeMem(S);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest }'
      '        {       EDX     source          }'
      ''
      '        TEST    EDX,EDX'
      '        JE      @@sourceDone'
      ''
      '        { bump up the ref count of the source }'
      ''
      '        CMP     [EDX-skew].StrRec.refCnt,0'
      
        '        JL      @@sourceDone                    { literal assign' +
        'ment -> jump taken }'
      '   LOCK INC     [EDX-skew].StrRec.refCnt'
      '@@sourceDone:'
      ''
      
        '        { we need to release whatever the dest is pointing to   ' +
        '}'
      ''
      
        '        MOV     ECX,[EAX]                       { fetch str     ' +
        '               }'
      '        MOV     [EAX],EDX'
      
        '        TEST    ECX,ECX                         { if nil, nothin' +
        'g to do        }'
      '        JE      @@done'
      
        '        CMP     [ECX-skew].StrRec.refCnt,0      { if < 0: litera' +
        'l str          }'
      '        JLE     @@done'
      
        '   LOCK DEC     [ECX-skew].StrRec.refCnt        { threadsafe dec' +
        ' refCount      }'
      '        JNE     @@done'
      
        '        LEA     EAX,[ECX-skew].StrRec.codePage  { if refCnt now ' +
        'zero, deallocate}'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP,12'
      '        {$ENDIF ALIGN_STACK}'
      '        CALL    _FreeMem'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP,12'
      '        {$ENDIF ALIGN_STACK}'
      '@@done:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      'procedure _WStrAsg(var Dest: _WideStr; const Source: _WideStr);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  _UStrAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(S' +
        'ource)));'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr }'
      '        {       EDX     Pointer to data       }'
      ''
      '        JMP     _UStrAsg'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      'begin'
      '  if Pointer(Dest) <> Pointer(Source) then'
      '  begin'
      '    if Pointer(Source) = nil then'
      '      _WStrClr(Dest)'
      '    else'
      '    begin'
      '      Len := __StringLength(Source);'
      '      if Len = 0 then'
      '        _WStrClr(Dest)'
      '      else'
      '      begin'
      
        '        if not SysReAllocStringLen(Dest, PWideChar(Pointer(Sourc' +
        'e)), Len) then'
      '          WStrError;'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr }'
      '        {       EDX     Pointer to data       }'
      '        CMP     [EAX],EDX'
      '        JE      @@1'
      '        TEST    EDX,EDX'
      '        JE      _WStrClr'
      '        MOV     ECX,[EDX-4]'
      '        SHR     ECX,1'
      '        JE      _WStrClr'
      '        PUSH    ECX'
      '        PUSH    EDX'
      '        PUSH    EAX'
      '        CALL    SysReAllocStringLen'
      '        TEST    EAX,EAX'
      '        JE      WStrError'
      '@@1:'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      
        '  _UStrAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(S' +
        'ource)));'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      'procedure _WStrLAsg(var Dest: _WideStr; const Source: _WideStr);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  _UStrLAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(' +
        'Source)));'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     _UStrLAsg'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _WStrAsg(Dest, Source);'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP   _WStrAsg'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      
        '  _UStrLAsg(UnicodeString(Pointer(Dest)), UnicodeString(Pointer(' +
        'Source)));'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      ''
      '{ 99.03.11'
      '  This function is used when assigning to global variables.'
      ''
      '  Literals are copied to prevent a situation where a dynamically'
      
        '  allocated DLL or package assigns a literal to a variable and t' +
        'hen'
      '  is unloaded -- thereby causing the string memory (in the code'
      '  segment of the DLL) to be removed -- and therefore leaving the'
      '  global variable pointing to invalid memory.'
      '}'
      'procedure _LStrAsg(var Dest: _AnsiStr; const Source: _AnsiStr);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  S, D: Pointer;'
      '  P: PStrRec;'
      '  Len: Integer;'
      'begin'
      '  S := Pointer(Source);'
      '  if S <> nil then'
      '  begin'
      
        '    if __StringRefCnt(S) < 0 then   // make copy of string liter' +
        'al'
      '    begin'
      '      Len := __StringLength(S);'
      '      S := _NewAnsiString(Len, __StringCodePage(S));'
      '      Move(_PAnsiChr(Source)^, S^, Len);'
      '    end else'
      '    begin'
      '      P := PStrRec(PByte(S) - SizeOf(StrRec));'
      '      AtomicIncrement(P.refCnt);'
      '    end;'
      '  end;'
      '  D := Pointer(Dest);'
      '  Pointer(Dest) := S;'
      '  if D <> nil then'
      '  begin'
      '    P := Pointer(PByte(D) - SizeOf(StrRec));'
      '    if (P.refCnt > 0) and (AtomicDecrement(P.refCnt) = 0) then'
      '      FreeMem(P);'
      '  end;'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX pointer to dest   str       }'
      '        { ->    EDX pointer to source str       }'
      ''
      
        '        TEST    EDX,EDX                         { have a source?' +
        ' }'
      
        '        JE      @@sourceDone                    { no -> jump    ' +
        ' }'
      ''
      '        CMP     [EDX-skew].StrRec.refCnt,0'
      
        '        JGE     @@noLiteral                     { literal string' +
        ' -> jump not taken }'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        MOV     EAX,[EDX-skew].StrRec.length'
      '        MOVZX   EDX,[EDX-skew].StrRec.codePage'
      '        CALL    _NewAnsiString'
      '        MOV     EDX,EAX'
      '        POP     EAX'
      '        PUSH    EDX'
      '        MOV     ECX,[EAX-skew].StrRec.length'
      '        CALL    Move'
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,4'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     @@sourceDone'
      ''
      '@@noLiteral:'
      '   LOCK INC     [EDX-skew].StrRec.refCnt'
      ''
      '@@sourceDone:'
      '        MOV     ECX,[EAX]'
      '        MOV     [EAX],EDX'
      '        TEST    ECX,ECX'
      '        JE      @@done'
      '        CMP     [ECX-skew].StrRec.refCnt,0'
      '        JLE     @@done'
      '   LOCK DEC     [ECX-skew].StrRec.refCnt'
      '        JNE     @@done'
      '        LEA     EAX,[ECX-skew].StrRec.codePage'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    _FreeMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      '@@done:'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _LStrLAsg(var Dest: _AnsiStr; const Source: _AnsiStr);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: Pointer;'
      '  S: PStrRec;'
      'begin'
      '  P := Pointer(Source);'
      '  if P <> nil then'
      '  begin'
      '    S := Pointer(PByte(P) - SizeOf(StrRec));'
      '    if S.refcnt >= 0 then'
      '      AtomicIncrement(S.refcnt);'
      '  end;'
      '  P := Pointer(Dest);'
      '  Pointer(Dest) := Pointer(Source);'
      '  if P <> nil then'
      '  begin'
      '    S := Pointer(PByte(P) - SizeOf(StrRec));'
      '    if (S.refCnt > 0) and (AtomicDecrement(S.refCnt) = 0) then'
      '      FreeMem(S);'
      '  end;'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX     pointer to dest }'
      '        {       EDX     source          }'
      ''
      '        TEST    EDX,EDX'
      '        JE      @@sourceDone'
      ''
      '        { bump up the ref count of the source }'
      ''
      '        CMP     [EDX-skew].StrRec.refCnt,0'
      
        '        JL      @@sourceDone                    { literal assign' +
        'ment -> jump taken }'
      '   LOCK INC     [EDX-skew].StrRec.refCnt'
      '@@sourceDone:'
      ''
      
        '        { we need to release whatever the dest is pointing to   ' +
        '}'
      ''
      '        MOV     ECX,[EAX]'
      '        MOV     [EAX],EDX'
      
        '        TEST    ECX,ECX                         { if nil, nothin' +
        'g to do        }'
      '        JE      @@done'
      
        '        CMP     [ECX-skew].StrRec.refCnt,0      { if < 0: litera' +
        'l str          }'
      '        JLE     @@done'
      
        '   LOCK DEC     [ECX-skew].StrRec.refCnt        { threadsafe dec' +
        ' refCount      }'
      '        JNE     @@done'
      
        '        LEA     EAX,[ECX-skew].StrRec.codePage  { if refCnt now ' +
        'zero, deallocate}'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    _FreeMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      '@@done:'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       string info utilities                           }'
      '{ ----------------------------------------------------- }'
      ''
      
        'function StringElementSize(const S: UnicodeString): Word; overlo' +
        'ad;'
      'begin'
      '  if S <> '#39#39' then'
      
        '    Result := PWord(PByte(S) - 10)^                          // ' +
        'StrRec.elemSize'
      '  else'
      '    Result := SizeOf(WideChar);'
      'end;'
      ''
      
        'function StringElementSize(const S: _RawByteStr): Word; overload' +
        ';'
      'begin'
      '  if S <> '#39#39' then'
      
        '    Result := PWord(PByte(S) - 10)^                          // ' +
        'StrRec.elemSize'
      '  else'
      '    Result := SizeOf(_AnsiChr);'
      'end;'
      ''
      '{$IFNDEF MSWINDOWS}'
      'function StringElementSize(const S: _WideStr): Word; overload;'
      'begin'
      '  if S <> '#39#39' then'
      
        '    Result := PWord(PByte(S) - 10)^                          // ' +
        'StrRec.elemSize'
      '  else'
      '    Result := SizeOf(WideChar);'
      'end;'
      '{$ENDIF !MSWINDOWS}'
      ''
      'function StringCodePage(const S: UnicodeString): Word; overload;'
      'begin'
      '  if S <> '#39#39' then'
      
        '    Result := PWord(PByte(S) - 12)^                          // ' +
        'StrRec.codePage'
      '  else'
      '    Result := Word(DefaultUnicodeCodePage);'
      'end;'
      ''
      'function StringCodePage(const S: _RawByteStr): Word; overload;'
      'begin'
      '  if S <> '#39#39' then'
      
        '    Result := PWord(PByte(S) - 12)^                          // ' +
        'StrRec.codePage'
      '  else'
      '{$IFDEF NEXTGEN}'
      '    Result := Word(CP_UTF8);'
      '{$ELSE  NEXTGEN}'
      '    Result := Word(DefaultSystemCodePage);'
      '{$ENDIF NEXTGEN}'
      'end;'
      ''
      '{$IFNDEF MSWINDOWS}'
      'function StringCodePage(const S: _WideStr): Word; overload;'
      'begin'
      '  if S <> '#39#39' then'
      
        '    Result := PWord(PByte(S) - 12)^                          // ' +
        'StrRec.codePage'
      '  else'
      '    Result := Word(DefaultUnicodeCodePage);'
      'end;'
      '{$ENDIF !MSWINDOWS}'
      ''
      'function StringRefCount(const S: UnicodeString): Integer;'
      'begin'
      
        '  if Pointer(S) <> nil then           // PStrRec should be used ' +
        'here, but'
      
        '    Result := PInteger(PByte(S) - 8)^ // a private symbol can'#39't ' +
        'be inlined'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      'function StringRefCount(const S: _RawByteStr): Integer;'
      'begin'
      
        '  if Pointer(S) <> nil then           // PStrRec should be used ' +
        'here, but'
      
        '    Result := PInteger(PByte(S) - 8)^ // a private symbol can'#39't ' +
        'be inlined'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      '{$IFNDEF MSWINDOWS}'
      'function StringRefCount(const S: _WideStr): Integer;'
      'begin'
      
        '  if Pointer(S) <> nil then           // PStrRec should be used ' +
        'here, but'
      
        '    Result := PInteger(PByte(S) - 8)^ // a private symbol can'#39't ' +
        'be inlined'
      '  else'
      '    Result := 0;'
      'end;'
      '{$ENDIF !MSWINDOWS}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for string length               }'
      '{ ----------------------------------------------------- }'
      ''
      'function _UStrLen(const S: UnicodeString): Integer;'
      '{$IFDEF CPU64BITS}'
      'begin'
      '  Result := 0;'
      
        '  if Pointer(S) <> nil then            // PStrRec should be used' +
        ' here, but'
      
        '    Result := PInteger(PByte(S) - 4)^; // a private symbol can'#39't' +
        ' be inlined'
      'end;'
      '{$ELSE !CPU64BITS}'
      'begin'
      '  Result := IntPtr(S);'
      
        '  if Result <> 0 then                       // PStrRec should be' +
        ' used here, but'
      
        '    Result := PInteger(PByte(Result - 4))^; // a private symbol ' +
        'can'#39't be inlined'
      'end;'
      '{$ENDIF !CPU64BITS}'
      ''
      'function _WStrLen(const S: _WideStr): Integer; inline;'
      '{$IFDEF CPU64BITS}'
      'begin'
      '  Result := 0;'
      '  if Pointer(S) <> nil then'
      '    {$IFDEF MSWINDOWS}'
      '    Result := PInteger(PByte(S) - 4)^ shr 1;'
      '    {$ELSE}'
      '    Result := PInteger(PByte(S) - 4)^;'
      '    {$ENDIF}'
      'end;'
      '{$ELSE !CPU64BITS}'
      'begin'
      '  Result := IntPtr(S);'
      '  if Result <> 0 then'
      '    {$IFDEF MSWINDOWS}'
      '    Result := PInteger(PByte(Result - 4))^ shr 1;'
      '    {$ELSE}'
      '    Result := PInteger(PByte(Result - 4))^;'
      '    {$ENDIF}'
      'end;'
      '{$ENDIF !CPU64BITS}'
      ''
      'function _LStrLen(const S: _RawByteStr): Integer;'
      '{$IFDEF CPU64BITS}'
      'begin'
      '  Result := 0;'
      
        '  if Pointer(S) <> nil then            // PStrRec should be used' +
        ' here, but'
      
        '    Result := PInteger(PByte(S) - 4)^; // a private symbol can'#39't' +
        ' be inlined'
      'end;'
      '{$ELSE !CPU64BITS}'
      'begin'
      '  Result := IntPtr(S);'
      
        '  if Result <> 0 then                       // PStrRec should be' +
        ' used here, but'
      
        '    Result := PInteger(PByte(Result - 4))^; // a private symbol ' +
        'can'#39't be inlined'
      'end;'
      '{$ENDIF !CPU64BITS}'
      ''
      '{$IFDEF PUREPASCAL}'
      'function _PStrLen(const str: _ShortStr): Integer; inline;'
      'begin'
      '  Result := Byte(str[0]);'
      'end;'
      '{$ENDIF PUREPASCAL}'
      ''
      'function _PCharLen(P: _PAnsiChr): Integer;'
      '{$IFNDEF LEGACY_PCHARLEN}'
      'begin'
      '  Result := 0;'
      '  if P <> nil then'
      '    while P[Result] <> #0 do'
      '      Inc(Result);'
      'end;'
      '{$ELSE !LEGACY_PCHARLEN}'
      '{$IFDEF CPUX86}'
      'asm'
      '        TEST    EAX,EAX'
      '        JE      @@5'
      '        PUSH    EAX'
      '        XOR     ECX,ECX'
      '@@0:    CMP     CL,[EAX+0]'
      '        JE      @@4'
      '        CMP     CL,[EAX+1]'
      '        JE      @@3'
      '        CMP     CL,[EAX+2]'
      '        JE      @@2'
      '        CMP     CL,[EAX+3]'
      '        JE      @@1'
      '        ADD     EAX,4'
      '        JMP     @@0'
      '@@1:    INC     EAX'
      '@@2:    INC     EAX'
      '@@3:    INC     EAX'
      '@@4:    POP     ECX'
      '        SUB     EAX,ECX'
      '@@5:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !LEGACY_PCHARLEN}'
      ''
      'function _PWCharLen(P: PWideChar): Integer;'
      '{$IFNDEF LEGACY_PWCHARLEN}'
      'begin'
      '  Result := 0;'
      '  if P <> nil then'
      '    while P[Result] <> #0 do'
      '      Inc(Result);'
      'end;'
      '{$ELSE !LEGACY_PWCHARLEN}'
      '{$IFDEF CPUX86}'
      'asm'
      '        TEST    EAX,EAX'
      '        JE      @@5'
      '        PUSH    EAX'
      '        XOR     ECX,ECX'
      '@@0:    CMP     CX,[EAX+0]'
      '        JE      @@4'
      '        CMP     CX,[EAX+2]'
      '        JE      @@3'
      '        CMP     CX,[EAX+4]'
      '        JE      @@2'
      '        CMP     CX,[EAX+6]'
      '        JE      @@1'
      '        ADD     EAX,8'
      '        JMP     @@0'
      '@@1:    ADD     EAX,2'
      '@@2:    ADD     EAX,2'
      '@@3:    ADD     EAX,2'
      '@@4:    POP     ECX'
      '        SUB     EAX,ECX'
      '        SHR     EAX,1'
      '@@5:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !LEGACY_PWCHARLEN}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       internal UniqueString* support functions        }'
      '{ ----------------------------------------------------- }'
      ''
      'function InternalUniqueStringU(var Str: UnicodeString): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      '  N: Pointer;'
      'begin'
      '  Result := Pointer(Str);'
      '  if Result <> nil then'
      '  begin'
      '    P := Pointer(PByte(Str) - SizeOf(StrRec));'
      '    if P.refCnt <> 1 then'
      '    begin'
      '      N := _NewUnicodeString(P.length);'
      '      Move(Result^, N^, P.length * SizeOf(WideChar));'
      '      _UStrClr(Str);'
      '      Pointer(Str) := N;'
      '      Result := N;'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to str              }'
      '        { <-    EAX pointer to unique copy      }'
      '        MOV     EDX,[EAX]       // EDX := str'
      '        TEST    EDX,EDX         // nil?'
      '        JE      @@exit'
      
        '        MOV     ECX,[EDX-skew].StrRec.refCnt // ECX := str.refCn' +
        't'
      '        DEC     ECX             // refCnt = 1?'
      '        JE      @@exit'
      ''
      '        PUSH    EBX'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '        {$ENDIF ALIGN_STACK}'
      '        MOV     EBX,EAX         // EBX := @str'
      '        MOV     EAX,[EDX-skew].StrRec.length'
      '        CALL    _NewUnicodeString'
      '        MOV     EDX,EAX         // EDX := newStr'
      '        XCHG    EAX,[EBX]       // EAX := str ; @str^ := newStr'
      '        {$IFDEF ALIGN_STACK}'
      '        MOV     [ESP],EAX       // save str'
      '        {$ELSE !ALIGN_STACK}'
      '        PUSH    EAX             // save str'
      '        {$ENDIF !ALIGN_STACK}'
      '        MOV     ECX,[EAX-skew].StrRec.length'
      '        SHL     ECX,1           // ECX := Length(str) * 2'
      
        '        CALL    Move            // Move(str, newStr, Length(str)' +
        ' * 2)'
      '        {$IFDEF ALIGN_STACK}'
      '        MOV    EAX,[ESP]        // EAX := str'
      '        {$ELSE !ALIGN_STACK}'
      '        POP     EAX             // EAX := str'
      '        {$ENDIF !ALIGN_STACK}'
      
        '        MOV     ECX,[EAX-skew].StrRec.refCnt // ECX := str.refCn' +
        't'
      '        DEC     ECX'
      '        JL      @@skip          // Was already zero?'
      '   LOCK DEC     [EAX-skew].StrRec.refCnt'
      '        JNZ     @@skip'
      
        '        LEA     EAX,[EAX-skew].StrRec.codePage  { if refCnt now ' +
        'zero, deallocate}'
      '        CALL    _FreeMem'
      '@@skip:'
      '        MOV     EDX,[EBX]       // EDX := @str^ (= newStr)'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '        {$ENDIF ALIGN_STACK}'
      '        POP     EBX'
      '@@exit:'
      '        MOV     EAX,EDX         // EAX := newStr'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'function InternalUniqueStringA(var Str: _AnsiStr): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      '  N: Pointer;'
      'begin'
      '  Result := Pointer(Str);'
      '  if Result <> nil then'
      '  begin'
      '    P := Pointer(PByte(Str) - sizeof(StrRec));'
      '    if P.refCnt <> 1 then'
      '    begin'
      '      N := _NewAnsiString(P.length, P.codePage);'
      '      Move(Result^, N^, P.length);'
      '      _LStrClr(Str);'
      '      Pointer(Str) := N;'
      '      Result := N;'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to str              }'
      '        { <-    EAX pointer to unique copy      }'
      '        MOV     EDX,[EAX]'
      '        TEST    EDX,EDX'
      '        JE      @@exit'
      '        MOV     ECX,[EDX-skew].StrRec.refCnt'
      '        DEC     ECX'
      '        JE      @@exit'
      ''
      '        PUSH    EBX'
      '        {$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '        {$ENDIF ALIGN_STACK}'
      '        MOV     EBX,EAX'
      '        MOV     EAX,[EDX-skew].StrRec.length'
      '        MOVZX   EDX,[EDX-skew].StrRec.codePage'
      '        CALL    _NewAnsiString'
      '        MOV     EDX,EAX'
      '        XCHG    EAX,[EBX]       // EAX := str ; @str^ := newStr'
      '        {$IFDEF ALIGN_STACK}'
      '        MOV     [ESP],EAX       // save str'
      '        {$ELSE !ALIGN_STACK}'
      '        PUSH    EAX'
      '        {$ENDIF !ALIGN_STACK}'
      '        MOV     ECX,[EAX-skew].StrRec.length'
      '        CALL    Move'
      '        {$IFDEF ALIGN_STACK}'
      '        MOV     EAX,[ESP]       // EAX := str'
      '        {$ELSE !ALIGN_STACK}'
      '        POP     EAX'
      '        {$ENDIF !ALIGN_STACK}'
      '        MOV     ECX,[EAX-skew].StrRec.refCnt'
      '        DEC     ECX'
      '        JL      @@skip'
      '   LOCK DEC     [EAX-skew].StrRec.refCnt'
      '        JNZ     @@skip'
      
        '        LEA     EAX,[EAX-skew].StrRec.codePage  { if refCnt now ' +
        'zero, deallocate}'
      '        CALL    _FreeMem'
      '@@skip:'
      '        MOV     EDX,[EBX]'
      '        {$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '        {$ENDIF ALIGN_STACK}'
      '        POP     EBX'
      '@@exit:'
      '        MOV     EAX,EDX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for _UniqueString* functions    }'
      '{ ----------------------------------------------------- }'
      ''
      'function _UniqueStringU(var Str: UnicodeString): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := InternalUniqueStringU(Str);'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     InternalUniqueStringU'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IFNDEF MSWINDOWS}'
      'function _UniqueStringW(var Str: _WideStr): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := InternalUniqueStringU(UnicodeString(Pointer(Str)));'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     InternalUniqueStringU'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      ''
      'function _UniqueStringA(var Str: _AnsiStr): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  Result := InternalUniqueStringA(Str);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        JMP     InternalUniqueStringA'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       UniqueString* functions                         }'
      '{ ----------------------------------------------------- }'
      ''
      'procedure UniqueString(var str: UnicodeString); overload;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  InternalUniqueStringU(str);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        JMP     InternalUniqueStringU'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure UniqueString(var str: _WideStr);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  InternalUniqueStringU(UnicodeString(Pointer(str)));'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     InternalUniqueStringU'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      'begin'
      
        '  // nothing to do - Windows WideStrings are always single refer' +
        'ence'
      'end;'
      '{$ENDIF}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      '  InternalUniqueStringU(UnicodeString(Pointer(str)));'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      'procedure UniqueString(var str: _AnsiStr);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  InternalUniqueStringA(str);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        JMP     InternalUniqueStringA'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      
        '{ ------------------------------------------------------------- ' +
        '}'
      
        '{       Compiler helper for comparing array of characters       ' +
        '}'
      
        '{ ------------------------------------------------------------- ' +
        '}'
      ''
      '{$IFDEF PUREPASCAL}'
      'function _PStrCmp(const Left, Right: _ShortStr): Integer;'
      'var'
      '  Len, LLen, RLen: Cardinal;'
      '  PLeft, PRight: PByte;'
      'begin'
      '  PLeft := PByte(@Left[0]);'
      '  PRight := PByte(@Right[0]);'
      '  LLen := PLeft^;'
      '  RLen := PRight^;'
      '  Inc(PLeft);'
      '  Inc(PRight);'
      '  if LLen > RLen then'
      '    Len := RLen'
      '  else'
      '    Len := LLen;'
      '  while Len >= SizeOf(UInt32) do'
      '  begin'
      '    if PUInt32(PLeft)^ <> PUInt32(PRight)^ then'
      '      Break;'
      '    if (Len < SizeOf(UInt32) * 2) or'
      '       (PUInt32(PByte(PLeft) + SizeOf(UInt32))^ <>'
      '       PUInt32(PByte(PRight) + SizeOf(UInt32))^) then'
      '    begin'
      '      Inc(PLeft, SizeOf(UInt32));'
      '      Inc(PRight, SizeOf(UInt32));'
      '      Dec(Len, SizeOf(UInt32));'
      '      Break;'
      '    end;'
      '    Inc(PLeft, SizeOf(UInt32) * 2);'
      '    Inc(PRight, SizeOf(UInt32) * 2);'
      '    Dec(Len, SizeOf(UInt32) * 2);'
      '  end;'
      '  if Len = 0 then'
      '    Exit(LLen - RLen);'
      '  Result := PByte(PLeft)^ - PByte(PRight)^;'
      '  if Result <> 0 then'
      '    Exit;'
      '  if Len = 1 then'
      '    Exit(LLen - RLen);'
      
        '  Result := PByte(PByte(PLeft) + 1)^ - PByte(PByte(PRight) + 1)^' +
        ';'
      '  if Result <> 0 then'
      '    Exit;'
      '  if Len = 2 then'
      '    Exit(LLen - RLen);'
      
        '  Result := PByte(PByte(PLeft) + 2)^ - PByte(PByte(PRight) + 2)^' +
        ';'
      '  if Result <> 0 then'
      '    Exit;'
      '  if Len = 3 then'
      '    Exit(LLen - RLen);'
      
        '  Result := PByte(PByte(PLeft) + 3)^ - PByte(PByte(PRight) + 3)^' +
        ';'
      '  if Result <> 0 then'
      '    Exit;'
      '  Exit(LLen - RLen);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'procedure       _PStrCmp;'
      'asm'
      '        {     ->EAX = Pointer to left string    }'
      '        {       EDX = Pointer to right string   }'
      '        {     <-ZF,CF = Result                  }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EAX'
      '        MOV     EDI,EDX'
      ''
      '        XOR     EAX,EAX'
      '        XOR     EDX,EDX'
      '        MOV     AL,[ESI]'
      '        MOV     DL,[EDI]'
      '        INC     ESI'
      '        INC     EDI'
      ''
      '        SUB     EAX,EDX { eax = len1 - len2 }'
      '        JA      @@skip1'
      
        '        ADD     EDX,EAX { edx = len2 + (len1 - len2) = len1     ' +
        '}'
      ''
      '@@skip1:'
      '        PUSH    EDX'
      '        SHR     EDX,2'
      '        JE      @@cmpRest'
      '@@longLoop:'
      '        MOV     ECX,[ESI]'
      '        MOV     EBX,[EDI]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        DEC     EDX'
      '        JE      @@cmpRestP4'
      '        MOV     ECX,[ESI+4]'
      '        MOV     EBX,[EDI+4]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        ADD     ESI,8'
      '        ADD     EDI,8'
      '        DEC     EDX'
      '        JNE     @@longLoop'
      '        JMP     @@cmpRest'
      '@@cmpRestP4:'
      '        ADD     ESI,4'
      '        ADD     EDI,4'
      '@@cmpRest:'
      '        POP     EDX'
      '        AND     EDX,3'
      '        JE      @@equal'
      ''
      '        MOV     CL,[ESI]'
      '        CMP     CL,[EDI]'
      '        JNE     @@exit'
      '        DEC     EDX'
      '        JE      @@equal'
      '        MOV     CL,[ESI+1]'
      '        CMP     CL,[EDI+1]'
      '        JNE     @@exit'
      '        DEC     EDX'
      '        JE      @@equal'
      '        MOV     CL,[ESI+2]'
      '        CMP     CL,[EDI+2]'
      '        JNE     @@exit'
      ''
      '@@equal:'
      '        ADD     EAX,EAX'
      '        JMP     @@exit'
      ''
      '@@misMatch:'
      '        POP     EDX'
      '        CMP     CL,BL'
      '        JNE     @@exit'
      '        CMP     CH,BH'
      '        JNE     @@exit'
      '        SHR     ECX,16'
      '        SHR     EBX,16'
      '        CMP     CL,BL'
      '        JNE     @@exit'
      '        CMP     CH,BH'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'function _AStrCmp(const Left, Right: _PAnsiChr; Len: NativeInt):' +
        ' Integer;'
      'var'
      '  P1, P2: PByte;'
      'begin'
      '  P1 := PByte(Left);'
      '  P2 := PByte(Right);'
      '  Result := 0;'
      '  while Len >= SizeOf(UInt32) do begin'
      '    if PUInt32(P1)^ <> PUInt32(P2)^ then break;'
      '    if (Len < SizeOf(UInt32) * 2) or'
      '       (PUInt32(PByte(P1) + SizeOf(UInt32))^ <>'
      '        PUInt32(PByte(P2) + SizeOf(UInt32))^) then'
      '    begin'
      '      Inc(P1, SizeOf(UInt32));'
      '      Inc(P2, SizeOf(UInt32));'
      '      Dec(Len, SizeOf(UInt32));'
      '      break;'
      '    end;'
      '    Inc(P1, SizeOf(UInt32) * 2);'
      '    Inc(P2, SizeOf(UInt32) * 2);'
      '    Dec(Len, SizeOf(UInt32) * 2);'
      '  end;'
      '  if Len = 0 then Exit;'
      '  Result := PByte(P1)^ - PByte(P2)^;'
      '  if Result <> 0 then Exit;'
      '  if Len = 1 then Exit;'
      '  Result := PByte(PByte(P1) + 1)^ - PByte(PByte(P2) + 1)^;'
      '  if Result <> 0 then Exit;'
      '  if Len = 2 then Exit;'
      '  Result := PByte(PByte(P1) + 2)^ - PByte(PByte(P2) + 2)^;'
      '  if Result <> 0 then Exit;'
      '  if Len = 3 then Exit;'
      '  Result := PByte(PByte(P1) + 3)^ - PByte(PByte(P2) + 3)^;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure       _AStrCmp;'
      'asm'
      '        {     ->EAX = Pointer to left string            }'
      '        {       EDX = Pointer to right string           }'
      '        {       ECX = Number of chars to compare        }'
      '        {     <-ZF,CF = Result                          }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    ECX'
      '        MOV     ESI,ECX'
      '        SHR     ESI,2'
      '        JE      @@cmpRest'
      ''
      '@@longLoop:'
      '        MOV     ECX,[EAX]'
      '        MOV     EBX,[EDX]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        DEC     ESI'
      '        JE      @@cmpRestP4'
      '        MOV     ECX,[EAX+4]'
      '        MOV     EBX,[EDX+4]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        ADD     EAX,8'
      '        ADD     EDX,8'
      '        DEC     ESI'
      '        JNE     @@longLoop'
      '        JMP     @@cmpRest'
      '@@cmpRestp4:'
      '        ADD     EAX,4'
      '        ADD     EDX,4'
      '@@cmpRest:'
      '        POP     ESI'
      '        AND     ESI,3'
      '        JE      @@exit'
      ''
      '        MOV     CL,[EAX]'
      '        CMP     CL,[EDX]'
      '        JNE     @@exit'
      '        DEC     ESI'
      '        JE      @@equal'
      '        MOV     CL,[EAX+1]'
      '        CMP     CL,[EDX+1]'
      '        JNE     @@exit'
      '        DEC     ESI'
      '        JE      @@equal'
      '        MOV     CL,[EAX+2]'
      '        CMP     CL,[EDX+2]'
      '        JNE     @@exit'
      ''
      '@@equal:'
      '        XOR     EAX,EAX'
      '        JMP     @@exit'
      ''
      '@@misMatch:'
      '        POP     ESI'
      '        CMP     CL,BL'
      '        JNE     @@exit'
      '        CMP     CH,BH'
      '        JNE     @@exit'
      '        SHR     ECX,16'
      '        SHR     EBX,16'
      '        CMP     CL,BL'
      '        JNE     @@exit'
      '        CMP     CH,BH'
      ''
      '@@exit:'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'function _WStrLCmp(const Left, Right: PWideChar; Len: NativeInt)' +
        ': Integer;'
      'var'
      '  P1, P2: PWord;'
      'begin'
      '  P1 := PWord(Left);'
      '  P2 := PWord(Right);'
      '  Result := 0;'
      '  while Len >= SizeOf(UInt32) div SizeOf(Word) do begin'
      '    if PUInt32(P1)^ <> PUInt32(P2)^ then break;'
      '    if (Len < SizeOf(UInt32) * 2 div SizeOf(Word)) or'
      '       (PUInt32(PByte(P1) + SizeOf(UInt32))^ <>'
      '        PUInt32(PByte(P2) + SizeOf(UInt32))^)'
      '    then'
      '    begin'
      '      P1 := PWord(PByte(P1) + SizeOf(UInt32));'
      '      P2 := PWord(PByte(P2) + SizeOf(UInt32));'
      '      Dec(Len, SizeOf(UInt32) div SizeOf(Word));'
      '      break;'
      '    end;'
      '    P1 := PWord(PByte(P1) + SizeOf(UInt32) * 2);'
      '    P2 := PWord(PByte(P2) + SizeOf(UInt32) * 2);'
      '    Dec(Len, SizeOf(UInt32) * 2 div SizeOf(Word));'
      '  end;'
      '  if Len = 0 then Exit;'
      '  Result := PWord(P1)^ - PWord(P2)^;'
      '  if Result <> 0 then Exit;'
      '  if Len = 1 then Exit;'
      '  Result := PWord(PByte(P1) + 2)^ - PWord(PByte(P2) + 2)^;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure       _WStrLCmp;'
      'asm'
      '        {     ->EAX = Pointer to left wide string       }'
      '        {       EDX = Pointer to right wide string      }'
      '        {       ECX = Number of chars to compare        }'
      '        {     <-ZF,CF = Result                          }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    ECX'
      '        MOV     ESI,ECX'
      '        SHR     ESI,1'
      '        JE      @@cmpRest'
      ''
      '@@longLoop:'
      '        MOV     ECX,[EAX]'
      '        MOV     EBX,[EDX]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        DEC     ESI'
      '        JE      @@cmpRestP4'
      '        MOV     ECX,[EAX+4]'
      '        MOV     EBX,[EDX+4]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        ADD     EAX,8'
      '        ADD     EDX,8'
      '        DEC     ESI'
      '        JNE     @@longLoop'
      '        JMP     @@cmpRest'
      '@@cmpRestp4:'
      '        ADD     EAX,4'
      '        ADD     EDX,4'
      '@@cmpRest:'
      '        POP     ESI'
      '        AND     ESI,1'
      '        JE      @@exit'
      ''
      '        MOV     CX,[EAX]'
      '        CMP     CX,[EDX]'
      '        JNE     @@exit'
      ''
      '@@equal:'
      '        XOR     EAX,EAX'
      '        JMP     @@exit'
      ''
      '@@misMatch:'
      '        POP     ESI'
      '        CMP     CX,BX'
      '        JNE     @@exit'
      '        SHR     ECX,16'
      '        SHR     EBX,16'
      '        CMP     CX,BX'
      ''
      '@@exit:'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for _ShortStr support           }'
      '{ ----------------------------------------------------- }'
      ''
      'procedure       _PStrCpy(Dest: _PShortStr; Source: _PShortStr);'
      'begin'
      '  Move(Source^, Dest^, Byte(Source^[0])+1);'
      'end;'
      ''
      
        'procedure       _PStrNCpy(Dest: _PShortStr; Source: _PShortStr; ' +
        'MaxLen: Byte);'
      'begin'
      '  if MaxLen > Byte(Source^[0]) then'
      '    MaxLen := Byte(Source^[0]);'
      '  Byte(Dest^[0]) := MaxLen;'
      '  Move(Source^[1], Dest^[1], MaxLen);'
      'end;'
      ''
      'procedure _PStrCat(Dest: _PShortStr; const Src: _ShortStr);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  DestLen, SrcLen, I: Integer;'
      'begin'
      '  DestLen := _PStrLen(Dest^);'
      '  SrcLen := _PStrLen(Src);'
      '  if DestLen + SrcLen > 255 then'
      '    SrcLen := 255 - DestLen;'
      '  Byte(Dest^[0]) := DestLen + SrcLen;'
      '  for I := 1 to SrcLen do'
      '    Dest^[DestLen + I] := Src[I];'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '{     ->EAX = Pointer to destination string     }'
      '{       EDX = Pointer to source string  }'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '{       load dest len into EAX  }'
      ''
      '        MOV     EDI,EAX'
      '        XOR     EAX,EAX'
      '        MOV     AL,[EDI]'
      ''
      '{       load source address in ESI, source len in ECX   }'
      ''
      '        MOV     ESI,EDX'
      '        XOR     ECX,ECX'
      '        MOV     CL,[ESI]'
      '        INC     ESI'
      ''
      
        '{       calculate final length in DL and store it in the destina' +
        'tion    }'
      ''
      '        MOV     DL,AL'
      '        ADD     DL,CL'
      '        JC      @@trunc'
      ''
      '@@cont:'
      '        MOV     [EDI],DL'
      ''
      '{       calculate final dest address    }'
      ''
      '        INC     EDI'
      '        ADD     EDI,EAX'
      ''
      '{       do the copy     }'
      ''
      '        REP     MOVSB'
      ''
      '                 '
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        RET'
      ''
      '@@trunc:'
      
        '        INC     DL      {       DL = #chars to truncate         ' +
        '        }'
      
        '        SUB     CL,DL   {       CL = source len - #chars to trun' +
        'cate    }'
      
        '        MOV     DL,255  {       DL = maximum length             ' +
        '        }'
      '        JMP     @@cont'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _PStrNCat(Dest: _PShortStr; const Src: _ShortStr; Size' +
        ':Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  DestLen, SrcLen, I: Integer;'
      'begin'
      '  DestLen := _PStrLen(Dest^);'
      '  SrcLen := _PStrLen(Src);'
      '  if DestLen + SrcLen > Size then'
      '    SrcLen := Size - DestLen;'
      '  Byte(Dest^[0]) := DestLen + SrcLen;'
      '  for I := 1 to SrcLen do'
      '    Dest^[DestLen + I] := Src[I];'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      
        '{     ->EAX = Pointer to destination string                     ' +
        '}'
      
        '{       EDX = Pointer to source string                          ' +
        '}'
      
        '{       CL  = max length of result (allocated size of dest - 1) ' +
        '}'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '{       load dest len into EAX  }'
      ''
      '        MOV     EDI,EAX'
      '        XOR     EAX,EAX'
      '        MOV     AL,[EDI]'
      ''
      '{       load source address in ESI, source len in EDX   }'
      ''
      '        MOV     ESI,EDX'
      '        XOR     EDX,EDX'
      '        MOV     DL,[ESI]'
      '        INC     ESI'
      ''
      
        '{       calculate final length in AL and store it in the destina' +
        'tion    }'
      ''
      '        ADD     AL,DL'
      '        JC      @@trunc'
      '        CMP     AL,CL'
      '        JA      @@trunc'
      ''
      '@@cont:'
      '        MOV     ECX,EDX'
      '        MOV     DL,[EDI]'
      '        MOV     [EDI],AL'
      ''
      '{       calculate final dest address    }'
      ''
      '        INC     EDI'
      '        ADD     EDI,EDX'
      ''
      '{       do the copy     }'
      ''
      '        REP     MOVSB'
      ''
      '@@done:'
      '        POP     EDI'
      '        POP     ESI'
      '        RET'
      ''
      '@@trunc:'
      '{       CL = maxlen     }'
      ''
      
        '        MOV     AL,CL           { AL = final length = maxlen    ' +
        '                }'
      
        '        SUB     CL,[EDI]        { CL = length to copy = maxlen -' +
        ' destlen        }'
      '        JBE     @@done'
      '        MOV     DL,CL'
      '        JMP     @@cont'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'function _Copy(const S: _ShortStr; Index, Count: Integer): _Shor' +
        'tStr;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len, I: Integer;'
      'begin'
      '  Len := Byte(S[0]);'
      '  if Len = 0 then'
      '    Byte(Result[0]) := 0'
      '  else'
      '  begin'
      '    if Index <= 0 then Index := 1'
      '    else if Index > Len then Index := Len + 1;'
      '    Len := Len - Index + 1;'
      '    if Count < 0 then Count := 0'
      '    else if Count > Len then Count := Len;'
      '    Byte(Result[0]) := Count;'
      '    for I := 1 to Count do'
      '      Result[I] := S[Index + I - 1];'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '{     ->EAX     Source string                   }'
      '{       EDX     index                           }'
      '{       ECX     count                           }'
      '{       [ESP+4] Pointer to result string        }'
      '{       PUSH    EBP              }'
      '{       MOV     EBP, ESP         }'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EAX'
      '        MOV     EDI,[Result]'
      ''
      '        XOR     EAX,EAX'
      '        OR      AL,[ESI]'
      '        JZ      @@srcEmpty'
      ''
      '{       limit index to satisfy 1 <= index <= Length(src) }'
      ''
      '        TEST    EDX,EDX'
      '        JLE     @@smallInx'
      '        CMP     EDX,EAX'
      '        JG      @@bigInx'
      '@@cont1:'
      ''
      
        '{       limit count to satisfy 0 <= count <= Length(src) - index' +
        ' + 1    }'
      ''
      
        '        SUB     EAX,EDX { calculate Length(src) - index + 1     ' +
        '}'
      '        INC     EAX'
      '        TEST    ECX,ECX'
      '        JL      @@smallCount'
      '        CMP     ECX,EAX'
      '        JG      @@bigCount'
      '@@cont2:'
      ''
      '        ADD     ESI,EDX'
      ''
      '        MOV     [EDI],CL'
      '        INC     EDI'
      '        REP     MOVSB'
      '        JMP     @@exit'
      ''
      '@@smallInx:'
      '        MOV     EDX,1'
      '        JMP     @@cont1'
      '@@bigInx:'
      '{       MOV     EDX,EAX'
      '        JMP     @@cont1 }'
      '@@smallCount:'
      '        XOR     ECX,ECX'
      '        JMP     @@cont2'
      '@@bigCount:'
      '        MOV     ECX,EAX'
      '        JMP     @@cont2'
      '@@srcEmpty:'
      '        MOV     [EDI],AL'
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'procedure _Delete(var s: _ShortStr; Index, Count: Integer);'
      'var'
      '  Len, TailLen: Integer;'
      'begin'
      '  Len := Byte(S[0]);'
      '  if (Index >= 1) and (Index <= Len) then'
      '  begin'
      '    if Count > 0 then'
      '    begin'
      '      TailLen := Len - Index + 1;'
      '      if Count > TailLen then Count := TailLen;'
      '      Byte(S[0]) := Len - Count;'
      '      Move(S[Index+Count], S[Index], TailLen - Count);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _Delete(S: _PShortStr; Index, Count: Integer);'
      'asm'
      '{     ->EAX     Pointer to s    }'
      '{       EDX     index           }'
      '{       ECX     count           }'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     EDI,EAX'
      ''
      '        XOR     EAX,EAX'
      '        MOV     AL,[EDI]'
      ''
      '{       if index not in [1 .. Length(s)] do nothing     }'
      ''
      '        TEST    EDX,EDX'
      '        JLE     @@exit'
      '        CMP     EDX,EAX'
      '        JG      @@exit'
      ''
      '{       limit count to [0 .. Length(s) - index + 1]     }'
      ''
      '        TEST    ECX,ECX'
      '        JLE     @@exit'
      
        '        SUB     EAX,EDX         { calculate Length(s) - index + ' +
        '1       }'
      '        INC     EAX'
      '        CMP     ECX,EAX'
      '        JLE     @@1'
      '        MOV     ECX,EAX'
      '@@1:'
      
        '        SUB     [EDI],CL        { reduce Length(s) by count     ' +
        '                }'
      
        '        ADD     EDI,EDX         { point EDI to first char to be ' +
        'deleted }'
      
        '        LEA     ESI,[EDI+ECX]   { point ESI to first char to be ' +
        'preserved       }'
      
        '        SUB     EAX,ECX         { #chars = Length(s) - index + 1' +
        ' - count        }'
      '        MOV     ECX,EAX'
      ''
      '        REP     MOVSB'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IFDEF NEXTGEN}'
      
        'procedure _Insert(const Source: _ShortStr; var S: _OpenString; I' +
        'ndex: Integer);'
      '{$ELSE}'
      
        'procedure _Insert(const Source: _ShortStr; var S: OpenString; In' +
        'dex: Integer);'
      '{$ENDIF}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      '  I: Integer;'
      '  Len1, Len2, Len3: Integer;'
      'begin'
      '  Len := Byte(S[0]);'
      '  if Index <= 0 then Index := 1'
      '  else if Index > Len + 1 then Index := Len + 1;'
      ''
      '  Len1 := Index - 1;'
      '  Len2 := Byte(Source[0]);'
      '  Len3 := Len - Len1;'
      ''
      '  if Len1 + Len2 + Len3 > High(S) then'
      '  begin'
      '    if Len1 + Len2 > High(S) then'
      '    begin'
      '      Len3 := 0;'
      '      Len2 := High(S) - Len1;'
      '    end'
      '    else'
      '      Len3 := High(S) - Len1 - Len2;'
      '  end;'
      ''
      '  Byte(S[0]) := Len1 + Len2 + Len3;'
      ''
      '  if Len2 > 0 then'
      '  begin'
      '    for I := Len3 downto 1 do'
      '      S[Len1 + Len2 + I] := S[Len1 + I];'
      '    for I := 1 to Len2 do'
      '      S[Len1 + I] := Source[I];'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        {     ->EAX     Pointer to source string        }'
      '        {       EDX     Pointer to destination string   }'
      '        {       ECX     Length of destination string    }'
      '        {       [ESP+4] Index                           }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    ECX'
      '        MOV     ECX,Index'
      
        '        SUB     ESP,512         { VAR buf: ARRAY [0..511] of Cha' +
        'r       }'
      ''
      
        '        MOV     EBX,EDX         { save pointer to s for later   ' +
        '}'
      '        MOV     ESI,EDX'
      ''
      '        XOR     EDX,EDX'
      '        MOV     DL,[ESI]'
      '        INC     ESI'
      ''
      '{       limit index to [1 .. Length(s)+1]       }'
      ''
      '        INC     EDX'
      '        TEST    ECX,ECX'
      '        JLE     @@smallInx'
      '        CMP     ECX,EDX'
      '        JG      @@bigInx'
      '@@cont1:'
      
        '        DEC     EDX             { EDX = Length(s)               ' +
        '}'
      
        '                                { EAX = Pointer to src          ' +
        '}'
      
        '                                { ESI = EBX = Pointer to s      ' +
        '}'
      
        '                                { ECX = Index                   ' +
        '}'
      ''
      '{       copy index-1 chars from s to buf        }'
      ''
      '        MOV     EDI,ESP'
      '        DEC     ECX'
      
        '        SUB     EDX,ECX         { EDX = remaining length of s   ' +
        '}'
      '        REP     MOVSB'
      ''
      '{       copy Length(src) chars from src to buf  }'
      ''
      
        '        XCHG    EAX,ESI         { save pointer into s, point ESI' +
        ' to src         }'
      
        '        MOV     CL,[ESI]        { ECX = Length(src) (ECX was zer' +
        'o after rep)    }'
      '        INC     ESI'
      '        REP     MOVSB'
      ''
      '{       copy remaining chars of s to buf        }'
      ''
      
        '        MOV     ESI,EAX         { restore pointer into s        ' +
        '        }'
      
        '        MOV     ECX,EDX         { copy remaining bytes of s     ' +
        '        }'
      '        REP     MOVSB'
      ''
      '{       calculate total chars in buf    }'
      ''
      
        '        SUB     EDI,ESP         { length = bufPtr - buf         ' +
        '}'
      
        '        MOV     ECX,[ESP+512]   { ECX = Min(length, destLength) ' +
        '}'
      
        '{       MOV     ECX,[EBP-16]   }{ ECX = Min(length, destLength) ' +
        '}'
      '        CMP     ECX,EDI'
      '        JB      @@1'
      '        MOV     ECX,EDI'
      '@@1:'
      
        '        MOV     EDI,EBX         { Point EDI to s                ' +
        '}'
      
        '        MOV     ESI,ESP         { Point ESI to buf              ' +
        '}'
      
        '        MOV     [EDI],CL        { Store length in s             ' +
        '}'
      '        INC     EDI'
      
        '        REP     MOVSB           { Copy length chars to s        ' +
        '}'
      '        JMP     @@exit'
      ''
      '@@smallInx:'
      '        MOV     ECX,1'
      '        JMP     @@cont1'
      '@@bigInx:'
      '        MOV     ECX,EDX'
      '        JMP     @@cont1'
      ''
      '@@exit:'
      '        ADD     ESP,512+4'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        '// Don'#39't use var param here - var _ShortStr is an open string pa' +
        'ram, which'
      
        '// passes the ptr in EAX and the string'#39's declared buffer length' +
        ' in EDX.'
      
        '// Compiler codegen expects only two params for this call - ptr ' +
        'and newlength'
      'procedure       _SetLength(s: _PShortStr; newLength: Byte);'
      'begin'
      '  Byte(s^[0]) := newLength;   // should also fill new space'
      'end;'
      ''
      
        'procedure       _SetString(s: _PShortStr; buffer: _PAnsiChr; len' +
        ': Byte);'
      'begin'
      '  Byte(s^[0]) := len;'
      '  if buffer <> nil then'
      '    Move(buffer^, s^[1], len);'
      'end;'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for _AnsiStr support          }'
      '{ ----------------------------------------------------- }'
      ''
      
        'procedure _LStrFromChar(var Dest: _AnsiStr; Source: _AnsiChr; Co' +
        'dePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _LStrFromPCharLen(Dest, @Source, 1, CodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest         }'
      '        {       DL      source ANSI character   }'
      '        {       ECX     CodePage                }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX'
      '        MOV     EDX,ESP'
      '        PUSH    ECX'
      '        MOV     ECX,1'
      '        CALL    _LStrFromPCharLen'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,8'
      '{$ELSE !ALIGN_STACK}'
      '        POP     EDX'
      '{$ENDIF !ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrFromWChar(var Dest: _AnsiStr; Source: WideChar; C' +
        'odePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _LStrFromPWCharLen(Dest, @Source, 1, CodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest         }'
      '        {       DX      source wide character   }'
      '        {       ECX     CodePage                }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX'
      '        MOV     EDX,ESP'
      '        PUSH    ECX'
      '        MOV     ECX,1'
      '        CALL    _LStrFromPWCharLen'
      '        POP     EDX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrFromPChar(var Dest: _AnsiStr; Source: _PAnsiChr; ' +
        'CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      '  P: _PAnsiChr;'
      'begin'
      '  Len := 0;'
      '  if Source <> nil then'
      '  begin'
      '    P := Source;'
      '    while P^ <> #0 do Inc(P);'
      '    Len := P - Source;'
      '  end;'
      '  _LStrFromPCharLen(Dest, Source, Len, CodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest                 }'
      '        {       EDX     pointer to ANSI characters      }'
      '        {       ECX     CodePage                        }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        PUSH    ECX'
      '{$ELSE ALIGN_STACK}'
      '        PUSH    [ESP]'
      '        MOV     [ESP+4],ECX'
      '{$ENDIF ALIGN_STACK}'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@5'
      '        PUSH    EDX'
      '@@0:    CMP     CL,[EDX+0]'
      '        JE      @@4'
      '        CMP     CL,[EDX+1]'
      '        JE      @@3'
      '        CMP     CL,[EDX+2]'
      '        JE      @@2'
      '        CMP     CL,[EDX+3]'
      '        JE      @@1'
      '        ADD     EDX,4'
      '        JMP     @@0'
      '@@1:    INC     EDX'
      '@@2:    INC     EDX'
      '@@3:    INC     EDX'
      '@@4:    MOV     ECX,EDX'
      '        POP     EDX'
      '        SUB     ECX,EDX'
      '@@5:'
      '{$IFDEF ALIGN_STACK}'
      '        CALL    _LStrFromPCharLen'
      '        ADD     ESP,8'
      '{$ELSE ALIGN_STACK}'
      '        JMP     _LStrFromPCharLen'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrFromPWChar(var Dest: _AnsiStr; Source: PWideChar;' +
        ' CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      '  P: PWideChar;'
      'begin'
      '  Len := 0;'
      '  if Source <> nil then'
      '  begin'
      '    P := Source;'
      '    while P^ <> #0 do Inc(P);'
      '    Len := P - Source;'
      '  end;'
      '  _LStrFromPWCharLen(Dest, Source, Len, CodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest                 }'
      '        {       EDX     pointer to wide characters      }'
      '        {       ECX     CodePage                        }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        PUSH    ECX'
      '{$ELSE ALIGN_STACK}'
      '        PUSH    [ESP]'
      '        MOV     [ESP+4],ECX'
      '{$ENDIF ALIGN_STACK}'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@5'
      '        PUSH    EDX'
      '@@0:    CMP     CX,[EDX+0]'
      '        JE      @@4'
      '        CMP     CX,[EDX+2]'
      '        JE      @@3'
      '        CMP     CX,[EDX+4]'
      '        JE      @@2'
      '        CMP     CX,[EDX+6]'
      '        JE      @@1'
      '        ADD     EDX,8'
      '        JMP     @@0'
      '@@1:    ADD     EDX,2'
      '@@2:    ADD     EDX,2'
      '@@3:    ADD     EDX,2'
      '@@4:    MOV     ECX,EDX'
      '        POP     EDX'
      '        SUB     ECX,EDX'
      '        SHR     ECX,1'
      '@@5:'
      '{$IFDEF ALIGN_STACK}'
      '        CALL    _LStrFromPWCharLen'
      '        ADD     ESP,8'
      '{$ELSE ALIGN_STACK}'
      '        JMP     _LStrFromPWCharLen'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrFromString(var Dest: _AnsiStr; const Source: _Sho' +
        'rtStr; CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  _LStrFromPCharLen(Dest, @Source[1], Byte(Source[0]), CodePage)' +
        ';'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest         }'
      '        {       EDX     pointer to _ShortStr  }'
      '        {       ECX     CodePage                }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        PUSH    ECX'
      '{$ELSE ALIGN_STACK}'
      '        PUSH    [ESP]'
      '        MOV     [ESP+4],ECX'
      '{$ENDIF ALIGN_STACK}'
      '        XOR     ECX,ECX'
      '        MOV     CL,[EDX]'
      '        INC     EDX'
      '{$IFDEF ALIGN_STACK}'
      '        CALL    _LStrFromPCharLen'
      '        ADD     ESP,8'
      '{$ELSE ALIGN_STACK}'
      '        JMP     _LStrFromPCharLen'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrFromArray(var Dest: _AnsiStr; Source: _PAnsiChr; ' +
        'Length: Integer; CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: _PAnsiChr;'
      'begin'
      '  P := Source;'
      '  while (Length > 0) and (P^ <> #0) do'
      '  begin'
      '    Dec(Length);'
      '    Inc(P);'
      '  end;'
      '  Length := P - Source;'
      '  _LStrFromPCharLen(Dest, Source, Length, CodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest                     }'
      '        {       EDX     pointer to source ANSI characters   }'
      '        {       ECX     number of characters of src         }'
      '        {       [ESP+0] caller EBP                          }'
      '        {       [ESP+4] return address                      }'
      '        {       [ESP+8] CodePage                            }'
      '        PUSH    EDI'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        MOV     EDI,EDX'
      '        XOR     EAX,EAX'
      '        REPNE   SCASB'
      '        JNE     @@1'
      '        NOT     ECX'
      '@@1:    POP     EAX'
      '        ADD     ECX,EAX'
      '        POP     EAX'
      '        POP     EDI'
      '        POP     EBP'
      '        JMP     _LStrFromPCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrFromWArray(var Dest: _AnsiStr; Source: PWideChar;' +
        ' Length: Integer; CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PWideChar;'
      'begin'
      '  P := Source;'
      '  while (Length > 0) and (P^ <> #0) do'
      '  begin'
      '    Dec(Length);'
      '    Inc(P);'
      '  end;'
      '  Length := P - Source;'
      '  _LStrFromPWCharLen(Dest, Source, Length, CodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest                     }'
      '        {       EDX     pointer to source wide characters   }'
      '        {       ECX     number of characters of src         }'
      '        {       [ESP+0] caller EBP                          }'
      '        {       [ESP+4] return address                      }'
      '        {       [ESP+8] CodePage                            }'
      '        PUSH    EDI'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        MOV     EDI,EDX'
      '        XOR     EAX,EAX'
      '        REPNE   SCASW'
      '        JNE     @@1'
      '        NOT     ECX'
      '@@1:    POP     EAX'
      '        ADD     ECX,EAX'
      '        POP     EAX'
      '        POP     EDI'
      '        POP     EBP'
      '        JMP     _LStrFromPWCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrFromWStr(var Dest: _AnsiStr; const Source: _WideS' +
        'tr; CodePage: Word);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _LStrFromUStr(Dest, UnicodeString(Pointer(Source)), CodePage);'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     _LStrFromUStr'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      'begin'
      '  Len := 0;'
      '  if Pointer(Source) <> nil then'
      '    Len := __StringLength(Source);'
      
        '  _LStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), Len, Code' +
        'Page);'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX     pointer to dest                 }'
      '        {       EDX     pointer to _WideStr data      }'
      '        {       ECX     CodePage                        }'
      '        PUSH    [ESP]'
      '        MOV     [ESP+4],ECX'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      '        MOV     ECX,[EDX-4]'
      '        SHR     ECX,1'
      '@@1:'
      '        JMP     _LStrFromPWCharLen'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      '  _LStrFromUStr(Dest, UnicodeString(Pointer(Source)), CodePage);'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      
        'procedure _LStrToString(Dest: _PShortStr; const Source: _AnsiStr' +
        '; MaxLen: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      'begin'
      
        '  if (Pointer(Source) = nil) or (__StringLength(Source) = 0) the' +
        'n'
      '    Byte(Dest^[0]) := 0'
      '  else'
      '  begin'
      '    Len := __StringLength(Source);'
      '    if Len > MaxLen then Len := MaxLen;'
      '    Byte(Dest^[0]) := Len;'
      '    Move(Source[Low(string)], Dest^[1], Len);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to result   }'
      '        {       EDX _AnsiStr s        }'
      '        {       ECX length of result    }'
      ''
      '        PUSH    EBX'
      '        TEST    EDX,EDX'
      '        JE      @@empty'
      '        MOV     EBX,[EDX-skew].StrRec.length'
      '        TEST    EBX,EBX'
      '        JE      @@empty'
      ''
      '        CMP     ECX,EBX'
      '        JL      @@truncate'
      '        MOV     ECX,EBX'
      '@@truncate:'
      '        MOV     [EAX],CL'
      '        INC     EAX'
      ''
      '        XCHG    EAX,EDX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    Move'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,8'
      '{$ENDIF ALIGN_STACK}'
      ''
      '        JMP     @@exit'
      ''
      '@@empty:'
      '        MOV     byte ptr [EAX],0'
      ''
      '@@exit:'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '                                                         '
      'procedure _LStrCat(var Dest: _AnsiStr; const Source: _AnsiStr);'
      '{$IFDEF PUREPASCAL}'
      'const'
      '  First: Cardinal = Low(string);'
      'var'
      '  L1, L2, Len: Cardinal;'
      '  Temp: _PAnsiChr;'
      'begin'
      '  if Pointer(Source) <> nil then'
      '  begin'
      '    if Pointer(Dest) = nil then'
      '      _LStrAsg(Dest, Source)'
      '    else'
      '    begin'
      '      L1 := __StringLength(Dest);'
      '      L2 := __StringLength(Source);'
      '      Len := L1 + L2;'
      
        '      if (((L1 and L2) or ((not Len) and (L1 or L2))) and $80000' +
        '000) <> 0 then _IntOver;'
      '      Temp := @Dest[First];'
      '      _LStrSetLength(Dest, Len, __StringCodePage(Dest));'
      '      if Temp = @Source[First] then'
      '        Temp := @Dest[First]'
      '      else'
      '        Temp := @Source[First];'
      '      Move(Temp^, Dest[L1+First], L2);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     pointer to dest }'
      '        {       EDX     source          }'
      ''
      '        TEST    EDX,EDX'
      '        JE      @@exit'
      ''
      '        MOV     ECX,[EAX]'
      '        TEST    ECX,ECX'
      '        JE      _LStrAsg'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      '        CMP     ESI,ECX'
      '        MOV     EDI,[ECX-skew].StrRec.length'
      ''
      '        MOV     EDX,[ESI-skew].StrRec.length'
      '        ADD     EDX,EDI'
      '        JO      @@lengthOverflow'
      '        CMP     ESI,ECX'
      '        JE      @@appendSelf'
      ''
      '        MOVZX   ECX,[ECX-skew].StrRec.codePage'
      '        CALL    _LStrSetLength'
      '        MOV     EAX,ESI'
      '        MOV     ECX,[ESI-skew].StrRec.length'
      ''
      '@@appendStr:'
      '        MOV     EDX,[EBX]'
      '        ADD     EDX,EDI'
      '        CALL    Move'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        RET'
      ''
      '@@appendSelf:'
      '        MOVZX   ECX,[ECX-skew].StrRec.codePage'
      '        CALL    _LStrSetLength'
      '        MOV     EAX,[EBX]'
      '        MOV     ECX,EDI'
      '        JMP     @@appendStr'
      ''
      '@@lengthOverflow:'
      '{$IFDEF ALIGN_STACK}'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     _IntOver'
      ''
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrCat3(var Dest:_AnsiStr; const Source1, Source2: _' +
        'AnsiStr);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  CodePage: Word;'
      '  Temp: Pointer;'
      '  L1, L2, Len: Cardinal;'
      'begin'
      '  if Pointer(Source1) = nil then'
      '    _LStrAsg(Dest, Source2)'
      '  else if Pointer(Source2) = nil then'
      '    _LStrAsg(Dest, Source1)'
      '  else'
      '  begin'
      '    if Pointer(Dest) = Pointer(Source1) then'
      '      _LStrCat(Dest, Source2)'
      '    else if Pointer(Dest) = Pointer(Source2) then'
      '    begin'
      '      L1 := __StringLength(Source1);'
      '      L2 := __StringLength(Source2);'
      '      Len := L1 + L2;'
      
        '      if (((L1 and L2) or ((not Len) and (L1 or L2))) and $80000' +
        '000) <> 0 then _IntOver;'
      '      CodePage := __StringCodePage(Source2);'
      '      Temp := _NewAnsiString(Len, CodePage);'
      '      Move(_PAnsiChr(Source1)^, _PAnsiChr(Temp)[0], L1);'
      '      Move(_PAnsiChr(Source2)^, _PAnsiChr(Temp)[L1], L2);'
      '      _LStrClr(Dest);'
      '      Pointer(Dest) := Temp;'
      '    end'
      '    else'
      '    begin'
      '      _LStrAsg(Dest, Source1);'
      '      _LStrCat(Dest, Source2);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        {     ->EAX = Pointer to dest   }'
      '        {       EDX = source1           }'
      '        {       ECX = source2           }'
      ''
      '        TEST    EDX,EDX'
      '        JE      @@assignSource2'
      ''
      '        TEST    ECX,ECX'
      '        JE      _LStrAsg'
      ''
      '        CMP     EDX,[EAX]'
      '        JE      @@appendToDest'
      ''
      '        CMP     ECX,[EAX]'
      '        JE      @@theHardWay'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        CALL    _LStrAsg'
      ''
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     _LStrCat'
      ''
      '@@theHardWay: // s(*EAX,ECX) := source1(EDX) + s(ECX)'
      ''
      '        PUSH    EDI'
      ''
      
        '        MOV     EDI,[EDX-skew].StrRec.length  // EDI := Length(s' +
        'ource1) + Length(source2)'
      '        ADD     EDI,[ECX-skew].StrRec.length'
      '        JO      @@overflow'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EAX'
      '        MOV     EBX,EDX   // EBX : source1'
      '        MOV     ESI,ECX   // ESI : source2'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EAX,EDI   // EAX := Final length'
      
        '        MOVZX   EDX,[ESI-skew].StrRec.codePage // use source2'#39's ' +
        'codepage'
      '        CALL    _NewAnsiString'
      '        MOV     EDI,EAX'
      ''
      '        MOV     EDX,EDI  //Move(source1, temp[0], len(source1))'
      '        MOV     EAX,EBX'
      '        MOV     ECX,[EBX-skew].StrRec.length'
      '        CALL    Move'
      ''
      
        '        MOV     EDX,EDI  //Move(source2, temp[len(source1)], len' +
        '(source2))'
      '        MOV     EAX,ESI'
      '        MOV     ECX,[ESI-skew].StrRec.length'
      '        ADD     EDX,[EBX-skew].StrRec.length'
      '        CALL    Move'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      ''
      '        POP     EAX'
      '        MOV     EDX,EDI'
      '        TEST    EDI,EDI'
      '        JE      @@skip'
      
        '        DEC     [EDI-skew].StrRec.refCnt    // EDI = local temp ' +
        'str - pass this reference to the caller'
      '@@skip:'
      '        CALL    _LStrAsg'
      ''
      '        POP     ESI'
      '        POP     EBX'
      '        POP     EDI'
      ''
      '        JMP     @@exit'
      ''
      '@@assignSource2:'
      '        MOV     EDX,ECX'
      '        JMP     _LStrAsg'
      ''
      '@@appendToDest:'
      '        MOV     EDX,ECX'
      '        JMP     _LStrCat'
      ''
      '@@overflow:'
      '        POP     EDI'
      '        JMP     _IntOver'
      ''
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IFDEF PUREPASCAL}'
      
        'procedure InternalLStrCatN(var Dest: _AnsiStr; ArgCnt: Integer; ' +
        'Strs: _PAnsiStr);'
      'var'
      '  CodePage: Word;'
      '  I, Start: Integer;'
      '  Len, L: Integer;'
      '  P: Pointer;'
      '  NewDest: Pointer;'
      '  Appending: Boolean;'
      'begin'
      '  CodePage := 0;'
      '  for I := 0 to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Strs)[I];'
      '    if P <> nil then'
      '    begin'
      '      CodePage := __StringCodePage(P);'
      '      if CodePage <> 0 then'
      '        Break;'
      '    end;'
      '  end;'
      '  Appending := False;'
      '  Len := 0;'
      '  for I := 0 to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Strs)[I];'
      '    if P <> nil then'
      '    begin'
      '      if P = Pointer(Dest) then'
      '        Appending := (I = 0);'
      '      Inc(Len, __StringLength(P));'
      '      if Len < 0 then _IntOver;'
      '    end;'
      '  end;'
      '  if Appending then'
      '  begin'
      '    // Dest is non-nil'
      '    L := __StringLength(Dest);'
      '    _LStrSetLength(Dest, Len, CodePage);'
      '    NewDest := Pointer(Dest);'
      '    Start := 1;'
      '  end'
      '  else'
      '  begin'
      '    NewDest := _NewAnsiString(Len, CodePage);'
      '    Start := 0;'
      '    L := 0;'
      '  end;'
      '  for I := Start to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Strs)[I];'
      '    if P <> nil then'
      '    begin'
      '      Move(P^, _PAnsiChr(NewDest)[L], __StringLength(P));'
      '      Inc(L, __StringLength(P));'
      '    end;'
      '  end;'
      '  if not Appending then'
      '  begin'
      '    if Pointer(Dest) <> nil then'
      '      _LStrClr(Dest);'
      '    Pointer(Dest) := NewDest;'
      '  end;'
      'end;'
      '{$ENDIF PUREPASCAL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _LStrCatN(var Dest: _AnsiStr; ArgCnt: Integer); cdecl;' +
        ' varargs;'
      'var'
      '  VAList: TVarArgList;'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  Buf: PPointerArray;'
      '  ArgIndex: Integer;'
      '  {$ENDIF}'
      'begin'
      '  VarArgStart(VAList);'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  GetMem(Buf, ArgCnt * SizeOf(Pointer));'
      '  for ArgIndex := 0 to ArgCnt - 1 do'
      '    Buf[ArgIndex] := VarArgGetValue(VAList, Pointer);'
      '  InternalLStrCatN(Dest, ArgCnt, _PAnsiStr(Buf));'
      '  FreeMem(Buf);'
      '  {$ELSE}'
      '  InternalLStrCatN(Dest, ArgCnt, _PAnsiStr(VAList));'
      '  {$ENDIF}'
      '  VarArgEnd(VAList);'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        'procedure       _LStrCatN{var dest:_AnsiStr; argCnt: Integer; ..' +
        '.};'
      'asm //StackAligned'
      '        {     ->EAX = Pointer to dest           }'
      '        {       EDX = number of args (>= 3)     }'
      
        '        {       [EBP+8], [EBP+12], ... crgCnt _AnsiStr arguments' +
        ', reverse order }'
      ''
      
        '        PUSH    0                   // Stack - xxxxxxx8 - Save C' +
        'odePage'
      '        PUSH    EBX                 // Stack - xxxxxxx4'
      '        PUSH    ESI                 // Stack - xxxxxxx0'
      '        PUSH    EDI                 // Stack - xxxxxxxc'
      '        PUSH    EDX                 // Stack - xxxxxxx8'
      '        PUSH    EAX                 // Stack - xxxxxxx4'
      
        '        PUSH    0                   // Stack - xxxxxxx0 - Local ' +
        'Temp'
      '        MOV     EBX,EDX'
      ''
      '        XOR     EDI,EDI'
      '        MOV     ECX,[ESP+EDX*4+7*4] // first arg is furthest out'
      '        TEST    ECX,ECX'
      '        JZ      @@0'
      '        MOVZX   ESI,[ECX-skew].StrRec.codePage'
      
        '        MOV     [ESP+6*4],ESI      // Save the first arg'#39's code ' +
        'page in case we need to copy'
      '        CMP     [EAX],ECX          // is dest = first arg?'
      '        JNE     @@0'
      
        '        MOV     EDI,ECX            // EDI nonzero -> potential a' +
        'ppendstr case'
      '        MOV     EAX,[ECX-skew].StrRec.length'
      '        DEC     EDX'
      '        JMP     @@loop1'
      '@@0:'
      '        XOR     EAX,EAX'
      '@@loop1:'
      '        MOV     ECX,[ESP+EDX*4+7*4]'
      '        TEST    ECX,ECX'
      '        JE      @@1'
      '        ADD     EAX,[ECX-skew].StrRec.length'
      '        JO      @@overflow'
      ''
      
        '        CMP     [ESP+6*4],0        // Have we already found a va' +
        'lid codepage?'
      '        JNZ     @@hascodepage'
      
        '        MOVZX   ESI,[ECX-skew].StrRec.codePage // Save the first' +
        ' non-blank arg we find'#39's codepage'
      '        MOV     [ESP+6*4],ESI'
      '@@hascodepage:'
      ''
      '        CMP     EDI,ECX          // is dest an arg besides arg1?'
      '        JNE     @@1'
      
        '        XOR     EDI,EDI          // can'#39't appendstr - dest is mu' +
        'ltiple args'
      '@@1:'
      '        DEC     EDX'
      '        JNE     @@loop1'
      ''
      '@@append:'
      
        '        TEST    EDI,EDI          // dest is 1st and only 1st arg' +
        '?'
      '        JZ      @@copy'
      '        MOV     EDX,EAX          // length into EDX'
      '        MOV     EAX,[ESP + 4]    // ptr to str into EAX'
      
        '        MOV     ESI,[EDI-skew].StrRec.Length  // save old size b' +
        'efore realloc'
      '        MOVZX   ECX,[EDI-Skew].StrRec.codePage'
      '        CALL    _LStrSetLength'
      
        '        MOV     EDI,[ESP + 4]        // append other strs to des' +
        't'
      '        MOV     EAX,[EDI]        // Stack - xxxxxxx0'
      '        MOV     [ESP],EAX'
      '        ADD     ESI,[EDI]        // ESI = end of old string'
      '        DEC     EBX'
      '        JMP     @@loop2'
      ''
      '@@copy:'
      '        MOV     EDX,[ESP+6*4]'
      '        CALL    _NewAnsiString'
      '        MOV     [ESP],EAX       // Stack - xxxxxxx0'
      '        MOV     ESI,EAX'
      ''
      '@@loop2:'
      '        MOV     EAX,[ESP+EBX*4+7*4]'
      '        MOV     EDX,ESI'
      '        TEST    EAX,EAX'
      '        JE      @@2'
      '        MOV     ECX,[EAX-skew].StrRec.length'
      '        ADD     ESI,ECX'
      '        CALL    Move'
      '@@2:'
      '        DEC     EBX'
      '        JNE     @@loop2'
      ''
      '        MOV     EDX,[ESP]'
      '        MOV     EAX,[ESP+4]         // Stack - xxxxxxx0'
      '        TEST    EDI,EDI'
      '        JNZ     @@exit'
      ''
      '        TEST    EDX,EDX'
      '        JE      @@skip'
      
        '        DEC     [EDX-skew].StrRec.refCnt   // EDX = local temp s' +
        'tr'
      '@@skip:'
      '        CALL    _LStrAsg'
      ''
      '@@exit:'
      
        '        ADD     ESP,8           // Stack - xxxxxxx8 - Clean Loca' +
        'l Temp & Saved EAX'
      '        POP     EDX             // Stack - xxxxxxxc'
      '        POP     EDI             // Stack - xxxxxxx0'
      '        POP     ESI             // Stack - xxxxxxx4'
      '        POP     EBX             // Stack - xxxxxxx8'
      
        '        POP     EAX             // Stack - xxxxxxxc - Codepage T' +
        'emp'
      
        '        POP     EAX             // Stack - xxxxxxx0 - Return Add' +
        'ress'
      '        LEA     ESP,[ESP+EDX*4]'
      
        '        JMP     EAX // Unbalanced CALL/RET means clobbered branc' +
        'h prediction.'
      
        '                    // Should fix codegen and have caller pop ar' +
        'guments, like cdecl.'
      ''
      '@@overflow:'
      '        JMP     _IntOver'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      '// Returns 0 : Left = Right'
      '//     minus : Left < Right'
      '//      plus : Left > Right'
      'function _LStrCmp(const Left, Right: _AnsiStr): Integer;'
      'var'
      '  Len, LLen, RLen: Integer;'
      '  LPtr, RPtr: _PAnsiChr;'
      'begin'
      '  if Pointer(Left) = Pointer(Right) then'
      '    Result := 0'
      '  else if Pointer(Left) = nil then'
      '    Result := 0 - __StringLength(Right)'
      '  else if Pointer(Right) = nil then'
      '    Result := __StringLength(Left)'
      '  else'
      '  begin'
      '    LLen := __StringLength(Left);'
      '    RLen := __StringLength(Right);'
      '    Len := LLen;'
      '    if Len > RLen then Len := RLen;'
      '    LPtr := _PAnsiChr(Left);'
      '    RPtr := _PAnsiChr(Right);'
      '    while Len > 0 do'
      '    begin'
      '      Result := Ord(LPtr^) - Ord(RPtr^);'
      '      if Result <> 0 then'
      '        Exit;'
      '      if Len = 1 then break;'
      '      Result := Ord(LPtr[1]) - Ord(RPtr[1]);'
      '      if Result <> 0 then'
      '        Exit;'
      '      Inc(LPtr, 2);'
      '      Inc(RPtr, 2);'
      '      Dec(Len, 2);'
      '    end;'
      '    Result := LLen - RLen;'
      '  end;'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        '{Original code by Pierre le Riche. Licensed under the CodeGear l' +
        'icense terms.}'
      'procedure _LStrCmp{left: _AnsiStr; right: _AnsiStr};'
      'asm'
      '  {On entry:'
      '     eax = @Left[1]'
      '     edx = @Right[1]'
      '   On exit:'
      '     Result in flags:'
      '       CF = 1 if Left < Right, CF = 0 otherwise'
      '       ZF = 1 if Left = Right, ZF = 0 otherwise}'
      ''
      
        '  CMP   EAX, EDX   // Do S1 and S2 point to the same string data' +
        '?'
      '  JE    @DoneNoPop'
      ''
      
        '  TEST  EAX, EDX   // Is one of the two string pointers perhaps ' +
        'nil?'
      '  JZ    @PossibleNilString'
      '@BothStringsNonNil:'
      
        '  {Compare the first character. (There has to be a trailing #0, ' +
        'so this'
      
        '   comparison is safe). In "random" string compares this can sav' +
        'e significant'
      '   CPU time.}'
      '  MOVZX ECX, BYTE PTR [EAX]'
      '  SUB   CL, [EDX]'
      '  JNE   @DoneNoPop'
      ''
      '  PUSH  EBX             // Save ebx'
      '  MOV   EBX, [EAX - 4]  // Set ebx = length(S1)'
      '  SUB   EBX, [EDX - 4]  // Set ebx = length(S1) - length(S2)'
      
        '  PUSH  EBX             // Save the length difference on the sta' +
        'ck'
      ''
      
        '  ADC   ECX, -1 // Set ecx = 0 if length(S1) <= length(S2), $fff' +
        'fffff otherwise'
      
        '  AND   ECX, EBX        // Set ecx = - min(length(S1), length(S2' +
        '))'
      ''
      '  SUB   ECX, [EAX - 4]'
      '  {Adjust the pointers to be negative offset based}'
      '  SUB   EAX, ECX'
      '  SUB   EDX, ECX'
      '@CompareLoop:'
      
        '  {Compare four bytes per cycle. (The start of string data is at' +
        ' least DWord'
      '   aligned, so this is safe.)}'
      '  MOV   EBX, [EAX + ECX]'
      '  XOR   EBX, [EDX + ECX]'
      '  JNZ   @Mismatch'
      ''
      '  ADD   ECX, 4   // Next four bytes'
      '  JS    @CompareLoop'
      ''
      
        '@MatchUpToLength: // All characters match up to the compare leng' +
        'th'
      '  POP   EAX       // Restore the string length difference to eax'
      
        '  ADD   EAX, EAX  // Set the flags according to the length diffe' +
        'rence'
      '  POP   EBX       // Restore ebx and return'
      '@DoneNoPop:'
      '  RET'
      ''
      '@Mismatch:'
      '  BSF   EBX, EBX // Find the byte index that mismatched'
      '  SHR   EBX, 3'
      ''
      '  ADD   ECX, EBX //   Is the mismatch beyond the compare length?'
      '  JNS   @MatchUpToLength'
      ''
      
        '  MOV   AL, [EAX + ECX] // Compare the mismatched byte, setting ' +
        'the flags'
      '  CMP   AL, [EDX + ECX]'
      ''
      
        '  POP   EBX      // Pop the length difference, restore ebx and r' +
        'eturn'
      '  POP   EBX'
      '  RET'
      '@PossibleNilString:'
      
        '  {There is a good probability that one of the strings are nil (' +
        'but not both)}'
      '  TEST  EAX, EAX'
      '  JZ    @FirstStringNil'
      '  TEST  EDX, EDX'
      '  JNZ   @BothStringsNonNil'
      ''
      
        '  CMP   [EAX - 4], EDX // S2 is nil - compare lengths of the str' +
        'ings'
      '  RET'
      '@FirstStringNil:'
      
        '  CMP   EAX, [EDX - 4] // S1 is nil - compare lengths of the str' +
        'ings'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _LStrEqual(const Left, Right: _AnsiStr): Integer;'
      'begin'
      '  Result := _LStrCmp(Left, Right);'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        '{Original code by Pierre le Riche. Licensed under the CodeGear l' +
        'icense terms.}'
      'procedure _LStrEqual{const Left, Right: _AnsiStr};'
      'asm'
      '  {On entry:'
      '     eax = @Left[1]'
      '     edx = @Right[1]'
      '   On exit:'
      '     Result in flags:'
      '       ZF = 1 if Left = Right, ZF = 0 otherwise}'
      ''
      
        '        CMP   EAX, EDX  //Do Left and Right point to the same st' +
        'ring data?'
      '        JE    @CompareDoneNoPop'
      ''
      
        '        TEST  EAX, EDX  //Is one of the two string pointers perh' +
        'aps nil?'
      '        JZ    @PossibleNilString'
      '@BothStringsNonNil:'
      '        MOV   ECX, [EAX - 4] //Compare lengths'
      '        CMP   ECX, [EDX - 4]'
      '        JNE   @CompareDoneNoPop'
      ''
      '        PUSH  EBX       // Save ebx'
      '        {Get pointers to the 4th last bytes in the strings}'
      '        LEA   EDX, [EDX + ECX - 4]'
      '        LEA   EBX, [EAX + ECX - 4]'
      '        NEG   ECX       // Negate the loop counter'
      
        '        {Compare the last four bytes. If the string length is le' +
        'ss'
      
        '         than four bytes then part of the length field is compar' +
        'ed'
      '         again - no harm done.}'
      '        MOV   EAX, [EBX]'
      '        CMP   EAX, [EDX]'
      '        JNE   @CompareDonePop'
      '@CompareLoop:'
      '        ADD   ECX, 4 // Next four bytes'
      '        JNS   @Match'
      '        {Compare four bytes per iteration}'
      '        MOV   EAX, [EBX + ECX]'
      '        CMP   EAX, [EDX + ECX]'
      '        JE    @CompareLoop'
      '@CompareDonePop:'
      '        POP   EBX'
      '@CompareDoneNoPop:'
      '        RET'
      '@Match:'
      '        XOR   EAX, EAX // Strings match - set the zero flag'
      '        POP   EBX'
      '        RET'
      '@PossibleNilString:'
      
        '        {There is a good probability that one of the strings are' +
        ' nil'
      '         (but not both)}'
      '        TEST  EAX, EAX'
      '        JZ    @FirstStringNil'
      '        TEST  EDX, EDX'
      '        JNZ   @BothStringsNonNil'
      '        {Right is nil - compare lengths of the strings}'
      '        CMP   [EAX - 4], EDX'
      '        RET'
      '@FirstStringNil:'
      '        {Left is nil - compare lengths of the strings}'
      '        CMP   EAX, [EDX - 4]'
      '        RET'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      'type'
      '  PEmptyString = ^TEmptyString;'
      '  TEmptyString = packed record'
      '    Rec: StrRec;'
      '    Nul: Word;'
      '  end;'
      ''
      'const'
      '  // Using an initialized _AnsiStr to be sure of alignement'
      '  // and so that it is read only.'
      '  // Note: This const assumes a little endian machine.'
      '  EmptyStringA: _AnsiStr ='
      '{$IFDEF CPU64BITS}'
      '  #$00#$00#$00#$00 +  // Padding, data is 16 byte aligned'
      '{$ENDIF}'
      '  #$FF#$FF +          // codePage := FFFF;'
      '  #$01#$00 +          // elemSize := 1;'
      '  #$FF#$FF#$FF#$FF +  // refCnt := -1;'
      '  #$00#$00#$00#$00 +  // length := 0;'
      '  #$00#$00;           // Data   := nil;'
      ''
      '  EmptyStringW: _AnsiStr ='
      '{$IFDEF CPU64BITS}'
      '  #$00#$00#$00#$00 +  // Padding, data is 16 byte aligned'
      '{$ENDIF}'
      '  #$FF#$FF +          // codePage := FFFF;'
      '  #$02#$00 +          // elemSize := 2;'
      '  #$FF#$FF#$FF#$FF +  // refCnt := -1;'
      '  #$00#$00#$00#$00 +  // length := 0;'
      '  #$00#$00;           // Data   := nil;'
      ''
      'function _LStrToPChar(const S: _AnsiStr): _PAnsiChr;'
      'begin'
      '  Result := Pointer(S);'
      '  if Result = nil then'
      '    Result := @(PEmptyString(Pointer(EmptyStringA))^.Nul);'
      'end;'
      ''
      
        'function _LStrCopy(const S: _AnsiStr; Index, Count: Integer): _A' +
        'nsiStr;'
      'var'
      '  L, N: Integer;'
      'begin'
      '  L := Length(S);'
      '  if Index < 1 then'
      '    Index := 0'
      '  else'
      '  begin'
      '    Dec(Index);'
      '    if Index > L then'
      '      Index := L;'
      '  end;'
      '  if Count < 0 then'
      '    N := 0'
      '  else'
      '  begin'
      '    N := L - Index;'
      '    if N > Count then'
      '      N := Count;'
      '  end;'
      '  if Pointer(S) = nil then'
      '    _LStrClr(Result)'
      '  else'
      
        '    _LStrFromPCharLen(Result, _PAnsiChr(Pointer(S)) + Index, N, ' +
        '__StringCodePage(S))'
      'end;'
      ''
      'procedure _LStrDelete(var S: _AnsiStr; Index, Count: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  L, N: Integer;'
      'begin'
      '  InternalUniqueStringA(S);'
      '  L := Length(S);'
      '  if (Index >= 1) and (Index <= L) and (Count > 0) then'
      '  begin'
      '    Dec(Index);'
      '    N := L - Index - Count;'
      '    if N < 0 then'
      '      N := 0;'
      
        '    Move(_PAnsiChr(Pointer(S))[L - N], _PAnsiChr(Pointer(S))[Ind' +
        'ex], N);'
      '    _LStrSetLength(S, Index + N, __StringCodePage(S));'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        {     ->EAX     Pointer to s    }'
      '        {       EDX     index           }'
      '        {       ECX     count           }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      ''
      '        CALL    InternalUniqueStringA'
      ''
      '        MOV     EDX,[EBX]'
      
        '        TEST    EDX,EDX         { source already empty: nothing ' +
        'to do   }'
      '        JE      @@exit'
      ''
      '        MOV     ECX,[EDX-skew].StrRec.length'
      ''
      
        '{       make index 0-based, if not in [0 .. Length(s)-1] do noth' +
        'ing     }'
      ''
      '        DEC     ESI'
      '        JL      @@exit'
      '        CMP     ESI,ECX'
      '        JGE     @@exit'
      ''
      '{       limit count to [0 .. Length(s) - index] }'
      ''
      '        TEST    EDI,EDI'
      '        JLE     @@exit'
      
        '        SUB     ECX,ESI         { ECX = Length(s) - index       ' +
        '}'
      '        CMP     EDI,ECX'
      '        JLE     @@1'
      '        MOV     EDI,ECX'
      '@@1:'
      ''
      
        '{       move length - index - count characters from s+index+coun' +
        't to s+index }'
      ''
      
        '        SUB     ECX,EDI         { ECX = Length(s) - index - coun' +
        't       }'
      
        '        ADD     EDX,ESI         { EDX = s+index                 ' +
        '}'
      
        '        LEA     EAX,[EDX+EDI]   { EAX = s+index+count           ' +
        '}'
      '        CALL    Move'
      ''
      '{       set length(s) to length(s) - count      }'
      ''
      '        MOV     EDX,[EBX]'
      '        MOV     EAX,EBX'
      '        MOVZX   ECX,[EDX-skew].StrRec.codePage'
      '        MOV     EDX,[EDX-skew].StrRec.length'
      '        SUB     EDX,EDI'
      '        CALL    _LStrSetLength'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _LStrInsert(const Source: _AnsiStr; var S: _AnsiStr; I' +
        'ndex: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  CodePage: Word;'
      '  SourceLen, DestLen, NewLen: Integer;'
      '  SelfInsert: Boolean;'
      'begin'
      '  SourceLen := Length(Source);'
      '  if SourceLen > 0 then'
      '  begin'
      '    CodePage := __StringCodePage(Source);'
      '    DestLen := Length(S);'
      '    if DestLen > 0 then'
      '      CodePage := __StringCodePage(S);'
      '    if Index < 1 then Index := 0 else'
      '    begin'
      '      Dec(Index);'
      '      if Index > DestLen then Index := DestLen;'
      '    end;'
      '    SelfInsert := (Pointer(Source) = Pointer(S));'
      '    NewLen := DestLen + SourceLen;'
      '    if NewLen < 0 then   // overflow check'
      '      _IntOver;'
      '    _LStrSetLength(S, NewLen, CodePage);'
      '    if Index < DestLen then'
      
        '      Move(_PAnsiChr(Pointer(S))[Index], _PAnsiChr(Pointer(S))[I' +
        'ndex + SourceLen],'
      '        (DestLen - Index));'
      '    if SelfInsert then'
      '      Move(Pointer(S)^, _PAnsiChr(Pointer(S))[Index], SourceLen)'
      '    else'
      
        '      Move(Pointer(Source)^, _PAnsiChr(Pointer(S))[Index], Sourc' +
        'eLen);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     source string                   }'
      '        {       EDX     pointer to destination string   }'
      '        {       ECX     index                           }'
      ''
      '        TEST    EAX,EAX'
      '        JE      @@nothingToDo'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,12'
      '{$ENDIF}'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      ''
      
        '{       make index 0-based and limit to 0 <= index <= Length(s) ' +
        '}'
      ''
      '        MOV     EDX,[EDX]'
      '        PUSH    EDX'
      '        TEST    EDX,EDX'
      '        JE      @@sIsNull'
      '        MOV     EDX,[EDX-skew].StrRec.length'
      '@@sIsNull:'
      '        DEC     EDI'
      '        JGE     @@indexNotLow'
      '        XOR     EDI,EDI'
      '@@indexNotLow:'
      '        CMP     EDI,EDX'
      '        JLE     @@indexNotHigh'
      '        MOV     EDI,EDX'
      '@@indexNotHigh:'
      ''
      '        MOV     EBP,[EBX-skew].StrRec.length'
      ''
      
        '{       set length of result to length(source) + length(s)      ' +
        '}'
      ''
      '        MOV     EAX,[ESI]'
      '        TEST    EAX,EAX'
      '        JNE     @@DestNotNull'
      '        MOV     EAX,EBX'
      '@@DestNotNull:'
      '        MOVZX   ECX,[EAX-skew].StrRec.codePage'
      '        MOV     EAX,ESI'
      '        ADD     EDX,EBP'
      '        JO      @@overflow'
      '        CALL    _LStrSetLength'
      '        POP     EAX'
      ''
      '        CMP     EAX,EBX'
      '        JNE     @@notInsertSelf'
      '        MOV     EBX,[ESI]'
      ''
      '@@notInsertSelf:'
      ''
      
        '{       move length(s) - length(source) - index chars from s+ind' +
        'ex to s+index+length(source) }'
      ''
      
        '        MOV     EAX,[ESI]                       { EAX = s       ' +
        '}'
      
        '        LEA     EDX,[EDI+EBP]                   { EDX = index + ' +
        'length(source)  }'
      '        MOV     ECX,[EAX-skew].StrRec.length'
      
        '        SUB     ECX,EDX                         { ECX = length(s' +
        ') - length(source) - index }'
      
        '        ADD     EDX,EAX                         { EDX = s + inde' +
        'x + length(source)      }'
      
        '        ADD     EAX,EDI                         { EAX = s + inde' +
        'x       }'
      '        CALL    Move'
      ''
      
        '{       copy length(source) chars from source to s+index        ' +
        '}'
      ''
      '        MOV     EAX,EBX'
      '        MOV     EDX,[ESI]'
      '        MOV     ECX,EBP'
      '        ADD     EDX,EDI'
      '        CALL    Move'
      ''
      '@@exit:'
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,12'
      '{$ENDIF}'
      '@@nothingToDo:'
      '        RET'
      ''
      '@@overflow:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,4'
      '{$ENDIF}'
      '        JMP     _IntOver'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IFDEF ANDROID}'
      '// Currently, elementsize doesn'#39't use.'
      
        'function CalcReallocMemorySizeWithGap(const size, elementsize: N' +
        'ativeInt): NativeInt; inline;'
      'const'
      '  MEMORYGAPSIZE = $100; // 256 bytes'
      'begin'
      '  Result := size;'
      '  if not EnableReallocMemoryGap then Exit;'
      '  if (size > $1_0000) then // 64K bytes'
      '  begin'
      
        '    Result := (size + MEMORYGAPSIZE) and (not (MEMORYGAPSIZE - 1' +
        '));'
      '  end;'
      'end;'
      '{$ENDIF ANDROID}'
      ''
      
        'procedure _LStrSetLength(var Str: _AnsiStr; NewLength: Integer; ' +
        'CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      '  Temp: Pointer;'
      '  CopyCount: Integer;'
      'begin'
      '  if newLength <= 0 then'
      '  begin'
      '    _LStrClr(Str);'
      '    Exit;'
      '  end'
      '  else'
      '  begin'
      '    if Pointer(Str) <> nil then'
      '    begin'
      '      if __StringRefCnt(Str) = 1 then'
      '      begin'
      '        P := Pointer(PByte(Str) - Sizeof(StrRec));'
      '{$IFDEF ANDROID}'
      
        '        _ReallocMem(Pointer(P), CalcReallocMemorySizeWithGap(New' +
        'Length + 1 + SizeOf(StrRec), sizeof(AnsiChar)));'
      '{$ELSE !ANDROID}'
      '        _ReallocMem(Pointer(P), NewLength + 1 + SizeOf(StrRec));'
      '{$ENDIF ANDROID}'
      '        P.length := NewLength;'
      '        Pointer(Str) := Pointer(PByte(P) + SizeOf(StrRec));'
      '        _PAnsiChr(Str)[NewLength] := #0;'
      '        Exit;'
      '      end;'
      '    end;'
      '    Temp := _NewAnsiString(NewLength, CodePage);'
      '    if Pointer(Str) = nil then'
      '    begin'
      '      Pointer(Str) := Temp;'
      '      Exit;'
      '    end;'
      '    CopyCount := __StringLength(Str);'
      '    if CopyCount > NewLength then'
      '      CopyCount := NewLength;'
      '    Move(_PAnsiChr(str)^, _PAnsiChr(Temp)^, CopyCount);'
      '    _LStrClr(Str);'
      '    Pointer(Str) := Temp;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to str  }'
      '        {       EDX     new length      }'
      '        {       ECX     codePage        }'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8                       // Stack - xxxxxxx4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBX                          // Stack - xxxxxxx0'
      '        PUSH    ESI                          // Stack - xxxxxxxc'
      '        PUSH    EDI                          // Stack - xxxxxxx8'
      '        PUSH    EBP                          // Stack - xxxxxxx4'
      
        '        PUSH    0                            // Stack - xxxxxxx0' +
        ' - Local Temp'
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EBP,ECX'
      '        XOR     EDI,EDI'
      ''
      '        TEST    EDX,EDX'
      '        JLE     @@setString'
      ''
      '        MOV     EAX,[EBX]'
      '        TEST    EAX,EAX'
      '        JE      @@copyString'
      ''
      '        CMP     [EAX-skew].StrRec.refCnt,1'
      '        JNE     @@copyString'
      ''
      '        SUB     EAX,rOff'
      '        ADD     EDX,rOff+1'
      '        JO      @@overflow'
      '        MOV     [ESP],EAX                    // Stack - xxxxxxx0'
      '        MOV     EAX,ESP'
      '        CALL    _ReallocMem'
      '        MOV     EAX,[ESP]                    // Stack - xxxxxxx0'
      '        ADD     EAX,rOff'
      '        MOV     [EBX],EAX'
      '        MOV     [EAX-skew].StrRec.length,ESI'
      '        MOV     BYTE PTR [EAX+ESI],0'
      '        JMP     @@exit'
      ''
      '@@overflow:'
      '        JMP     _IntOver'
      ''
      '@@copyString:'
      '        MOV     EAX,EDX'
      '        MOV     EDX,EBP'
      '        CALL    _NewAnsiString'
      '        MOV     EDI,EAX'
      ''
      '        MOV     EAX,[EBX]'
      '        TEST    EAX,EAX'
      '        JE      @@setString'
      ''
      '        MOV     EDX,EDI'
      '        MOV     ECX,[EAX-skew].StrRec.length'
      '        CMP     ECX,ESI'
      '        JL      @@moveString'
      '        MOV     ECX,ESI'
      ''
      '@@moveString:'
      '        CALL    Move'
      ''
      '@@setString:'
      '        MOV     EAX,EBX'
      '        CALL    _LStrClr'
      '        MOV     [EBX],EDI'
      ''
      '@@exit:'
      
        '        POP     EDX                          // Stack - xxxxxxx4' +
        ' - Local Temp'
      '        POP     EBP                          // Stack - xxxxxxx8'
      '        POP     EDI                          // Stack - xxxxxxxc'
      '        POP     ESI                          // Stack - xxxxxxx0'
      '        POP     EBX                          // Stack - xxxxxxx4'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8                       // Stack - xxxxxxxc'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      
        'procedure _LStrFromUStr(var Dest: _AnsiStr; const Source: Unicod' +
        'eString; CodePage: Word);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Pointer(Source) = nil then'
      '    _LStrClr(Dest)'
      '  else'
      
        '    _LStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), __Strin' +
        'gLength(Source), CodePage)'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX pointer to dest                 }'
      '        {       EDX pointer to UnicodeString data   }'
      '        {       ECX destination codepage            }'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,8'
      '        PUSH    ECX'
      '{$ELSE !ALIGN_STACK}'
      '        PUSH    [ESP]'
      '        MOV     [ESP+4],ECX'
      '{$ENDIF !ALIGN_STACK}'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      
        '        MOV     ECX,[EDX-Skew].StrRec.length     // length in Un' +
        'icodeString is widechar count'
      '@@1:'
      '{$IFDEF ALIGN_STACK}'
      '        CALL    _LStrFromPWCharLen'
      '        ADD     ESP,8'
      '        RET'
      '{$ELSE !ALIGN_STACK}'
      '        JMP     _LStrFromPWCharLen'
      '{$ENDIF !ALIGN_STACK}'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for _WideStr support          }'
      '{ ----------------------------------------------------- }'
      ''
      'procedure UStrSet(var S: UnicodeString; P: PWideChar); forward;'
      'procedure WStrSet(var S: _WideStr; P: PWideChar);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Temp: Pointer;'
      'begin'
      '  Temp := AtomicExchange(Pointer(S), Pointer(P));'
      '  if Temp <> nil then'
      '    _WStrClr(Temp);'
      'end;'
      '{$ELSE}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     UStrSet'
      'end;'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        XCHG    [EAX],EDX'
      '        TEST    EDX,EDX'
      '        JZ      @@1'
      '        PUSH    EDX'
      '        CALL    SysFreeString'
      '@@1:'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _WStrFromChar(var Dest: _WideStr; Source: _AnsiChr);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  InternalWStrFromPCharLen(Dest, @Source, 1, DefaultSystemCodePa' +
        'ge);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        PUSH    EDX'
      '        MOV     EDX,ESP'
      '        MOV     ECX,1'
      '        PUSH    DefaultSystemCodePage'
      '        CALL    InternalWStrFromPCharLen'
      '        POP     EDX'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     _UStrFromChar'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _WStrFromWChar(var Dest: _WideStr; Source: WideChar);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _WStrFromPWCharLen(Dest, @Source, 1);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)   }'
      '        {       EDX     character             (source) }'
      '        PUSH    EDX'
      '        MOV     EDX,ESP'
      '        MOV     ECX,1'
      '        CALL    _WStrFromPWCharLen'
      '        POP     EDX'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP _UStrFromWChar'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _WStrFromPChar(var Dest: _WideStr; Source: _PAnsiChr);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  InternalWStrFromPCharLen(Dest, Source, _PCharLen(Source), Defa' +
        'ultSystemCodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)    }'
      '        {       EDX     Pointer to character  (source)  }'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@5'
      '        PUSH    EDX'
      '@@0:    CMP     CL,[EDX+0]'
      '        JE      @@4'
      '        CMP     CL,[EDX+1]'
      '        JE      @@3'
      '        CMP     CL,[EDX+2]'
      '        JE      @@2'
      '        CMP     CL,[EDX+3]'
      '        JE      @@1'
      '        ADD     EDX,4'
      '        JMP     @@0'
      '@@1:    INC     EDX'
      '@@2:    INC     EDX'
      '@@3:    INC     EDX'
      '@@4:    MOV     ECX,EDX'
      '        POP     EDX'
      '        SUB     ECX,EDX'
      '@@5:    JMP     _WStrFromPCharLen'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     _UStrFromPChar'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _WStrFromPWChar(var Dest: _WideStr; Source: PWideChar)' +
        ';'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Pointer(Source) = nil then'
      '    _WStrClr(Dest)'
      '  else'
      '    _WStrFromPWCharLen(Dest, Source, _PWCharLen(Source));'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)   }'
      '        {       EDX     Pointer to character  (source) }'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@5'
      '        PUSH    EDX'
      '@@0:    CMP     CX,[EDX+0]'
      '        JE      @@4'
      '        CMP     CX,[EDX+2]'
      '        JE      @@3'
      '        CMP     CX,[EDX+4]'
      '        JE      @@2'
      '        CMP     CX,[EDX+6]'
      '        JE      @@1'
      '        ADD     EDX,8'
      '        JMP     @@0'
      '@@1:    ADD     EDX,2'
      '@@2:    ADD     EDX,2'
      '@@3:    ADD     EDX,2'
      '@@4:    MOV     ECX,EDX'
      '        POP     EDX'
      '        SUB     ECX,EDX'
      '        SHR     ECX,1'
      '@@5:    JMP     _WStrFromPWCharLen'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     _UStrFromPWChar'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _WStrFromString(var Dest: _WideStr; const Source: _Sho' +
        'rtStr);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  InternalWStrFromPCharLen(Dest, @Source[1], Byte(Source[0]), De' +
        'faultSystemCodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        XOR     ECX,ECX'
      '        MOV     CL,[EDX]'
      '        INC     EDX'
      '        JMP     _WStrFromPCharLen'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP    _UStrFromString'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _WStrFromArray(var Dest: _WideStr; Source: _PAnsiChr; ' +
        'Length: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: _PAnsiChr;'
      'begin'
      '  P := Source;'
      '  while (Length > 0) and (P^ <> #0) do'
      '  begin'
      '    Dec(Length);'
      '    Inc(P);'
      '  end;'
      '  Length := P - Source;'
      
        '  InternalWStrFromPCharLen(Dest, Source, Length, DefaultSystemCo' +
        'dePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)   }'
      '        {       EDX     Pointer to character  (source) }'
      '        {       ECX     Length of source characters    }'
      '        PUSH    EDI'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        MOV     EDI,EDX'
      '        XOR     EAX,EAX'
      '        REPNE   SCASB'
      '        JNE     @@1'
      '        NOT     ECX'
      '@@1:    POP     EAX'
      '        ADD     ECX,EAX'
      '        POP     EAX'
      '        POP     EDI'
      '        JMP     _WStrFromPCharLen'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     _UStrFromArray'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _WStrFromWArray(var Dest: _WideStr; Source: PWideChar;' +
        ' Length: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PWideChar;'
      'begin'
      '  P := Source;'
      '  while (Length > 0) and (P^ <> #0) do'
      '  begin'
      '    Dec(Length);'
      '    Inc(P);'
      '  end;'
      '  Length := P - Source;'
      '  _WStrFromPWCharLen(Dest, Source, Length);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)   }'
      '        {       EDX     Pointer to character  (source) }'
      '        {       ECX     Length of source characters    }'
      '        PUSH    EDI'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        MOV     EDI,EDX'
      '        XOR     EAX,EAX'
      '        REPNE   SCASW'
      '        JNE     @@1'
      '        NOT     ECX'
      '@@1:    POP     EAX'
      '        ADD     ECX,EAX'
      '        POP     EAX'
      '        POP     EDI'
      '        JMP     _WStrFromPWCharLen'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     _UStrFromWArray'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _WStrFromLStr(var Dest: _WideStr; const Source: _AnsiS' +
        'tr);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      'begin'
      '  if Pointer(Source) = nil then'
      '    _WStrClr(Dest)'
      '  else'
      '  begin'
      '    Len := __StringLength(Source);'
      
        '    InternalWStrFromPCharLen(Dest, _PAnsiChr(Pointer(Source)), L' +
        'en, __StringCodePage(Source))'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      
        '// Inject the CodePage parameter onto the stack ahead of the ret' +
        'urn address'
      '        MOVZX   ECX,[EDX-Skew].StrRec.codePage'
      '        PUSH    [ESP]'
      '        MOV     [ESP+4],ECX'
      ''
      '        MOV     ECX,[EDX-Skew].StrRec.length'
      '        JMP     InternalWStrFromPCharLen'
      '@@1:    JMP     _WStrClr'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     _UStrFromLStr'
      'end;'
      '{$ENDIF}'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      
        'procedure _WStrToString(Dest: _PShortStr; const Source: _WideStr' +
        '; MaxLen: Integer);'
      'var'
      '  SourceLen, DestLen: Integer;'
      '  Buffer: array[0..511] of _AnsiChr;'
      'begin'
      '  if MaxLen > 255 then MaxLen := 255;'
      '  SourceLen := Length(Source);'
      '  if SourceLen >= MaxLen then SourceLen := MaxLen;'
      '  if SourceLen = 0 then'
      '    DestLen := 0'
      '  else'
      '  begin'
      
        '    DestLen := CharFromWChar(Buffer, High(Buffer), PWideChar(Poi' +
        'nter(Source)), SourceLen);'
      '    if DestLen < 0 then'
      '      DestLen := 0'
      '    else if DestLen > MaxLen then'
      '      DestLen := MaxLen;'
      '  end;'
      '  Byte(Dest^[0]) := DestLen;'
      '  if DestLen > 0 then Move(Buffer, Dest^[1], DestLen);'
      'end;'
      ''
      'function _WStrToPWChar(const S: _WideStr): PWideChar;'
      'const'
      '  EmptyString = '#39#39';'
      'begin'
      '  if Pointer(S) = nil then'
      '    Result := EmptyString'
      '  else'
      '    Result := Pointer(S);'
      'end;'
      ''
      'procedure _WStrCat(var Dest: _WideStr; const Source: _WideStr);'
      'var'
      '  DestLen, SourceLen: Integer;'
      '  NewStr: PWideChar;'
      'begin'
      '  SourceLen := Length(Source);'
      '  if SourceLen <> 0 then'
      '  begin'
      '    DestLen := Length(Dest);'
      '    NewStr := _NewWideString(DestLen + SourceLen);'
      '    if DestLen > 0 then'
      '      Move(Pointer(Dest)^, NewStr^, DestLen * sizeof(WideChar));'
      
        '    Move(Pointer(Source)^, NewStr[DestLen], SourceLen * sizeof(W' +
        'ideChar));'
      '    WStrSet(Dest, NewStr);'
      '  end;'
      'end;'
      ''
      
        'procedure _WStrCat3(var Dest: _WideStr; const Source1, Source2: ' +
        '_WideStr);'
      'var'
      '  Source1Len, Source2Len: Integer;'
      '  NewStr: PWideChar;'
      'begin'
      '  Source1Len := Length(Source1);'
      '  Source2Len := Length(Source2);'
      '  if (Source1Len <> 0) or (Source2Len <> 0) then'
      '  begin'
      '    NewStr := _NewWideString(Source1Len + Source2Len);'
      
        '    Move(Pointer(Source1)^, Pointer(NewStr)^, Source1Len * sizeo' +
        'f(WideChar));'
      
        '    Move(Pointer(Source2)^, NewStr[Source1Len], Source2Len * siz' +
        'eof(WideChar));'
      '    WStrSet(Dest, NewStr);'
      '  end'
      '  else'
      '    _WStrClr(Dest);'
      'end;'
      ''
      '{$IF (not defined(X86ASMRTL))}'
      '{$IFDEF MSWINDOWS}'
      
        'procedure InternalWStrCatN(var Dest: _WideStr; ArgCnt: Integer; ' +
        'Strs: PWideString);'
      'var'
      '  I: Integer;'
      '  Len, L: Integer;'
      '  P: Pointer;'
      '  NewDest: Pointer;'
      'begin'
      '  Len := 0;'
      '  for I := 0 to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Strs)[I];'
      '    if P <> nil then'
      '    begin'
      '      Inc(Len, __StringLength(_WideStr(P)));'
      '      if Len < 0 then _IntOver;'
      '    end;'
      '  end;'
      '  NewDest := _NewWideString(Len);'
      '  L := 0;'
      '  for I := 0 to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Strs)[I];'
      '    if P <> nil then'
      '    begin'
      
        '      Move(P^, PWideChar(NewDest)[L], __StringLength(_WideStr(P)' +
        ') * SizeOf(WideChar));'
      '      Inc(L, __StringLength(_WideStr(P)));'
      '    end;'
      '  end;'
      '  WStrSet(Dest, NewDest);'
      'end;'
      '{$ENDIF MSWINDOWS}'
      ''
      
        'procedure InternalUStrCatN(var Dest: UnicodeString; ArgCnt: Inte' +
        'ger; Strs: PUnicodeString);'
      'var'
      '  I, Start: Integer;'
      '  Len, L: Integer;'
      '  P: Pointer;'
      '  NewDest: Pointer;'
      '  Appending: Boolean;'
      'begin'
      '  Appending := False;'
      '  Len := 0;'
      '  for I := 0 to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Strs)[I];'
      '    if P <> nil then'
      '    begin'
      '      if P = Pointer(Dest) then'
      '        Appending := (I = 0);'
      '      Inc(Len, __StringLength(P));'
      '      if Len < 0 then _IntOver;'
      '    end;'
      '  end;'
      '  if Appending then'
      '  begin'
      '    // Dest is non-nil'
      '    L := __StringLength(Dest);'
      '    _UStrSetLength(Dest, Len);'
      '    NewDest := Pointer(Dest);'
      '    Start := 1;'
      '  end'
      '  else'
      '  begin'
      '    NewDest := _NewUnicodeString(Len);'
      '    Start := 0;'
      '    L := 0;'
      '  end;'
      '  for I := Start to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Strs)[I];'
      '    if P <> nil then'
      '    begin'
      
        '      Move(P^, PWideChar(NewDest)[L], __StringLength(P) * SizeOf' +
        '(WideChar));'
      '      Inc(L, __StringLength(P));'
      '    end;'
      '  end;'
      '  if not Appending then'
      '  begin'
      '    if Pointer(Dest) <> nil then'
      '      _UStrClr(Dest);'
      '    Pointer(Dest) := NewDest;'
      '  end;'
      'end;'
      ''
      
        'procedure _WStrCatN(var Dest: _WideStr; ArgCnt: Integer); cdecl;' +
        ' varargs;'
      'var'
      '  VAList: TVarArgList;'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  Buf: PPointerArray;'
      '  ArgIndex: Integer;'
      '  {$ENDIF}'
      'begin'
      '  VarArgStart(VAList);'
      '  {$IFDEF MSWINDOWS}'
      '  InternalWStrCatN(Dest, ArgCnt, _PWideStr(VAList));'
      '  {$ELSE !MSWINDOWS}'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  GetMem(Buf, ArgCnt * SizeOf(Pointer));'
      '  for ArgIndex := 0 to ArgCnt - 1 do'
      '    Buf[ArgIndex] := VarArgGetValue(VAList, Pointer);'
      
        '  InternalUStrCatN(UnicodeString(Pointer(Dest)), ArgCnt, PUnicod' +
        'eString(Buf));'
      '  FreeMem(Buf);'
      '  {$ELSE}'
      
        '  InternalUStrCatN(UnicodeString(Pointer(Dest)), ArgCnt, PUnicod' +
        'eString(VAList));'
      '  {$ENDIF}'
      '  {$ENDIF !MSWINDOWS}'
      '  VarArgEnd(VAList);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _WStrCatN{var Dest: _WideStr; ArgCnt: Integer; ...};'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        {     ->EAX = Pointer to dest }'
      '        {       EDX = number of args (>= 3) }'
      
        '        {       [ESP+4], [ESP+8], ... crgCnt _WideStr arguments ' +
        '}'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDX'
      '        PUSH    EAX'
      '        MOV     EBX,EDX'
      ''
      '        XOR     EAX,EAX'
      '@@loop1:'
      '        MOV     ECX,[ESP+EDX*4+4*4]'
      '        TEST    ECX,ECX'
      '        JE      @@1'
      '        ADD     EAX,[ECX-4]'
      '@@1:'
      '        DEC     EDX'
      '        JNE     @@loop1'
      ''
      '        SHR     EAX,1'
      '        CALL    _NewWideString'
      '        PUSH    EAX'
      '        MOV     ESI,EAX'
      ''
      '@@loop2:'
      '        MOV     EAX,[ESP+EBX*4+5*4]'
      '        MOV     EDX,ESI'
      '        TEST    EAX,EAX'
      '        JE      @@2'
      '        MOV     ECX,[EAX-4]'
      '        ADD     ESI,ECX'
      '        CALL    Move'
      '@@2:'
      '        DEC     EBX'
      '        JNE     @@loop2'
      ''
      '        POP     EDX'
      '        POP     EAX'
      '        CALL    WStrSet'
      ''
      '        POP     EDX'
      '        POP     ESI'
      '        POP     EBX'
      '        POP     EAX'
      '        LEA     ESP,[ESP+EDX*4]'
      '        JMP     EAX'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'asm'
      '        {     ->EAX = Pointer to dest }'
      '        {       EDX = number of args (>= 3) }'
      
        '        {       [ESP+4], [ESP+8], ... crgCnt _WideStr arguments ' +
        '}'
      ''
      '        JMP    _UStrCatN'
      'end;'
      '{$ENDIF POSIX}'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      '// Returns 0 : Left = Right'
      '//     minus : Left < Right'
      '//      plus : Left > Right'
      'function _WStrCmp(const Left, Right: _WideStr): Integer;'
      'var'
      '  Len, LLen, RLen: Integer;'
      '  LPtr, RPtr: PWideChar;'
      'begin'
      '  if Pointer(Left) = Pointer(Right) then'
      '    Result := 0'
      '  else if Pointer(Left) = nil then'
      '    Result := 0 - __StringLength(Right)'
      '  else if Pointer(Right) = nil then'
      '    Result := __StringLength(Left)'
      '  else'
      '  begin'
      '    LLen := __StringLength(Left);'
      '    RLen := __StringLength(Right);'
      '    Len := LLen;'
      '    if Len > RLen then Len := RLen;'
      '    LPtr := PWideChar(Left);'
      '    RPtr := PWideChar(Right);'
      '    while Len > 0 do'
      '    begin'
      '      Result := Ord(LPtr^) - Ord(RPtr^);'
      '      if Result <> 0 then'
      '        Exit;'
      '      if Len = 1 then break;'
      '      Result := Ord(LPtr[1]) - Ord(RPtr[1]);'
      '      if Result <> 0 then'
      '        Exit;'
      '      Inc(LPtr, 2);'
      '      Inc(RPtr, 2);'
      '      Dec(Len, 2);'
      '    end;'
      '    Result := LLen - RLen;'
      '  end;'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _WStrCmp{Left, Right: _WideStr};'
      '{$IFDEF MSWINDOWS}'
      'asm //StackAlignSafe'
      '        {     ->EAX = Pointer to left string    }'
      '        {       EDX = Pointer to right string   }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     ESI,EAX'
      '        MOV     EDI,EDX'
      ''
      '        CMP     EAX,EDX'
      '        JE      @@exit'
      ''
      '        TEST    ESI,ESI'
      '        JE      @@str1null'
      ''
      '        TEST    EDI,EDI'
      '        JE      @@str2null'
      ''
      '        MOV     EAX,[ESI-4]'
      '        MOV     EDX,[EDI-4]'
      ''
      '        SUB     EAX,EDX { eax = len1 - len2 }'
      '        JA      @@skip1 { len1 > len2 (unsigned)? }'
      
        '        ADD     EDX,EAX { edx = len2 + (len1 - len2) = len1     ' +
        '}'
      '                        // edx := Min(len1, len2)'
      '@@skip1:'
      '        PUSH    EDX'
      '        SHR     EDX,2'
      '        JE      @@cmpRest'
      '@@longLoop:'
      '        MOV     ECX,[ESI]'
      '        MOV     EBX,[EDI]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        DEC     EDX'
      '        JE      @@cmpRestP4'
      '        MOV     ECX,[ESI+4]'
      '        MOV     EBX,[EDI+4]'
      '        CMP     ECX,EBX'
      '        JNE     @@misMatch'
      '        ADD     ESI,8'
      '        ADD     EDI,8'
      '        DEC     EDX'
      '        JNE     @@longLoop'
      '        JMP     @@cmpRest'
      '@@cmpRestP4:'
      '        ADD     ESI,4'
      '        ADD     EDI,4'
      '@@cmpRest:'
      '        POP     EDX'
      '        AND     EDX,2'
      '        JE      @@equal'
      ''
      '        MOV     CX,[ESI]'
      '        MOV     BX,[EDI]'
      '        CMP     CX,BX'
      '        JNE     @@exit'
      ''
      '@@equal:'
      '        ADD     EAX,EAX'
      '        JMP     @@exit'
      ''
      '@@str1null:'
      '        MOV     EDX,[EDI-4]'
      '        SUB     EAX,EDX'
      '        JMP     @@exit'
      ''
      '@@str2null:'
      '        MOV     EAX,[ESI-4]'
      '        SUB     EAX,EDX'
      '        JMP     @@exit'
      ''
      '@@misMatch:'
      '        POP     EDX'
      '        CMP     CX,BX'
      '        JNE     @@exit'
      '        SHR     ECX,16'
      '        SHR     EBX,16'
      '        CMP     CX,BX'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'asm'
      '        {     ->EAX = Pointer to left string    }'
      '        {       EDX = Pointer to right string   }'
      ''
      '        JMP     _UStrCmp'
      'end;'
      '{$ENDIF POSIX}'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _WStrEqual(const Left, Right: _WideStr): Integer;'
      'begin'
      '  Result := _WStrCmp(Left, Right);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _WStrEqual{const Left, Right: _WideStr};'
      '{$IFDEF MSWINDOWS}'
      'asm'
      '        JMP     _WStrCmp'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'asm'
      '        JMP     _UStrCmp'
      'end;'
      '{$ENDIF POSIX}'
      '{$ENDIF X86ASMRTL}'
      ''
      
        'function _WStrCopy(const S: _WideStr; Index, Count: Integer): _W' +
        'ideStr;'
      'var'
      '  L, N: Integer;'
      'begin'
      '  L := Length(S);'
      '  if Index < 1 then'
      '    Index := 0'
      '  else'
      '  begin'
      '    Dec(Index);'
      '    if Index > L then'
      '      Index := L;'
      '  end;'
      '  if Count < 0 then'
      '    N := 0'
      '  else'
      '  begin'
      '    N := L - Index;'
      '    if N > Count then'
      '      N := Count;'
      '  end;'
      '  _WStrFromPWCharLen(Result, PWideChar(Pointer(S)) + Index, N);'
      'end;'
      ''
      'procedure _WStrDelete(var S: _WideStr; Index, Count: Integer);'
      'var'
      '  L, N: Integer;'
      '  NewStr: PWideChar;'
      'begin'
      '  L := Length(S);'
      
        '  if (L > 0) and (Index >= 1) and (Index <= L) and (Count > 0) t' +
        'hen'
      '  begin'
      '    Dec(Index);'
      '    N := L - Index - Count;'
      '    if N < 0 then N := 0;'
      '    if (Index = 0) and (N = 0) then NewStr := nil else'
      '    begin'
      '      NewStr := _NewWideString(Index + N);'
      '      if Index > 0 then'
      '        Move(Pointer(S)^, NewStr^, Index * 2);'
      '      if N > 0 then'
      
        '        Move(PWideChar(Pointer(S))[L - N], NewStr[Index], N * 2)' +
        ';'
      '    end;'
      '    WStrSet(S, NewStr);'
      '  end;'
      'end;'
      ''
      
        'procedure _WStrInsert(const Source: _WideStr; var Dest: _WideStr' +
        '; Index: Integer);'
      'var'
      '  SourceLen, DestLen: Integer;'
      '  NewStr: PWideChar;'
      'begin'
      '  SourceLen := Length(Source);'
      '  if SourceLen > 0 then'
      '  begin'
      '    DestLen := Length(Dest);'
      '    if Index < 1 then Index := 0 else'
      '    begin'
      '      Dec(Index);'
      '      if Index > DestLen then Index := DestLen;'
      '    end;'
      '    NewStr := _NewWideString(DestLen + SourceLen);'
      '    if Index > 0 then'
      '      Move(Pointer(Dest)^, NewStr^, Index * 2);'
      '    Move(Pointer(Source)^, NewStr[Index], SourceLen * 2);'
      '    if Index < DestLen then'
      
        '      Move(PWideChar(Pointer(Dest))[Index], NewStr[Index + Sourc' +
        'eLen],'
      '        (DestLen - Index) * 2);'
      '    WStrSet(Dest, NewStr);'
      '  end;'
      'end;'
      ''
      'procedure _WStrSetLength(var S: _WideStr; NewLength: Integer);'
      'var'
      '  NewStr: PWideChar;'
      '  Count: Integer;'
      'begin'
      '  NewStr := nil;'
      '  if NewLength > 0 then'
      '  begin'
      '    NewStr := _NewWideString(NewLength);'
      '    Count := Length(S);'
      '    if Count > 0 then'
      '    begin'
      '      if Count > NewLength then Count := NewLength;'
      '      Move(Pointer(S)^, NewStr^, Count * SizeOf(WideChar));'
      '    end;'
      '  end;'
      '  WStrSet(S, NewStr);'
      'end;'
      ''
      
        'procedure _WCharToString(Dest: _PShortStr; const Source: WideCha' +
        'r; MaxLen: Integer);'
      'var'
      '  DestLen: Integer;'
      '  Buffer: array[0..255] of _AnsiChr;'
      'begin'
      '  if MaxLen > 255 then MaxLen := 255;'
      '  DestLen := CharFromWChar(Buffer, High(Buffer), @Source, 1);'
      '  if DestLen < 0 then'
      '    DestLen := 0'
      '  else if DestLen > MaxLen then'
      '    DestLen := MaxLen;'
      '  Byte(Dest^[0]) := DestLen;'
      '  if DestLen > 0 then Move(Buffer, Dest^[1], DestLen);'
      'end;'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for UnicodeString support       }'
      '{ ----------------------------------------------------- }'
      ''
      '{ UnicodeString helper functions }'
      ''
      ''
      'function _UStrToPWChar(const S: UnicodeString): PWideChar;'
      'begin'
      '  Result := Pointer(S);'
      '  if Result = nil then'
      '    Result := @(PEmptyString(Pointer(EmptyStringW))^.Nul);'
      'end;'
      ''
      
        'procedure _UStrFromChar(var Dest: UnicodeString; Source: _AnsiCh' +
        'r);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _UStrFromPCharLen(Dest, @Source, 1);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX      // char on stack'
      '        MOV     EDX,ESP  // addr of char on stack in EDX'
      '        MOV     ECX,1'
      '        CALL    _UStrFromPCharLen'
      '        POP     EDX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrFromWChar(var Dest: UnicodeString; Source: WideCh' +
        'ar);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _UStrFromPWCharLen(Dest, @Source, 1);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX'
      '        MOV     EDX,ESP'
      '        MOV     ECX,1'
      '        CALL    _UStrFromPWCharLen'
      '        POP     EDX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrFromPChar(var Dest: UnicodeString; Source: _PAnsi' +
        'Chr);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _UStrFromPCharLen(Dest, Source, _PCharLen(Source));'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)   }'
      '        {       EDX     Pointer to character  (source) }'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@5'
      '        PUSH    EDX'
      '@@0:    CMP     CL,[EDX+0]'
      '        JE      @@4'
      '        CMP     CL,[EDX+1]'
      '        JE      @@3'
      '        CMP     CL,[EDX+2]'
      '        JE      @@2'
      '        CMP     CL,[EDX+3]'
      '        JE      @@1'
      '        ADD     EDX,4'
      '        JMP     @@0'
      '@@1:    INC     EDX'
      '@@2:    INC     EDX'
      '@@3:    INC     EDX'
      '@@4:    MOV     ECX,EDX'
      '        POP     EDX'
      '        SUB     ECX,EDX'
      '@@5:    JMP     _UStrFromPCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrFromPWChar(var Dest: UnicodeString; Source: PWide' +
        'Char);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _UStrFromPWCharLen(Dest, Source, _PWCharLen(Source));'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX     Pointer to _WideStr (dest)   }'
      '        {       EDX     Pointer to character  (source) }'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@5'
      '        PUSH    EDX'
      '@@0:    CMP     CX,[EDX+0]'
      '        JE      @@4'
      '        CMP     CX,[EDX+2]'
      '        JE      @@3'
      '        CMP     CX,[EDX+4]'
      '        JE      @@2'
      '        CMP     CX,[EDX+6]'
      '        JE      @@1'
      '        ADD     EDX,8'
      '        JMP     @@0'
      '@@1:    ADD     EDX,2'
      '@@2:    ADD     EDX,2'
      '@@3:    ADD     EDX,2'
      '@@4:    MOV     ECX,EDX'
      '        POP     EDX'
      '        SUB     ECX,EDX'
      '        SHR     ECX,1'
      '@@5:    JMP     _UStrFromPWCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrFromArray(var Dest: UnicodeString; Source: _PAnsi' +
        'Chr; Length: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: _PAnsiChr;'
      'begin'
      '  P := Source;'
      '  while (Length > 0) and (P^ <> #0) do'
      '  begin'
      '    Dec(Length);'
      '    Inc(P);'
      '  end;'
      '  Length := P - Source;'
      '  _UStrFromPCharLen(Dest, Source, Length);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        PUSH    EDI'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        MOV     EDI,EDX'
      '        XOR     EAX,EAX'
      '        REPNE   SCASB      // find #0'
      '        JNE     @@1'
      '        NOT     ECX'
      '@@1:    POP     EAX'
      '        ADD     ECX,EAX'
      '        POP     EAX'
      '        POP     EDI'
      '        JMP     _UStrFromPCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrFromWArray(var Dest: UnicodeString; Source: PWide' +
        'Char; Length: Integer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PWideChar;'
      'begin'
      '  P := Source;'
      '  while (Length > 0) and (P^ <> #0) do'
      '  begin'
      '    Dec(Length);'
      '    Inc(P);'
      '  end;'
      '  Length := P - Source;'
      '  _UStrFromPWCharLen(Dest, Source, Length);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        PUSH    EDI'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        MOV     EDI,EDX'
      '        XOR     EAX,EAX'
      '        REPNE   SCASW     // find #$0000'
      '        JNE     @@1'
      '        NOT     ECX'
      '@@1:    POP     EAX'
      '        ADD     ECX,EAX'
      '        POP     EAX'
      '        POP     EDI'
      '        JMP     _UStrFromPWCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrFromLStr(var Dest: UnicodeString; const Source: _' +
        'AnsiStr);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Pointer(Source) = nil then'
      '    _UStrClr(Dest)'
      '  else'
      
        '    InternalUStrFromPCharLen(Dest, _PAnsiChr(Pointer(Source)), _' +
        '_StringLength(Source), __StringCodePage(Source));'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      '        MOVZX   ECX,WORD PTR [EDX-Skew].StrRec.codePage'
      '{$IFDEF ALIGN_STACK}'
      '        PUSH    EBP         // Need a stack frame setup for the'
      
        '        MOV     EBP, ESP    // unwinder in case there'#39's an Excep' +
        'tion'
      '        SUB     ESP, 4'
      '        PUSH    ECX'
      '        MOV     ECX,[EDX-Skew].StrRec.length'
      '        CALL    InternalUStrFromPCharLen'
      '        ADD     ESP, 4'
      '        POP     EBP'
      '        RET'
      '{$ELSE}'
      '        PUSH    [ESP]'
      '        MOV     [ESP+4],ECX'
      '        MOV     ECX,[EDX-Skew].StrRec.length'
      '        JMP     InternalUStrFromPCharLen'
      '{$ENDIF ALIGN_STACK}'
      '@@1:    JMP     _UStrFromPCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrFromWStr(var Dest: UnicodeString; const Source: _' +
        'WideStr);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _UStrAsg(Dest, UnicodeString(Pointer(Source)));'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     _UStrAsg'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Len: Integer;'
      'begin'
      '  Len := 0;'
      '  if Pointer(Source) <> nil then'
      '    Len := __StringLength(Source);'
      '  _UStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), Len);'
      'end;'
      '{$ELSE}'
      'asm'
      '        { ->    EAX pointer to dest                 }'
      '        {       EDX pointer to _WideStr data      }'
      ''
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JZ      @@1            // nil source => zero length'
      '        MOV     ECX,[EDX-4]'
      
        '        SHR     ECX,1          // length in _WideStr is byte cou' +
        'nt'
      '@@1:    JMP     _UStrFromPWCharLen'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      '  _UStrAsg(Dest, UnicodeString(Pointer(Source)));'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      
        'procedure _WStrFromUStr(var Dest: _WideStr; const Source: Unicod' +
        'eString);'
      '{$IFDEF POSIX}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _WStrAsg(Dest, _WideStr(Pointer(Source)));'
      'end;'
      '{$ELSE}'
      'asm'
      '        JMP     _WStrAsg'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Pointer(Source) = nil then'
      '    _WStrClr(Dest)'
      '  else'
      
        '    _WStrFromPWCharLen(Dest, PWideChar(Pointer(Source)), __Strin' +
        'gLength(Source))'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to dest                 }'
      '        {       EDX pointer to UnicodeString data   }'
      ''
      '        XOR     ECX,ECX'
      '        TEST    EDX,EDX'
      '        JZ      @@1            // nil source => zero length'
      
        '        MOV     ECX,[EDX-Skew].StrRec.length    // length in Uni' +
        'codeString is widechar count'
      '@@1:    JMP     _WStrFromPWCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      '{$ENDIF MSWINDOWS}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      '  _WStrAsg(Dest, _WideStr(Pointer(Source)));'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      
        'procedure _UStrToString(Dest: _PShortStr; const Source: UnicodeS' +
        'tring; MaxLen: Integer);'
      'var'
      '  SourceLen, DestLen: Integer;'
      '  Buffer: array[0..511] of _AnsiChr;'
      'begin'
      '  if MaxLen > 255 then MaxLen := 255;'
      '  SourceLen := Length(Source);'
      '  if SourceLen >= MaxLen then SourceLen := MaxLen;'
      '  if SourceLen = 0 then'
      '    DestLen := 0'
      '  else'
      '  begin'
      
        '    DestLen := CharFromWChar(Buffer, High(Buffer), PWideChar(Poi' +
        'nter(Source)), SourceLen);'
      '    if DestLen < 0 then'
      '      DestLen := 0'
      '    else if DestLen > MaxLen then'
      '      DestLen := MaxLen;'
      '  end;'
      '  Byte(Dest^[0]) := DestLen;'
      '  if DestLen > 0 then Move(Buffer, Dest^[1], DestLen);'
      'end;'
      ''
      
        'procedure _UStrFromString(var Dest: UnicodeString; const Source:' +
        ' _ShortStr);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      
        '  InternalUStrFromPCharLen(Dest, @Source[1], Byte(Source[0]), De' +
        'faultSystemCodePage);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        XOR     ECX,ECX'
      '        MOV     CL,[EDX]'
      '        INC     EDX'
      '        JMP     _UStrFromPCharLen'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrSetLength(var Str: UnicodeString; NewLength: Inte' +
        'ger);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: PStrRec;'
      '  Temp: Pointer;'
      '  CopyCount: Integer;'
      'begin'
      '  if NewLength <= 0 then'
      '    _UStrClr(Str)'
      '  else'
      '  begin'
      '    if Pointer(Str) <> nil then'
      '    begin'
      '      if __StringRefCnt(Str) = 1 then'
      '      begin'
      '        P := Pointer(PByte(Str) - Sizeof(StrRec));'
      
        '        if Cardinal(NewLength) >= Cardinal(- SizeOf(StrRec) - Si' +
        'zeOf(WideChar)) div 2 then'
      '          _IntOver;'
      '{$IFDEF ANDROID}'
      
        '        _ReallocMem(Pointer(P), CalcReallocMemorySizeWithGap((Ne' +
        'wLength + 1) * SizeOf(WideChar) + SizeOf(StrRec), sizeof(WideCha' +
        'r)));'
      '{$ELSE !ANDROID}'
      
        '        _ReallocMem(Pointer(P), (NewLength + 1) * SizeOf(WideCha' +
        'r) + SizeOf(StrRec));'
      '{$ENDIF ANDROID}'
      '        P.length := NewLength;'
      '        Pointer(Str) := Pointer(PByte(P) + SizeOf(StrRec));'
      '        PWideChar(Str)[NewLength] := #0;'
      '        Exit;'
      '      end;'
      '    end;'
      '    Temp := _NewUnicodeString(NewLength);'
      '    if Pointer(Str) <> nil then'
      '    begin'
      '      CopyCount := __StringLength(Str);'
      '      if CopyCount > NewLength then'
      '        CopyCount := NewLength;'
      
        '      Move(PWideChar(Str)^, PWideChar(Temp)^, CopyCount * SizeOf' +
        '(WideChar));'
      '      _UStrClr(Str);'
      '    end;'
      '    Pointer(Str) := Temp;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '        { ->    EAX     Pointer to S  }'
      '        {       EDX     new length    }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        MOV     EBX,EAX       // EBX saves @S'
      '        MOV     ESI,EDX       // ESI saves NewLength (chars)'
      '        XOR     EDI,EDI       // EDI := 0; EDI is Temp (result)'
      ''
      '        TEST    EDX,EDX       // NewLength <= 0?'
      '        JLE     @@setString   // Assign S := Temp'
      ''
      '        MOV     EAX,[EBX]     // EAX := S'
      '        TEST    EAX,EAX       // nil?'
      
        '        JE      @@copyString  // cannot reallocate (it'#39's nil), s' +
        'o copy'
      ''
      '        CMP     [EAX-skew].StrRec.refCnt,1 // !!! MT safety'
      '        JNE     @@copyString  // not unique, so copy'
      ''
      
        '        SUB     EAX,rOff      // Offset EAX "S" to start of memo' +
        'ry block'
      '        ADD     EDX,EDX       // Double length to get size'
      '        JO      @@overflow'
      '        ADD     EDX,rOff+2    // Add string rec size'
      '        JO      @@overflow'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX           // Put S on stack'
      '        MOV     EAX,ESP       // to pass by reference'
      '        CALL    _ReallocMem'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        ADD     EAX,rOff      // Readjust'
      '        MOV     [EBX],EAX     // Store'
      '        MOV     [EAX-skew].StrRec.length,ESI'
      '        MOV     WORD PTR [EAX+ESI*2],0 // Null terminate'
      '        TEST    EDI,EDI       // Was a temp created?'
      '        JZ      @@exit'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDI'
      '        MOV     EAX,ESP'
      '        CALL    _LStrClr'
      '        POP     EDI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     @@exit'
      ''
      '@@overflow:'
      '        JMP     _IntOver'
      ''
      '@@copyString:'
      '        MOV     EAX,EDX       // EAX := NewLength'
      '        CALL    _NewUnicodeString'
      '        MOV     EDI,EAX       // EDI "Temp" := new string'
      ''
      '        MOV     EAX,[EBX]     // EAX := S, also Source of Move'
      '        TEST    EAX,EAX       // nil?'
      '        JE      @@setString   // Assign straight away'
      ''
      
        '        MOV     EDX,EDI       // EDX := EDI "Temp", also Dest of' +
        ' Move'
      
        '        MOV     ECX,[EAX-skew].StrRec.length  // ECX := Length(S' +
        '), also Count of Move'
      '        CMP     ECX,ESI       // ECX "Length(S)" <> NewLength'
      '        JL      @@moveString  // ECX smaller => jump'
      '        MOV     ECX,ESI       // ECX := ESI'
      ''
      '@@moveString:'
      
        '        SHL     ECX,1         // Length widechars to bytes trans' +
        'lation'
      '        CALL    Move          // Move ECX chars from EAX to EDX'
      ''
      '@@setString:'
      '        MOV     EAX,EBX       // EAX := @S'
      '        CALL    _LStrClr      // clear S'
      '        MOV     [EBX],EDI     // S := Temp'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrCat(var Dest: UnicodeString; const Source: Unicod' +
        'eString);'
      '{$IFDEF PUREPASCAL}'
      'const'
      '  First = Cardinal(Low(string));'
      'var'
      '  L1, L2, Len: Cardinal;'
      '  Temp: PWideChar;'
      'begin'
      '  if Pointer(Source) <> nil then'
      '  begin'
      '    if Pointer(Dest) = nil then'
      '      _UStrAsg(Dest, Source)'
      '    else'
      '    begin'
      '      L1 := __StringLength(Dest);'
      '      L2 := __StringLength(Source);'
      '      Len := L1 + L2;'
      '      if (Len and $C0000000) <> 0 then _IntOver;'
      '      Temp := @Dest[First];'
      '      _UStrSetLength(Dest, Len);'
      '      if Temp = @Source[First] then'
      '        Temp := @Dest[First]'
      '      else'
      '        Temp := @Source[First];'
      '      Move(Temp^, Dest[L1+First], L2 * SizeOf(WideChar));'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '        { ->    EAX     pointer to dest }'
      '        {       EDX     source          }'
      ''
      '        TEST    EDX,EDX       // Source empty, nop.'
      '        JE      @@exit'
      ''
      '        MOV     ECX,[EAX]     // ECX := Dest'
      '        TEST    ECX,ECX       // Nil source => assignment'
      '        JE      _UStrAsg'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        MOV     EBX,EAX         // EBX := @Dest'
      '        MOV     ESI,EDX         // ESI := Source'
      
        '        MOV     EDI,[ECX-skew].StrRec.length  // EDI := Length(D' +
        'est)'
      ''
      
        '        MOV     EDX,[ESI-skew].StrRec.length  // EDX := Length(S' +
        'ource)'
      
        '        ADD     EDX,EDI         // EDX := (Length(Source) + Leng' +
        'th(Dest)) * 2'
      '        TEST    EDX,$C0000000'
      '        JNZ     @@lengthOverflow'
      '        CMP     ESI,ECX'
      '        JE      @@appendSelf'
      ''
      '        CALL    _UStrSetLength  // Set length of Dest'
      '        MOV     EAX,ESI         // EAX := Source'
      
        '        MOV     ECX,[ESI-skew].StrRec.length // ECX := Length(So' +
        'urce)'
      ''
      '@@appendStr:'
      '        MOV     EDX,[EBX]       // EDX := Dest'
      
        '        SHL     EDI,1           // EDI to bytes (Length(Dest) * ' +
        '2)'
      
        '        ADD     EDX,EDI         // Offset EDX for destination of' +
        ' move'
      
        '        SHL     ECX,1           // convert Length(Source) to byt' +
        'es'
      
        '        CALL    Move            // Move(Source, Dest + Length(De' +
        'st)*2, Length(Source)*2)'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        RET'
      ''
      '@@appendSelf:'
      '        CALL    _UStrSetLength'
      '        MOV     EAX,[EBX]'
      '        MOV     ECX,EDI'
      '        JMP     @@appendStr'
      ''
      '@@lengthOverflow:'
      '        JMP     _IntOver'
      ''
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrCat3(var Dest: UnicodeString; const Source1, Sour' +
        'ce2: UnicodeString);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Temp: Pointer;'
      '  L1, L2, Len: Cardinal;'
      'begin'
      '  if Pointer(Source1) = nil then'
      '    _UStrAsg(Dest, Source2)'
      '  else if Pointer(Source2) = nil then'
      '    _UStrAsg(Dest, Source1)'
      '  else'
      '  begin'
      '    if Pointer(Dest) = Pointer(Source1) then'
      '      _UStrCat(Dest, Source2)'
      '    else if Pointer(Dest) = Pointer(Source2) then'
      '    begin'
      '      L1 := __StringLength(Source1);'
      '      L2 := __StringLength(Source2);'
      '      Len := L1 + L2;'
      
        '      if (((L1 and L2) or ((not Len) and (L1 or L2))) and $80000' +
        '000) <> 0 then _IntOver;'
      '      Temp := _NewUnicodeString(Len);'
      
        '      Move(PWideChar(Source1)^, PWideChar(Temp)[0], L1 * SizeOf(' +
        'WideChar));'
      
        '      Move(PWideChar(Source2)^, PWideChar(Temp)[L1], L2 * SizeOf' +
        '(WideChar));'
      '      _UStrClr(Dest);'
      '      Pointer(Dest) := Temp;'
      '    end'
      '    else'
      '    begin'
      '      _UStrAsg(Dest, Source1);'
      '      _UStrCat(Dest, Source2);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      '        {     ->EAX = Pointer to dest   }'
      '        {       EDX = source1           }'
      '        {       ECX = source2           }'
      ''
      '        TEST    EDX,EDX'
      '        JE      @@assignSource2'
      ''
      '        TEST    ECX,ECX'
      '        JE      _UStrAsg'
      ''
      '        CMP     EDX,[EAX]'
      '        JE      @@appendToDest'
      ''
      '        CMP     ECX,[EAX]'
      '        JE      @@theHardWay'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        CALL    _UStrAsg'
      ''
      '        POP     EDX'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     _UStrCat'
      ''
      '@@theHardWay: // s(*EAX,ECX) := source1(EDX) + s(ECX)'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EBX,EDX         // EBX := source1'
      '        MOV     ESI,ECX         // ESI := source2'
      '        PUSH    EAX             // Push(@s)'
      ''
      '        MOV     EAX,[EBX-skew].StrRec.length'
      '        ADD     EAX,[ESI-skew].StrRec.length'
      ''
      
        '        TEST    EAX,$C0000000   // either of top two bits set =>' +
        ' overflow for size'
      '        JNZ     @@overflow'
      
        '        CALL    _NewUnicodeString   // EAX := new string ("resul' +
        't")'
      ''
      '        MOV     EDI,EAX         // EDI := result'
      ''
      '        MOV     EDX,EDI         // EDX := result'
      '        MOV     EAX,EBX         // EAX := source1'
      
        '        MOV     ECX,[EBX-skew].StrRec.length // ECX := Length(so' +
        'urce1)'
      '        SHL     ECX,1           // double ECX for bytes'
      
        '        CALL    Move            // Move(source1, result, Length(' +
        'source1)*2)'
      ''
      '        MOV     EAX,ESI         // EAX := source2'
      
        '        MOV     ECX,[ESI-skew].StrRec.length // ECX := Length(so' +
        'urce2)'
      '        SHL     ECX,1           // ECX => to bytes'
      
        '        MOV     EDX,[EBX-skew].StrRec.length // EDX := Length(so' +
        'urce1)'
      '        SHL     EDX,1           // EDX => to bytes'
      
        '        ADD     EDX,EDI         // EDX := result + (num bytes in' +
        ' source1)'
      
        '        CALL    Move            // Move(source2, result+offset, ' +
        'Length(source2)*2)'
      ''
      '        POP     EAX             // EAX := Pop() // @s'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP,12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EDX,EDI         // EDX := result'
      '        TEST    EDI,EDI'
      
        '        JE      @@skip          // result is nil? => don'#39't decre' +
        'ment'
      
        '        DEC     [EDI-skew].StrRec.refCnt    // EDI = local temp ' +
        'str; _UStrAsg will addref, so ensure final refCnt = 1'
      '@@skip:'
      '        CALL    _UStrAsg'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      ''
      '        JMP     @@exit'
      ''
      '@@assignSource2:'
      '        MOV     EDX,ECX'
      '        JMP     _UStrAsg'
      ''
      '@@appendToDest:'
      '        MOV     EDX,ECX'
      '        JMP     _UStrCat'
      ''
      '@@overflow:'
      '        JMP     _IntOver'
      ''
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _UStrCatN(var Dest: UnicodeString; ArgCnt: Integer); c' +
        'decl; varargs;'
      'var'
      '  VAList: TVarArgList;'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  Buf: PPointerArray;'
      '  ArgIndex: Integer;'
      '  {$ENDIF}'
      'begin'
      '  VarArgStart(VAList);'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  GetMem(Buf, ArgCnt * SizeOf(Pointer));'
      '  for ArgIndex := 0 to ArgCnt - 1 do'
      '    Buf[ArgIndex] := VarArgGetValue(VAList, Pointer);'
      '  InternalUStrCatN(Dest, ArgCnt, PUnicodeString(Buf));'
      '  FreeMem(Buf);'
      '  {$ELSE}'
      '  InternalUStrCatN(Dest, ArgCnt, PUnicodeString(VAList));'
      '  {$ENDIF}'
      '  VarArgEnd(VAList);'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        'procedure _UStrCatN{var dest:UnicodeString; argCnt: Integer; ...' +
        '};'
      'asm //StackAlignSafe'
      '        {     ->EAX = Pointer to dest           }'
      '        {       EDX = number of args (>= 3)     }'
      
        '        {       [ESP+4], [ESP+8], ... argCnt UnicodeString argum' +
        'ents, reverse order }'
      ''
      '        SUB     ESP,4                       // Stack - xxxxxxx8'
      '        PUSH    EBX                         // Stack - xxxxxxx4'
      '        PUSH    ESI                         // Stack - xxxxxxx0'
      '        PUSH    EDI                         // Stack - xxxxxxxc'
      '        PUSH    EDX                         // Stack - xxxxxxx8'
      '        PUSH    EAX                         // Stack - xxxxxxx4'
      
        '        PUSH    0                           // Stack - xxxxxxx0 ' +
        '- Local Temp'
      '        MOV     EBX,EDX'
      ''
      '        XOR     EDI,EDI'
      '        MOV     ECX,[ESP+EDX*4+7*4] // first arg is furthest out'
      '        TEST    ECX,ECX'
      '        JZ      @@0'
      '        CMP     [EAX],ECX          // is dest = first arg?'
      '        JNE     @@0'
      
        '        MOV     EDI,ECX            // EDI nonzero -> potential a' +
        'ppendstr case'
      
        '        MOV     EAX,[ECX-skew].StrRec.length  // EAX accumulates' +
        ' final length during @@loop1'
      '        DEC     EDX'
      '        JMP     @@loop1'
      '@@0:'
      '        XOR     EAX,EAX'
      '@@loop1:'
      '        MOV     ECX,[ESP+EDX*4+7*4]'
      '        TEST    ECX,ECX'
      '        JE      @@1'
      '        ADD     EAX,[ECX-skew].StrRec.length'
      '        TEST    EAX,$C0000000'
      '        JNZ     @@overflow'
      '        CMP     EDI,ECX          // is dest an arg besides arg1?'
      '        JNE     @@1'
      
        '        XOR     EDI,EDI          // can'#39't appendstr - dest is mu' +
        'ltiple args'
      '@@1:'
      '        DEC     EDX'
      '        JNE     @@loop1'
      ''
      '@@append:'
      
        '        TEST    EDI,EDI          // dest is 1st and only 1st arg' +
        '?'
      '        JZ      @@copy'
      '        MOV     EDX,EAX          // length into EDX'
      '        MOV     EAX,[ESP + 4]    // ptr to str into EAX'
      
        '        MOV     ESI,[EDI-skew].StrRec.Length  // save old size b' +
        'efore realloc'
      '        CALL    _UStrSetLength'
      '        MOV     EDI,[ESP + 4]    // append other strs to dest'
      '        MOV     EAX,[EDI]'
      '        MOV     [ESP],EAX'
      
        '        SHL     ESI,1            // Length to bytes for offset i' +
        'nto string'
      '        ADD     ESI,[EDI]        // ESI = end of old string'
      '        DEC     EBX'
      '        JMP     @@loop2'
      ''
      '@@copy:'
      '        CALL    _NewUnicodeString'
      '        MOV     [ESP],EAX'
      '        MOV     ESI,EAX'
      ''
      '@@loop2:'
      '        // Loop invariants:'
      '        // - ESI is target of move, going through final dest'
      '        // - EBX is arg index in stack to get arguments;'
      
        '        //   last argument pushed last => lowest address => addr' +
        'esses decrease from first to last'
      '        MOV     EAX,[ESP+EBX*4+7*4]     // EAX := argN'
      '        MOV     EDX,ESI                 // EDX := dest'
      '        TEST    EAX,EAX                 // argN nil?'
      '        JE      @@2                     // => skip'
      
        '        MOV     ECX,[EAX-skew].StrRec.length    // ECX := Length' +
        '(argN)'
      '        SHL     ECX,1                   // ECX to bytes'
      
        '        ADD     ESI,ECX                 // ESI (running target o' +
        'f move) += ECX'
      
        '        CALL    Move                    // Move(argN, dest, Leng' +
        'th(argN) * 2)'
      '@@2:'
      '        DEC     EBX'
      '        JNE     @@loop2'
      ''
      '        MOV     EDX,[ESP]'
      '        MOV     EAX,[ESP + 4]'
      '        TEST    EDI,EDI'
      '        JNZ     @@exit'
      ''
      '        TEST    EDX,EDX'
      '        JE      @@skip'
      
        '        DEC     [EDX-skew].StrRec.refCnt   // EDX = local temp s' +
        'tr'
      '@@skip:'
      '        CALL    _UStrAsg'
      ''
      '@@exit:'
      
        '        ADD     ESP,8                     // Stack - xxxxxxx8 - ' +
        'Clean Local Temp & Saved EAX'
      '        POP     EDX                       // Stack - xxxxxxxc'
      '        POP     EDI                       // Stack - xxxxxxx0'
      '        POP     ESI                       // Stack - xxxxxxx4'
      '        POP     EBX                       // Stack - xxxxxxx8'
      '        POP     EAX                       // Stack - xxxxxxxc'
      '        POP     EAX // ret address from CALL Stack - xxxxxxx0'
      '        LEA     ESP,[ESP+EDX*4]'
      
        '        JMP     EAX // Unbalanced CALL/RET means clobbered branc' +
        'h prediction.'
      
        '                    // Should fix codegen and have caller pop ar' +
        'guments, like cdecl.'
      ''
      '@@overflow:'
      '        JMP     _IntOver'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _UStrCmp(const Left, Right: UnicodeString): Integer;'
      'label'
      '  BothStringsNonNil, FoundMismatch;'
      'var'
      '  LPtr, RPtr: PByte;'
      '  i: NativeInt;'
      'begin'
      '  LPtr := Pointer(Left);'
      '  RPtr := Pointer(Right);'
      '  if LPtr <> RPtr then'
      '  begin'
      '    if NativeUInt(LPtr) and NativeUInt(RPtr) <> 0 then'
      '    begin'
      'BothStringsNonNil:'
      '      i := 0;'
      '      if PInteger(@LPtr[0])^ <> PInteger(@RPtr[0])^ then'
      '        goto FoundMismatch;'
      '      Result := __StringLength(LPtr) - __StringLength(RPtr);'
      '      // set i to -Min(Length(Left), Length(Right) * 2'
      
        '      i := (((Result shr 31 - 1) and Result) - __StringLength(LP' +
        'tr)) * 2;'
      '      LPtr := LPtr - i;'
      '      RPtr := RPtr - i;'
      '      repeat'
      '        Inc(i, 4);'
      '        if i >= 0 then Exit;'
      '        if PInteger(@LPtr[i])^ <> PInteger(@RPtr[i])^ then'
      '        begin'
      'FoundMismatch:'
      
        '          Result := Ord(PChar(@LPtr[i])^) - Ord(PChar(@RPtr[i])^' +
        ');'
      '          if Result = 0 then'
      
        '            Result := Ord(PChar(@LPtr[i+2])^) - Ord(PChar(@RPtr[' +
        'i+2])^);'
      '          Exit;'
      '        end;'
      '      until False;'
      '    end'
      '    else if LPtr = nil then'
      '      Result := -__StringLength(RPtr)'
      '    else if RPtr = nil then'
      '      Result := __StringLength(LPtr)'
      '    else'
      '      goto BothStringsNonNil;'
      '  end'
      '  else'
      '    Result := 0;'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        '{Original code by Pierre le Riche. Licensed under the CodeGear l' +
        'icense terms.}'
      'procedure _UStrCmp{const Left, Right: UnicodeString};'
      'asm'
      '  {On entry:'
      '     eax = @Left[1]'
      '     edx = @Right[1]'
      '   On exit:'
      '     Result in flags:'
      '       CF = 1 if Left < Right, CF = 0 otherwise'
      '       ZF = 1 if Left = Right, ZF = 0 otherwise}'
      ''
      
        '        CMP     EAX, EDX // Do Left and Right point to the same ' +
        'string data?'
      '        JE      @DoneNoPop'
      ''
      
        '        TEST    EAX, EDX // Is one of the two string pointers pe' +
        'rhaps nil?'
      '        JZ      @PossibleNilString'
      '@BothStringsNonNil:'
      
        '  {Compare the first two characters. (There has to be a trailing' +
        ' #0, and non-nil'
      
        '   UnicodeStrings must contain at least one other character so t' +
        'his comparison'
      
        '   is safe). In "random" string compares this can save significa' +
        'nt CPU time.}'
      '        MOV     ECX, [EAX]'
      '        CMP     ECX, [EDX]'
      '        JNE @InitialMismatch'
      ''
      '        PUSH    EBX             // Save ebx'
      '        MOV     EBX, [EAX - 4]  // set ebx = Length(Left)'
      '        XOR     ECX, ECX'
      
        '        SUB     EBX, [EDX - 4]  // set ebx = Length(Left) - Leng' +
        'th(Right)'
      
        '        PUSH    EBX             // Save the length difference on' +
        ' the stack'
      ''
      
        '        ADC     ECX, -1  // set ecx = 0 if Length(Left) < Length' +
        '(Right), $ffffffff otherwise'
      
        '        AND     ECX, EBX // set ecx = - min(length(Left), Length' +
        '(Right))'
      '        SUB     ECX, [EAX - 4]'
      ''
      '        ADD     ECX, ECX        // Two bytes per character'
      ''
      '        SUB     EAX, ECX        // Adjust the pointers to be'
      '        SUB     EDX, ECX        // negative offset based'
      ''
      '@CompareLoop:'
      '        ADD     ECX, 4          // Next four bytes'
      '        JNS     @MatchUpToLength'
      
        '        {Compare four bytes (two characters) per cycle. This com' +
        'pare may include the'
      
        '         trailing #0 for uneven string lengths, in which case no' +
        ' harm is done.}'
      '        MOV     EBX, [EAX + ECX]'
      '        CMP     EBX, [EDX + ECX]'
      '        JE      @CompareLoop'
      
        '        {Found a mismatch: Swap the two characters into the corr' +
        'ect order}'
      '        MOV     EDX, [EDX + ECX]'
      '        ROR     EBX, 16'
      '        ROR     EDX, 16'
      ''
      
        '        CMP     EBX, EDX  // Compare the characters again, setti' +
        'ng the flags'
      
        '        POP     EBX       // Pop the length difference, restore ' +
        'ebx and return'
      '        POP     EBX'
      '        RET'
      '        {All characters match up to the compare length}'
      '@MatchUpToLength:'
      
        '        POP     EAX       // Restore the string length differenc' +
        'e to eax'
      ''
      
        '        ADD     EAX, EAX  // Set the flags according to the leng' +
        'th difference'
      '        POP     EBX       // Restore ebx and return'
      '@DoneNoPop:'
      '        RET'
      '@InitialMismatch:'
      
        '        MOV     EDX, [EDX]  // Swap the two characters into the ' +
        'correct order'
      '        ROR     ECX, 16'
      '        ROR     EDX, 16'
      
        '        CMP     ECX, EDX    // Compare them again so the flags a' +
        're set correctly'
      '        RET'
      '@PossibleNilString:'
      
        '        {There is a good probability that one of the strings are' +
        ' nil (but not both)}'
      '        TEST    EAX, EAX'
      '        JZ      @StringNil'
      '        TEST    EDX, EDX'
      '        JNZ     @BothStringsNonNil'
      '@StringNil:'
      
        '        CMP     EAX, EDX  // One of the strings are nil, so comp' +
        'are pointers'
      '        RET'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'function _UStrEqual(const Left, Right: UnicodeString): Integer;'
      'label'
      '  BothStringsNonNil, FoundMismatch;'
      'var'
      '  LPtr, RPtr: PByte;'
      '  i: NativeInt;'
      'begin'
      '  LPtr := Pointer(Left);'
      '  RPtr := Pointer(Right);'
      '  if LPtr <> RPtr then'
      '  begin'
      '    if NativeUInt(LPtr) and NativeUInt(RPtr) <> 0 then'
      '    begin'
      'BothStringsNonNil:'
      '      Result := __StringLength(LPtr);'
      '      if Result <> __StringLength(RPtr) then'
      '        goto FoundMismatch;'
      '      i := Result * -2;'
      '      LPtr := LPtr - i;'
      '      RPtr := RPtr - i;'
      '      repeat'
      '        if PInteger(@LPtr[i])^ <> PInteger(@RPtr[i])^ then'
      '          goto FoundMismatch;'
      '        Inc(i, 4);'
      '      until i >= 0;'
      '    end'
      '    else if (LPtr <> nil) and (RPtr <> nil) then'
      '      goto BothStringsNonNil'
      '    else'
      'FoundMismatch:'
      '      Exit(-1);'
      '  end;'
      '  Result := 0;'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        '{Original code by Pierre le Riche. Licensed under the CodeGear l' +
        'icense terms.}'
      'procedure _UStrEqual{const Left, Right: UnicodeString};'
      'asm'
      '  {On entry:'
      '     eax = @Left[1]'
      '     edx = @Right[1],'
      '   On exit:'
      '     ZF = 1 if Left = Right'
      '     ZF = 0 if Left <> Right}'
      ''
      '        CMP     EAX, EDX  // Same string?'
      '        JE      @DoneNoPop'
      ''
      '        TEST    EAX, EDX  // Any of the two possibly nil?'
      '        JZ      @PossibleNilString'
      '@BothStringsNonNil:'
      ''
      
        '        MOV     ECX, [EAX - skew].StrRec.length // Get the strin' +
        'g length'
      
        '        CMP     ECX, [EDX - skew].StrRec.length // Are the strin' +
        'g lengths the same?'
      '        JNE     @DoneNoPop'
      '        ADD     ECX, ECX    // Two bytes per character'
      
        '        ADD     EAX, ECX    // Point eax and edx to just past th' +
        'e last character'
      '        ADD     EDX, ECX'
      '        NEG     ECX         // Make the counter negative based'
      ''
      '        PUSH    EBX         // Save ebx'
      '@CompareLoop:'
      
        '        MOV     EBX, [EAX + ECX] // Compare four bytes per itera' +
        'tion'
      '        CMP     EBX, [EDX + ECX]'
      '        JNE     @Mismatch'
      ''
      '        ADD     ECX, 4      // Next two characters'
      '        JS      @CompareLoop'
      '        XOR     EAX, EAX    // Match: Set the ZF'
      '@Mismatch:'
      '        POP     EBX         // Restore ebx'
      ''
      '        RET'
      '@PossibleNilString:'
      
        '        {There is a good probability that one of the strings are' +
        ' nil (but not both)}'
      '        TEST    EAX, EAX'
      '        JZ      @StringNil'
      '        TEST    EDX, EDX'
      '        JNZ     @BothStringsNonNil'
      '@StringNil:'
      '        {One of the strings are nil. Clear the ZF.}'
      '        CMP     EAX, EDX'
      '@DoneNoPop:'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      
        'function _UStrCopy(const S: UnicodeString; Index, Count: Integer' +
        '): UnicodeString;'
      'var'
      '  L, N: Integer;'
      'begin'
      '  L := Length(S);'
      '  if Index < 1 then'
      '    Index := 0'
      '  else'
      '  begin'
      '    Dec(Index);'
      '    if Index > L then'
      '      Index := L;'
      '  end;'
      '  if Count < 0 then'
      '    N := 0'
      '  else'
      '  begin'
      '    N := L - Index;'
      '    if N > Count then'
      '      N := Count;'
      '  end;'
      '  _UStrFromPWCharLen(Result, PWideChar(Pointer(S)) + Index, N);'
      'end;'
      ''
      '                                                 '
      'procedure UStrSet(var S: UnicodeString; P: PWideChar);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  Temp: Pointer;'
      'begin'
      '  Temp := AtomicExchange(Pointer(S), Pointer(P));'
      '  if Temp <> nil then'
      '    _UStrClr(Temp);'
      'end;'
      '{$ELSE}'
      '{$IFDEF CPUX86}'
      'asm'
      '        XCHG    [EAX],EDX'
      '        TEST    EDX,EDX'
      '        JZ      @@1'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX'
      '        MOV     EAX,ESP'
      '        CALL    _UStrClr'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '@@1:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _UStrDelete(var S: UnicodeString; Index, Count: Intege' +
        'r);'
      'var'
      '  L, N: Integer;'
      'begin'
      '  InternalUniqueStringU(S);'
      '  L := Length(S);'
      '  if (Index >= 1) and (Index <= L) and (Count > 0) then'
      '  begin'
      '    Dec(Index);'
      '    N := L - Index - Count;'
      '    if N < 0 then'
      '      N := 0;'
      
        '    Move(PWideChar(Pointer(S))[L - N], PWideChar(Pointer(S))[Ind' +
        'ex], N * 2);'
      '    SetLength(S, Index + N);'
      '  end;'
      'end;'
      ''
      
        'procedure _UStrInsert(const Source: UnicodeString; var Dest: Uni' +
        'codeString; Index: Integer);'
      'var'
      '  SourceLen, DestLen, NewLen: Integer;'
      '  SelfInsert: Boolean;'
      'begin'
      '  SourceLen := Length(Source);'
      '  if SourceLen > 0 then'
      '  begin'
      '    DestLen := Length(Dest);'
      '    if Index < 1 then Index := 0 else'
      '    begin'
      '      Dec(Index);'
      '      if Index > DestLen then Index := DestLen;'
      '    end;'
      '    SelfInsert := (Pointer(Source) = Pointer(Dest));'
      '    NewLen := DestLen + SourceLen;'
      '    if NewLen < 0 then   // overflow check'
      '      _IntOver;'
      '    SetLength(Dest, NewLen);'
      '    if Index < DestLen then'
      
        '      Move(PWideChar(Pointer(Dest))[Index], PWideChar(Pointer(De' +
        'st))[Index + SourceLen],'
      '        (DestLen - Index) * 2);'
      '    if SelfInsert then'
      
        '      Move(Pointer(Dest)^, PWideChar(Pointer(Dest))[Index], Sour' +
        'ceLen * 2)'
      '    else'
      
        '      Move(Pointer(Source)^, PWideChar(Pointer(Dest))[Index], So' +
        'urceLen * 2);'
      '  end;'
      'end;'
      ''
      '{ ----------------------------------------------------- }'
      '{       string utilities                                }'
      '{ ----------------------------------------------------- }'
      ''
      
        'function Pos(const SubStr, Str: _ShortStr; Offset: Integer): Int' +
        'eger;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I, LIterCnt, L, J: Integer;'
      '  PSubStr, PS: _PAnsiChr;'
      'begin'
      '  L := _PStrLen(SubStr);'
      
        '  { Calculate the number of possible iterations. Not valid if Of' +
        'fset < 1. }'
      '  LIterCnt := _PStrLen(Str) - Offset - L + 1;'
      ''
      
        '  { Only continue if the number of iterations is positive or zer' +
        'o (there is space to check) }'
      '  if (Offset > 0) and (LIterCnt >= 0) and (L > 0) then'
      '  begin'
      '    PSubStr := @SubStr[1];'
      '    PS := @Str[1];'
      '    Inc(PS, Offset - 1);'
      ''
      '    for I := 0 to LIterCnt do'
      '    begin'
      '      J := 0;'
      '      while (J >= 0) and (J < L) do'
      '      begin'
      '        if PS[I + J] = PSubStr[J] then'
      '          Inc(J)'
      '        else'
      '          J := -1;'
      '      end;'
      '      if J >= L then'
      '        Exit(I + Offset);'
      '    end;'
      '  end;'
      ''
      '  Result := 0;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      '(* ***** BEGIN LICENSE BLOCK *****'
      ' *'
      
        ' * The function PosEx is licensed under the CodeGear license ter' +
        'ms.'
      ' *'
      ' * The initial developer of the original code is Fastcode'
      ' *'
      
        ' * Portions created by the initial developer are Copyright (C) 2' +
        '002-2004'
      ' * the initial developer. All Rights Reserved.'
      ' *'
      ' * Contributor(s): Aleksandr Sharahov'
      ' *'
      ' * ***** END LICENSE BLOCK ***** *)'
      'asm'
      '       test  eax, eax'
      '       jz    @Nil'
      '       test  edx, edx'
      '       jz    @Nil'
      '       dec   ecx'
      '       jl    @Nil'
      ''
      '       push  esi'
      '       push  ebx'
      ''
      '       movzx   esi, byte ptr [edx]  //Length(Str)'
      '       movzx   ebx, byte ptr [eax]  //Length(Substr)'
      '       inc   edx'
      '       inc   eax'
      '       sub   esi, ecx      //effective length of Str'
      
        '       add   edx, ecx      //addr of the first AnsiChar at start' +
        'ing position'
      '       cmp   esi, ebx'
      
        '       jl    @Past         //jump if EffectiveLength(Str)<Length' +
        '(Substr)'
      '       test  ebx, ebx'
      '       jle   @Past         //jump if Length(Substr)<=0'
      ''
      '       add   esp, -12'
      '       add   ebx, -1       //Length(Substr)-1'
      '       add   esi, edx      //addr of the terminator'
      
        '       add   edx, ebx      //addr of the last AnsiChar at starti' +
        'ng position'
      '       mov   [esp+8], esi  //save addr of the terminator'
      '       add   eax, ebx      //addr of the last AnsiChar of Substr'
      '       sub   ecx, edx      //-@Str[Length(Substr)]'
      '       neg   ebx           //-(Length(Substr)-1)'
      '       mov   [esp+4], ecx  //save -@Str[Length(Substr)]'
      '       mov   [esp], ebx    //save -(Length(Substr)-1)'
      '       movzx ecx, byte ptr [eax] //the last AnsiChar of Substr'
      ''
      '@Loop:'
      '       cmp   cl, [edx]'
      '       jz    @Test0'
      '@AfterTest0:'
      '       cmp   cl, [edx+1]'
      '       jz    @TestT'
      '@AfterTestT:'
      '       add   edx, 4'
      '       cmp   edx, [esp+8]'
      '       jb   @Continue'
      '@EndLoop:'
      '       add   edx, -2'
      '       cmp   edx, [esp+8]'
      '       jb    @Loop'
      '@Exit:'
      '       add   esp, 12'
      '@Past:'
      '       pop   ebx'
      '       pop   esi'
      '@Nil:'
      '       xor   eax, eax'
      '       ret'
      '@Continue:'
      '       cmp   cl, [edx-2]'
      '       jz    @Test2'
      '       cmp   cl, [edx-1]'
      '       jnz   @Loop'
      '@Test1:'
      '       add   edx,  1'
      '@Test2:'
      '       add   edx, -2'
      '@Test0:'
      '       add   edx, -1'
      '@TestT:'
      '       mov   esi, [esp]'
      '       test  esi, esi'
      '       jz    @Found'
      '@AnsiString:'
      '       movzx ebx, word ptr [esi+eax]'
      '       cmp   bx, word ptr [esi+edx+1]'
      '       jnz   @AfterTestT'
      '       cmp   esi, -2'
      '       jge   @Found'
      '       movzx ebx, word ptr [esi+eax+2]'
      '       cmp   bx, word ptr [esi+edx+3]'
      '       jnz   @AfterTestT'
      '       add   esi, 4'
      '       jl    @AnsiString'
      '@Found:'
      '       mov   eax, [esp+4]'
      '       add   edx, 2'
      ''
      '       cmp   edx, [esp+8]'
      '       ja    @Exit'
      ''
      '       add   esp, 12'
      '       add   eax, edx'
      '       pop   ebx'
      '       pop   esi'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '(* ***** BEGIN LICENSE BLOCK *****'
      ' *'
      
        ' * The function Pos is licensed under the CodeGear license terms' +
        '.'
      ' *'
      ' * The initial developer of the original code is Fastcode'
      ' *'
      
        ' * Portions created by the initial developer are Copyright (C) 2' +
        '002-2004'
      ' * the initial developer. All Rights Reserved.'
      ' *'
      ' * Contributor(s):'
      ' * Aleksandr Sharahov'
      ' * Stefan Glienke'
      ' *'
      ' * ***** END LICENSE BLOCK ***** *)'
      
        'function _UStrPos(SubStr, Str: PWideChar; Offset: Integer): Inte' +
        'ger;'
      '{$POINTERMATH ON}'
      'var'
      '  len, lenSub: NativeInt;'
      '  ch: WideChar;'
      '  Start, Stop: PWideChar;'
      'label'
      '  Loop0,'
      '  TestT, Test0, Test1, Test2, Test3, Test4,'
      '  AfterTestT, AfterTest0,'
      '  Ret, Exit0;'
      'begin;'
      '  if (Str = nil) or (SubStr = nil) or (Offset < 1) then'
      '    goto Exit0;'
      ''
      '  // fast access to length - did the nil check already'
      '  lenSub := PInteger(SubStr)[-1];'
      '  Dec(lenSub);'
      '  len := PInteger(Str)[-1];'
      '  if (len < lenSub + Offset) then'
      '    goto Exit0;'
      ''
      '  Stop := @Str[len];'
      '  Str := @Str[lenSub];'
      '  SubStr := @SubStr[lenSub];'
      '  Start := Str;'
      '  Str := @Str[Offset + 3];'
      ''
      '  ch := SubStr[0];'
      '  lenSub := -lenSub;'
      ''
      '  while Str < Stop do'
      '  begin'
      '    if ch = Str[-4] then'
      '      goto Test4;'
      '    if ch = Str[-3] then'
      '      goto Test3;'
      '    if ch = Str[-2] then'
      '      goto Test2;'
      '    if ch = Str[-1] then'
      '      goto Test1;'
      'Loop0:'
      '    if ch = Str[0] then'
      '      goto Test0;'
      'AfterTest0:'
      '    if ch = Str[1] then'
      '      goto TestT;'
      'AfterTestT:'
      '    Str := Str + 6;'
      '  end;'
      '  Str := Str - 4;'
      '  if Str < Stop then'
      '    goto Loop0;'
      '  goto Exit0;'
      ''
      'Test3:'
      '  Str := Str - 2;'
      'Test1:'
      '  Str := Str - 2;'
      'TestT:'
      '  len := lenSub;'
      '  while len < 0 do'
      '  begin'
      '    if PInteger(@SubStr[len])^ <> PInteger(@Str[len + 1])^ then'
      '      goto AfterTestT;'
      '    len := len + 2;'
      '  end;'
      '  Str := Str + 2;'
      '  if Str <= Stop then'
      '    goto Ret;'
      '  goto Exit0;'
      ''
      'Test4:'
      '  Str := Str - 2;'
      'Test2:'
      '  Str := Str - 2;'
      'Test0:'
      '  len := lenSub;'
      '  while len < 0 do'
      '  begin'
      '    if PInteger(@SubStr[len])^ <> PInteger(@Str[len])^ then'
      '      goto AfterTest0;'
      '    len := len + 2;'
      '  end;'
      '  Inc(Str);'
      ''
      'Ret:'
      '  Exit((NativeInt(Str) - NativeInt(Start)) shr 1);'
      'Exit0:'
      '  Result := 0;'
      '{$POINTERMATH OFF}'
      'end;'
      ''
      '{$IFDEF MSWINDOWS}'
      
        'function _WStrPos(SubStr, Str: PWideChar; Offset: Integer): Inte' +
        'ger;'
      '{$POINTERMATH ON}'
      'var'
      '  len, lenSub: NativeInt;'
      '  ch: WideChar;'
      '  Start, Stop: PWideChar;'
      'label'
      '  Loop0,'
      '  TestT, Test0, Test1, Test2, Test3, Test4,'
      '  AfterTestT, AfterTest0,'
      '  Ret, Exit0;'
      'begin;'
      '  if (Str = nil) or (SubStr = nil) or (Offset < 1) then'
      '    goto Exit0;'
      ''
      '  // fast access to length - did the nil check already'
      '  lenSub := PInteger(SubStr)[-1] shr 1;'
      '  Dec(lenSub);'
      '  len := PInteger(Str)[-1] shr 1;'
      '  if (len < lenSub + Offset) then'
      '    goto Exit0;'
      ''
      '  Stop := @Str[len];'
      '  Str := @Str[lenSub];'
      '  SubStr := @SubStr[lenSub];'
      '  Start := Str;'
      '  Str := @Str[Offset + 3];'
      ''
      '  ch := SubStr[0];'
      '  lenSub := -lenSub;'
      ''
      '  while Str < Stop do'
      '  begin'
      '    if ch = Str[-4] then'
      '      goto Test4;'
      '    if ch = Str[-3] then'
      '      goto Test3;'
      '    if ch = Str[-2] then'
      '      goto Test2;'
      '    if ch = Str[-1] then'
      '      goto Test1;'
      'Loop0:'
      '    if ch = Str[0] then'
      '      goto Test0;'
      'AfterTest0:'
      '    if ch = Str[1] then'
      '      goto TestT;'
      'AfterTestT:'
      '    Str := Str + 6;'
      '  end;'
      '  Str := Str - 4;'
      '  if Str < Stop then'
      '    goto Loop0;'
      '  goto Exit0;'
      ''
      'Test3:'
      '  Str := Str - 2;'
      'Test1:'
      '  Str := Str - 2;'
      'TestT:'
      '  len := lenSub;'
      '  while len < 0 do'
      '  begin'
      '    if PInteger(@SubStr[len])^ <> PInteger(@Str[len + 1])^ then'
      '      goto AfterTestT;'
      '    len := len + 2;'
      '  end;'
      '  Str := Str + 2;'
      '  if Str <= Stop then'
      '    goto Ret;'
      '  goto Exit0;'
      ''
      'Test4:'
      '  Str := Str - 2;'
      'Test2:'
      '  Str := Str - 2;'
      'Test0:'
      '  len := lenSub;'
      '  while len < 0 do'
      '  begin'
      '    if PInteger(@SubStr[len])^ <> PInteger(@Str[len])^ then'
      '      goto AfterTest0;'
      '    len := len + 2;'
      '  end;'
      '  Inc(Str);'
      ''
      'Ret:'
      '  Exit((NativeInt(Str) - NativeInt(Start)) shr 1);'
      'Exit0:'
      '  Result := 0;'
      '{$POINTERMATH OFF}'
      'end;'
      '{$ENDIF MSWINDOWS}'
      ''
      
        'function _LStrPos(SubStr, Str: _PAnsiChr; Offset: Integer): Inte' +
        'ger;'
      '{$POINTERMATH ON}'
      'var'
      '  len, lenSub: NativeInt;'
      '  ch: AnsiChar;'
      '  Start, Stop: PAnsiChar;'
      'label'
      '  Loop0,'
      '  TestT, Test0, Test1, Test2, Test3, Test4,'
      '  AfterTestT, AfterTest0,'
      '  Ret, Exit0;'
      'begin;'
      '  if (Str = nil) or (SubStr = nil) or (Offset < 1) then'
      '    goto Exit0;'
      ''
      '  // fast access to length - did the nil check already'
      '  lenSub := PInteger(SubStr)[-1];'
      '  Dec(lenSub);'
      '  len := PInteger(Str)[-1];'
      '  if (len < lenSub + Offset) then'
      '    goto Exit0;'
      ''
      '  Stop := @Str[len];'
      '  Str := @Str[lenSub];'
      '  SubStr := @SubStr[lenSub];'
      '  Start := Str;'
      '  Str := @Str[Offset + 3];'
      ''
      '  ch := SubStr[0];'
      '  lenSub := -lenSub;'
      ''
      '  while Str < Stop do'
      '  begin'
      '    if ch = Str[-4] then'
      '      goto Test4;'
      '    if ch = Str[-3] then'
      '      goto Test3;'
      '    if ch = Str[-2] then'
      '      goto Test2;'
      '    if ch = Str[-1] then'
      '      goto Test1;'
      'Loop0:'
      '    if ch = Str[0] then'
      '      goto Test0;'
      'AfterTest0:'
      '    if ch = Str[1] then'
      '      goto TestT;'
      'AfterTestT:'
      '    Str := Str + 6;'
      '  end;'
      '  Str := Str - 4;'
      '  if Str < Stop then'
      '    goto Loop0;'
      '  goto Exit0;'
      ''
      'Test3:'
      '  Str := Str - 2;'
      'Test1:'
      '  Str := Str - 2;'
      'TestT:'
      '  len := lenSub;'
      '  while len < 0 do'
      '  begin'
      '    if PWord(@SubStr[len])^ <> PWord(@Str[len + 1])^ then'
      '      goto AfterTestT;'
      '    len := len + 2;'
      '  end;'
      '  Str := Str + 2;'
      '  if Str <= Stop then'
      '    goto Ret;'
      '  goto Exit0;'
      ''
      'Test4:'
      '  Str := Str - 2;'
      'Test2:'
      '  Str := Str - 2;'
      'Test0:'
      '  len := lenSub;'
      '  while len < 0 do'
      '  begin'
      '    if PWord(@SubStr[len])^ <> PWord(@Str[len])^ then'
      '      goto AfterTest0;'
      '    len := len + 2;'
      '  end;'
      '  Inc(Str);'
      ''
      'Ret:'
      '  Exit(Str - Start);'
      'Exit0:'
      '  Result := 0;'
      '{$POINTERMATH OFF}'
      'end;'
      ''
      
        'function StringOfChar(Ch: WideChar; Count: Integer): UnicodeStri' +
        'ng; overload;'
      'var'
      '  P: PWideChar;'
      'begin'
      '  _UStrFromPWCharLen(Result, nil, Count);'
      '  P := Pointer(Result);'
      '  while Count > 0 do'
      '  begin'
      '    Dec(Count);'
      '    P[Count] := Ch;'
      '  end;'
      'end;'
      ''
      
        'function StringOfChar(Ch: _AnsiChr; Count: Integer): _AnsiStr; o' +
        'verload;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _LStrClr(Result);'
      '  if Count > 0 then'
      '  begin'
      
        '    Pointer(Result) := _NewAnsiString(Count, DefaultSystemCodePa' +
        'ge);'
      '    _FillChar(Pointer(Result)^, Count, Ch);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAligned'
      '        { ->    AL      c               }'
      '        {       EDX     count           }'
      '        {       ECX     result          }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      ''
      '        MOV     EAX,ECX'
      '        CALL    _LStrClr'
      ''
      '        TEST    ESI,ESI'
      '        JLE     @@exit'
      ''
      '        MOV     EAX,ESI'
      '{$IFDEF PIC}'
      '        PUSH    EAX'
      '        PUSH    EBX'
      '        PUSH    ECX'
      '        CALL    GetGOT'
      '        MOV     EDX, [EAX].OFFSET DefaultSystemCodePage'
      '        MOV     EDX, [EDX]'
      '        POP     ECX'
      '        POP     EBX'
      '        POP     EAX'
      '{$ELSE}'
      '        MOV     EDX,DefaultSystemCodePage'
      '{$ENDIF}'
      '        CALL    _NewAnsiString'
      ''
      '        MOV     [EDI],EAX'
      ''
      '        MOV     EDX,ESI'
      '        MOV     CL,BL'
      ''
      '        CALL    _FillChar'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      ''
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure SetAnsiString(Dest: _PAnsiStr; Source: _PAnsiChr; Leng' +
        'th: Integer; CodePage: Word);'
      'begin'
      '  _LStrFromPCharLen(Dest^, Source, Length, CodePage);'
      'end;'
      ''
      
        'procedure SetAnsiString(Dest: _PAnsiStr; Source: PWideChar; Leng' +
        'th: Integer; CodePage: Word);'
      'begin'
      '  _LStrFromPWCharLen(Dest^, Source, Length, CodePage);'
      'end;'
      ''
      
        'procedure SetCodePage(var S: _RawByteStr; CodePage: Word; Conver' +
        't: Boolean);'
      'var'
      '  W: UnicodeString;'
      '  NewLen: Integer;'
      'begin'
      '  if (StringCodePage(S) = CodePage) or (Length(S) = 0) then'
      '    Exit;'
      '  if Convert then'
      '  begin'
      '    if StringElementSize(S) = 1 then'
      
        '      W := UnicodeString(S)  // This up-converts to Unicode utf-' +
        '16 using the existing codepage in the payload'
      '    else'
      
        '      W := UnicodeString(Pointer(S));  // Payload is already utf' +
        '-16 so just reference it'
      '    // now find out how large the resulting string will be'
      
        '    NewLen := CharFromWChar(nil, 0, PWideChar(W), Length(W), Cod' +
        'ePage);'
      '    SetLength(S, NewLen);'
      
        '    // finally actually convert the payload based on the new Cod' +
        'ePage'
      '    if NewLen > 0 then'
      
        '      CharFromWChar(_PAnsiChr(S), Length(S), PWideChar(W), Lengt' +
        'h(W), CodePage);'
      '  end'
      '  else'
      '    InternalUniqueStringA(_AnsiStr(S));'
      '  if Length(S) > 0 then'
      '    PWord(PByte(S) - 12)^ := CodePage;'
      'end;'
      ''
      
        'function UnicodeStringToUCS4String(const S: UnicodeString): UCS4' +
        'String;'
      'var'
      '  I: Integer;'
      '  CharCount: Integer;'
      'begin'
      '  CharCount := 0;'
      '  SetLength(Result, Length(S) + 1);'
      '  I := Low(string) - 1;'
      '  while I < High(S) do'
      '  begin'
      ''
      
        '    if ((S[I + 1] >= #$D800) and (S[I + 1] <= #$DFFF)) and (I + ' +
        '1 < Length(S)) then'
      '    begin'
      
        '      Result[CharCount] := UCS4Char((Cardinal(S[I + 1]) and $000' +
        '003FF) shl 10 or (Cardinal(S[I + 2]) and $000003FF) + $00010000)' +
        ';'
      '      Inc(I);'
      '    end'
      '    else'
      '      Result[CharCount] := UCS4Char(S[I + 1]);'
      ''
      '    Inc(CharCount);'
      '    Inc(I);'
      '  end;'
      '  Result[CharCount] := 0;'
      '  SetLength(Result, CharCount + 1);'
      'end;'
      ''
      
        'function UCS4StringToUnicodeString(const S: UCS4String): Unicode' +
        'String;'
      'var'
      '  I: Integer;'
      '  CharCount: Integer;'
      '  Tmp: array of Char;'
      'begin'
      
        '  SetLength(Tmp, Length(S) * 2 - 1); //Maximum possible number o' +
        'f characters'
      '  CharCount := -1;'
      ''
      '  I := 0;'
      '  while I < Length(S) - 1 do'
      '  begin'
      '    if S[I] >= $10000 then'
      '    begin'
      '      Inc(CharCount);'
      
        '      Tmp[CharCount] := WideChar((((S[I] - $00010000) shr 10) an' +
        'd $000003FF) or $D800);'
      '      Inc(CharCount);'
      
        '      Tmp[CharCount] := WideChar(((S[I] - $00010000) and $000003' +
        'FF)or $DC00);'
      '    end'
      '    else'
      '    begin'
      '      Inc(CharCount);'
      '      Tmp[CharCount] := WideChar(S[I]);'
      '    end;'
      ''
      '    Inc(I);'
      '  end;'
      ''
      '  SetString(Result, PChar(Tmp), CharCount + 1);'
      'end;'
      ''
      
        'function WideCharToUCS4String(S: PWideChar; Len: Integer = MaxIn' +
        't): UCS4String;'
      'var'
      '  Buffer: array[0..255] of UCS4Char;'
      '  Index: Integer;'
      ''
      
        '  procedure FlushBuffer(var Result: UCS4String; AddNull: Integer' +
        ');'
      '  begin'
      '    SetLength(Result, Length(Result) + Index + AddNull);'
      
        '    Move(Buffer, Result[Length(Result) - Index - AddNull], Index' +
        ' * SizeOf(UCS4Char));'
      '    if AddNull > 0 then'
      '      Result[Length(Result) - 1] := 0;'
      '    Index := 0;'
      '  end;'
      ''
      'begin'
      '  Index := 0;'
      '  while (S[0] <> #0) and (Len > 0) do'
      '  begin'
      
        '    if ((S[0] >= #$D800) and (S[0] <= #$DFFF)) and (Len > 0) and' +
        ' (S[1] <> #0) then'
      '    begin'
      
        '      Buffer[Index] := UCS4Char((Cardinal(S[0]) and $000003FF) s' +
        'hl 10 or (Cardinal(S[1]) and $000003FF) + $00010000);'
      '      Inc(S);'
      '    end'
      '    else'
      '      Buffer[Index] := UCS4Char(S[0]);'
      '    Inc(Index);'
      '    Inc(S);'
      '    Dec(Len);'
      '    if Index >= Length(Buffer) then'
      '      FlushBuffer(Result, 0);'
      '  end;'
      '  FlushBuffer(Result, 1);'
      'end;'
      ''
      
        '                                                                ' +
        '                                         '
      '//function UTF8Encode(const WS: UnicodeString): _UTF8Str;'
      '//function UTF8Decode(const S: _UTF8Str): UnicodeString;'
      ''
      ''
      
        '{ ------------------------------------------------------------- ' +
        '}'
      
        '{       Compiler helper for initializing/finalizing variable    ' +
        '}'
      
        '{ ------------------------------------------------------------- ' +
        '}'
      ''
      
        '{ ==============================================================' +
        '============='
      
        '  InitializeRecord, InitializeArray, and Initialize are PIC safe' +
        ' even though'
      
        '  they alter EBX because they only call each other.  They never ' +
        'call out to'
      '  other functions and they don'#39't access global data.'
      '  (Except TRecordInitializer call for managed record. However,'
      '  record initializer will have EBX fixup prologs)'
      ''
      
        '  FinalizeRecord, Finalize, and FinalizeArray are PIC safe becau' +
        'se they call'
      '  Pascal routines which will have EBX fixup prologs.'
      
        '  ==============================================================' +
        '=============}'
      'procedure _InitializeRecord(p: Pointer; typeInfo: Pointer);'
      
        '{$IF defined(PUREPASCAL) or defined(MANAGED_RECORD)} // _Initial' +
        'izeRecord'
      'var'
      '  FT, EFT: PFieldTable;'
      '  {$IFDEF MANAGED_RECORD}'
      '  ROps: PRecordOperatorTable;'
      '  N: NativeUInt;'
      '  {$IFDEF WEAKREF}'
      '  WeakMarker: NativeUInt;'
      '  {$ENDIF}'
      '  {$ENDIF}'
      '  I: NativeUInt;'
      '  FTypeInfo: PTypeInfo;'
      '  F: Pointer;'
      'begin'
      
        '  FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeInfo).N' +
        'ame[0]));'
      '  {$IFDEF MANAGED_RECORD}'
      '  ROps := PRecordOperatorTable(@FT.Fields[FT.Count]);'
      '  if PTypeInfo(typeInfo).Kind = tkMRecord then'
      '  begin'
      
        '    if (ROps^.Count > roiInitializer) and Assigned(ROps^.Initial' +
        'izer) then'
      '    begin'
      '      ROps^.Initializer(P);'
      '      Exit;'
      '    end;'
      '  end;'
      '  {$ENDIF}'
      '  if FT.Count > 0 then'
      '  begin'
      '    {$IFDEF MANAGED_RECORD}'
      '    N := 0;'
      '    {$IFDEF WEAKREF}'
      '    WeakMarker := 0;'
      
        '    if (ROps.Count > roiRecFlags) and (ROps.RecFlags and rofHasW' +
        'eakField <> 0) then'
      '    begin'
      '      for I := FT.Count - 1 downto 0 do'
      '        if FT.Fields[I].TypeInfo = nil then'
      '        begin'
      '          WeakMarker := I;'
      '          Break;'
      '        end;'
      '    end;'
      '    {$ENDIF}'
      '    try'
      '    {$ENDIF}'
      '      for I := 0 to FT.Count - 1 do'
      '      begin'
      '        {$IFDEF WEAKREF}'
      '        if FT.Fields[I].TypeInfo = nil then'
      '          Continue;'
      '        {$ENDIF}'
      '        {$IFDEF MANAGED_RECORD}'
      '        N := I;'
      '        {$ENDIF}'
      '        FTypeInfo := FT.Fields[I].TypeInfo^;'
      '        F := PByte(P) + FT.Fields[I].Offset;'
      ''
      '        case FTypeInfo.Kind of'
      '          {$IFDEF WEAKINSTREF}'
      '          tkMethod:'
      '            TMethod(F^) := Default(TMethod);'
      '          {$ENDIF}'
      '          {$IFDEF AUTOREFCOUNT}'
      '          tkClass,'
      '          {$ENDIF}'
      
        '          tkLString, tkWString, tkInterface, tkDynArray, tkUStri' +
        'ng:'
      '            PPointer(F)^ := nil;'
      '          tkVariant:'
      '            PVarData(F)^ := Default(TVarData);'
      '          tkArray:'
      '            begin'
      
        '              EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeIn' +
        'fo(FTypeInfo).Name[0]));'
      
        '              _InitializeArray(F, EFT.Fields[0].TypeInfo^, EFT.C' +
        'ount);'
      '            end;'
      '          {$IFDEF MANAGED_RECORD}'
      '          tkMRecord,'
      '          {$ENDIF}'
      '          tkRecord:'
      '            _InitializeRecord(F, FTypeInfo);'
      '        else'
      '          Error(reInvalidPtr);'
      '        end;'
      '      end;'
      '    {$IFDEF MANAGED_RECORD}'
      '    except'
      '      {$IFDEF WEAKREF}'
      '      if N > WeakMarker then'
      '        N := WeakMarker;'
      '      {$ENDIF}'
      
        '      FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeInf' +
        'o).Name[0]));'
      '      while N > 0 do'
      '      begin'
      '        Dec(N);'
      
        '        _FinalizeArray(Pointer(PByte(P) + UIntPtr(FT.Fields[N].O' +
        'ffset)), FT.Fields[N].TypeInfo^, 1);'
      '      end;'
      '      raise;'
      '    end;'
      '    {$ENDIF}'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL and !MANAGED_RECORD}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to record to be initialized }'
      '        {       EDX pointer to type info                }'
      ''
      '        XOR     ECX,ECX'
      ''
      '        PUSH    EBX'
      '        MOV     CL,[EDX+1]                  { type name length }'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      
        '        LEA     ESI,[EDX+ECX+2+8]           { address of destruc' +
        'table fields }'
      
        '        MOV     EDI,[EDX+ECX+2+4]           { number of destruct' +
        'able fields }'
      ''
      '{$IFDEF MANAGED_RECORD} // _InitializeRecord'
      '        CMP     BYTE PTR [EDX],tkMRecord'
      '        JNZ     @@NotMRecord'
      '        LEA     ECX,[ESI+EDI*8]'
      '        CMP     [ECX].TRecordOperatorTable.Count,roiInitializer'
      '        JBE     @@NoInitializer'
      '        MOV     ECX,[ECX].TRecordOperatorTable.Initializer'
      '        TEST    ECX,ECX'
      '        JZ      @@NoInitializer'
      '        { ECX=Initializer, EAX=Dest }'
      '        CALL    ECX'
      '        JMP     @@exit'
      '@@NoInitializer:'
      '@@NotMRecord:'
      '{$ENDIF}'
      
        '        MOV     EBX,EAX                     // PIC safe. See com' +
        'ment above'
      '        TEST    EDI,EDI'
      '        JZ      @@exit'
      ''
      '@@loop:'
      ''
      '        MOV     EDX,[ESI]'
      '{$IFDEF WEAKREF}'
      '        TEST    EDX,EDX'
      '        JE      @@skip'
      '{$ENDIF}'
      '        MOV     EAX,[ESI+4]'
      '        ADD     EAX,EBX'
      '        MOV     EDX,[EDX]'
      '        MOV     ECX,1'
      '        CALL    _InitializeArray'
      '{$IFDEF WEAKREF}'
      '@@skip:'
      '{$ENDIF}'
      '        ADD     ESI,8'
      '        DEC     EDI'
      '        JG      @@loop'
      ''
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ELSE !CPUX86}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF !CPUX86}'
      '{$ENDIF !PUREPASCAL and !MANAGED_RECORD}'
      ''
      
        'procedure InitializeArray(p: Pointer; typeInfo: Pointer; elemCou' +
        'nt: NativeUInt);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _InitializeArray(p, typeInfo, elemCount);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '  JMP _InitializeArray'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _InitializeArray(p: Pointer; typeInfo: Pointer; elemCo' +
        'unt: NativeUInt);'
      
        '{$IF defined(PUREPASCAL) or defined(MANAGED_RECORD)} // _Initial' +
        'izeArray'
      ''
      '{$IFDEF MANAGED_RECORD}'
      
        '  procedure _InitializeArrayManagedRecord(p: Pointer; typeInfo: ' +
        'Pointer; elemCount: NativeUInt);'
      '  var'
      '    FT: PFieldTable;'
      '    I, J: NativeUInt;'
      '    P2: Pointer;'
      '    Size: NativeUInt;'
      '  begin'
      
        '    FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeInfo)' +
        '.Name[0]));'
      '    Size := FT.Size;'
      '    J := 0;'
      '    P2 := P;'
      '    try'
      '      I := 0;'
      '      repeat'
      '        _InitializeRecord(@PByte(P)[I], typeInfo);'
      '        I := I + Size;'
      '        J := I;'
      '        Dec(elemCount);'
      '      until elemCount = 0;'
      '    except'
      '      while J > 0 do'
      '      begin'
      '        Dec(J, Size);'
      '        try'
      '          _FinalizeRecord(@PByte(P2)[J], typeInfo);'
      '        except'
      '        end;'
      '      end;'
      '      raise;'
      '    end;'
      '  end;'
      '{$ENDIF}'
      ''
      'var'
      '  FT: PFieldTable;'
      '  Size: NativeUInt;'
      'begin'
      '  if elemCount = 0 then Exit;'
      '  case PTypeInfo(typeInfo).Kind of'
      '{$IFDEF WEAKINSTREF}'
      '    tkMethod:'
      '      if elemCount = 1 then'
      '        TMethod(P^) := Default(TMethod)'
      '      else'
      '        FillChar(P^, SizeOf(TMethod) * elemCount, 0);'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '    tkClass,'
      '{$ENDIF}'
      '    tkLString, tkWString, tkInterface, tkDynArray, tkUString:'
      '      if elemCount = 1 then'
      '        PPointer(P)^ := nil'
      '      else'
      '        FillChar(P^, SizeOf(Pointer) * elemCount, 0);'
      '    tkVariant:'
      '      if elemCount = 1 then'
      '        PVarData(P)^ := Default(TVarData)'
      '      else'
      '        FillChar(P^, SizeOf(TVarData) * elemCount, 0);'
      '    tkArray:'
      '      begin'
      
        '        FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeI' +
        'nfo).Name[0]));'
      
        '        _InitializeArray(P, FT.Fields[0].TypeInfo^, FT.Count * e' +
        'lemCount);'
      '      end;'
      '    tkRecord:'
      '      begin'
      
        '        FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeI' +
        'nfo).Name[0]));'
      '        Size := FT.Size;'
      '        repeat'
      '          _InitializeRecord(P, typeInfo);'
      '          Inc(PByte(P), Size);'
      '          Dec(elemCount);'
      '        until elemCount = 0;'
      '      end;'
      '{$IFDEF MANAGED_RECORD}'
      '    tkMRecord:'
      '      _InitializeArrayManagedRecord(P, typeInfo, elemCount);'
      '{$ENDIF}'
      '  else'
      '    Error(reInvalidPtr);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL and !MANAGED_RECORD}'
      '{$IFDEF CPUX86}'
      'asm'
      
        '        { ->    EAX     pointer to data to be initialized       ' +
        '}'
      
        '        {       EDX     pointer to type info describing data    ' +
        '}'
      
        '        {       ECX     number of elements of that type         ' +
        '}'
      ''
      '        TEST    ECX, ECX'
      '        JZ      @@zerolength'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      
        '        MOV     EBX,EAX             // PIC safe.  See comment ab' +
        'ove'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      ''
      '        XOR     EDX,EDX'
      '        MOV     AL,[ESI]'
      '        MOV     DL,[ESI+1]'
      '        XOR     ECX,ECX'
      ''
      '{$IFDEF WEAKINSTREF}'
      '        CMP     AL,tkMethod'
      '        JE      @@Method'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '        CMP     AL,tkClass'
      '        JE      @@Class'
      '{$ENDIF}'
      '        CMP     AL,tkLString'
      '        JE      @@LString'
      '        CMP     AL,tkWString'
      '        JE      @@WString'
      '        CMP     AL,tkVariant'
      '        JE      @@Variant'
      '        CMP     AL,tkArray'
      '        JE      @@Array'
      '        CMP     AL,tkRecord'
      '        JE      @@Record'
      '        CMP     AL,tkInterface'
      '        JE      @@Interface'
      '        CMP     AL,tkDynArray'
      '        JE      @@DynArray'
      '        CMP     AL,tkUString'
      '        JE      @@UString'
      '{$IFDEF MANAGED_RECORD} // _InitializeArray'
      '        CMP     AL,tkMRecord'
      '        JE      @@Record'
      '{$ENDIF}'
      '        MOV     AL,reInvalidPtr'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        JMP     Error'
      ''
      '@@Class:'
      '@@LString:'
      '@@WString:'
      '@@Interface:'
      '@@DynArray:'
      '@@UString:'
      '        MOV     [EBX],ECX'
      '        ADD     EBX,4'
      '        DEC     EDI'
      '        JG      @@LString'
      '        JMP     @@exit'
      ''
      '@@Variant:'
      '        MOV     [EBX   ],ECX'
      '        MOV     [EBX+ 4],ECX'
      '        MOV     [EBX+ 8],ECX'
      '        MOV     [EBX+12],ECX'
      '        ADD     EBX,16'
      '        DEC     EDI'
      '        JG      @@Variant'
      '        JMP     @@exit'
      ''
      '{$IFDEF WEAKINSTREF}'
      '@@Method:'
      '        MOV     [EBX   ],ECX'
      '        MOV     [EBX+ 4],ECX'
      '        ADD     EBX,8'
      '        DEC     EDI'
      '        JG      @@Method'
      '        JMP     @@exit'
      '{$ENDIF}'
      ''
      '@@Array:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBP'
      '        MOV     EBP,EDX'
      '@@ArrayLoop:'
      
        '        MOV     EDX,[ESI+EBP+2+8]    // address of destructable ' +
        'fields typeinfo'
      '        MOV     EAX,EBX'
      
        '        ADD     EBX,[ESI+EBP+2]      // size in bytes of the arr' +
        'ay data'
      
        '        MOV     ECX,[ESI+EBP+2+4]    // number of destructable f' +
        'ields'
      '        MOV     EDX,[EDX]'
      '        CALL    _InitializeArray'
      '        DEC     EDI'
      '        JG      @@ArrayLoop'
      '        POP     EBP'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     @@exit'
      ''
      '@@Record:'
      
        '        // inv: EBX=PtrToData, EDX=NameLen, ESI=TypeInfo, EDI=Nu' +
        'mElem'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBP'
      '        MOV     EBP,EDX'
      '@@RecordLoop:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,[ESI+EBP+2]'
      '        MOV     EDX,ESI'
      '        CALL    _InitializeRecord'
      '        DEC     EDI'
      '        JG      @@RecordLoop'
      '        POP     EBP'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      ''
      '@@exit:'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '@@zerolength:'
      'end;'
      '{$ELSE !CPUX86}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF !CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _Initialize(p: Pointer; typeInfo: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _InitializeArray(p, typeInfo, 1);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        MOV     ECX,1'
      '        JMP     _InitializeArray'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '{$IFDEF MANAGED_RECORD}'
      'function HasRecordInitializer(TypeInfo: Pointer): Boolean;'
      'var'
      '  FT: PFieldTable;'
      '  ROps: PRecordOperatorTable;'
      '  I: Cardinal;'
      'begin'
      '  Result := False;'
      '  while PTypeInfo(TypeInfo).Kind = tkArray do'
      '  begin'
      
        '    FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo)' +
        '.Name[0]));'
      '    TypeInfo := FT.Fields[0].TypeInfo^;'
      '  end;'
      '  if PTypeInfo(TypeInfo).Kind = tkMRecord then'
      '  begin'
      
        '    FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo)' +
        '.Name[0]));'
      
        '    ROps := PRecordOperatorTable(PByte(@FT.Fields[0]) + UIntPtr(' +
        'FT.Count * SizeOf(TFieldInfo)));'
      
        '    Result := (ROps^.Count > roiInitializer) and Assigned(ROps^.' +
        'Initializer);'
      '  end;'
      '  if (not Result) and'
      '     ((PTypeInfo(TypeInfo).Kind = tkRecord) or'
      '      (PTypeInfo(TypeInfo).Kind = tkMRecord)) then'
      '  begin'
      
        '    FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo)' +
        '.Name[0]));'
      '    if FT.Count > 0 then'
      '    begin'
      '      for I := 0 to FT.Count - 1 do'
      '      begin'
      '        {$IFDEF WEAKREF}'
      '        if FT.Fields[I].TypeInfo = nil then'
      '          Continue;'
      '        {$ENDIF}'
      '        Result := HasRecordInitializer(FT.Fields[I].TypeInfo^);'
      '        if Result then'
      '          Break;'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF MANAGED_RECORD}'
      ''
      'procedure _VarClr(var v: TVarData);'
      'begin'
      '  if Assigned(VarClearProc) then'
      '    VarClearProc(v)'
      '  else'
      '    Error(reVarInvalidOp);'
      'end;'
      ''
      '{$IF (not defined(X86ASMRTL)) or defined(MANAGED_RECORD)}'
      
        'function _FinalizeRecord(P: Pointer; TypeInfo: Pointer): Pointer' +
        ';'
      'var'
      '  FT, ArrayFT: PFieldTable;'
      '  Field: ^TFieldInfo;'
      '  FieldInfo: PPTypeInfo;'
      '  FieldData: Pointer;'
      '  FieldIndex: NativeUInt;'
      
        '{$IF defined(MANAGED_RECORD) or defined(WEAKREF)} // _FinalizeRe' +
        'cord'
      '  ROps: PRecordOperatorTable;'
      '{$ENDIF}'
      '{$IFDEF MANAGED_RECORD} // _FinalizeRecord'
      '  Field2: ^TFieldInfo;'
      '  ArrayFT2: PFieldTable;'
      '{$ENDIF}'
      '{$IFDEF WEAKREF}'
      '  Weak: Boolean;'
      '{$ENDIF}'
      'begin'
      
        '  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).N' +
        'ame[0]));'
      '{$IF defined(MANAGED_RECORD) or defined(WEAKREF)}'
      
        '  ROps := PRecordOperatorTable(PByte(@FT.Fields[0]) + UIntPtr(FT' +
        '.Count * SizeOf(TFieldInfo)));'
      '{$ENDIF}'
      '{$IFDEF MANAGED_RECORD}'
      '  if PTypeInfo(TypeInfo).Kind = tkMRecord then'
      '  begin'
      
        '    if (ROps^.Count > roiFinalizer) and Assigned(ROps^.Finalizer' +
        ') then'
      '    begin'
      '      ROps^.Finalizer(P);'
      '      Exit(P);'
      '    end;'
      '  end;'
      '{$ENDIF}'
      '  if FT.Count > 0 then'
      '  begin'
      '{$IFDEF WEAKREF}'
      '    Weak := False;'
      '    if ROps^.Count > roiRecFlags then'
      '      Weak := ROps^.RecFlags and rofHasWeakField <> 0;'
      '{$ENDIF}'
      '    FieldIndex := FT.Count;'
      '    {$IFDEF MANAGED_RECORD}'
      '    try'
      '    {$ENDIF}'
      '      Field := @FT.Fields[FieldIndex];'
      ''
      '      {$IFDEF WEAKREF}'
      '      if Weak then'
      '      begin'
      '        repeat'
      '          Dec(Field);'
      '          Dec(FieldIndex);'
      '          if Field.TypeInfo = nil then Break;'
      ''
      '          FieldData := Pointer(PByte(P) + IntPtr(Field.Offset));'
      '          FieldInfo := Field.TypeInfo;'
      '          case FieldInfo^.Kind of'
      '            {$IFDEF WEAKINTFREF}'
      '            tkInterface: _IntfWeakClear(IInterface(FieldData^));'
      '            {$ENDIF}'
      '            {$IFDEF WEAKINSTREF}'
      '            tkClass: _InstWeakClear(TObject(FieldData^));'
      
        '            tkMethod: _ClosureRemoveWeakRef(TMethod(FieldData^))' +
        ';'
      '            {$ENDIF}'
      '          else'
      '            System.Error(reInvalidPtr);'
      '          end;'
      '        until False;'
      ''
      '        {$IFDEF MANAGED_RECORD}'
      '        Weak := False;'
      '        {$ENDIF}'
      '      end;'
      '      {$ENDIF}'
      ''
      '      while FieldIndex > 0 do'
      '      begin'
      '        Dec(Field);'
      '        Dec(FieldIndex);'
      '        FieldInfo := Field.TypeInfo;'
      '        FieldData := Pointer(PByte(P) + IntPtr(Field.Offset));'
      '        case FieldInfo^.Kind of'
      '          {$IFDEF WEAKINSTREF}'
      '          tkMethod: _ClosureRemoveWeakRef(TMethod(FieldData^));'
      '          {$ENDIF}'
      '          {$IFDEF AUTOREFCOUNT}'
      '          tkClass: _InstClear(TObject(FieldData^));'
      '          {$ENDIF}'
      '          tkLString: _LStrClr(FieldData^);'
      '          tkWString: _WStrClr(FieldData^);'
      '          tkUString: _UStrClr(FieldData^);'
      '          tkVariant: _VarClr(PVarData(FieldData)^);'
      '          tkArray:'
      '          begin'
      
        '            ArrayFT := PFieldTable(PByte(FieldInfo^) + Byte(PTyp' +
        'eInfo(FieldInfo^).Name[0]));'
      
        '            _FinalizeArray(FieldData, ArrayFT.Fields[0].TypeInfo' +
        '^, ArrayFT.Count);'
      '          end;'
      '          tkMRecord,'
      '          tkRecord: _FinalizeRecord(FieldData, FieldInfo^);'
      '          tkInterface: _IntfClear(IInterface(FieldData^));'
      
        '          tkDynArray: _DynArrayClear(PPointer(FieldData)^, Field' +
        'Info^);'
      '        else'
      '          System.Error(reInvalidPtr);'
      '        end;'
      '      end;'
      ''
      '    {$IFDEF MANAGED_RECORD} // _FinalizeRecord'
      '    except'
      '      Field2 := @FT.Fields[FieldIndex];'
      ''
      '      {$IFDEF WEAKREF}'
      '      if Weak then'
      '        while Field2.TypeInfo <> nil do'
      '        begin'
      '          Dec(Field2);'
      '          Dec(FieldIndex);'
      '          try'
      
        '            FieldData := Pointer(PByte(P) + IntPtr(Field2.Offset' +
        '));'
      '            FieldInfo := Field2.TypeInfo;'
      '            case FieldInfo^.Kind of'
      '              {$IFDEF WEAKINTFREF}'
      
        '              tkInterface: _IntfWeakClear(IInterface(FieldData^)' +
        ');'
      '              {$ENDIF}'
      '              {$IFDEF WEAKINSTREF}'
      '              tkClass: _InstWeakClear(TObject(FieldData^));'
      
        '              tkMethod: _ClosureRemoveWeakRef(TMethod(FieldData^' +
        '));'
      '              {$ENDIF}'
      '            else'
      '              System.Error(reInvalidPtr);'
      '            end;'
      '          except'
      '          end;'
      '        end;'
      '      {$ENDIF}'
      ''
      '      while FieldIndex > 0 do'
      '      begin'
      '        Dec(Field2);'
      '        Dec(FieldIndex);'
      '        FieldInfo := Field2.TypeInfo;'
      '        try'
      
        '          FieldData := Pointer(PByte(P) + IntPtr(Field2.Offset))' +
        ';'
      '          case FieldInfo^.Kind of'
      '            {$IFDEF WEAKINSTREF}'
      
        '            tkMethod: _ClosureRemoveWeakRef(TMethod(FieldData^))' +
        ';'
      '            {$ENDIF}'
      '            {$IFDEF AUTOREFCOUNT}'
      '            tkClass: _InstClear(TObject(FieldData^));'
      '            {$ENDIF}'
      '            tkLString: _LStrClr(FieldData^);'
      '            tkWString: _WStrClr(FieldData^);'
      '            tkUString: _UStrClr(FieldData^);'
      '            tkVariant: _VarClr(PVarData(FieldData)^);'
      '            tkArray:'
      '            begin'
      
        '              ArrayFT2 := PFieldTable(PByte(FieldInfo^) + Byte(P' +
        'TypeInfo(FieldInfo^).Name[0]));'
      
        '              _FinalizeArray(FieldData, ArrayFT2.Fields[0].TypeI' +
        'nfo^, ArrayFT2.Count);'
      '            end;'
      '            tkMRecord,'
      '            tkRecord: _FinalizeRecord(FieldData, FieldInfo^);'
      '            tkInterface: _IntfClear(IInterface(FieldData^));'
      
        '            tkDynArray: _DynArrayClear(PPointer(FieldData)^, Fie' +
        'ldInfo^);'
      '          else'
      '            System.Error(reInvalidPtr);'
      '          end;'
      '        except'
      '        end;'
      '      end;'
      ''
      '      raise;'
      '    end;'
      '    {$ENDIF MANAGED_RECORD} // _FinalizeRecord'
      '  end;'
      '  Result := P;'
      'end;'
      '{$ELSE X86ASMRTL and not MANAGED_RECORD}'
      'procedure _FinalizeRecord(p: Pointer; typeInfo: Pointer);'
      'asm'
      '        { ->    EAX pointer to record to be finalized   }'
      '        {       EDX pointer to type info                }'
      ''
      '        XOR     ECX,ECX'
      ''
      '        PUSH    EBX'
      '        MOV     CL,[EDX+1]'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     EBX,EAX'
      '        LEA     ESI,[EDX+ECX+2+8]'
      '        MOV     EDI,[EDX+ECX+2+4]'
      ''
      '{$IFDEF MANAGED_RECORD} // _FinalizeRecord'
      '        CMP     BYTE PTR [EDX],tkMRecord'
      '        JNZ     @@NotMRecord'
      '        LEA     ECX,[ESI+EDI*8]'
      '        CMP     [ECX].TRecordOperatorTable.Count,roiFinalizer'
      '        JBE     @@NoFinalizer'
      '        MOV     ECX,[ECX].TRecordOperatorTable.Finalizer'
      '        TEST    ECX,ECX'
      '        JZ      @@NoFinalizer'
      '        { ECX=Finalizer, EAX=Dest }'
      '        CALL    ECX'
      '        JMP     @@exit'
      '@@NoFinalizer:'
      '@@NotMRecord:'
      '{$ENDIF}'
      '        TEST    EDI,EDI'
      '        JZ      @@exit'
      ''
      '@@loop:'
      ''
      '        MOV     EDX,[ESI]'
      '{$IFDEF WEAKREF}'
      '        TEST    EDX,EDX'
      '        JE      @@weak'
      '{$ENDIF}'
      '        MOV     EAX,[ESI+4]'
      '        ADD     EAX,EBX'
      '        MOV     EDX,[EDX]'
      '        MOV     ECX,1'
      '        CALL    _FinalizeArray'
      '        ADD     ESI,8'
      '        DEC     EDI'
      '        JG      @@loop'
      '{$IFDEF WEAKREF}'
      '        JMP     @@exit'
      ''
      '@@weak:'
      '        ADD     ESI,8'
      '        DEC     EDI'
      ''
      '@@weakLoop:'
      '        MOV     EDX,[ESI]'
      '        MOV     EAX,[ESI+4]'
      '        ADD     EAX,EBX'
      '        MOV     EDX,[EDX]'
      '{$IFDEF WEAKINTFREF}'
      '        CMP     BYTE PTR [EDX].TTypeInfo.Kind,tkInterface'
      '        JE      @@clrWeakIntf'
      '{$ENDIF}'
      '{$IFDEF WEAKINSTREF}'
      '        CMP     BYTE PTR [EDX].TTypeInfo.Kind,tkClass'
      '        JE      @@clrWeakInst'
      '        CMP     BYTE PTR [EDX].TTypeInfo.Kind,tkMethod'
      '        JE      @@clrWeakMethod'
      '{$ENDIF}'
      '        MOV     AL,reInvalidPtr'
      '        JMP     Error'
      ''
      '{$IFDEF WEAKINTFREF}'
      '@@clrWeakIntf:'
      '        CALL    _IntfWeakClear'
      '        JMP     @@next'
      '{$ENDIF}'
      '{$IFDEF WEAKINSTREF}'
      '@@clrWeakInst:'
      '        CALL    _InstWeakClear'
      '        JMP     @@next'
      '@@clrWeakMethod:'
      '        CALL    _ClosureRemoveWeakRef'
      '{$ENDIF}'
      '@@next:'
      '        ADD     ESI,8'
      '        DEC     EDI'
      '        JG      @@weakLoop'
      '{$ENDIF}'
      '@@exit:'
      '        MOV     EAX,EBX'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF X86ASMRTL and not MANAGED_RECORD}'
      ''
      '{$IF (not defined(X86ASMRTL)) or defined(MANAGED_RECORD)}'
      
        'function _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCount' +
        ': NativeUInt): Pointer;'
      ''
      '  {$IF defined(MANAGED_RECORD)}'
      
        '  procedure FinalizeExcept(P: Pointer; TypeInfo: Pointer; ElemCo' +
        'unt: NativeUInt);'
      '  var'
      '    FT: PFieldTable;'
      '    ElemSize: NativeUInt;'
      '  begin'
      
        '    FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo)' +
        '.Name[0]));'
      ''
      
        '    if PTypeInfo(TypeInfo).Kind in [tkArray, tkRecord, tkMRecord' +
        '] then'
      '      ElemSize := FT.Size'
      '    else'
      '      ElemSize := SizeOf(Pointer);'
      ''
      '    Inc(PByte(P), ElemSize);'
      '    Dec(ElemCount);'
      '    if ElemCount > 0 then'
      '    begin'
      '      repeat'
      '        try'
      '          case PTypeInfo(TypeInfo).Kind of'
      '            {$IF defined(AUTOREFCOUNT)}'
      '            tkClass:     _InstClear(TObject(P^));'
      '            {$ENDIF}'
      
        '            tkArray:     _FinalizeArray(P, FT.Fields[0].TypeInfo' +
        '^, FT.Count);'
      '            tkMRecord,'
      '            tkRecord:    _FinalizeRecord(P, TypeInfo);'
      '            tkInterface: _IntfClear(IInterface(P^));'
      '            tkDynArray:  _DynArrayClear(PPointer(P)^, TypeInfo);'
      '          else'
      '            System.Error(reInvalidPtr);'
      '          end;'
      '        except'
      '        end;'
      '        Inc(PByte(P), ElemSize);'
      '        Dec(ElemCount);'
      '      until ElemCount = 0;'
      '    end;'
      '  end;'
      '  {$ENDIF}'
      ''
      'var'
      '  FT: PFieldTable;'
      'begin'
      '  Result := P;'
      '  if ElemCount = 0 then Exit;'
      '  case PTypeInfo(TypeInfo).Kind of'
      '{$IFDEF WEAKINSTREF}'
      '    tkMethod:'
      '      repeat'
      '        _ClosureRemoveWeakRef(TMethod(P^));'
      '        Inc(PByte(P), SizeOf(TMethod));'
      '        Dec(ElemCount);'
      '      until ElemCount = 0;'
      '{$ENDIF}'
      '    {$IF defined(AUTOREFCOUNT) and not defined(MANAGED_RECORD)}'
      '    tkClass:'
      '      {$IF defined(MANAGED_RECORD)}'
      '      try'
      '      {$ENDIF}'
      '        repeat'
      '          _InstClear(TObject(P^));'
      '          Inc(PByte(P), SizeOf(Pointer));'
      '          Dec(ElemCount);'
      '        until ElemCount = 0;'
      '      {$IF defined(MANAGED_RECORD)}'
      '      except'
      '        FinalizeExcept(P, TypeInfo, ElemCount);'
      '        raise;'
      '      end;'
      '      {$ENDIF}'
      '    {$ENDIF}'
      '    tkLString: _LStrArrayClr(P^, ElemCount);'
      '    tkWString: _WStrArrayClr(P^, ElemCount);'
      '    tkUString: _UStrArrayClr(P^, ElemCount);'
      '    tkVariant:'
      '      repeat'
      '        _VarClr(PVarData(P)^);'
      '        Inc(PByte(P), SizeOf(TVarData));'
      '        Dec(ElemCount);'
      '      until ElemCount = 0;'
      '    tkArray:'
      '      {$IF defined(MANAGED_RECORD)}'
      '      try'
      '      {$ELSE}'
      '      begin'
      '      {$ENDIF}'
      
        '        FT := PFieldTable(PByte(typeInfo) + Byte(PTypeInfo(typeI' +
        'nfo).Name[0]));'
      '        repeat'
      '          _FinalizeArray(P, FT.Fields[0].TypeInfo^, FT.Count);'
      '          Inc(PByte(P), FT.Size);'
      '          Dec(ElemCount);'
      '        until ElemCount = 0;'
      '      {$IF defined(MANAGED_RECORD)}'
      '      except'
      '        FinalizeExcept(P, TypeInfo, ElemCount);'
      '        raise;'
      '      {$ENDIF}'
      '      end;'
      '    tkMRecord,'
      '    tkRecord:'
      '      {$IF defined(MANAGED_RECORD)}'
      '      try'
      '      {$ELSE}'
      '      begin'
      '      {$ENDIF}'
      
        '        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeI' +
        'nfo).Name[0]));'
      '        repeat'
      '          _FinalizeRecord(P, TypeInfo);'
      '          Inc(PByte(P), FT.Size);'
      '          Dec(ElemCount);'
      '        until ElemCount = 0;'
      '      {$IF defined(MANAGED_RECORD)}'
      '      except'
      '        FinalizeExcept(P, TypeInfo, ElemCount);'
      '        raise;'
      '      {$ENDIF}'
      '      end;'
      '    tkInterface:'
      '      {$IF defined(MANAGED_RECORD)}'
      '      try'
      '      {$ENDIF}'
      '        repeat'
      '          _IntfClear(IInterface(P^));'
      '          Inc(PByte(P), SizeOf(Pointer));'
      '          Dec(ElemCount);'
      '        until ElemCount = 0;'
      '      {$IF defined(MANAGED_RECORD)}'
      '      except'
      '        FinalizeExcept(P, TypeInfo, ElemCount);'
      '        raise;'
      '      end;'
      '      {$ENDIF}'
      '    tkDynArray:'
      '      {$IF defined(MANAGED_RECORD)}'
      '      try'
      '      {$ENDIF}'
      '        repeat'
      
        '          { The cast and dereference of P here is to fake out th' +
        'e call to'
      
        '            _DynArrayClear.  That function expects a var paramet' +
        'er.  Our'
      
        '            declaration says we got a non-var parameter, but bec' +
        'ause of'
      
        '            the data type that got passed to us (tkDynArray), th' +
        'is isn'#39't'
      
        '            strictly true.  The compiler will have passed us a r' +
        'eference. }'
      '          _DynArrayClear(PPointer(P)^, typeInfo);'
      '          Inc(PByte(P), SizeOf(Pointer));'
      '          Dec(ElemCount);'
      '        until ElemCount = 0;'
      '      {$IF defined(MANAGED_RECORD)}'
      '      except'
      '        FinalizeExcept(P, TypeInfo, ElemCount);'
      '        raise;'
      '      end;'
      '      {$ENDIF}'
      '  else'
      '    System.Error(reInvalidPtr);'
      '  end;'
      'end;'
      '{$ELSE X86ASMRTL and not MANAGED_RECORD}'
      
        'procedure _FinalizeArray(P: Pointer; TypeInfo: Pointer; ElemCoun' +
        't: NativeUInt);'
      'asm'
      
        '        { ->    EAX     pointer to data to be finalized         ' +
        '}'
      
        '        {       EDX     pointer to type info describing data    ' +
        '}'
      
        '        {       ECX     number of elements of that type         ' +
        '}'
      ''
      
        '        { This code appears to be PIC safe.  The functions calle' +
        'd from'
      '          here either don'#39't make external calls or call Pascal'
      '          routines that will fix up EBX in their prolog code'
      '          (FreeMem, VarClr, IntfClr).  }'
      ''
      
        '        CMP     ECX, 0                        { no array -> nop ' +
        '}'
      '        JE      @@zerolength'
      ''
      '        PUSH    EAX'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      ''
      '        XOR     EDX,EDX'
      '        MOV     AL,[ESI]'
      '        MOV     DL,[ESI+1]'
      ''
      '{$IFDEF WEAKINSTREF}'
      '        CMP     AL,tkMethod'
      '        JE      @@Method'
      '{$ENDIF}'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      '        CMP     AL,tkClass'
      '        JE      @@Class'
      '{$ENDIF}'
      ''
      '        CMP     AL,tkLString'
      '        JE      @@LString'
      ''
      '        CMP     AL,tkUString'
      '        JE      @@UString'
      ''
      '        CMP     AL,tkWString'
      '        JE      @@WString'
      ''
      '        CMP     AL,tkVariant'
      '        JE      @@Variant'
      ''
      '        CMP     AL,tkArray'
      '        JE      @@Array'
      ''
      '        CMP     AL,tkRecord'
      '        JE      @@Record'
      ''
      '        CMP     AL,tkInterface'
      '        JE      @@Interface'
      ''
      '        CMP     AL,tkDynArray'
      '        JE      @@DynArray'
      ''
      '{$IFDEF MANAGED_RECORD} // _FinalizeArray'
      '        CMP     AL,tkMRecord'
      '        JE      @@Record'
      '{$ENDIF}'
      ''
      '        JMP     @@error'
      ''
      '@@LString:'
      '        CMP     ECX,1'
      '        MOV     EAX,EBX'
      '        JG      @@LStringArray'
      '        CALL    _LStrClr'
      '        JMP     @@exit'
      '@@LStringArray:'
      '        MOV     EDX,ECX'
      '        CALL    _LStrArrayClr'
      '        JMP     @@exit'
      ''
      '@@WString:'
      '        CMP     ECX,1'
      '        MOV     EAX,EBX'
      '        JG      @@WStringArray'
      '        CALL    _WStrClr'
      '        JMP     @@exit'
      '@@WStringArray:'
      '        MOV     EDX,ECX'
      '        CALL    _WStrArrayClr'
      '        JMP     @@exit'
      ''
      '@@UString:'
      '        CMP     ECX,1'
      '        MOV     EAX,EBX'
      '        JG      @@UStringArray'
      '        CALL    _UStrClr'
      '        JMP     @@exit'
      '@@UStringArray:'
      '        MOV     EDX,ECX'
      '        CALL    _UStrArrayClr'
      '        JMP     @@exit'
      ''
      '@@Variant:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,16'
      '        CALL    _VarClr'
      '        DEC     EDI'
      '        JG      @@Variant'
      '        JMP     @@exit'
      '@@Array:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBP'
      '        MOV     EBP,EDX'
      '@@ArrayLoop:'
      '        MOV     EDX,[ESI+EBP+2+8]'
      '        MOV     EAX,EBX'
      '        ADD     EBX,[ESI+EBP+2]'
      '        MOV     ECX,[ESI+EBP+2+4]'
      '        MOV     EDX,[EDX]'
      '        CALL    _FinalizeArray'
      '        DEC     EDI'
      '        JG      @@ArrayLoop'
      '        POP     EBP'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     @@exit'
      ''
      '@@Record:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EBP'
      '        MOV     EBP,EDX'
      '@@RecordLoop:'
      '        { inv: EDI = number of array elements to finalize }'
      ''
      '        MOV     EAX,EBX'
      '        ADD     EBX,[ESI+EBP+2]'
      '        MOV     EDX,ESI'
      '        CALL    _FinalizeRecord'
      '        DEC     EDI'
      '        JG      @@RecordLoop'
      '        POP     EBP'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     @@exit'
      ''
      '@@Interface:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,4'
      '        CALL    _IntfClear'
      '        DEC     EDI'
      '        JG      @@Interface'
      '        JMP     @@exit'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      '@@Class:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,4'
      '        CALL    _InstClear'
      '        DEC     EDI'
      '        JG      @@Class'
      '        JMP     @@exit'
      '{$ENDIF}'
      ''
      '{$IFDEF WEAKINSTREF}'
      '@@Method:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,8'
      '        CALL    _ClosureRemoveWeakRef'
      '        DEC     EDI'
      '        JG      @@Method'
      '        JMP     @@exit'
      '{$ENDIF}'
      ''
      '@@DynArray:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,ESI'
      '        ADD     EBX,4'
      '        CALL    _DynArrayClear'
      '        DEC     EDI'
      '        JG      @@DynArray'
      '        JMP     @@exit'
      ''
      '@@error:'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        POP     EAX'
      '        MOV     AL,reInvalidPtr'
      '        JMP     Error'
      ''
      '@@exit:'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        POP     EAX'
      '@@zerolength:'
      'end;'
      '{$ENDIF X86ASMRTL and not MANAGED_RECORD}'
      ''
      '{$IF (not defined(X86ASMRTL)) or defined(MANAGED_RECORD)}'
      'function _Finalize(p: Pointer; typeInfo: Pointer): Pointer;'
      '{$ELSE X86ASMRTL and not MANAGED_RECORD}'
      'procedure _Finalize(p: Pointer; typeInfo: Pointer);'
      '{$ENDIF X86ASMRTL and not MANAGED_RECORD}'
      '{$IF not defined(X86ASMRTL)}'
      'begin'
      '  Result := _FinalizeArray(p, typeInfo, 1);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'asm'
      '        MOV     ECX,1'
      '        JMP     _FinalizeArray'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      'procedure _AddRefRecord(P: Pointer; TypeInfo: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  FT: PFieldTable;'
      '  I: Cardinal;'
      'begin'
      
        '  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).N' +
        'ame[0]));'
      '  if FT.Count > 0 then'
      '  begin'
      '    for I := 0 to FT.Count - 1 do'
      '    begin'
      '{$IFDEF WEAKREF}'
      
        '      // Check for the sentinal indicating the following fields ' +
        'are weak references'
      '      // which don'#39't need to be reference counted'
      '      if FT.Fields[I].TypeInfo = nil then'
      '        Break;'
      '{$ENDIF}'
      
        '      _AddRefArray(Pointer(PByte(P) + UIntPtr(FT.Fields[I].Offse' +
        't)), FT.Fields[I].TypeInfo^, 1);'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        { ->    EAX pointer to record to be referenced  }'
      '        {       EDX pointer to type info        }'
      ''
      '        XOR     ECX,ECX'
      ''
      '        PUSH    EBX'
      '        MOV     CL,[EDX+1]'
      ''
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        MOV     EBX,EAX'
      '        LEA     ESI,[EDX+ECX+2+8]'
      '        MOV     EDI,[EDX+ECX+2+4]'
      '        TEST    EDI,EDI'
      '        JZ      @@exit'
      '@@loop:'
      ''
      '        MOV     EDX,[ESI]'
      '{$IFDEF WEAKREF}'
      
        '        // Check for the sentinal indicating the following field' +
        's are weak references'
      '        // which don'#39't need to be reference counted'
      '        TEST    EDX,EDX'
      '        JE      @@exit'
      '{$ENDIF}'
      '        MOV     EAX,[ESI+4]'
      '        ADD     EAX,EBX'
      '        MOV     EDX,[EDX]'
      '        MOV     ECX, 1'
      '        CALL    _AddRefArray'
      '        ADD     ESI,8'
      '        DEC     EDI'
      '        JG      @@loop'
      '@@exit:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _VarAddRef(var v: TVarData);'
      'begin'
      '  if Assigned(VarAddRefProc) then'
      '    VarAddRefProc(v)'
      '  else'
      '    Error(reVarInvalidOp);'
      'end;'
      ''
      
        'procedure _AddRefArray(P: Pointer; TypeInfo: Pointer; ElemCount:' +
        ' NativeUInt);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  FT: PFieldTable;'
      'begin'
      '  if ElemCount = 0 then Exit;'
      '  case PTypeInfo(TypeInfo).Kind of'
      '{$IFDEF WEAKINSTREF}'
      '    tkMethod:'
      '      while ElemCount > 0 do'
      '      begin'
      '        _ClosureAddWeakRef(TMethod(P^));'
      '        Inc(PByte(P), SizeOf(TMethod));'
      '        Dec(ElemCount);'
      '      end;'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '    tkClass:'
      '      while ElemCount > 0 do'
      '      begin'
      '        _InstAddRef(TObject(P^));'
      '        Inc(PByte(P), SizeOf(Pointer));'
      '        Dec(ElemCount);'
      '      end;'
      '{$ENDIF}'
      '    tkLString:'
      '      while ElemCount > 0 do'
      '      begin'
      '        _LStrAddRef(PPointer(P)^);'
      '        Inc(PByte(P), SizeOf(Pointer));'
      '        Dec(ElemCount);'
      '      end;'
      '    tkWString:'
      '      while ElemCount > 0 do'
      '      begin'
      '        {$IFDEF MSWINDOWS}'
      '        _WStrAddRef(PWideString(P)^);'
      '        {$ELSE}'
      '        _WStrAddRef(PPointer(P)^);'
      '        {$ENDIF}'
      '        Inc(PByte(P), SizeOf(Pointer));'
      '        Dec(ElemCount);'
      '      end;'
      '    tkUString:'
      '      while ElemCount > 0 do'
      '      begin'
      '        _UStrAddRef(PPointer(P)^);'
      '        Inc(PByte(P), SizeOf(Pointer));'
      '        Dec(ElemCount);'
      '      end;'
      '    tkVariant:'
      '      while ElemCount > 0 do'
      '      begin'
      '        _VarAddRef(PVarData(P)^);'
      '        Inc(PByte(P), SizeOf(TVarData));'
      '        Dec(ElemCount);'
      '      end;'
      '    tkArray:'
      '      begin'
      
        '        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeI' +
        'nfo).Name[0]));'
      '        while ElemCount > 0 do'
      '        begin'
      '          _AddRefArray(P, FT.Fields[0].TypeInfo^, FT.Count);'
      '          Inc(PByte(P), FT.Size);'
      '          Dec(ElemCount);'
      '        end;'
      '      end;'
      '{$IFDEF MANAGED_RECORD} // _AddRefArray'
      '    tkRecord, tkMRecord:'
      '{$ELSE}'
      '    tkRecord:'
      '{$ENDIF}'
      '      begin'
      
        '        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeI' +
        'nfo).Name[0]));'
      '        while ElemCount > 0 do'
      '        begin'
      '          _AddRefRecord(P, TypeInfo);'
      '          Inc(PByte(P), FT.Size);'
      '          Dec(ElemCount);'
      '        end;'
      '      end;'
      '    tkInterface:'
      '      while ElemCount > 0 do'
      '      begin'
      '        _IntfAddRef(IInterface(P^));'
      '        Inc(PByte(P), SizeOf(Pointer));'
      '        Dec(ElemCount);'
      '      end;'
      '    tkDynArray:'
      '      while ElemCount > 0 do'
      '      begin'
      '        _DynArrayAddRef(PPointer(P)^);'
      '        Inc(PByte(P), SizeOf(Pointer));'
      '        Dec(ElemCount);'
      '      end;'
      '  else'
      '    Error(reInvalidPtr);'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAligned'
      
        '        { ->    EAX     pointer to data to be referenced        ' +
        '}'
      
        '        {       EDX     pointer to type info describing data    ' +
        '}'
      
        '        {       ECX     number of elements of that type         ' +
        '}'
      ''
      
        '        { This code appears to be PIC safe.  The functions calle' +
        'd from'
      
        '          here either don'#39't make external calls (LStrAddRef, WSt' +
        'rAddRef) or'
      
        '          are Pascal routines that will fix up EBX in their prol' +
        'og code'
      '          (VarAddRef, IntfAddRef).  }'
      ''
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      ''
      '        TEST  ECX,ECX'
      '        JZ    @@exit'
      ''
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      ''
      '        XOR     EDX,EDX'
      '        MOV     AL,[ESI]'
      '        MOV     DL,[ESI+1]'
      ''
      '{$IFDEF WEAKINSTREF}'
      '        CMP     AL,tkMethod'
      '        JE      @@Method'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '        CMP     AL,tkClass'
      '        JE      @@Class'
      '{$ENDIF}'
      '        CMP     AL,tkLString'
      '        JE      @@LString'
      '        CMP     AL,tkWString'
      '        JE      @@WString'
      '        CMP     AL,tkUString'
      '        JE      @@UString'
      '        CMP     AL,tkVariant'
      '        JE      @@Variant'
      '        CMP     AL,tkArray'
      '        JE      @@Array'
      '        CMP     AL,tkRecord'
      '        JE      @@Record'
      '        CMP     AL,tkInterface'
      '        JE      @@Interface'
      '        CMP     AL,tkDynArray'
      '        JE      @@DynArray'
      '{$IFDEF MANAGED_RECORD} // _AddRefArray'
      '        CMP     AL,tkMRecord'
      '        JE      @@Record'
      '{$ENDIF}'
      '        MOV     AL,reInvalidPtr'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        JMP     Error'
      ''
      '@@LString:'
      '@@UString:'
      '{$IFDEF POSIX}'
      '@@WString:'
      '{$ENDIF POSIX}'
      '        MOV     EAX,[EBX]'
      '        ADD     EBX,4'
      '        CALL    _LStrAddRef'
      '        DEC     EDI'
      '        JG      @@LString'
      '        JMP     @@exit'
      ''
      '{$IFDEF MSWINDOWS}'
      '@@WString:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,4'
      '        CALL    _WStrAddRef'
      '        DEC     EDI'
      '        JG      @@WString'
      '        JMP     @@exit'
      '{$ENDIF MSWINDOWS}'
      '@@Variant:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,16'
      '        CALL    _VarAddRef'
      '        DEC     EDI'
      '        JG      @@Variant'
      '        JMP     @@exit'
      ''
      '@@Array:'
      '        PUSH    EBP'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EBP,EDX'
      '@@ArrayLoop:'
      '        MOV     EDX,[ESI+EBP+2+8]'
      '        MOV     EAX,EBX'
      '        ADD     EBX,[ESI+EBP+2]'
      '        MOV     ECX,[ESI+EBP+2+4]'
      '        MOV     EDX,[EDX]'
      '        CALL    _AddRefArray'
      '        DEC     EDI'
      '        JG      @@ArrayLoop'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EBP'
      '        JMP     @@exit'
      ''
      '@@Record:'
      '        PUSH    EBP'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EBP,EDX'
      '@@RecordLoop:'
      '        MOV     EAX,EBX'
      '        ADD     EBX,[ESI+EBP+2]'
      '        MOV     EDX,ESI'
      '        CALL    _AddRefRecord'
      '        DEC     EDI'
      '        JG      @@RecordLoop'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EBP'
      '        JMP     @@exit'
      ''
      '@@Interface:'
      '        MOV     EAX,[EBX]'
      '        ADD     EBX,4'
      '        CALL    _IntfAddRef'
      '        DEC     EDI'
      '        JG      @@Interface'
      '        JMP     @@exit'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      '@@Class:'
      '        MOV     EAX,[EBX]'
      '        ADD     EBX,4'
      '        CALL    _InstAddRef'
      '        DEC     EDI'
      '        JG      @@Class'
      '        JMP     @@exit'
      '{$ENDIF}'
      ''
      '{$IFDEF WEAKINSTREF}'
      '@@Method:'
      '        MOV     EAX,[EBX]'
      '        ADD     EBX,8'
      '        CALL    _ClosureAddWeakRef'
      '        DEC     EDI'
      '        JG      @@Class'
      '        JMP     @@exit'
      '{$ENDIF}'
      ''
      '@@DynArray:'
      '        MOV     EAX,[EBX]'
      '        ADD     EBX,4'
      '        CALL    _DynArrayAddRef'
      '        DEC     EDI'
      '        JG      @@DynArray'
      '@@exit:'
      ''
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _AddRef(P: Pointer; TypeInfo: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _AddRefArray(P, TypeInfo, 1);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        MOV     ECX,1'
      '        JMP     _AddRefArray'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _VarCopy(var Dest: TVarData; const Src: TVarData);'
      'begin'
      '  if Assigned(VarCopyProc) then'
      '    VarCopyProc(Dest, Src)'
      '  else'
      '    Error(reVarInvalidOp);'
      'end;'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'procedure _CopyRecord(Dest, Source, TypeInfo: Pointer);'
      'var'
      '  FT, EFT: PFieldTable;'
      '{$IFDEF MANAGED_RECORD} // _CopyRecord'
      '  ROps: PRecordOperatorTable;'
      '{$ENDIF}'
      '  I, Count, L: Cardinal;'
      '{$IFDEF WEAKREF}'
      '  J, K: Cardinal;'
      '{$ENDIF}'
      '  Offset: UIntPtr;'
      '  FTypeInfo: PTypeInfo;'
      '  DestOff, SrcOff: Pointer;'
      'begin'
      
        '  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).N' +
        'ame[0]));'
      '{$IFDEF MANAGED_RECORD} // _CopyRecord'
      '  if PTypeInfo(TypeInfo).Kind = tkMRecord then'
      '  begin'
      
        '    ROps := PRecordOperatorTable(PByte(@FT.Fields[0]) + UIntPtr(' +
        'FT.Count * SizeOf(TFieldInfo)));'
      
        '    if (ROps^.Count > roiAssignOperator) and Assigned(ROps^.Assi' +
        'gnOperator) then'
      '    begin'
      '      ROps^.AssignOperator(Dest, Source);'
      '      Exit;'
      '    end;'
      '  end;'
      '{$ENDIF MANAGED_RECORD} // _CopyRecord'
      '  Offset := 0;'
      '  if FT.Count > 0 then'
      '  begin'
      '    Count := FT.Count;'
      '{$IFDEF WEAKREF}'
      '    K := Count;'
      '    for I := Count - 1 downto 0 do'
      '      if FT.Fields[I].TypeInfo = nil then'
      '      begin'
      '        K := I + 1; // found the weak sentinal'
      '        Dec(Count); // remove the sentinal from consideration'
      '        Break;'
      '      end;'
      '    J := 0;'
      '{$ENDIF}'
      '    for L := 0 to Count - 1 do'
      '    begin'
      '{$IFDEF WEAKREF}'
      
        '      if (FT.Fields[J].TypeInfo <> nil) and ((K = FT.Count) or (' +
        'FT.Fields[J].Offset < FT.Fields[K].Offset)) then'
      '      begin'
      '        I := J;'
      '        Inc(J);'
      '      end else'
      '      begin'
      '        I := K;'
      '        Inc(K);'
      '      end;'
      '{$ELSE}'
      '      I := L;'
      '{$ENDIF}'
      '      if FT.Fields[I].Offset > Offset then'
      '        Move(Pointer(PByte(Source) + Offset)^,'
      '             Pointer(PByte(Dest) + Offset)^,'
      '             FT.Fields[I].Offset - Offset);'
      '      Offset := FT.Fields[I].Offset;'
      '      FTypeInfo := FT.Fields[I].TypeInfo^;'
      '      DestOff := Pointer(PByte(Dest) + Offset);'
      '      SrcOff := Pointer(PByte(Source) + Offset);'
      '      case FTypeInfo.Kind of'
      '{$IFDEF WEAKINSTREF}'
      '        tkMethod:'
      '          begin'
      '            _CopyClosure(PMethod(DestOff)^, PMethod(SrcOff)^);'
      '            Inc(Offset, SizeOf(TMethod));'
      '          end;'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '        tkClass:'
      '          begin'
      '{$IFDEF WEAKINSTREF}'
      '            if I > J then'
      
        '              _InstWeakCopy(TObject(PPointer(DestOff)^), TObject' +
        '(PPointer(SrcOff)^))'
      '            else'
      '{$ENDIF}'
      
        '              _InstCopy(TObject(PPointer(DestOff)^), TObject(PPo' +
        'inter(SrcOff)^));'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '{$ENDIF}'
      '        tkLString:'
      '          begin'
      '            _LStrAsg(_PAnsiStr(DestOff)^, _PAnsiStr(SrcOff)^);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkWString:'
      '          begin'
      '            _WStrAsg(_PWideStr(DestOff)^, _PWideStr(SrcOff)^);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkUString:'
      '          begin'
      
        '            _UStrAsg(PUnicodeString(DestOff)^, PUnicodeString(Sr' +
        'cOff)^);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkVariant:'
      '          begin'
      '            _VarCopy(PVarData(DestOff)^, PVarData(SrcOff)^);'
      '            Inc(Offset, SizeOf(TVarData));'
      '          end;'
      '        tkArray:'
      '          begin'
      
        '            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo' +
        '(FTypeInfo).Name[0]));'
      
        '            _CopyArray(DestOff, SrcOff, EFT.Fields[0].TypeInfo^,' +
        ' EFT.Count);'
      '            Inc(Offset, EFT.Size);'
      '          end;'
      '{$IFDEF MANAGED_RECORD} // _CopyRecord'
      '        tkRecord, tkMRecord:'
      '{$ELSE}'
      '        tkRecord:'
      '{$ENDIF}'
      '          begin'
      
        '            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo' +
        '(FTypeInfo).Name[0]));'
      '            _CopyRecord(DestOff, SrcOff, FTypeInfo);'
      '            Inc(Offset, EFT.Size);'
      '          end;'
      '        tkInterface:'
      '          begin'
      '{$IFDEF WEAKINTFREF}'
      '            if I > J then'
      
        '              _IntfWeakCopy(IInterface(PPointer(DestOff)^), IInt' +
        'erface(PPointer(SrcOff)^))'
      '            else'
      '{$ENDIF}'
      
        '              _IntfCopy(IInterface(PPointer(DestOff)^), IInterfa' +
        'ce(PPointer(SrcOff)^));'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkDynArray:'
      '          begin'
      
        '            _DynArrayAsg(PPointer(DestOff)^, PPointer(SrcOff)^, ' +
        'FTypeInfo);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '      else'
      '        Error(reInvalidPtr);'
      '      end;'
      '    end;'
      '  end;'
      '  if FT.Size > Offset then'
      '    Move(Pointer(PByte(Source) + Offset)^,'
      '         Pointer(PByte(Dest) + Offset)^,'
      '         FT.Size - Offset);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _CopyRecord{ dest, source, typeInfo: Pointer };'
      'const'
      '  FldPtr = 8;'
      '  EndPtr = 4;'
      '  RecSize = 0;'
      '  TFieldInfoSize = SizeOf(TFieldInfo);'
      'asm'
      '        { ->    EAX pointer to dest             }'
      '        {       EDX pointer to source           }'
      '        {       ECX pointer to typeInfo         }'
      ''
      '        PUSH    EBX                      { 12 -> 8  }'
      '        PUSH    ESI                      { 8  -> 4  }'
      '        PUSH    EDI                      { 4  -> 0  }'
      '        PUSH    EBP                      { 0  -> 12 }'
      
        '        PUSH    0                        { 12 -> 8  use [ESP+Fld' +
        'Ptr] for the "saved" Field pointer }'
      
        '        PUSH    0                        { 8  -> 4  use [ESP+End' +
        'Ptr] for the "end" of the field info array }'
      ''
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      ''
      '        XOR     EAX,EAX'
      '        MOV     AL,[ECX].TTypeInfo.Name.Byte'
      ''
      '        LEA     EDI,[ECX+EAX+2+8]'
      '        MOV     EBP,[EDI-4] //TFieldTable.Count'
      ''
      '{$IFDEF MANAGED_RECORD} // _CopyRecord'
      '        CMP     BYTE PTR [ECX],tkMRecord'
      '        JNZ     @@NotMRecord'
      '        PUSH    ECX                      { 4  -> 0  }'
      '        LEA     ECX,[EDI+EBP*8]'
      
        '        CMP     [ECX].TRecordOperatorTable.Count,roiAssignOperat' +
        'or'
      '        JBE     @@NoAssignOperator'
      '        MOV     ECX,[ECX].TRecordOperatorTable.AssignOperator'
      '        TEST    ECX,ECX'
      '        JZ      @@NoAssignOperator'
      '        MOV     EAX,EBX'
      '        CALL    ECX     { EAX=Dest, EDX=Source }'
      '        POP     ECX                      { 0  -> 4  }'
      '        JMP     @@noMove2'
      '@@NoAssignOperator:'
      '        POP     ECX                      { 0  -> 4  }'
      '@@NotMRecord:'
      '{$ENDIF}'
      ''
      '        XOR     EAX,EAX'
      '        MOV     ECX,[EDI-8] //TFieldTable.Size'
      '        TEST    EBP,EBP'
      '        JZ      @@moveWhole'
      '        PUSH    ECX                      { 4  -> 0  }'
      '{$IFDEF WEAKREF}'
      '        MOV     ECX,EBP'
      '        LEA     EDX,[EDI+ECX*TFieldInfoSize]'
      '        MOV     [ESP+EndPtr],EDX'
      '        MOV     [ESP+FldPtr],EDX'
      '@@findWeak:'
      
        '        CMP     [EDI+ECX*TFieldInfoSize-TFieldInfoSize].TFieldIn' +
        'fo.TypeInfo,0'
      '        JE      @@hasWeak'
      '        DEC     ECX'
      '        JNZ     @@findWeak'
      '        JMP     @@loop'
      '@@hasWeak:'
      '        LEA     ECX,[EDI+ECX*8]'
      '        MOV     [ESP+FldPtr],ECX'
      
        '        DEC     EBP     { Remove the sentinal from consideration' +
        ' }'
      '{$ENDIF}'
      '@@loop:'
      '{$IFDEF WEAKREF}'
      '        MOV     EDX,[ESP+FldPtr]'
      '        CMP     EDX,[ESP+EndPtr]'
      '        JE      @@noWeak'
      '        CMP     [EDX].TFieldInfo.TypeInfo,0'
      '        JE      @@noWeak'
      '        CMP     [EDI].TFieldInfo.TypeInfo,0'
      
        '        JE      @@doneStrong  { found the sentinal, so the rest ' +
        'are all weak }'
      '        MOV     ECX,[EDX+4] // TFieldInfo.Offset'
      
        '        CMP     ECX,[EDI+4] // TFieldInfo.Offset Compare the off' +
        'sets'
      '        JA      @@noWeak'
      '@@doneStrong:'
      
        '        XCHG    EDI,[ESP+FldPtr] // Swap the Weak/noWeak pointer' +
        's'
      '@@noWeak:'
      '{$ENDIF}'
      '        MOV     ECX,[EDI+4] //TFieldInfo.Offset'
      '        SUB     ECX,EAX'
      '        JLE     @@nomove1'
      '        MOV     EDX,EAX'
      '        ADD     EAX,ESI'
      '        ADD     EDX,EBX'
      '        CALL    Move'
      '@@noMove1:'
      '        MOV     EAX,[EDI+4] //TFieldInfo.Offset'
      '        MOV     EDX,[EDI].TFieldInfo.TypeInfo'
      '        MOV     EDX,[EDX]'
      '        MOV     CL,[EDX].TTypeInfo.Kind'
      ''
      '{$IFDEF WEAKINSTREF}'
      '        CMP     CL,tkMethod'
      '        JE      @@Method'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '        CMP     CL,tkClass'
      '        JE      @@Class'
      '{$ENDIF}'
      '        CMP     CL,tkInterface'
      '        JE      @@Interface'
      '{$IFDEF WEAKREF}'
      '        CMP     EDI,[ESP+FldPtr]'
      '        JA      @@error'
      '{$ENDIF}'
      '        CMP     CL,tkLString'
      '        JE      @@LString'
      '        CMP     CL,tkWString'
      '        JE      @@WString'
      '        CMP     CL,tkUString'
      '        JE      @@UString'
      '        CMP     CL,tkVariant'
      '        JE      @@Variant'
      '        CMP     CL,tkArray'
      '        JE      @@Array'
      '        CMP     CL,tkRecord'
      '        JE      @@Record'
      '        CMP     CL,tkDynArray'
      '        JE      @@DynArray'
      '{$IFDEF MANAGED_RECORD} // _CopyRecord'
      '        CMP     CL,tkMRecord'
      '        JE      @@Record'
      '{$ENDIF}'
      '@@error:'
      '        MOV     AL,reInvalidPtr'
      '        POP     ECX                      { 0  -> 4  }'
      '        ADD     ESP, 8                   { 4  -> 12 }'
      '        POP     EBP                      { 12 -> 0  }'
      '        POP     EDI                      { 0  -> 4  }'
      '        POP     ESI                      { 4  -> 8  }'
      '        POP     EBX                      { 8  -> 12 }'
      '        JMP     Error'
      ''
      '@@LString:'
      '        MOV     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _LStrAsg'
      '        MOV     EAX,4'
      '        JMP     @@common'
      ''
      '@@UString:'
      '        MOV     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _UStrAsg'
      '        MOV     EAX,4'
      '        JMP     @@common'
      ''
      '@@WString:'
      '        MOV     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _WStrAsg'
      '        MOV     EAX,4'
      '        JMP     @@common'
      ''
      '@@Variant:'
      '        LEA     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _VarCopy'
      '        MOV     EAX,16'
      '        JMP     @@common'
      ''
      '@@Array:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8                   { 0  -> 8  }'
      '{$ENDIF ALIGN_STACK}'
      '        XOR     ECX,ECX'
      '        MOV     CL,[EDX+1]'
      '        PUSH    dword ptr [EDX+ECX+2]    { 8  -> 4  }'
      '        PUSH    dword ptr [EDX+ECX+2+4]  { 4  -> 0  }'
      '        MOV     ECX,[EDX+ECX+2+8]'
      '        MOV     ECX,[ECX]'
      '        LEA     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _CopyArray'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     @@common'
      ''
      '@@Record:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12                  { 0  -> 4  }'
      '{$ENDIF ALIGN_STACK}'
      '        XOR     ECX,ECX'
      '        MOV     CL,[EDX+1]'
      '        MOV     ECX,[EDX+ECX+2]'
      '        PUSH    ECX                      { 4  -> 0  }'
      '        MOV     ECX,EDX'
      '        LEA     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _CopyRecord'
      '        POP     EAX                      { 0  -> 4  }'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12                  { 4  -> 0  }'
      '{$ENDIF ALIGN_STACK}'
      '        JMP     @@common'
      ''
      '@@Interface:'
      '        MOV     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '{$IFDEF WEAKINTFREF}'
      
        '        CMP     EDI,[ESP+FldPtr]                { if Weak then _' +
        'IntfWeakCopy else _IntfCopy }'
      '        JB      @@intfCopy'
      ''
      '        CALL    _IntfWeakCopy'
      '        MOV     EAX,4'
      '        JMP     @@common'
      '@@intfCopy:'
      '{$ENDIF}'
      '        CALL    _IntfCopy'
      '        MOV     EAX,4'
      '        JMP     @@common'
      ''
      '{$IFDEF WEAKINSTREF}'
      '@@Method:'
      '        LEA     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _CopyClosure'
      '        MOV     EAX,8'
      '        JMP     @@common'
      '{$ENDIF}'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      '@@Class:'
      '        MOV     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '{$IFDEF WEAKINSTREF}'
      
        '        CMP     EDI,[ESP+FldPtr]                { if Weak then _' +
        'InstWeakCopy else _InstCopy }'
      '        JB      @@instCopy'
      ''
      '        CALL    _InstWeakCopy'
      '        MOV     EAX,4'
      '        JMP     @@common'
      '@@instCopy:'
      '{$ENDIF}'
      '        CALL    _InstCopy'
      '        MOV     EAX,4'
      '        JMP     @@common'
      '{$ENDIF}'
      ''
      '@@DynArray:'
      '        MOV     ECX,EDX'
      '        MOV     EDX,[ESI+EAX]'
      '        ADD     EAX,EBX'
      '        CALL    _DynArrayAsg'
      '        MOV     EAX,4'
      ''
      '@@common:'
      '        ADD     EAX,[EDI+4]'
      '        ADD     EDI,8'
      '        DEC     EBP'
      '        JNZ     @@loop'
      '        POP     ECX                      { 0  -> 4  }'
      ''
      '@@moveWhole:'
      '        SUB     ECX,EAX'
      '        JLE     @@noMove2'
      '        LEA     EDX,[EBX+EAX]'
      '        ADD     EAX,ESI'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4                   { 4  -> 0  }'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    Move'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4                   { 0  -> 4  }'
      '{$ENDIF ALIGN_STACK}'
      '@@noMove2:'
      ''
      '        ADD     ESP, 8                   { 4  -> 12 }'
      '        POP     EBP                      { 12 -> 0  }'
      '        POP     EDI                      { 0  -> 4  }'
      '        POP     ESI                      { 4  -> 8  }'
      '        POP     EBX                      { 8  -> 12 }'
      'end;                                     { 12 -> 0  RET }'
      '{$ENDIF X86ASMRTL}'
      ''
      'procedure MoveRecord(Dest, Source, TypeInfo: Pointer);'
      '{$IF defined(MANAGED_RECORD)} // MoveRecord'
      'type'
      
        '  _CopyRecordProcType = procedure(Dest, Source, TypeInfo: Pointe' +
        'r);'
      '  _FinalizeRecordProcType = procedure(Dest, TypeInfo: Pointer);'
      '{$ENDIF}'
      'var'
      '  FT, EFT: PFieldTable;'
      '  I, Count, L: Cardinal;'
      '{$IFDEF WEAKREF}'
      '  J, K: Cardinal;'
      '{$ENDIF}'
      '  Offset: UIntPtr;'
      '  FTypeInfo: PTypeInfo;'
      '  DestOff, SrcOff: Pointer;'
      'begin'
      
        '  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).N' +
        'ame[0]));'
      '  {$IFDEF MANAGED_RECORD} // MoveRecord'
      '  if PTypeInfo(TypeInfo).Kind = tkMRecord then'
      '  begin'
      '    _CopyRecordProcType(@_CopyRecord)(Dest, Source, TypeInfo);'
      '    _FinalizeRecordProcType(@_FinalizeRecord)(Source, TypeInfo);'
      '    Exit;'
      '  end;'
      '  {$ENDIF}'
      '  // _CopyRecord(Dest, Source, TypeInfo);'
      '  // _FinalizeRecord(Source, TypeInfo);'
      '  Offset := 0;'
      '  if FT.Count > 0 then'
      '  begin'
      '    Count := FT.Count;'
      '{$IFDEF WEAKREF}'
      '    K := Count;'
      '    for I := Count - 1 downto 0 do'
      '      if FT.Fields[I].TypeInfo = nil then'
      '      begin'
      '        K := I + 1; // found the weak sentinal'
      '        Dec(Count); // remove the sentinal from consideration'
      '        Break;'
      '      end;'
      '    J := 0;'
      '{$ENDIF}'
      '    for L := 0 to Count - 1 do'
      '    begin'
      '{$IFDEF WEAKREF}'
      
        '      if (FT.Fields[J].TypeInfo <> nil) and ((K = FT.Count) or (' +
        'FT.Fields[J].Offset < FT.Fields[K].Offset)) then'
      '      begin'
      '        I := J;'
      '        Inc(J);'
      '      end else'
      '      begin'
      '        I := K;'
      '        Inc(K);'
      '      end;'
      '{$ELSE}'
      '      I := L;'
      '{$ENDIF}'
      '      if FT.Fields[I].Offset > Offset then'
      '        Move(Pointer(PByte(Source) + Offset)^,'
      '             Pointer(PByte(Dest) + Offset)^,'
      '             FT.Fields[I].Offset - Offset);'
      '      Offset := FT.Fields[I].Offset;'
      '      FTypeInfo := FT.Fields[I].TypeInfo^;'
      '      DestOff := Pointer(PByte(Dest) + Offset);'
      '      SrcOff := Pointer(PByte(Source) + Offset);'
      '      case FTypeInfo.Kind of'
      '{$IFDEF WEAKINSTREF}'
      '        tkMethod:'
      '          begin'
      '            _CopyClosure(PMethod(DestOff)^, PMethod(SrcOff)^);'
      '            _ClosureRemoveWeakRef(PMethod(SrcOff)^);'
      '            Inc(Offset, SizeOf(TMethod));'
      '          end;'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '        tkClass:'
      '          begin'
      '{$IFDEF WEAKINSTREF}'
      '            if I > J then'
      '            begin'
      
        '              _InstWeakCopy(TObject(PPointer(DestOff)^), TObject' +
        '(PPointer(SrcOff)^));'
      '              _InstWeakClear(TObject(PPointer(SrcOff)^));'
      '            end'
      '            else'
      '{$ENDIF}'
      
        '              _InstCopy(TObject(PPointer(DestOff)^), TObject(PPo' +
        'inter(SrcOff)^));'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '{$ENDIF}'
      '        tkLString:'
      '          begin'
      '            _LStrAsg(_PAnsiStr(DestOff)^, _PAnsiStr(SrcOff)^);'
      '            _LStrClr(_PAnsiStr(SrcOff)^);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkWString:'
      '          begin'
      '            _WStrAsg(_PWideStr(DestOff)^, _PWideStr(SrcOff)^);'
      '            _WStrClr(_PWideStr(SrcOff)^);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkUString:'
      '          begin'
      
        '            _UStrAsg(PUnicodeString(DestOff)^, PUnicodeString(Sr' +
        'cOff)^);'
      '            _UStrClr(PUnicodeString(SrcOff)^);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkVariant:'
      '          begin'
      '            _VarCopy(PVarData(DestOff)^, PVarData(SrcOff)^);'
      '            _VarClr(PVarData(SrcOff)^);'
      '            Inc(Offset, SizeOf(TVarData));'
      '          end;'
      '        tkArray:'
      '          begin'
      
        '            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo' +
        '(FTypeInfo).Name[0]));'
      
        '            MoveArray(DestOff, SrcOff, EFT.Fields[0].TypeInfo^, ' +
        'EFT.Count);'
      '            Inc(Offset, EFT.Size);'
      '          end;'
      '        tkRecord, tkMRecord:'
      '          begin'
      
        '            EFT := PFieldTable(PByte(FTypeInfo) + Byte(PTypeInfo' +
        '(FTypeInfo).Name[0]));'
      '            MoveRecord(DestOff, SrcOff, FTypeInfo);'
      '            Inc(Offset, EFT.Size);'
      '          end;'
      '        tkInterface:'
      '          begin'
      '{$IFDEF WEAKINTFREF}'
      '            if I > J then'
      '            begin'
      
        '              _IntfWeakCopy(IInterface(PPointer(DestOff)^), IInt' +
        'erface(PPointer(SrcOff)^));'
      '              _IntfWeakClear(IInterface(PPointer(SrcOff)^));'
      '            end'
      '            else'
      '{$ENDIF}'
      '            begin'
      
        '              _IntfCopy(IInterface(PPointer(DestOff)^), IInterfa' +
        'ce(PPointer(SrcOff)^));'
      '              _IntfClear(IInterface(PPointer(SrcOff)^));'
      '            end;'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '        tkDynArray:'
      '          begin'
      
        '            _DynArrayAsg(PPointer(DestOff)^, PPointer(SrcOff)^, ' +
        'FTypeInfo);'
      '            _DynArrayClear(PPointer(SrcOff)^, FTypeInfo);'
      '            Inc(Offset, SizeOf(Pointer));'
      '          end;'
      '      else'
      '        Error(reInvalidPtr);'
      '      end;'
      '    end;'
      '  end;'
      '  if FT.Size > Offset then'
      '    Move(Pointer(PByte(Source) + Offset)^,'
      '         Pointer(PByte(Dest) + Offset)^,'
      '         FT.Size - Offset);'
      'end;'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _CopyObject(Dest, Source: Pointer; vmtPtrOffs: NativeI' +
        'nt; TypeInfo: Pointer);'
      'var'
      '  SavedVmtPtr: Pointer;'
      'begin'
      '  SavedVmtPtr := PPointer(PByte(Dest) + vmtPtrOffs)^;'
      '  _CopyRecord(Dest, Source, TypeInfo);'
      '  PPointer(PByte(Dest) + vmtPtrOffs)^ := SavedVmtPtr;'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        'procedure       _CopyObject{ dest, source: Pointer; vmtPtrOffs: ' +
        'NativeInt; typeInfo: Pointer };'
      'asm'
      '        { ->    EAX     pointer to dest         }'
      '        {       EDX     pointer to source       }'
      '        {       ECX     offset of vmt in object }'
      '        {       [ESP+4] pointer to typeInfo     }'
      ''
      
        '        ADD     ECX,EAX                         { pointer to des' +
        't vmt }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      
        '        PUSH    dword ptr [ECX]                 { save dest vmt ' +
        '}'
      '        PUSH    ECX'
      '{$IFDEF ALIGN_STACK}'
      '        MOV     ECX,[ESP+4+4+4+4]'
      '{$ELSE}'
      '        MOV     ECX,[ESP+4+4+4]'
      '{$ENDIF}'
      '        CALL    _CopyRecord'
      '        POP     ECX'
      
        '        POP     dword ptr [ECX]                 { restore dest v' +
        'mt }'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        RET     4'
      ''
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _CopyArray(Dest, Source, TypeInfo: Pointer; Count: Nat' +
        'iveUInt);'
      'var'
      '  FT: PFieldTable;'
      'begin'
      '  if Count = 0 then Exit;'
      '  case PTypeInfo(TypeInfo).Kind of'
      '{$IFDEF WEAKINSTREF}'
      '    tkMethod:'
      '      repeat'
      '        _CopyClosure(PMethod(Dest)^, PMethod(Source)^);'
      '        Inc(PByte(Dest), SizeOf(TMethod));'
      '        Inc(PByte(Source), SizeOf(TMethod));'
      '        Dec(Count);'
      '      until Count = 0;'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '    tkClass:'
      '      repeat'
      
        '        _InstCopy(TObject(PPointer(Dest)^), TObject(PPointer(Sou' +
        'rce)^));'
      '        Inc(PByte(Dest), SizeOf(Pointer));'
      '        Inc(PByte(Source), SizeOf(Pointer));'
      '        Dec(Count);'
      '      until Count = 0;'
      '{$ENDIF}'
      '    tkLString:'
      '      repeat'
      '        _LStrAsg(_PAnsiStr(Dest)^, _PAnsiStr(Source)^);'
      '        Inc(PByte(Dest), SizeOf(Pointer));'
      '        Inc(PByte(Source), SizeOf(Pointer));'
      '        Dec(Count);'
      '      until Count = 0;'
      '    tkWString:'
      '      repeat'
      '        _WStrAsg(_PWideStr(Dest)^, _PWideStr(Source)^);'
      '        Inc(PByte(Dest), SizeOf(Pointer));'
      '        Inc(PByte(Source), SizeOf(Pointer));'
      '        Dec(Count);'
      '      until Count = 0;'
      '    tkUString:'
      '      repeat'
      
        '        _UStrAsg(PUnicodeString(Dest)^, PUnicodeString(Source)^)' +
        ';'
      '        Inc(PByte(Dest), SizeOf(Pointer));'
      '        Inc(PByte(Source), SizeOf(Pointer));'
      '        Dec(Count);'
      '      until Count = 0;'
      '    tkVariant:'
      '      repeat'
      '        _VarCopy(PVarData(Dest)^, PVarData(Source)^);'
      '        Inc(PByte(Dest), SizeOf(TVarData));'
      '        Inc(PByte(Source), SizeOf(TVarData));'
      '        Dec(Count);'
      '      until Count = 0;'
      '    tkArray:'
      '      begin'
      
        '        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeI' +
        'nfo).Name[0]));'
      '        repeat'
      
        '          _CopyArray(Pointer(Dest), Pointer(Source), FT.Fields[0' +
        '].TypeInfo^, FT.Count);'
      '          Inc(PByte(Dest), FT.Size);'
      '          Inc(PByte(Source), FT.Size);'
      '          Dec(Count);'
      '        until Count = 0;'
      '      end;'
      '    {$IFDEF MANAGED_RECORD} // _CopyArray'
      '    tkRecord, tkMRecord:'
      '    {$ELSE}'
      '    tkRecord:'
      '    {$ENDIF}'
      '      begin'
      
        '        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeI' +
        'nfo).Name[0]));'
      '        repeat'
      '          _CopyRecord(Dest, Source, TypeInfo);'
      '          Inc(PByte(Dest), FT.Size);'
      '          Inc(PByte(Source), FT.Size);'
      '          Dec(Count);'
      '        until Count = 0;'
      '      end;'
      '    tkInterface:'
      '      repeat'
      
        '        _IntfCopy(IInterface(PPointer(Dest)^), IInterface(PPoint' +
        'er(Source)^));'
      '        Inc(PByte(Dest), SizeOf(Pointer));'
      '        Inc(PByte(Source), SizeOf(Pointer));'
      '        Dec(Count);'
      '      until Count = 0;'
      '    tkDynArray:'
      '      repeat'
      
        '        _DynArrayAsg(PPointer(Dest)^, PPointer(Source)^, TypeInf' +
        'o);'
      '        Inc(PByte(Dest), SizeOf(Pointer));'
      '        Inc(PByte(Source), SizeOf(Pointer));'
      '        Dec(Count);'
      '      until Count = 0;'
      '  else'
      '    Error(reInvalidPtr);'
      '  end;'
      'end;'
      '{$ELSE X86ASMRTL}'
      
        'procedure _CopyArray{ dest, source, typeInfo: Pointer; cnt: Inte' +
        'ger };'
      'asm'
      '        { ->    EAX pointer to dest             }'
      '        {       EDX pointer to source           }'
      '        {       ECX pointer to typeInfo         }'
      '        {       [ESP+4] count                   }'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        MOV     EBX,EAX'
      '        MOV     ESI,EDX'
      '        MOV     EDI,ECX'
      '        MOV     EBP,[ESP+4+4*4]'
      ''
      '        MOV     CL,[EDI]'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '{$IFDEF WEAKINSTREF}'
      '        CMP     CL,tkMethod'
      '        JE      @@Method'
      '{$ENDIF}'
      '{$IFDEF AUTOREFCOUNT}'
      '        CMP     CL,tkClass'
      '        JE      @@Class'
      '{$ENDIF}'
      '        CMP     CL,tkLString'
      '        JE      @@LString'
      '        CMP     CL,tkWString'
      '        JE      @@WString'
      '        CMP     CL,tkUString'
      '        JE      @@UString'
      '        CMP     CL,tkVariant'
      '        JE      @@Variant'
      '        CMP     CL,tkArray'
      '        JE      @@Array'
      '        CMP     CL,tkRecord'
      '        JE      @@Record'
      '        CMP     CL,tkInterface'
      '        JE      @@Interface'
      '        CMP     CL,tkDynArray'
      '        JE      @@DynArray'
      '{$IFDEF MANAGED_RECORD} // _CopyArray'
      '        CMP     CL,tkMRecord'
      '        JE      @@Record'
      '{$ENDIF}'
      '        MOV     AL,reInvalidPtr'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        JMP     Error'
      ''
      '@@LString:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,[ESI]'
      '        CALL    _LStrAsg'
      '        ADD     EBX,4'
      '        ADD     ESI,4'
      '        DEC     EBP'
      '        JNE     @@LString'
      '        JMP     @@exit'
      ''
      '@@WString:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,[ESI]'
      '        CALL    _WStrAsg'
      '        ADD     EBX,4'
      '        ADD     ESI,4'
      '        DEC     EBP'
      '        JNE     @@WString'
      '        JMP     @@exit'
      ''
      '@@UString:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,[ESI]'
      '        CALL    _UStrAsg'
      '        ADD     EBX,4'
      '        ADD     ESI,4'
      '        DEC     EBP'
      '        JNE     @@UString'
      '        JMP     @@exit'
      ''
      '@@Variant:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,ESI'
      '        CALL    _VarCopy'
      '        ADD     EBX,16'
      '        ADD     ESI,16'
      '        DEC     EBP'
      '        JNE     @@Variant'
      '        JMP     @@exit'
      ''
      '@@Array:'
      '        XOR     ECX,ECX'
      '        MOV     CL,[EDI+1]'
      '        LEA     EDI,[EDI+ECX+2]'
      '@@ArrayLoop:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,ESI'
      '        MOV     ECX,[EDI+8]'
      '        MOV     ECX,[ECX]'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4 // Negitive Adjustment'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    dword ptr [EDI+4]'
      '        CALL    _CopyArray'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        ADD     EBX,[EDI]'
      '        ADD     ESI,[EDI]'
      '        DEC     EBP'
      '        JNE     @@ArrayLoop'
      '        JMP     @@exit'
      ''
      '@@Record:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,ESI'
      '        MOV     ECX,EDI'
      '        CALL    _CopyRecord'
      '        XOR     EAX,EAX'
      '        MOV     AL,[EDI+1]'
      '        ADD     EBX,[EDI+EAX+2]'
      '        ADD     ESI,[EDI+EAX+2]'
      '        DEC     EBP'
      '        JNE     @@Record'
      '        JMP     @@exit'
      ''
      '@@Interface:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,[ESI]'
      '        CALL    _IntfCopy'
      '        ADD     EBX,4'
      '        ADD     ESI,4'
      '        DEC     EBP'
      '        JNE     @@Interface'
      '        JMP     @@exit'
      ''
      '{$IFDEF WEAKINSTREF}'
      '@@Method:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,ESI'
      '        CALL    _CopyClosure'
      '        ADD     EBX,8'
      '        ADD     ESI,8'
      '        DEC     EBP'
      '        JNE     @@Method'
      '        JMP     @@exit'
      '{$ENDIF}'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      '@@Class:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,[ESI]'
      '        CALL    _InstCopy'
      '        ADD     EBX,4'
      '        ADD     ESI,4'
      '        DEC     EBP'
      '        JNE     @@Class'
      '        JMP     @@exit'
      '{$ENDIF}'
      ''
      '@@DynArray:'
      '        MOV     EAX,EBX'
      '        MOV     EDX,[ESI]'
      '        MOV     ECX,EDI'
      '        CALL    _DynArrayAsg'
      '        ADD     EBX,4'
      '        ADD     ESI,4'
      '        DEC     EBP'
      '        JNE     @@DynArray'
      ''
      '@@exit:'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        RET     4'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      
        'procedure MoveArray(Dest, Source, TypeInfo: Pointer; Count: Nati' +
        'veInt);'
      'var'
      '  FT: PFieldTable;'
      'begin'
      '  if Count = 0 then Exit;'
      '  case PTypeInfo(TypeInfo).Kind of'
      '{$IFDEF WEAKINSTREF}'
      '    tkMethod:'
      '      while Count > 0 do'
      '      begin'
      '        _CopyClosure(PMethod(Dest)^, PMethod(Source)^);'
      '        _ClosureRemoveWeakRef(TMethod(Source^));'
      '        Inc(PByte(Dest), SizeOf(TMethod));'
      '        Inc(PByte(Source), SizeOf(TMethod));'
      '        Dec(Count);'
      '      end;'
      '{$ELSE !WEAKINSTREF}'
      '    tkMethod:'
      
        '      Move(PByte(Source)^, PByte(Dest)^, Count * SizeOf(TMethod)' +
        ');'
      '{$ENDIF WEAKINSTREF}'
      '    tkClass,'
      '    tkLString,'
      '    tkWString,'
      '    tkUString,'
      '    tkDynArray,'
      '    tkInterface:'
      
        '      Move(PByte(Source)^, PByte(Dest)^, Count * SizeOf(Pointer)' +
        ');'
      '    tkVariant:'
      
        '      Move(PByte(Source)^, PByte(Dest)^, Count * SizeOf(TVarData' +
        '));'
      '    tkArray:'
      '      begin'
      
        '        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeI' +
        'nfo).Name[0]));'
      '        while Count > 0 do'
      '        begin'
      
        '          MoveArray(Dest, Source, FT.Fields[0].TypeInfo^, FT.Cou' +
        'nt);'
      '          Inc(PByte(Dest), FT.Size);'
      '          Inc(PByte(Source), FT.Size);'
      '          Dec(Count);'
      '        end;'
      '      end;'
      '{$IF defined(MANAGED_RECORD)} // MoveArray'
      '    tkRecord, tkMRecord:'
      '{$ELSE}'
      '    tkRecord:'
      '{$ENDIF}'
      '      begin'
      
        '        FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeI' +
        'nfo).Name[0]));'
      '        while Count > 0 do'
      '        begin'
      '          MoveRecord(Dest, Source, TypeInfo);'
      '          Inc(PByte(Dest), FT.Size);'
      '          Inc(PByte(Source), FT.Size);'
      '          Dec(Count);'
      '        end;'
      '      end;'
      '  else'
      '    Error(reInvalidPtr);'
      '  end;'
      'end;'
      ''
      'function _New(Size: NativeInt; TypeInfo: Pointer): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  GetMem(Result, Size);'
      '  if Result <> nil then'
      '    _Initialize(Result, TypeInfo);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      '        { ->    EAX size of object to allocate  }'
      '        {       EDX pointer to typeInfo         }'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX'
      '        CALL    _GetMem'
      '        POP     EDX'
      '        TEST    EAX,EAX'
      '        JE      @@exit'
      '        PUSH    EAX'
      '        CALL    _Initialize'
      '        POP     EAX'
      '@@exit:'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _Dispose(P: Pointer; TypeInfo: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _Finalize(P, TypeInfo);'
      '  FreeMem(P);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      'asm'
      
        '        { ->    EAX     Pointer to object to be disposed        ' +
        '}'
      
        '        {       EDX     Pointer to type info                    ' +
        '}'
      ''
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        CALL    _Finalize'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        CALL    _FreeMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      
        'procedure CopyArray(Dest, Source, TypeInfo: Pointer; Count: Nati' +
        'veInt);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Count > 0 then'
      '    _CopyArray(Dest, Source, TypeInfo, Count);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      
        '        // PUSH EBP -- implicitly generated by existence of 4th ' +
        'parameter'
      '        CMP     dword ptr [EBP+8],0'
      '        JBE     @@Exit'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    dword ptr [EBP+8]'
      '        CALL    _CopyArray'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '@@Exit:'
      
        '        // POP EBP -- implicitly generated by existence of 4th p' +
        'arameter'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure FinalizeArray(P, TypeInfo: Pointer; Count: NativeUInt)' +
        ';'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _FinalizeArray(P, TypeInfo, Count);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        JMP     _FinalizeArray'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure CopyRecord(Dest, Source, TypeInfo: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _CopyRecord(Dest, Source, TypeInfo);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        // inv: EAX=Dest, EDX=Source, ECX=TypeInfo'
      '        JMP     _CopyRecord'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'Procedure FinalizeRecord(P: Pointer; TypeInfo: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  _FinalizeRecord(P, TypeInfo);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        // inv: EAX=Dest, EDX=TypeInfo'
      '        JMP     _FinalizeRecord'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      '// Dest is zero-filled before call.'
      '// inv: (PTypeInfo(TypeInfo).Kind = tkRecord) or'
      '//      (PTypeInfo(TypeInfo).Kind = tkMRecord)'
      'procedure InvokeRecordInitializer(Dest, TypeInfo: Pointer);'
      '{$IFDEF MANAGED_RECORD}'
      'var'
      '  FT: PFieldTable;'
      '  ROps: PRecordOperatorTable;'
      '  I: NativeUInt;'
      '  Field: ^TFieldInfo;'
      '  FieldIndex: NativeUInt;'
      '{$ENDIF MANAGED_RECORD}'
      'begin'
      '  {$IFDEF MANAGED_RECORD}'
      
        '  FT := PFieldTable(@PByte(TypeInfo)[Byte(PTypeInfo(TypeInfo).Na' +
        'me[0])]);'
      '  if PTypeInfo(TypeInfo).Kind = tkMRecord then'
      '  begin'
      '    ROps := PRecordOperatorTable(@FT.Fields[FT.Count]);'
      
        '    if (ROps^.Count > roiInitializer) and Assigned(ROps^.Initial' +
        'izer) then'
      '    begin'
      '      ROps^.Initializer(Dest);'
      '      Exit;'
      '    end;'
      '  end;'
      '  if FT.Count > 0 then'
      '  begin'
      '    I := 0;'
      '    try'
      '      Field := @FT.Fields[0];'
      '      for FieldIndex := 1 to FT.Count do'
      '      begin'
      '        {$IFDEF WEAKREF}'
      '        if Field.TypeInfo = nil then'
      '          Break;'
      '        {$ENDIF}'
      
        '        if Field.TypeInfo^.Kind in [tkArray, tkRecord, tkMRecord' +
        '] then'
      
        '          InvokeRecordInitializerArray(Pointer(PByte(Dest) + Fie' +
        'ld.Offset), Field.TypeInfo^, 1);'
      '        Inc(Field);'
      '        Inc(I);'
      '      end;'
      '    except'
      '      while I > 0 do'
      '      begin'
      '        Dec(I);'
      '        try'
      
        '          _FinalizeArray(Pointer(PByte(Dest) + FT.Fields[I].Offs' +
        'et), FT.Fields[I].TypeInfo^, 1);'
      '        except'
      '        end;'
      '      end;'
      '      raise;'
      '    end;'
      '  end;'
      '  {$ENDIF MANAGED_RECORD}'
      'end;'
      ''
      
        'procedure InvokeRecordInitializerArray(Dest, TypeInfo: Pointer; ' +
        'ElemCount: NativeUInt);'
      '{$IFDEF MANAGED_RECORD}'
      'var'
      '  FT: PFieldTable;'
      '  ROps: PRecordOperatorTable;'
      '  Initializer: TRecordInitializer;'
      '  I: NativeUInt;'
      '{$ENDIF MANAGED_RECORD}'
      'begin'
      '{$IFDEF MANAGED_RECORD}'
      '  while PTypeInfo(TypeInfo).Kind = tkArray do'
      '  begin'
      
        '    FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo)' +
        '.Name[0]));'
      '    ElemCount := ElemCount * FT.Count;'
      '    TypeInfo := FT.Fields[0].TypeInfo^;'
      '  end;'
      
        '  FT := PFieldTable(PByte(TypeInfo) + Byte(PTypeInfo(TypeInfo).N' +
        'ame[0]));'
      '  if PTypeInfo(TypeInfo).Kind = tkMRecord then'
      '  begin'
      
        '    ROps := PRecordOperatorTable(PByte(@FT.Fields[0]) + UIntPtr(' +
        'FT.Count * SizeOf(TFieldInfo)));'
      
        '    if (ROps^.Count > roiInitializer) and Assigned(ROps^.Initial' +
        'izer) then'
      '    begin'
      '      Initializer := ROps^.Initializer;'
      '      I := 0;'
      '      try'
      '        while I < ElemCount do'
      '        begin'
      '          Initializer(Dest);'
      '          Inc(PByte(Dest), FT.Size);'
      '          Inc(I);'
      '        end;'
      '      except'
      '        _FinalizeArray(PByte(Dest) - I * FT.Size, TypeInfo, I);'
      '        raise;'
      '      end;'
      '      Exit;'
      '    end;'
      '  end;'
      '  case PTypeInfo(TypeInfo).Kind of'
      '    tkRecord, tkMRecord:'
      '      begin'
      '        I := 0;'
      '        try'
      '          while I < ElemCount do'
      '          begin'
      '            InvokeRecordInitializer(Dest, TypeInfo);'
      '            Inc(PByte(Dest), FT.Size);'
      '            Inc(I);'
      '          end;'
      '        except'
      
        '          _FinalizeArray(PByte(Dest) - I * FT.Size, TypeInfo, I)' +
        ';'
      '          raise;'
      '        end;'
      '      end;'
      '  end;'
      '{$ENDIF MANAGED_RECORD}'
      'end;'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Wide character support                          }'
      '{ ----------------------------------------------------- }'
      ''
      'function WideCharToString(Source: PWideChar): UnicodeString;'
      'begin'
      '  WideCharToStrVar(Source, Result);'
      'end;'
      ''
      
        'function WideCharLenToString(Source: PWideChar; SourceLen: Integ' +
        'er): UnicodeString;'
      'begin'
      '  WideCharLenToStrVar(Source, SourceLen, Result);'
      'end;'
      ''
      
        'procedure WideCharToStrVar(Source: PWideChar; var Dest: UnicodeS' +
        'tring);'
      'begin'
      '  _UStrFromPWChar(Dest, Source);'
      'end;'
      ''
      
        'procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Inte' +
        'ger;'
      '  var Dest: UnicodeString);'
      'begin'
      '  _UStrFromPWCharLen(Dest, Source, SourceLen);'
      'end;'
      ''
      
        'procedure WideCharLenToStrVar(Source: PWideChar; SourceLen: Inte' +
        'ger;'
      '  var Dest: _AnsiStr);'
      'begin'
      
        '  _LStrFromPWCharLen(Dest, Source, SourceLen, DefaultSystemCodeP' +
        'age);'
      'end;'
      ''
      
        'function StringToWideChar(const Source: UnicodeString; Dest: PWi' +
        'deChar;'
      '  DestSize: Integer): PWideChar;'
      'begin'
      '  //Check to see if enough storage is allocated'
      '  if Length(Source) + 1 > DestSize then'
      '  begin'
      '    if DestSize > 0 then'
      '    begin'
      '      Dest[0] := #0;'
      '      Result := Dest;'
      '    end'
      '    else'
      '    begin'
      '      Result := '#39#39';'
      '    end;'
      '    Exit;'
      '  end;'
      ''
      
        '  Move(Source[Low(string)], Dest[0], Length(Source) * SizeOf(Wid' +
        'eChar));'
      '  Dest[Length(Source)] := #0;'
      '  Result := Dest;'
      'end;'
      ''
      '{ ----------------------------------------------------- }'
      '{       OLE string support                              }'
      '{ ----------------------------------------------------- }'
      ''
      'function OleStrToString(Source: PWideChar): UnicodeString;'
      'begin'
      '  OleStrToStrVar(Source, Result);'
      'end;'
      ''
      'procedure OleStrToStrVar(Source: PWideChar; var Dest: _AnsiStr);'
      'begin'
      
        '  WideCharLenToStrVar(Source, Length(_WideStr(Pointer(Source))),' +
        ' Dest);'
      'end;'
      ''
      
        'procedure OleStrToStrVar(Source: PWideChar; var Dest: UnicodeStr' +
        'ing);'
      'begin'
      
        '  WideCharLenToStrVar(Source, Length(_WideStr(Pointer(Source))),' +
        ' Dest);'
      'end;'
      ''
      'function StringToOleStr(const Source: _AnsiStr): PWideChar;'
      'begin'
      '  Result := nil;'
      
        '  _WStrFromPCharLen(_WideStr(Pointer(Result)), _PAnsiChr(Pointer' +
        '(Source)), Length(Source));'
      'end;'
      ''
      
        'function StringToOleStr(const Source: UnicodeString): PWideChar;' +
        ' overload;'
      'begin'
      '  Result := nil;'
      
        '  _WStrFromPWCharLen(_WideStr(Pointer(Result)), PWideChar(Pointe' +
        'r(Source)), Length(Source));'
      'end;'
      ''
      '{ ----------------------------------------------------- }'
      '{       Variant manager support   (obsolete)            }'
      '{ ----------------------------------------------------- }'
      ''
      'procedure GetVariantManager(var VarMgr: TVariantManager);'
      'begin'
      '  FillChar(VarMgr, sizeof(VarMgr), 0);'
      'end;'
      ''
      'procedure SetVariantManager(const VarMgr: TVariantManager);'
      'begin'
      'end;'
      ''
      'function IsVariantManagerSet: Boolean;'
      'begin'
      '  Result := False;'
      'end;'
      ''
      
        '                                                                ' +
        ' '
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _IntfDispCall(Result: Pointer; const Dispatch: IDispat' +
        'ch;'
      '  DispDesc: PDispDesc); cdecl; varargs;'
      'type'
      
        '  TDispCallByIDProc = procedure(Result: Pointer; const Dispatch:' +
        ' IDispatch;'
      '    DispDesc: PDispDesc; Params: Pointer); cdecl;'
      'var'
      '  VAList: TVarArgList;'
      'begin'
      '  VarArgStart(VAList);'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '                                             '
      
        '  TDispCallByIDProc(DispCallByIDProc)(Result, Dispatch, DispDesc' +
        ', @VAList);'
      '  {$ELSE}'
      
        '  TDispCallByIDProc(DispCallByIDProc)(Result, Dispatch, DispDesc' +
        ', Pointer(VAList));'
      '  {$ENDIF}'
      '  VarArgEnd(VAList);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _IntfDispCall;'
      'asm'
      '{$IFDEF PIC}'
      '        PUSH    EAX'
      '        PUSH    ECX'
      '        CALL    GetGOT'
      '        POP     ECX'
      '        LEA     EAX,[EAX].OFFSET DispCallByIDProc'
      '        MOV     EAX,[EAX]'
      '        XCHG    EAX,[ESP]'
      '        RET'
      '{$ELSE}'
      '        JMP     DispCallByIDProc'
      '{$ENDIF}'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      
        '                                                                ' +
        '      '
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _DispCallByIDError(Result: Pointer; const Dispatch: ID' +
        'ispatch;'
      '  DispDesc: PDispDesc; Params: Pointer); cdecl;'
      'begin'
      '  ErrorAt(byte(reVarDispatch), ReturnAddress);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _DispCallByIDError;'
      'asm'
      '        MOV     AL,reVarDispatch'
      '        JMP     Error'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF not defined(X86ASMRTL)}'
      'procedure _IntfVarCall(Dest: PVarData; const Source: TVarData;'
      '  CallDesc: PCallDesc); cdecl; varargs;'
      '{$ELSE X86ASMRTL}'
      'procedure _IntfVarCall;'
      '{$ENDIF X86ASMRTL}'
      'begin'
      'end;'
      ''
      '{$IF defined(CPUX86) and defined(ASSEMBLER)}'
      '// 64 bit integer helper routines'
      '//'
      '// These functions always return the 64-bit result in EDX:EAX'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit signed multiply'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//'
      
        '//  Param 1(EDX:EAX), Param 2([ESP+8]:[ESP+4])  ; before reg pus' +
        'hing'
      '//'
      'procedure __llmul;'
      'asm //StackAlignSafe'
      '        PUSH  EDX'
      '        PUSH  EAX'
      ''
      '  // Param2 : [ESP+16]:[ESP+12]  (hi:lo)'
      '  // Param1 : [ESP+4]:[ESP]      (hi:lo)'
      ''
      '        MOV   EAX, [ESP+16]'
      '        MUL   DWORD PTR [ESP]'
      '        MOV   ECX, EAX'
      ''
      '        MOV   EAX, [ESP+4]'
      '        MUL   DWORD PTR [ESP+12]'
      '        ADD   ECX, EAX'
      ''
      '        MOV   EAX, [ESP]'
      '        MUL   DWORD PTR [ESP+12]'
      '        ADD   EDX, ECX'
      ''
      '        POP   ECX'
      '        POP   ECX'
      ''
      '        RET   8'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit signed multiply, with overflow check'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//'
      '//  Param1 ~= U   (Uh, Ul)'
      '//  Param2 ~= V   (Vh, Vl)'
      '//'
      
        '//  Param 1(EDX:EAX), Param 2([ESP+8]:[ESP+4])  ; before reg pus' +
        'hing'
      '//'
      '//  compiler-helper function'
      '//  O-flag set on exit   => result is invalid'
      '//  O-flag clear on exit => result is valid'
      'procedure __llmulo;'
      'asm //StackAlignSafe'
      '        PUSH  EDI'
      '        PUSH  ESI'
      '        PUSH  EBX'
      '        PUSH  ECX'
      ''
      '//  Param 1 : [ESP+4]:[ESP+0] and EDX:EAX, Param1(hi:lo)'
      '//  Param 2 : [ESP+24]:[ESP+20] (hi:lo)'
      ''
      '        MOV     EBX, [ESP+20]'
      '        MOV     ECX, [ESP+24]'
      '        MOV     EDI, ECX'
      '        OR      EDI, EDX'
      '        JZ      @@02'
      '        MOV     ESI, ECX'
      '        MOV     EDI, EDX'
      '        SAR     ESI, 31'
      '        SAR     EDI, 31'
      '        XOR     EBX, ESI'
      '        XOR     ECX, ESI'
      '        XOR     EAX, EDI'
      '        XOR     EDX, EDI'
      '        SUB     EBX, ESI'
      '        SBB     ECX, ESI'
      '        SUB     EAX, EDI'
      '        SBB     EDX, EDI'
      '        XOR     EDI, ESI'
      '        TEST    EDX, EDX'
      '        JNZ     @@03'
      '        XCHG    EAX, EBX'
      '        MOV     EDX, ECX'
      '        TEST    ECX, ECX'
      '        JZ      @@02'
      '@@01:   MOV     ECX, EAX'
      '        MOV     EAX, EDX'
      '        MUL     EBX'
      '        JO      @@Done'
      '        TEST    EAX, EAX'
      '        JS      @@OverFlow'
      '        XCHG    EAX, ECX'
      '@@02:   MUL     EBX'
      '        TEST    EDX, EDX'
      '        JS      @@OverFlow'
      '        ADD     EDX, ECX'
      '        JO      @@Done'
      '        XOR     EAX, EDI'
      '        XOR     EDX, EDI'
      '        SUB     EAX, EDI'
      '        SBB     EDX, EDI'
      '@@Done: POP     ECX'
      '        POP     EBX'
      '        POP     ESI'
      '        POP     EDI'
      '        RET     8'
      ''
      '@@03:   TEST    ECX, ECX'
      '        JZ      @@01'
      '@@OverFlow:'
      '        MOV     EAX, $80000000 // Set Overflow'
      '        DEC     EAX'
      '        JMP     @@Done'
      'end;'
      ''
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit unsigned multiply, with overflow check'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//'
      '//  Param1 ~= U   (Uh, Ul)'
      '//  Param2 ~= V   (Vh, Vl)'
      '//'
      
        '//  Param 1(EDX:EAX), Param 2([ESP+8]:[ESP+4])  ; before reg pus' +
        'hing'
      '//'
      '//  compiler-helper function'
      '//  CF-flag set on exit   => overflow. result is invalid'
      '//  CF-flag clear on exit => result is valid'
      ''
      'procedure __llumulo;'
      'asm //StackAlignSafe'
      '        PUSH    EBX'
      '        PUSH    ECX'
      ''
      '//  Param 1 : [ESP+4]:[ESP+0] and EDX:EAX, Param1(hi:lo)'
      '//  Param 2 : [ESP+16]:[ESP+12] (hi:lo)'
      ''
      '        MOV     EBX, [ESP+12]'
      '        MOV     ECX, [ESP+16]'
      '        TEST    EDX, EDX'
      '        JNZ     @@03'
      '        XCHG    EAX, EBX'
      '        MOV     EDX, ECX'
      '        TEST    ECX, ECX'
      '        JZ      @@02'
      '@@01:   MOV     ECX, EAX'
      '        MOV     EAX, EDX'
      '        MUL     EBX'
      '        JC      @@Done'
      '        XCHG    EAX, ECX'
      '@@02:   MUL     EBX'
      '        ADD     EDX, ECX'
      '@@Done: POP     ECX'
      '        POP     EBX'
      '        RET     8'
      ''
      '@@03:   TEST    ECX, ECX'
      #9'JZ      @@01'
      '        STC'
      '        JMP     @@Done'
      'end;'
      ''
      '(* ***** BEGIN LICENSE BLOCK *****'
      ' *'
      
        ' * The function __lldiv is licensed under the CodeGear license t' +
        'erms.'
      ' *'
      ' * The initial developer of the original code is Fastcode'
      ' *'
      
        ' * Portions created by the initial developer are Copyright (C) 2' +
        '002-2004'
      ' * the initial developer. All Rights Reserved.'
      ' *'
      ' * Contributor(s): AMD, John O'#39'Harrow and Dennis Christensen'
      ' *'
      ' * ***** END LICENSE BLOCK ***** *)'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit signed division'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      ''
      '//'
      '//  Dividend = Numerator, Divisor = Denominator'
      '//'
      
        '//  Dividend(EDX:EAX), Divisor([ESP+8]:[ESP+4])  ; before reg pu' +
        'shing'
      '//'
      '//'
      'procedure __lldiv; //JOH Version'
      'asm //StackAlignSafe'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        PUSH    EBP'
      '        MOV     EBP, ESP'
      '{$ENDIF}'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        MOV     EBX, [ESP+20]'
      '        MOV     ECX, [ESP+24]'
      '{$ELSE !PC_MAPPED_EXCEPTIONS}'
      '        MOV     EBX, [ESP+16]'
      '        MOV     ECX, [ESP+20]'
      '{$ENDIF !PC_MAPPED_EXCEPTIONS}'
      '        MOV     ESI, EDX'
      '        MOV     EDI, ECX'
      '        SAR     ESI, 31'
      '        XOR     EAX, ESI'
      '        XOR     EDX, ESI'
      '        SUB     EAX, ESI'
      '        SBB     EDX, ESI          // EDX:EAX := abs(Dividend)'
      '        SAR     EDI, 31'
      '        XOR     ESI, EDI          // 0 if X and Y have same sign'
      '        XOR     EBX, EDI'
      '        XOR     ECX, EDI'
      '        SUB     EBX, EDI'
      '        SBB     ECX, EDI          // ECX:EBX := abs(Divisor)'
      '        JNZ     @@BigDivisor      // divisor > 32^32-1'
      
        '        CMP     EDX, EBX          // only one division needed ? ' +
        '(ecx = 0)'
      
        '        JB      @@OneDiv          // yes, one division sufficien' +
        't'
      '        MOV     ECX, EAX          // save dividend-lo in ecx'
      '        MOV     EAX, EDX          // get dividend-hi'
      '        XOR     EDX, EDX          // zero extend it into edx:eax'
      '        DIV     EBX               // quotient-hi in eax'
      
        '        XCHG    EAX, ECX          // ecx = quotient-hi, eax =div' +
        'idend-lo'
      '@@OneDiv:'
      '        DIV     EBX               // eax = quotient-lo'
      
        '        MOV     EDX, ECX          // edx = quotient-hi(quotient ' +
        'in edx:eax)'
      '        JMP     @SetSign'
      '@@BigDivisor:'
      
        '        SUB     ESP, 12           // Create three local variable' +
        's.'
      '        MOV     [ESP  ], EAX      // dividend_lo'
      '        MOV     [ESP+4], EBX      // divisor_lo'
      '        MOV     [ESP+8], EDX      // dividend_hi'
      '        MOV     EDI, ECX          //  edi:ebx and ecx:esi'
      '        SHR     EDX, 1            // shift both'
      '        RCR     EAX, 1            //  divisor and'
      '        ROR     EDI, 1            //   and dividend'
      '        RCR     EBX, 1            //    right by 1 bit'
      
        '        BSR     ECX, ECX          // ecx = number of remaining s' +
        'hifts'
      '        SHRD    EBX, EDI, CL      // scale down divisor and'
      
        '        SHRD    EAX, EDX, CL      //   dividend such that diviso' +
        'r'
      
        '        SHR     EDX, CL           //    less than 2^32 (i.e. fit' +
        's in ebx)'
      
        '        ROL     EDI, 1            // restore original divisor (e' +
        'di:esi)'
      '        DIV     EBX               // compute quotient'
      '        MOV     EBX, [ESP]        // dividend_lo'
      '        MOV     ECX, EAX          // save quotient'
      
        '        IMUL    EDI, EAX          // quotient * divisor hi-word ' +
        '(low only)'
      '        MUL     DWORD PTR [ESP+4] // quotient * divisor low word'
      
        '        ADD     EDX, EDI          // edx:eax = quotient * diviso' +
        'r'
      
        '        SUB     EBX, EAX          // dividend-lo - (quot.*diviso' +
        'r)-lo'
      '        MOV     EAX, ECX          // get quotient'
      '        MOV     ECX, [ESP+8]      // dividend_hi'
      
        '        SBB     ECX, EDX          // subtract divisor * quot. fr' +
        'om dividend'
      
        '        SBB     EAX, 0            // Adjust quotient if remainde' +
        'r is negative.'
      
        '        XOR     EDX, EDX          // clear hi-word of quot (eax<' +
        '=FFFFFFFFh)'
      '        ADD     ESP, 12           // Remove local variables.'
      '@SetSign:'
      '        XOR     EAX, ESI          // If (quotient < 0),'
      
        '        XOR     EDX, ESI          //   compute 1'#39's complement of' +
        ' result.'
      '        SUB     EAX, ESI          // If (quotient < 0),'
      
        '        SBB     EDX, ESI          //   compute 2'#39's complement of' +
        ' result.'
      '@Done:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        POP     EBP'
      '{$ENDIF}'
      '        RET     8'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      
        '//  64-bit signed division with overflow check (98.05.15: not im' +
        'plementated yet)'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      ''
      '//'
      '//  Dividend = Numerator, Divisor = Denominator'
      '//'
      '//  Dividend(EDX:EAX), Divisor([ESP+8]:[ESP+4])'
      '//  Param 1 (EDX:EAX), Param 2([ESP+8]:[ESP+4])'
      '//'
      '//  Param1 ~= U   (Uh, Ul)'
      '//  Param2 ~= V   (Vh, Vl)'
      '//'
      '//  compiler-helper function'
      '//  O-flag set on exit   => result is invalid'
      '//  O-flag clear on exit => result is valid'
      '//'
      'procedure __lldivo;'
      'asm //StackAligned'
      
        '    //Don'#39't need to stack align only calls local __lldiv which d' +
        'oesn'#39't not call anything else'
      '  // check for overflow condition: min(int64) DIV -1'
      '        push  esi'
      '        mov esi, [esp+12]   // Vh'
      '        and esi, [esp+8]    // Vl'
      '        cmp esi, 0ffffffffh   // V = -1?'
      '        jne @@divok'
      ''
      '        mov esi, eax'
      '        or  esi, edx'
      '        cmp esi, 80000000H    // U = min(int64)?'
      '        jne @@divok'
      ''
      '@@divOvl:'
      '        mov eax, esi'
      '        pop esi'
      '        dec eax                     // turn on O-flag'
      '        ret 8'
      ''
      '@@divok:'
      '        pop esi'
      '        push  dword ptr [esp+8]   // Vh'
      
        '        push  dword ptr [esp+8]   // Vl (offset is changed from ' +
        'push)'
      ''
      '        call  __lldiv'
      '        and eax, eax    // turn off O-flag'
      '        ret 8'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit unsigned division'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      ''
      
        '//  Dividend(EAX(hi):EDX(lo)), Divisor([ESP+8](hi):[ESP+4](lo)) ' +
        ' // before reg pushing'
      'procedure __lludiv;'
      'asm //StackAlignSafe'
      '        PUSH    EBP'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        MOV     EBP, ESP'
      '{$ENDIF}'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '//'
      '//       Now the stack looks something like this:'
      '//'
      '//               24[esp]: divisor (high dword)'
      '//               20[esp]: divisor (low dword)'
      '//               16[esp]: return EIP'
      '//               12[esp]: previous EBP'
      '//                8[esp]: previous EBX'
      '//                4[esp]: previous ESI'
      '//                 [esp]: previous EDI'
      '//'
      ''
      
        '//       dividend is pushed last, therefore the first in the arg' +
        's'
      '//       divisor next.'
      '//'
      
        '        MOV     EBX,20[ESP]             // get the first low wor' +
        'd'
      
        '        MOV     ECX,24[ESP]             // get the first high wo' +
        'rd'
      ''
      '        OR      ECX,ECX'
      
        '        JNZ     @__lludiv@slow_ldiv     // both high words are z' +
        'ero'
      ''
      '        OR      EDX,EDX'
      '        JZ      @__lludiv@quick_ldiv'
      ''
      '        or      ebx,ebx'
      
        '        JZ      @__lludiv@quick_ldiv    // if ecx:ebx == 0 force' +
        ' a zero divide'
      '          // we don'#39't expect this to actually'
      '          // work'
      ''
      '@__lludiv@slow_ldiv:'
      '        MOV     EBP,ECX'
      '        MOV     ECX,64                  // shift counter'
      
        '        XOR     EDI,EDI                 // fake a 64 bit dividen' +
        'd'
      '        XOR     ESI,ESI'
      ''
      '@__lludiv@xloop:'
      
        '        SHL     EAX,1                   // shift dividend left o' +
        'ne bit'
      '        RCL     EDX,1'
      '        RCL     ESI,1'
      '        RCL     EDI,1'
      '        CMP     EDI,EBP                 // dividend larger?'
      '        JB      @__lludiv@nosub'
      '        JA      @__lludiv@subtract'
      '        CMP     ESI,EBX                 // maybe'
      '        JB      @__lludiv@nosub'
      ''
      '@__lludiv@subtract:'
      '        SUB     ESI,EBX'
      '        SBB     EDI,EBP                 // subtract the divisor'
      '        INC     EAX                     // build quotient'
      ''
      '@__lludiv@nosub:'
      '        loop    @__lludiv@xloop'
      '//'
      
        '//       When done with the loop the four registers values'#39' look' +
        ' like:'
      '//'
      '//       |     edi    |    esi     |    edx     |    eax     |'
      '//       |        remainder        |         quotient        |'
      '//'
      ''
      '@__lludiv@finish:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        POP     EBP'
      '        RET     8'
      ''
      '@__lludiv@quick_ldiv:'
      '        DIV     EBX                     // unsigned divide'
      '        XOR     EDX,EDX'
      '        JMP     @__lludiv@finish'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit modulo'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      ''
      
        '//  Dividend(EDX:EAX), Divisor([ESP+8]:[ESP+4])  // before reg p' +
        'ushing'
      'procedure __llmod;'
      'asm //StackAlignSafe'
      '        PUSH    EBP'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        MOV     EBP, ESP'
      '{$ENDIF}'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        XOR     EDI,EDI'
      '//'
      
        '//       dividend is pushed last, therefore the first in the arg' +
        's'
      '//       divisor next.'
      '//'
      
        '        MOV     EBX,20[ESP]             // get the first low wor' +
        'd'
      
        '        MOV     ECX,24[ESP]             // get the first high wo' +
        'rd'
      '        OR      ECX,ECX'
      
        '        JNZ     @__llmod@slow_ldiv      // both high words are z' +
        'ero'
      ''
      '        OR      EDX,EDX'
      '        JZ      @__llmod@quick_ldiv'
      ''
      '        OR      EBX,EBX'
      
        '        JZ      @__llmod@quick_ldiv     // if ecx:ebx == 0 force' +
        ' a zero divide'
      '          // we don'#39't expect this to actually'
      '          // work'
      '@__llmod@slow_ldiv:'
      '//'
      
        '//               Signed division should be done.  Convert negati' +
        've'
      '//               values to positive and do an unsigned division.'
      '//               Store the sign value in the next higher bit of'
      
        '//               di (test mask of 4).  Thus when we are done, te' +
        'sting'
      '//               that bit will determine the sign of the result.'
      '//'
      '        OR      EDX,EDX                 // test sign of dividend'
      '        JNS     @__llmod@onepos'
      '        NEG     EDX'
      '        NEG     EAX'
      '        SBB     EDX,0                   // negate dividend'
      '        OR      EDI,1'
      ''
      '@__llmod@onepos:'
      '        OR      ECX,ECX                 // test sign of divisor'
      '        JNS     @__llmod@positive'
      '        NEG     ECX'
      '        NEG     EBX'
      '        SBB     ECX,0                   // negate divisor'
      ''
      '@__llmod@positive:'
      '        MOV     EBP,ECX'
      '        MOV     ECX,64                  // shift counter'
      '        PUSH    EDI                     // save the flags'
      '//'
      '//       Now the stack looks something like this:'
      '//'
      '//               24[esp]: divisor (high dword)'
      '//               20[esp]: divisor (low dword)'
      '//               16[esp]: return EIP'
      '//               12[esp]: previous EBP'
      '//                8[esp]: previous EBX'
      '//                4[esp]: previous ESI'
      '//                 [esp]: previous EDI'
      '//'
      
        '        XOR     EDI,EDI                 // fake a 64 bit dividen' +
        'd'
      '        XOR     ESI,ESI'
      ''
      '@__llmod@xloop:'
      
        '        SHL     EAX,1                   // shift dividend left o' +
        'ne bit'
      '        RCL     EDX,1'
      '        RCL     ESI,1'
      '        RCL     EDI,1'
      '        CMP     EDI,EBP                 // dividend larger?'
      '        JB      @__llmod@nosub'
      '        JA      @__llmod@subtract'
      '        CMP     ESI,EBX                 // maybe'
      '        JB      @__llmod@nosub'
      ''
      '@__llmod@subtract:'
      '        SUB     ESI,EBX'
      '        SBB     EDI,EBP                 // subtract the divisor'
      '        INC     EAX                     // build quotient'
      ''
      '@__llmod@nosub:'
      '        LOOP    @__llmod@xloop'
      '//'
      
        '//       When done with the loop the four registers values'#39' look' +
        ' like:'
      '//'
      '//       |     edi    |    esi     |    edx     |    eax     |'
      '//       |        remainder        |         quotient        |'
      '//'
      '        MOV     EAX,ESI'
      '        mov     edx,edi                 // use remainder'
      ''
      '        POP     EBX                     // get control bits'
      '        TEST    EBX,1                   // needs negative'
      '        JZ      @__llmod@finish'
      '        NEG     EDX'
      '        NEG     EAX'
      '        SBB     EDX,0                    // negate'
      ''
      '@__llmod@finish:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        POP     EBP'
      '        RET     8'
      ''
      '@__llmod@quick_ldiv:'
      '        DIV     EBX                     // unsigned divide'
      '        XCHG    EAX,EDX'
      '        XOR     EDX,EDX'
      '        JMP     @__llmod@finish'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      
        '//  64-bit signed modulo with overflow (98.05.15: overflow not y' +
        'et supported)'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      ''
      '//  Dividend(EDX:EAX), Divisor([ESP+8]:[ESP+4])'
      '//  Param 1 (EDX:EAX), Param 2([ESP+8]:[ESP+4])'
      '//'
      '//  Param1 ~= U   (Uh, Ul)'
      '//  Param2 ~= V   (Vh, Vl)'
      '//'
      '//  compiler-helper function'
      '//  O-flag set on exit   => result is invalid'
      '//  O-flag clear on exit => result is valid'
      '//'
      'procedure __llmodo;'
      'asm //StackAlignSafe'
      
        '    //Don'#39't need to stack align only calls local __llmod which d' +
        'oesn'#39't not call anything else'
      '  // check for overflow condition: min(int64) MOD -1'
      '        PUSH  ESI'
      '        MOV   ESI, [ESP+12]     // Vh'
      '        AND   ESI, [ESP+8]      // Vl'
      '        CMP   ESI, 0FFFFFFFFH   // V = -1?'
      '        JNE   @@modok'
      ''
      '        MOV   ESI, EAX'
      '        OR    ESI, EDX'
      '        CMP   ESI, 80000000H    // U = min(int64)?'
      '        JNE   @@modok'
      ''
      '@@modOvl:'
      '        MOV   EAX, ESI'
      '        POP   ESI'
      '        DEC   EAX               // turn on O-flag'
      '        RET   8'
      ''
      '@@modok:'
      '        POP   ESI'
      '        PUSH  DWORD PTR [ESP+8] // Vh'
      
        '        PUSH  DWORD PTR [ESP+8] // Vl (offset is changed from pu' +
        'sh)'
      ''
      '        CALL  __llmod'
      '        AND   EAX, EAX    // turn off O-flag'
      '        RET   8'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit unsigned modulo'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      
        '//  Dividend(EAX(hi):EDX(lo)), Divisor([ESP+8](hi):[ESP+4](lo)) ' +
        ' // before reg pushing'
      'procedure __llumod;'
      'asm //StackAlignSafe'
      '        PUSH    EBP'
      '{$IFDEF PC_MAPPED_EXCEPTIONS}'
      '        MOV     EBP, ESP'
      '{$ENDIF}'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '//'
      '//       Now the stack looks something like this:'
      '//'
      '//               24[esp]: divisor (high dword)'
      '//               20[esp]: divisor (low dword)'
      '//               16[esp]: return EIP'
      '//               12[esp]: previous EBP'
      '//                8[esp]: previous EBX'
      '//                4[esp]: previous ESI'
      '//                 [esp]: previous EDI'
      '//'
      ''
      
        '//       dividend is pushed last, therefore the first in the arg' +
        's'
      '//       divisor next.'
      '//'
      
        '        MOV     EBX,20[ESP]             // get the first low wor' +
        'd'
      
        '        MOV     ECX,24[ESP]             // get the first high wo' +
        'rd'
      '        OR      ECX,ECX'
      
        '        JNZ     @__llumod@slow_ldiv     // both high words are z' +
        'ero'
      ''
      '        OR      EDX,EDX'
      '        JZ      @__llumod@quick_ldiv'
      ''
      '        OR      EBX,EBX'
      
        '        JZ      @__llumod@quick_ldiv    // if ecx:ebx == 0 force' +
        ' a zero divide'
      '          // we don'#39't expect this to actually'
      '          // work'
      '@__llumod@slow_ldiv:'
      '        MOV     EBP,ECX'
      '        MOV     ECX,64                  // shift counter'
      
        '        XOR     EDI,EDI                 // fake a 64 bit dividen' +
        'd'
      '        XOR     ESI,ESI                 //'
      ''
      '@__llumod@xloop:'
      
        '        SHL     EAX,1                   // shift dividend left o' +
        'ne bit'
      '        RCL     EDX,1'
      '        RCL     ESI,1'
      '        RCL     EDI,1'
      '        CMP     EDI,EBP                 // dividend larger?'
      '        JB      @__llumod@nosub'
      '        JA      @__llumod@subtract'
      '        CMP     ESI,EBX                 // maybe'
      '        JB      @__llumod@nosub'
      ''
      '@__llumod@subtract:'
      '        SUB     ESI,EBX'
      '        SBB     EDI,EBP                 // subtract the divisor'
      '        INC     EAX                     // build quotient'
      ''
      '@__llumod@nosub:'
      '        LOOP    @__llumod@xloop'
      '//'
      
        '//       When done with the loop the four registers values'#39' look' +
        ' like:'
      '//'
      '//       |     edi    |    esi     |    edx     |    eax     |'
      '//       |        remainder        |         quotient        |'
      '//'
      '        MOV     EAX,ESI'
      '        MOV     EDX,EDI                 // use remainder'
      ''
      '@__llumod@finish:'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      '        POP     EBP'
      '        RET     8'
      ''
      '@__llumod@quick_ldiv:'
      '        DIV     EBX                     // unsigned divide'
      '        XCHG    EAX,EDX'
      '        XOR     EDX,EDX'
      '        jmp     @__llumod@finish'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit shift left'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      ''
      '// target (EDX:EAX) count (ECX)'
      '//'
      'procedure __llshl;'
      'asm //StackAlignSafe'
      '        AND   CL, $3F'
      '        CMP   CL, 32'
      '        JL    @__llshl@below32'
      '        MOV   EDX, EAX'
      '        SHL   EDX, CL'
      '        XOR   EAX, EAX'
      '        RET'
      ''
      '@__llshl@below32:'
      '        SHLD  EDX, EAX, CL'
      '        SHL   EAX, CL'
      '        RET'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit signed shift right'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '// target (EDX:EAX) count (ECX)'
      'procedure __llshr;'
      'asm //StackAlignSafe'
      '        AND   CL, $3F'
      '        CMP   CL, 32'
      '        JL    @__llshr@below32'
      '        MOV   EAX, EDX'
      '        CDQ'
      '        SAR   EAX,CL'
      '        RET'
      ''
      '@__llshr@below32:'
      '        SHRD  EAX, EDX, CL'
      '        SAR   EDX, CL'
      '        RET'
      'end;'
      ''
      
        '// -------------------------------------------------------------' +
        '-----------------'
      '//  64-bit unsigned shift right'
      
        '// -------------------------------------------------------------' +
        '-----------------'
      ''
      '// target (EDX:EAX) count (ECX)'
      'procedure __llushr;'
      'asm //StackAlignSafe'
      '        and cl, $3F'
      '        cmp cl, 32'
      '        jl  @__llushr@below32'
      '        mov eax, edx'
      '        xor edx, edx'
      '        shr eax, cl'
      '        ret'
      ''
      '@__llushr@below32:'
      '        shrd  eax, edx, cl'
      '        shr edx, cl'
      '        ret'
      'end;'
      '{$ENDIF}'
      ''
      
        'function _StrUInt64Digits(val: UInt64; width: Integer; sign: Boo' +
        'lean): _ShortStr;'
      'var'
      '  d: array[0..31] of Char;  { need 19 digits and a sign }'
      '  i, k: Integer;'
      '  spaces: Integer;'
      'begin'
      
        '  { Produce an ASCII representation of the number in reverse ord' +
        'er }'
      '  i := 0;'
      '  repeat'
      '    d[i] := Chr( (val mod 10) + Ord('#39'0'#39') );'
      '    Inc(i);'
      '    val := val div 10;'
      '  until val = 0;'
      '  if sign then'
      '  begin'
      '    d[i] := '#39'-'#39';'
      '    Inc(i);'
      '  end;'
      ''
      '  { Fill the Result with the appropriate number of blanks }'
      '  if width > 255 then'
      '    width := 255;'
      '  k := 1;'
      '  spaces := width - i;'
      '  while k <= spaces do'
      '  begin'
      '    Result[k] := _AnsiChr('#39' '#39');'
      '    Inc(k);'
      '  end;'
      ''
      '  { Fill the Result with the number }'
      '  while i > 0 do'
      '  begin'
      '    Dec(i);'
      '    Result[k] := _AnsiChr(d[i]);'
      '    Inc(k);'
      '  end;'
      ''
      '  { Result is k-1 characters long }'
      '  SetLength(Result, k-1);'
      'end;'
      ''
      'function _StrInt64(val: Int64; width: Integer): _ShortStr;'
      'begin'
      '  Result := _StrUInt64Digits(Abs(val), width, val < 0);'
      'end;'
      ''
      'function _Str0Int64(val: Int64): _ShortStr;'
      'begin'
      '  Result := _StrInt64(val, 0);'
      'end;'
      ''
      'function _StrUInt64(val: UInt64; width: Integer): _ShortStr;'
      'begin'
      '  Result := _StrUInt64Digits(val, width, False);'
      'end;'
      ''
      'function _Str0UInt64(val: Int64): _ShortStr;'
      'begin'
      '  Result := _StrUInt64(val, 0);'
      'end;'
      ''
      
        'function _WriteInt64(var t: TTextRec; val: Int64; width: Integer' +
        '): Pointer;'
      'var'
      '  s: _ShortStr;'
      'begin'
      '  s := _StrInt64(val, 0);'
      '  Result := _WriteString(t, s, width);'
      'end;'
      ''
      'function _Write0Int64(var t: TTextRec; val: Int64): Pointer;'
      'begin'
      '  Result := _WriteInt64(t, val, 0);'
      'end;'
      ''
      
        'function _WriteUInt64(var t: TTextRec; val: UInt64; width: Integ' +
        'er): Pointer;'
      'var'
      '  s: _ShortStr;'
      'begin'
      '  s := _StrUInt64Digits(val, 0, False);'
      '  Result := _WriteString(t, s, width);'
      'end;'
      ''
      'function _Write0UInt64(var t: TTextRec; val: UInt64): Pointer;'
      'begin'
      '  Result := _WriteUInt64(t, val, 0);'
      'end;'
      ''
      
        'function _ValInt64L(const s: _AnsiStr; var code: Integer): Int64' +
        ';'
      'begin'
      '  Result := _ValInt64(string(s), code);'
      'end;'
      ''
      'function _ReadInt64(var t: TTextRec): Int64;'
      'var'
      '  p: PWord;'
      '  count: Integer;'
      '  c: Byte;'
      '  eof: Boolean;'
      '  code: Integer;'
      '  u: UnicodeString;'
      'begin'
      '  if _SeekEof(t) then'
      '    Result := 0'
      '  else'
      '  begin'
      '    SetLength(U, 32);'
      '    p := PWord(U);'
      '    for count := 1 to 32 do'
      '    begin'
      '      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '      if c <= $20 then break;'
      '      p^ := c;'
      '      _SkipAnsiChar(t);'
      '      Inc(p);'
      '    end;'
      '    SetLength(U, (PByte(p) - PByte(U)) div sizeof(word));'
      '    Result := _ValInt64(u, code);'
      '    if code <> 0 then'
      '      SetInOutRes(106);'
      '  end;'
      'end;'
      ''
      '                                              '
      'function _ReadUInt64(var t: TTextRec): UInt64;'
      'var'
      '  p: PWord;'
      '  count: Integer;'
      '  c: Byte;'
      '  eof: Boolean;'
      '  code: Integer;'
      '  u: UnicodeString;'
      'begin'
      '  if _SeekEof(t) then'
      '    Result := 0'
      '  else'
      '  begin'
      '    SetLength(U, 32);'
      '    p := PWord(U);'
      '    for count := 1 to 32 do'
      '    begin'
      '      c := _GetAnsiChar(t, eof, DefaultSystemCodePage);'
      '      if c <= $20 then break;'
      '      p^ := c;'
      '      _SkipAnsiChar(t);'
      '      Inc(p);'
      '    end;'
      '    SetLength(U, (PByte(p) - PByte(U)) div sizeof(word));'
      '    Result := _ValUInt64(u, code);'
      '    if code <> 0 then'
      '      SetInOutRes(106);'
      '  end;'
      'end;'
      ''
      'function _ValInt64(const S: string; var Code: Integer): Int64;'
      'const'
      '  FirstIndex = Low(string);'
      'var'
      '  I: Integer;'
      '  Dig: Integer;'
      '  Sign: Boolean;'
      '  Empty: Boolean;'
      'begin'
      '  I := FirstIndex;'
      '  Sign := False;'
      '  Result := 0;'
      '  Empty := True;'
      ''
      '  if S = '#39#39' then'
      '  begin'
      '    Code := 1;'
      '    Exit;'
      '  end;'
      '  while S[I] = '#39' '#39' do'
      '    Inc(I);'
      ''
      '  if S[I] = '#39'-'#39' then'
      '  begin'
      '    Sign := True;'
      '    Inc(I);'
      '  end'
      '  else if S[I] = '#39'+'#39' then'
      '    Inc(I);'
      '  // Hex'
      
        '  if ((S[I] = '#39'0'#39') and (I < High(S)) and ((S[I+1] = '#39'X'#39') or (S[I' +
        '+1] = '#39'x'#39'))) or'
      '      (S[I] = '#39'$'#39') or'
      '      (S[I] = '#39'X'#39') or'
      '      (S[I] = '#39'x'#39') then'
      '  begin'
      '    if S[I] = '#39'0'#39' then'
      '      Inc(I);'
      '    Inc(I);'
      '    while True do'
      '    begin'
      '      case S[I] of'
      '       '#39'0'#39'..'#39'9'#39': Dig := Ord(S[I]) - Ord('#39'0'#39');'
      '       '#39'A'#39'..'#39'F'#39': Dig := Ord(S[I]) - Ord('#39'A'#39') + 10;'
      '       '#39'a'#39'..'#39'f'#39': Dig := Ord(S[I]) - Ord('#39'a'#39') + 10;'
      '      else'
      '        Break;'
      '      end;'
      '      if (Result < 0) or (Result > (High(Int64) shr 3)) then'
      '        Break;'
      '      Result := Result shl 4 + Dig;'
      '      Inc(I);'
      '      Empty := False;'
      '    end;'
      ''
      '    if Sign then'
      '      Result := - Result;'
      '  end'
      '  // Decimal'
      '  else'
      '  begin'
      '    while True do'
      '    begin'
      '      case S[I] of'
      '        '#39'0'#39'..'#39'9'#39': Dig := Ord(S[I]) - Ord('#39'0'#39');'
      '      else'
      '        Break;'
      '      end;'
      '      if (Result < 0) or (Result > (High(Int64) div 10)) then'
      '        Break;'
      '      Result := Result*10 + Dig;'
      '      Inc(I);'
      '      Empty := False;'
      '    end;'
      ''
      '    if Sign then'
      '      Result := - Result;'
      '    if (Result <> 0) and (Sign <> (Result < 0)) then'
      '      Dec(I);'
      '  end;'
      ''
      '  if ((S[I] <> Char(#0)) or Empty) then'
      '    Code := I + 1 - FirstIndex'
      '  else'
      '    Code := 0;'
      'end;'
      ''
      '                                             '
      'function _ValUInt64(const s: string; var code: Integer): UInt64;'
      'const'
      '  FirstIndex = Low(string);'
      'var'
      '  i: Integer;'
      '  dig: Integer;'
      '  sign: Boolean;'
      '  empty: Boolean;'
      'begin'
      '  i := FirstIndex;'
      '  Result := 0;'
      '  if s = '#39#39' then'
      '  begin'
      '    code := 1;'
      '    exit;'
      '  end;'
      '  while s[i] = Char('#39' '#39') do'
      '    Inc(i);'
      '  sign := False;'
      '  if s[i] =  Char('#39'-'#39') then'
      '  begin'
      '    sign := True;'
      '    Inc(i);'
      '  end'
      '  else if s[i] =  Char('#39'+'#39') then'
      '    Inc(i);'
      '  empty := True;'
      '  if (s[i] =  Char('#39'$'#39')) or (Upcase(s[i]) =  Char('#39'X'#39'))'
      
        '    or ((s[i] =  Char('#39'0'#39')) and (I < High(S)) and (Upcase(s[i+1]' +
        ') =  Char('#39'X'#39'))) then'
      '  begin'
      '    if s[i] =  Char('#39'0'#39') then'
      '      Inc(i);'
      '    Inc(i);'
      '    while True do'
      '    begin'
      '      case   Char(s[i]) of'
      '       Char('#39'0'#39').. Char('#39'9'#39'): dig := Ord(s[i]) -  Ord('#39'0'#39');'
      
        '       Char('#39'A'#39').. Char('#39'F'#39'): dig := Ord(s[i]) - (Ord('#39'A'#39') - 10)' +
        ';'
      
        '       Char('#39'a'#39').. Char('#39'f'#39'): dig := Ord(s[i]) - (Ord('#39'a'#39') - 10)' +
        ';'
      '      else'
      '        break;'
      '      end;'
      '      if Result > (High(UInt64) shr 4) then'
      '        Break;'
      '      if sign and (dig <> 0) then'
      '        Break;'
      '      Result := Result shl 4 + Cardinal(dig);'
      '      Inc(i);'
      '      empty := False;'
      '    end;'
      '  end'
      '  else'
      '  begin'
      '    while True do'
      '    begin'
      '      case  Char(s[i]) of'
      '        Char('#39'0'#39').. Char('#39'9'#39'): dig := Ord(s[i]) - Ord('#39'0'#39');'
      '      else'
      '        break;'
      '      end;'
      '                // 18446744073709551615'
      '      if Result >= 1844674407370955161 then'
      '      begin'
      
        '        if (Result > 1844674407370955161) or (High(UInt64) - Res' +
        'ult*10 < dig) then'
      '          Break'
      '      end;'
      '      if sign and (dig <> 0) then'
      '        Break;'
      '      Result := Result*10 + Cardinal(dig);'
      '      Inc(i);'
      '      empty := False;'
      '    end;'
      '  end;'
      '  if (s[i] <> Char(#0)) or empty then'
      '    code := i + 1 - FirstIndex'
      '  else'
      '    code := 0;'
      'end;'
      ''
      ''
      '{ ----------------------------------------------------- }'
      '{       Compiler helper for Dynamic array support       }'
      '{ ----------------------------------------------------- }'
      ''
      '// A must be non-nil.'
      'function __DynArrayLength(const A: Pointer): NativeInt; inline;'
      'begin'
      
        '  Result := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec))^.Lengt' +
        'h;'
      'end;'
      ''
      '// A must be non-nil.'
      'function __DynArrayRefCnt(const A: Pointer): Integer; inline;'
      'begin'
      
        '  Result := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec))^.RefCn' +
        't;'
      'end;'
      ''
      
        'procedure __CopyArray(Dest, Source, TypeInfo: Pointer; Count: Na' +
        'tiveInt); inline;'
      'begin'
      '{$IFDEF PUREPASCAL}'
      '  _CopyArray(Dest, Source, TypeInfo, Count);'
      '{$ELSE}'
      '  CopyArray(Dest, Source, TypeInfo, Count);'
      '{$ENDIF}'
      'end;'
      ''
      'function _DynArrayLength(const A: Pointer): NativeInt;'
      'begin'
      '  Result := NativeInt(A);'
      
        '  if Result <> 0 then                                         //' +
        ' TDynArrayRec should be used here but a'
      
        '    Result := PNativeInt(PByte(Result) - SizeOf(NativeInt))^; //' +
        ' private symbol cannot be inlined'
      'end;'
      ''
      'function _DynArrayHigh(const A: Pointer): NativeInt;'
      'begin'
      '  Result := _DynArrayLength(A) - 1;'
      'end;'
      ''
      'procedure DynArrayClear(var A: Pointer; TypeInfo: Pointer);'
      'begin'
      '  _DynArrayClear(a, typeInfo);'
      'end;'
      ''
      'type'
      '  TRegisteredTypeInfo = record'
      '    t: PTypeInfo;'
      '    v: Boolean;'
      '  end;'
      ''
      'var'
      '  // 0 : System.RTTI.TValue'
      '  RegisteredTypeInfoTable: array[0..0] of TRegisteredTypeInfo;'
      ''
      
        'procedure RegisterWeakRefTypeInfo(const aTypeInfo: Pointer; cons' +
        't Value: Boolean; const index: Integer);'
      'begin'
      '  // Order is important.'
      '  RegisteredTypeInfoTable[index].v := Value;'
      '  RegisteredTypeInfoTable[index].t := aTypeInfo;'
      'end;'
      ''
      'function InternalHasWeakRef(elementType: PTypeInfo): Boolean;'
      'type'
      '  PPPTypeInfo = ^PPTypeInfo;'
      'var'
      '  FT: PFieldTable;'
      '  I: Integer;'
      'begin'
      '  Result := True;'
      '  if elementType <> nil then'
      '  begin'
      '    while True do'
      '    begin'
      '{$IF Length(RegisteredTypeInfoTable) = 1}'
      
        '      if RegisteredTypeInfoTable[0].t = elementType then Exit(Re' +
        'gisteredTypeInfoTable[0].v);'
      '{$ENDIF}'
      '{$IF Length(RegisteredTypeInfoTable) = 2}'
      
        '      if RegisteredTypeInfoTable[1].t = elementType then Exit(Re' +
        'gisteredTypeInfoTable[1].v);'
      '{$ENDIF}'
      '{$IF Length(RegisteredTypeInfoTable) > 2}'
      '      for I := 2 to SizeOf(RegisteredTypeInfoTable)-1 do'
      '        if RegisteredTypeInfoTable[I].t = elementType then'
      '          Exit(RegisteredTypeInfoTable[I].v);'
      '{$ENDIF}'
      '      case elementType.Kind of'
      '{$IFDEF WEAKINSTREF}'
      '        tkMethod:'
      '          Exit;'
      '{$ENDIF WEAKINSTREF}'
      '        tkArray:'
      
        '          elementType := PFieldTable(PByte(elementType) + Byte(e' +
        'lementType.Name[0])).Fields[0].TypeInfo^;'
      '        tkMRecord,'
      '        tkRecord:'
      '          begin'
      
        '            FT := PFieldTable(PByte(elementType) + Byte(elementT' +
        'ype.Name[0]));'
      '            if FT.Count > 0 then'
      '              for I := 0 to FT.Count - 1 do'
      '              begin'
      '                if (FT.Fields[I].TypeInfo = nil) then'
      '                  Exit;'
      '                elementType := FT.Fields[I].TypeInfo^;'
      '{$IFDEF WEAKINSTREF}'
      '                if elementType.Kind = tkMethod then'
      '                  Exit'
      '                else'
      '{$ENDIF WEAKINSTREF}'
      
        '                if (elementType.Kind = tkArray) and InternalHasW' +
        'eakRef(PFieldTable(PByte(elementType) + Byte(elementType.Name[0]' +
        ')).Fields[0].TypeInfo^) then'
      '                  Exit'
      
        '                else if (elementType.Kind = tkRecord) and Intern' +
        'alHasWeakRef(elementType) then'
      '                  Exit;'
      '              end;'
      '            Break;'
      '          end;'
      '        else'
      '          Break;'
      '      end;'
      '    end;'
      '  end;'
      '  Result := False;'
      'end;'
      ''
      'threadvar'
      '  PrevElementType: PTypeInfo;'
      '  PrevElementTypeResult: Boolean;'
      ''
      'function SysHasWeakRef(const elementType: Pointer): Boolean;'
      'begin'
      '  if PrevElementType = elementType then'
      '    result := PrevElementTypeResult'
      '  else'
      '  begin'
      '    result := InternalHasWeakRef(elementType);'
      '    PrevElementType := elementType;'
      '    PrevElementTypeResult := result;'
      '  end;'
      'end;'
      ''
      
        'procedure DynArraySetLength(var a: Pointer; typeInfo: Pointer; d' +
        'imCnt: NativeInt; lengthVec: PNativeint);'
      'var'
      '  i,j: NativeInt;'
      '  newLength, oldLength, minLength: NativeInt;'
      '  elSize: NativeInt;'
      '  t: PDynArrayTypeInfo;'
      '  ElTypeInfo: Pointer;'
      '  neededSize: NativeInt;'
      '  p, pp: Pointer;'
      'begin'
      '  p := a;'
      ''
      
        '  // Fetch the new length of the array in this dimension, and th' +
        'e old length'
      '  newLength := lengthVec^;'
      '  if newLength <= 0 then'
      '  begin'
      '    if newLength < 0 then'
      '      Error(reRangeError);'
      '    _DynArrayClear(a, typeInfo);'
      '    exit;'
      '  end;'
      ''
      '  oldLength := 0;'
      '  if p <> nil then'
      '  begin'
      '    Dec(PByte(p), SizeOf(TDynArrayRec));'
      '    oldLength := PDynArrayRec(p).Length;'
      '  end;'
      ''
      '  // Calculate the needed size of the heap object'
      
        '  t := PDynArrayTypeInfo( PByte(typeInfo) + PDynArrayTypeInfo(ty' +
        'peInfo).name );'
      '  elSize := t.elSize;'
      '  if t.elType <> nil then'
      '    ElTypeInfo := t.elType^'
      '  else'
      '    ElTypeInfo := nil;'
      '  neededSize := newLength*elSize;'
      '  if neededSize div newLength <> elSize then'
      '    Error(reRangeError);'
      '  Inc(neededSize, SizeOf(TDynArrayRec));'
      '  if neededSize < 0 then'
      '    Error(reRangeError);'
      ''
      
        '  // If the heap object isn'#39't shared (ref count = 1), just resiz' +
        'e it. Otherwise, we make a copy'
      '  if (p = nil) or (PDynArrayRec(p).RefCnt = 1) then'
      '  begin'
      '    pp := p;'
      '{$IF not Defined(WEAKREF)}'
      '    if (newLength < oldLength) and (ElTypeInfo <> nil) then'
      
        '      FinalizeArray(PByte(p) + SizeOf(TDynArrayRec) + newLength*' +
        'elSize, ElTypeInfo, oldLength - newLength);'
      '    ReallocMem(pp, neededSize);'
      '{$ELSE}'
      '    if (ElTypeInfo <> nil) then'
      '    begin'
      '      if SysHasWeakRef(PTypeInfo(ElTypeInfo)) then'
      '      begin'
      '        if newLength < oldLength then'
      '          minLength := newLength'
      '        else'
      '          minLength := oldLength;'
      '        GetMem(pp, neededSize);'
      
        '        FillChar((PByte(pp) + SizeOf(TDynArrayRec))^, minLength ' +
        '* elSize, 0);'
      '        if p <> nil then'
      '        begin'
      '          MoveArray(PByte(pp) + SizeOf(TDynArrayRec),'
      
        '                     PByte(p) + SizeOf(TDynArrayRec), ElTypeInfo' +
        ', minLength);'
      '          if newLength < oldLength then'
      
        '            FinalizeArray(PByte(p) + SizeOf(TDynArrayRec) + newL' +
        'ength*elSize, ElTypeInfo, oldLength - newLength);'
      '          FreeMem(p);'
      '        end;'
      '      end'
      '      else'
      '      begin'
      '        if (newLength < oldLength) then'
      
        '          FinalizeArray(PByte(p) + SizeOf(TDynArrayRec) + newLen' +
        'gth*elSize, ElTypeInfo, oldLength - newLength);'
      '{$IFDEF ANDROID}'
      
        '        ReallocMem(pp, CalcReallocMemorySizeWithGap(neededSize, ' +
        'elSize));'
      '{$ELSE}'
      '        ReallocMem(pp, neededSize);'
      '{$ENDIF ANDROID}'
      '      end;'
      '    end'
      '    else'
      '{$IFDEF ANDROID}'
      
        '      ReallocMem(pp, CalcReallocMemorySizeWithGap(neededSize, el' +
        'Size));'
      '{$ELSE}'
      '      ReallocMem(pp, neededSize);'
      '{$ENDIF ANDROID}'
      '{$ENDIF not WEAKREF}'
      '    p := pp;'
      '  end'
      '  else'
      '  begin'
      '    GetMem(p, neededSize);'
      '    minLength := oldLength;'
      '    if minLength > newLength then'
      '      minLength := newLength;'
      '    if ElTypeInfo <> nil then'
      '    begin'
      
        '      FillChar((PByte(p) + SizeOf(TDynArrayRec))^, minLength*elS' +
        'ize, 0);'
      
        '      __CopyArray(PByte(p) + SizeOf(TDynArrayRec), a, ElTypeInfo' +
        ', minLength)'
      '    end'
      '    else'
      
        '      Move(PByte(a)^, (PByte(p) + SizeOf(TDynArrayRec))^, minLen' +
        'gth*elSize);'
      '    _DynArrayClear(a, typeInfo);'
      '  end;'
      ''
      
        '  // The heap object will now have a ref count of 1 and the new ' +
        'length'
      '  PDynArrayRec(p).RefCnt := 1;'
      '  PDynArrayRec(p).Length := newLength;'
      '  Inc(PByte(p), SizeOf(TDynArrayRec));'
      ''
      
        '  // Set the new memory to all zero bits and calls constructor i' +
        'f needed'
      '  if newLength > oldLength then'
      '  begin'
      
        '    FillChar((PByte(p) + elSize * oldLength)^, elSize * (newLeng' +
        'th - oldLength), 0);'
      '    {$IFDEF MANAGED_RECORD}'
      
        '    if (ElTypeInfo <> nil) and HasRecordInitializer(ElTypeInfo) ' +
        'then'
      
        '      InvokeRecordInitializerArray(PByte(p) + oldLength*elSize, ' +
        'ElTypeInfo, newLength - oldLength);'
      '    {$ENDIF}'
      '  end;'
      ''
      '  // Take care of the inner dimensions, if any'
      '  if dimCnt > 1 then'
      '  begin'
      '    Inc(lengthVec);'
      '    Dec(dimCnt);'
      '    i := 0;'
      '    try'
      '      while i < newLength do'
      '        begin'
      
        '          DynArraySetLength(PPointerArray(p)[i], ElTypeInfo, dim' +
        'Cnt, lengthVec);'
      '          Inc(i);'
      '        end;'
      '    except'
      '      // Free arrays on exception'
      '      for j := 0 to i  do'
      '        _DynArrayClear(PPointerArray(p)[j], ElTypeInfo);'
      '      _DynArrayClear(p, typeInfo);'
      '      raise;'
      '    end;'
      '  end;'
      '  a := p;'
      'end;'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'procedure _DynArraySetLength(var A: Pointer; TypeInfo: Pointer; ' +
        'DimCnt: NativeInt); cdecl; varargs;'
      'type'
      '  {$IFDEF CPU64BITS}'
      '  NativeIntArray = array [0..256*1024*1024 - 2] of NativeInt;'
      '  {$ELSE !CPU64BITS}'
      '  NativeIntArray = array [0..512*1024*1024 - 2] of NativeInt;'
      '  {$ENDIF !CPU64BITS}'
      '  PNativeIntArray = ^NativeIntArray;'
      'var'
      '  VAList: TVarArgList;'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  Buf: PNativeIntArray;'
      '  ArgIndex: Integer;'
      '  {$ENDIF}'
      'begin'
      '  VarArgStart(VAList);'
      '  {$IFDEF RECORD_TVARARGLIST}'
      '  GetMem(Buf, DimCnt * SizeOf(NativeInt));'
      '  for ArgIndex := 0 to DimCnt - 1 do'
      '    Buf[ArgIndex] := VarArgGetValue(VAList, NativeInt);'
      '  DynArraySetLength(A, TypeInfo, DimCnt, PNativeInt(Buf));'
      '  FreeMem(Buf);'
      '  {$ELSE}'
      '  DynArraySetLength(A, TypeInfo, DimCnt, PNativeInt(VAList));'
      '  {$ENDIF}'
      '  VarArgEnd(VAList);'
      'end;'
      '{$ELSE X86ASMRTL}'
      'procedure _DynArraySetLength;'
      'asm'
      
        '{       PROCEDURE _DynArraySetLength(var a: dynarray; typeInfo: ' +
        'PDynArrayTypeInfo; dimCnt: NaativeInt; lengthVec: ^NaativeInt) }'
      
        '{     ->EAX     Pointer to dynamic array (= pointer to pointer t' +
        'o heap object) }'
      
        '{       EDX     Pointer to type info for the dynamic array      ' +
        '               }'
      
        '{       ECX     number of dimensions                            ' +
        '               }'
      
        '{       [ESP+4] dimensions                                      ' +
        '               }'
      '{$IFDEF ALIGN_STACK}'
      
        '        PUSH    EBP        // Setup stack frame in case of excep' +
        'tion'
      
        '        MOV     EBP, ESP   // to prevent unwinder from freaking ' +
        'out'
      '        SUB     ESP, 4'
      '        PUSH    ESP'
      '        ADD     dword ptr [ESP],12'
      '{$ELSE !ALIGN_STACK}'
      '        PUSH    ESP'
      '        ADD     dword ptr [ESP],4'
      '{$ENDIF !ALIGN_STACK}'
      '        CALL    DynArraySetLength'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '        POP     EBP'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF X86ASMRTL}'
      ''
      '{$IF defined(X86ASMRTL)}'
      
        'procedure _DynArrayCopy(A: Pointer; TypeInfo: Pointer; var Resul' +
        't: Pointer);'
      'begin'
      '  if A <> nil then'
      
        '    _DynArrayCopyRange(A, TypeInfo, 0, PDynArrayRec(PByte(A) - S' +
        'izeOf(TDynArrayRec)).Length, Result)'
      '  else'
      '    _DynArrayClear(Result, TypeInfo);'
      'end;'
      '{$ELSE !X86ASMRTL}'
      
        'procedure _DynArrayCopy(var Result: Pointer; A: Pointer; TypeInf' +
        'o: Pointer);'
      'begin'
      '  if A <> nil then'
      
        '    _DynArrayCopyRange(Result, A, TypeInfo, 0, PDynArrayRec(PByt' +
        'e(A) - SizeOf(TDynArrayRec)).Length)'
      '  else'
      '    _DynArrayClear(Result, TypeInfo);'
      'end;'
      '{$ENDIF !X86ASMRTL}'
      ''
      '{$IF defined(X86ASMRTL)}'
      
        'procedure _DynArrayCopyRange(A: Pointer; TypeInfo: Pointer; Inde' +
        'x, Count : Integer; var Result: Pointer);'
      '{$ELSE}'
      
        'procedure _DynArrayCopyRange(var Result: Pointer; A: Pointer; Ty' +
        'peInfo: Pointer; Index, Count: NativeInt);'
      '{$ENDIF}'
      'var'
      '  arrayLength: NativeInt;'
      '  elSize: Integer;'
      '  typeInf: PDynArrayTypeInfo;'
      '  p: Pointer;'
      'begin'
      '  p := nil;'
      '  if A <> nil then'
      '  begin'
      '    typeInf := TypeInfo;'
      ''
      '    // Limit index and count to values within the array'
      '    if Index < 0 then'
      '    begin'
      '      Inc(Count, Index);'
      '      Index := 0;'
      '    end;'
      
        '    arrayLength := PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec))' +
        '.Length;'
      '    if Index > arrayLength then'
      '      Index := arrayLength;'
      '    if Count > arrayLength - Index then'
      '      Count := arrayLength - Index;'
      '    if Count < 0 then'
      '      Count := 0;'
      ''
      '    if Count > 0 then'
      '    begin'
      
        '      // Figure out the size and type descriptor of the element ' +
        'type'
      '      Inc(PByte(typeInf), typeInf.name);'
      '      elSize := typeInf.elSize;'
      '      if typeInf.elType <> nil then'
      '        typeInf := typeInf.elType^'
      '      else'
      '        typeInf := nil;'
      ''
      '      // Allocate the amount of memory needed'
      '      GetMem(p, Count * elSize + SizeOf(TDynArrayRec));'
      ''
      
        '      // The reference count of the new array is 1, the length i' +
        's count'
      '      PDynArrayRec(p).RefCnt := 1;'
      '      PDynArrayRec(p).Length := Count;'
      '      Inc(PByte(p), SizeOf(TDynArrayRec));'
      '      Inc(PByte(A), Index * elSize);'
      ''
      
        '      // If the element type needs destruction, we must copy eac' +
        'h element,'
      '      // otherwise we can just copy the bits'
      '      if Count > 0 then'
      '      begin'
      '        if typeInf <> nil then'
      '        begin'
      '          FillChar(p^, Count * elSize, 0);'
      '          __CopyArray(p, A, typeInf, Count)'
      '        end'
      '        else'
      '          Move(A^, p^, Count * elSize);'
      '      end;'
      '    end;'
      '  end;'
      '  DynArrayClear(Result, TypeInfo);'
      '  Result := p;'
      'end;'
      ''
      '{$IF not defined(X86ASMRTL)}'
      
        'function _DynArrayClear(var A: Pointer; TypeInfo: Pointer): Poin' +
        'ter;'
      '{$ELSE}'
      'procedure _DynArrayClear(var A: Pointer; TypeInfo: Pointer);'
      '{$ENDIF}'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: Pointer;'
      '  Len: NativeInt;'
      'begin'
      '  // Nothing to do if Pointer to heap object is nil'
      '  P := A;'
      '  if P <> nil then'
      '  begin'
      '    // Set the variable to be finalized to nil'
      '    A := nil;'
      '    // Decrement ref count. Nothing to do if not zero now.'
      '    if __DynArrayRefCnt(P) > 0 then'
      '    begin'
      
        '      if AtomicDecrement(PDynArrayRec(PByte(P) - SizeOf(TDynArra' +
        'yRec))^.RefCnt) = 0 then'
      '      begin'
      '        // Fetch the type descriptor of the elements'
      '        Inc(PByte(TypeInfo), PDynArrayTypeInfo(TypeInfo)^.name);'
      '        if PDynArrayTypeInfo(TypeInfo)^.elType <> nil then'
      '        begin'
      
        '          Len := PDynArrayRec(PByte(P) - SizeOf(TDynArrayRec))^.' +
        'Length;'
      '          if Len <> 0 then'
      '          begin'
      '            TypeInfo := PDynArrayTypeInfo(TypeInfo)^.elType^;'
      '            _FinalizeArray(P, TypeInfo, Len);'
      '          end;'
      '        end;'
      '        // Now deallocate the array'
      '        Dec(PByte(P), SizeOf(TDynArrayRec));'
      '        _FreeMem(P);'
      '      end;'
      '    end;'
      '  end;'
      '  Result := @A;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm //StackAlignSafe'
      
        '{     ->EAX     Pointer to dynamic array (Pointer to pointer to ' +
        'heap object)}'
      
        '{       EDX     Pointer to type info                            ' +
        '            }'
      ''
      '        {       Nothing to do if Pointer to heap object is nil }'
      '        MOV     ECX,[EAX]'
      '        TEST    ECX,ECX'
      '        JE      @@exit'
      ''
      '        {       Set the variable to be finalized to nil }'
      '        MOV     dword ptr [EAX],0'
      ''
      '        {       If < 0: Literal data. Not in the heap }'
      '        CMP     dword ptr [ECX-8],0'
      '        JLE     @@exit'
      ''
      
        '        {       Decrement ref count. Nothing to do if not zero n' +
        'ow. }'
      '   LOCK DEC     dword ptr [ECX-8]'
      '        JNE     @@exit'
      ''
      '        {       Save the source - we'#39're supposed to return it }'
      '        PUSH    EAX'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EAX,ECX'
      ''
      '        {       Fetch the type descriptor of the elements }'
      '        XOR     ECX,ECX'
      '        MOV     CL,[EDX].TDynArrayTypeInfo.name;'
      '        MOV     EDX,[EDX+ECX].TDynArrayTypeInfo.elType;'
      ''
      '        {       If it'#39's non-nil, finalize the elements }'
      '        TEST    EDX,EDX'
      '        JE      @@noFinalize'
      '        MOV     ECX,[EAX-4]'
      '        TEST    ECX,ECX'
      '        JE      @@noFinalize'
      '        MOV     EDX,[EDX]'
      
        '        {       Save/restore the array around the call to _Final' +
        'izeArray }'
      '{$IFDEF ALIGN_STACK}'
      '        MOV     [ESP], EAX'
      '{$ELSE !ALIGN_STACK}'
      '        PUSH    EAX'
      '{$ENDIF !ALIGN_STACK}'
      '        CALL    _FinalizeArray'
      '{$IFDEF ALIGN_STACK}'
      '        MOV     EAX, [ESP]'
      '{$ELSE !ALIGN_STACK}'
      '        POP     EAX'
      '{$ENDIF !ALIGN_STACK}'
      '@@noFinalize:'
      '        {       Now deallocate the array }'
      '        SUB     EAX,8'
      '        CALL    _FreeMem'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        POP     EAX'
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _DynArrayAsg(var Dest: Pointer; Src: Pointer; TypeInfo' +
        ': Pointer);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if Src <> nil then'
      '  begin'
      '    if __DynArrayRefCnt(Src) < 0 then'
      '    begin'
      '{$IF defined(X86ASMRTL)}'
      '      _DynArrayCopy(Src, TypeInfo, Dest);'
      '{$ELSE}'
      '      _DynArrayCopy(Dest, Src, TypeInfo);'
      '{$ENDIF}'
      '      Exit;'
      '    end;'
      '  end;'
      '  _DynArrayAddRef(Src);'
      '  _DynArrayClear(Dest, TypeInfo);'
      '  Dest := Src;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      
        '{     ->EAX     Pointer to destination (pointer to pointer to he' +
        'ap object) }'
      '{       EDX     source (pointer to heap object) }'
      '{       ECX     Pointer to rtti describing dynamic array }'
      ''
      
        '        {       Increment ref count of source if non-nil and non' +
        '-negative }'
      '        TEST    EDX,EDX'
      '        JE      @@skipInc'
      '        CMP     dword ptr [EDX-8],0'
      '        JL      @@copyConst'
      '   LOCK INC     dword ptr [EDX-8]'
      '@@skipInc:'
      '        PUSH    EBX'
      '        MOV     EBX,[EAX]'
      
        '        {       Dec ref count of destination - if it becomes 0, ' +
        'clear dest }'
      '        TEST    EBX,EBX'
      '        JE      @@skipClear'
      '        CMP     dword ptr [EBX-8],0'
      '        JLE     @@skipClear'
      '   LOCK DEC     dword ptr [EBX-8]'
      '        JNZ     @@skipClear'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        MOV     EDX,ECX'
      '        INC     dword ptr [EBX-8]'
      '        {       Stack is aligned at this point }'
      '        CALL    _DynArrayClear'
      '        POP     EDX'
      '        POP     EAX'
      '@@skipClear:'
      '        {       Finally store source into destination }'
      '        MOV     [EAX],EDX'
      '        POP     EBX'
      '        RET'
      '@@copyConst:'
      
        '        XCHG    EAX,ECX         { EAX := TypeInfo; EDX := Src; E' +
        'CX := Dest }'
      
        '        XCHG    EAX,EDX         { EAX := Src; EDX := TypeInfo; E' +
        'CX := Dest }'
      '        JMP     _DynArrayCopy'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _DynArrayAddRef(P: Pointer);'
      '{$IFDEF PUREPASCAL}'
      'begin'
      '  if P <> nil then'
      '    if __DynArrayRefCnt(P) >= 0 then'
      
        '      AtomicIncrement(PDynArrayRec(PByte(P) - SizeOf(TDynArrayRe' +
        'c))^.RefCnt);'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '{     ->EAX     Pointer to heap object }'
      '        TEST    EAX,EAX'
      '        JE      @@exit'
      '        {       If < 0: Literal data. Not in the heap }'
      '        CMP     dword ptr [EAX-8],0'
      '        JL      @@exit'
      '   LOCK INC     dword ptr [EAX-8]'
      '@@exit:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure DynArrayCopy(var Result: Pointer; a: Pointer; typeInfo' +
        ': Pointer);'
      'begin'
      '{$IF defined(X86ASMRTL)}'
      '  _DynArrayCopy(a, typeInfo, Result);'
      '{$ELSE}'
      '  _DynArrayCopy(Result, a, typeInfo);'
      '{$ENDIF}'
      'end;'
      ''
      
        'procedure DynArrayCopyRange(var Result: Pointer; A: Pointer; Typ' +
        'eInfo: Pointer; Index, Count: NativeInt);'
      'begin'
      '{$IF defined(X86ASMRTL)}'
      '  _DynArrayCopyRange(A, TypeInfo, Index, Count, Result);'
      '{$ELSE}'
      '  _DynArrayCopyRange(Result, A, TypeInfo, Index, Count);'
      '{$ENDIF}'
      'end;'
      ''
      'procedure DynArrayUnique(var A: Pointer; typeInfo: Pointer);'
      'begin'
      
        '  if (A <> nil) and (PDynArrayRec(PByte(A) - SizeOf(TDynArrayRec' +
        '))^.RefCnt > 1) then'
      '    DynArrayCopy(A, A, typeInfo);'
      'end;'
      ''
      'function _DynArrayRelease(P: Pointer): Integer;'
      'begin'
      '  Result := __DynArrayRefCnt(P);'
      '  if Result > 0 then'
      
        '    Result := AtomicDecrement(PDynArrayRec(PByte(P) - SizeOf(TDy' +
        'nArrayRec))^.RefCnt);'
      'end;'
      ''
      
        'procedure _DynArrayCat(var Dest: Pointer; Source: Pointer; typeI' +
        'nfo: Pointer);'
      'var'
      '  L1, L2, Len: NativeInt;'
      '  ElSize, NeededSize: NativeInt;'
      '  ElTypeInfo: Pointer;'
      '  Dims: array[0..0] of NativeInt;'
      '  Temp: Pointer;'
      'begin'
      '  if Source <> nil then'
      '  begin'
      '    if Dest = nil then'
      '      _DynArrayAsg(Dest, Source, typeInfo)'
      '    else'
      '    begin'
      '      L1 := __DynArrayLength(Dest);'
      '      L2 := __DynArrayLength(Source);'
      '      Len := L1 + L2;'
      ''
      
        '      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo' +
        ').name;'
      '      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;'
      '      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then'
      '        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^'
      '      else'
      '        ElTypeInfo := nil;'
      ''
      '      // Calculate the needed size of the heap object'
      '      NeededSize := Len * ElSize;'
      '      if NeededSize div Len <> ElSize then'
      '        _IntOver;'
      '      Inc(NeededSize, SizeOf(TDynArrayRec));'
      '      if NeededSize < 0 then'
      '        _IntOver;'
      ''
      '      Temp := Dest;'
      '      Dims[0] := Len;'
      '      DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);'
      '      if Temp = Source then'
      '        Source := Dest;'
      '      if ElTypeInfo <> nil then'
      
        '        __CopyArray(@PByte(Dest)[L1 * ElSize], Source, ElTypeInf' +
        'o, L2)'
      '      else'
      '        Move(Source^, PByte(Dest)[L1 * ElSize], L2 * ElSize);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure _DynArrayCat3(var Dest: Pointer; Source1, Source2: Poi' +
        'nter; typeInfo: Pointer);'
      'var'
      '  L1, L2, Len: NativeInt;'
      '  ElSize, NeededSize: NativeInt;'
      '  ElTypeInfo: Pointer;'
      '  Dims: array[0..0] of NativeInt;'
      '  Temp: Pointer;'
      'begin'
      '  if Source1 = nil then'
      '    _DynArrayAsg(Dest, Source2, typeInfo)'
      '  else if Source2 = nil then'
      '    _DynArrayAsg(Dest, Source1, typeInfo)'
      '  else'
      '  begin'
      '    if Dest = Source1 then'
      '      _DynArrayCat(Dest, Source2, typeInfo)'
      '    else if Dest = Source2 then'
      '    begin'
      '      L1 := __DynArrayLength(Source1);'
      '      L2 := __DynArrayLength(Source2);'
      '      Len := L1 + L2;'
      ''
      
        '      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo' +
        ').name;'
      '      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;'
      '      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then'
      '        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^'
      '      else'
      '        ElTypeInfo := nil;'
      ''
      '      // Calculate the needed size of the heap object'
      '      NeededSize := Len * ElSize;'
      '      if NeededSize div Len <> ElSize then'
      '        _IntOver;'
      '      Inc(NeededSize, SizeOf(TDynArrayRec));'
      '      if NeededSize < 0 then'
      '        _IntOver;'
      ''
      '      Temp := nil;'
      '      Dims[0] := Len;'
      '      DynArraySetLength(Temp, typeInfo, 1, @Dims[0]);'
      '      if ElTypeInfo <> nil then'
      '      begin'
      
        '        __CopyArray(@PByte(Temp)[0          ], Source1, ElTypeIn' +
        'fo, L1);'
      
        '        __CopyArray(@PByte(Temp)[L1 * ElSize], Source2, ElTypeIn' +
        'fo, L2);'
      '      end'
      '      else'
      '      begin'
      '        Move(Source1^, PByte(Temp)[0          ], L1 * ElSize);'
      '        Move(Source2^, PByte(Temp)[L1 * ElSize], L2 * ElSize);'
      '      end;'
      '      _DynArrayClear(Dest, typeInfo);'
      '      Dest := Temp;'
      '    end'
      '    else'
      '    begin'
      '      _DynArrayAsg(Dest, Source1, typeInfo);'
      '      _DynArrayCat(Dest, Source2, typeInfo);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure _DynArrayCatN(var Dest: Pointer; ArgCnt: Integer; type' +
        'Info: Pointer; Arrays: PPointer);'
      'var'
      '  I, Start: NativeInt;'
      '  Len, L, SrcLen: NativeInt;'
      '  P: Pointer;'
      '  NewDest: Pointer;'
      '  Appending: Boolean;'
      '  Dims: array[0..0] of NativeInt;'
      '  ElTypeInfo: Pointer;'
      '  ElSize: NativeInt;'
      'begin'
      '  Appending := False;'
      '  Len := 0;'
      '  for I := 0 to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Arrays)[I];'
      '    if P <> nil then'
      '    begin'
      '      if P = Dest then'
      '        Appending := (I = 0);'
      '      Inc(Len, __DynarrayLength(P));'
      '      if Len < 0 then _IntOver;'
      '    end;'
      '  end;'
      ''
      
        '  ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).na' +
        'me;'
      '  ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;'
      '  if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then'
      '    ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^'
      '  else'
      '    ElTypeInfo := nil;'
      ''
      '  if Appending then'
      '  begin'
      '    // Dest is non-nil'
      '    L := __DynArrayLength(Dest);'
      '    Dims[0] := Len;'
      '    DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);'
      '    NewDest := Pointer(Dest);'
      '    Start := 1;'
      '  end'
      '  else'
      '  begin'
      '    NewDest := nil;'
      '    Dims[0] := Len;'
      '    DynArraySetLength(NewDest, typeInfo, 1, @Dims[0]);'
      '    Start := 0;'
      '    L := 0;'
      '  end;'
      '  for I := Start to ArgCnt - 1 do'
      '  begin'
      '    P := PPointerArray(Arrays)[I];'
      '    if P <> nil then'
      '    begin'
      '      SrcLen := __DynArrayLength(P);'
      '      if ElTypeInfo <> nil then'
      
        '        __CopyArray(@PByte(NewDest)[L * ElSize], P, ElTypeInfo, ' +
        'SrcLen)'
      '      else'
      '        Move(P^, PByte(NewDest)[L * ElSize], SrcLen * ElSize);'
      '      Inc(L, SrcLen);'
      '    end;'
      '  end;'
      '  if not Appending then'
      '  begin'
      '    if Dest <> nil then'
      '      _DynArrayClear(Dest, typeInfo);'
      '    Dest := NewDest;'
      '  end;'
      'end;'
      ''
      
        'procedure _DynArrayDelete(var Dest: Pointer; Index, Count: Nativ' +
        'eInt; typeInfo: Pointer);'
      'var'
      '  L, N, I: NativeInt;'
      '  Dims: array[0..0] of NativeInt;'
      '  ElTypeInfo: Pointer;'
      '  ElSize: NativeInt;'
      '  S, D: Pointer;'
      'begin'
      '  if Dest <> nil then'
      '  begin'
      '    L := __DynArrayLength(Dest);'
      '    if (Index >= 0) and (Index < L) and (Count > 0) then'
      '    begin'
      '      N := L - Index - Count;'
      '      if N < 0 then'
      '        N := 0;'
      ''
      
        '      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo' +
        ').name;'
      '      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;'
      '      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then'
      '        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^'
      '      else'
      '        ElTypeInfo := nil;'
      ''
      '      D := @PByte(Dest)[Index * ElSize];'
      '      S := @PByte(Dest)[(L - N) * ElSize];'
      '      if ElTypeInfo <> nil then'
      '      begin'
      '        for I := 1 to N do'
      '        begin'
      '          __CopyArray(D, S, ElTypeInfo, 1);'
      '          Inc(PByte(D), ElSize);'
      '          Inc(PByte(S), ElSize);'
      '        end;'
      '      end'
      '      else'
      '        Move(S^, D^, N * ElSize);'
      '      Dims[0] := Index + N;'
      '      DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure _DynArrayInsert(Source: Pointer; var Dest: Pointer; In' +
        'dex: NativeInt; typeInfo: Pointer);'
      'var'
      '  SourceLen, DestLen, NewLen, I: NativeInt;'
      '  SelfInsert: Boolean;'
      '  Dims: array[0..0] of NativeInt;'
      '  ElTypeInfo: Pointer;'
      '  ElSize: NativeInt;'
      '  S, D: Pointer;'
      'begin'
      '  if Source <> nil then'
      '  begin'
      '    SourceLen := __DynArrayLength(Source);'
      '    if SourceLen > 0 then'
      '    begin'
      '      if Dest = nil then'
      '        DestLen := 0'
      '      else'
      '        DestLen := __DynArrayLength(Dest);'
      '      if Index < 0 then'
      '        Index := 0'
      '      else'
      '      begin'
      '        if Index > DestLen then'
      '          Index := DestLen;'
      '      end;'
      '      SelfInsert := (Source = Dest);'
      ''
      
        '      ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo' +
        ').name;'
      '      ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;'
      '      if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then'
      '        ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^'
      '      else'
      '        ElTypeInfo := nil;'
      ''
      '      NewLen := DestLen + SourceLen;'
      '      if NewLen < 0 then   // overflow check'
      '        _IntOver;'
      '      Dims[0] := NewLen;'
      '      DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);'
      '      if Index < DestLen then'
      '      begin'
      '        if ElTypeInfo <> nil then'
      '        begin'
      '          S := @PByte(Dest)[DestLen * ElSize];'
      '          D := @PByte(Dest)[(DestLen + SourceLen) * ElSize];'
      '          for I := Index to DestLen - 1 do'
      '          begin'
      '            Dec(PByte(D), ElSize);'
      '            Dec(PByte(S), ElSize);'
      '            __CopyArray(D, S, ElTypeInfo, 1);'
      '          end;'
      '        end'
      '        else'
      
        '          Move(PByte(Dest)[Index * ElSize], PByte(Dest)[(Index +' +
        ' SourceLen) * ElSize],'
      '            (DestLen - Index) * ElSize);'
      '      end;'
      '      if ElTypeInfo <> nil then'
      '      begin'
      '        if SelfInsert then'
      '        begin'
      '          S := @PByte(Dest)[SourceLen * ElSize];'
      '          D := @PByte(Dest)[(Index + SourceLen) * ElSize];'
      '          for I := 1 to SourceLen do'
      '          begin'
      '            Dec(PByte(D), ElSize);'
      '            Dec(PByte(S), ElSize);'
      '            __CopyArray(D, S, ElTypeInfo, 1);'
      '          end;'
      '        end'
      '        else'
      
        '          __CopyArray(@PByte(Dest)[Index * ElSize], Source, ElTy' +
        'peInfo, SourceLen);'
      '      end'
      '      else'
      '      begin'
      '        if SelfInsert then'
      '          Source := Dest;'
      
        '        Move(Source^, PByte(Dest)[Index * ElSize], SourceLen * E' +
        'lSize);'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure _DynArrayInsertElem(const Source; var Dest: Pointer; I' +
        'ndex: NativeInt; typeInfo: Pointer);'
      'const'
      '  SourceLen = 1;'
      'var'
      '  DestLen, NewLen, I: NativeInt;'
      '  Dims: array[0..0] of NativeInt;'
      '  ElTypeInfo: Pointer;'
      '  ElSize: NativeInt;'
      '  S, D: Pointer;'
      'begin'
      '  if Dest = nil then'
      '    DestLen := 0'
      '  else'
      '    DestLen := __DynArrayLength(Dest);'
      '  if Index < 0 then'
      '    Index := 0'
      '  else'
      '  begin'
      '    if Index > DestLen then'
      '      Index := DestLen;'
      '  end;'
      ''
      
        '  ElTypeInfo := PByte(typeInfo) + PDynArrayTypeInfo(typeInfo).na' +
        'me;'
      '  ElSize := PDynArrayTypeInfo(ElTypeInfo).elSize;'
      '  if PDynArrayTypeInfo(ElTypeInfo).elType <> nil then'
      '    ElTypeInfo := PDynArrayTypeInfo(ElTypeInfo).elType^'
      '  else'
      '    ElTypeInfo := nil;'
      ''
      '  NewLen := DestLen + SourceLen;'
      '  if NewLen < 0 then   // overflow check'
      '    _IntOver;'
      '  Dims[0] := NewLen;'
      '  DynArraySetLength(Dest, typeInfo, 1, @Dims[0]);'
      '  if Index < DestLen then'
      '  begin'
      '    if ElTypeInfo <> nil then'
      '    begin'
      '      S := @PByte(Dest)[DestLen * ElSize];'
      '      D := @PByte(Dest)[(DestLen + SourceLen) * ElSize];'
      '      for I := Index to DestLen - 1 do'
      '      begin'
      '        Dec(PByte(D), ElSize);'
      '        Dec(PByte(S), ElSize);'
      '        __CopyArray(D, S, ElTypeInfo, 1);'
      '      end;'
      '    end'
      '    else'
      
        '      Move(PByte(Dest)[Index * ElSize], PByte(Dest)[(Index + Sou' +
        'rceLen) * ElSize],'
      '        (DestLen - Index) * ElSize);'
      '  end;'
      '  if ElTypeInfo <> nil then'
      
        '    __CopyArray(@PByte(Dest)[Index * ElSize], @Source, ElTypeInf' +
        'o, SourceLen)'
      '  else if ElSize = 8 then'
      '    PUInt64(@PByte(Dest)[Index * 8])^ := PUInt64(@Source)^'
      '  else if ElSize = 4 then'
      '    PUInt32(@PByte(Dest)[Index * 4])^ := PUInt32(@Source)^'
      '  else if ElSize = 2 then'
      '    PWord(@PByte(Dest)[Index * 2])^ := PWord(@Source)^'
      '  else if ElSize = 1 then'
      '    PByte(Dest)[Index] := PByte(@Source)^'
      '  else'
      '    Move(Source, PByte(Dest)[Index * ElSize], ElSize);'
      'end;'
      ''
      '{$IF (not defined(WEAK_NATIVEINT)) or defined(CPU64BITS)}'
      
        'function DynArrayIndex(P: Pointer; const Indices: array of Nativ' +
        'eInt; TypInfo: Pointer): Pointer; overload;'
      'var'
      '  I, L, H: Integer;'
      'begin'
      '  L := Low(Indices);'
      '  H := High(Indices);'
      ''
      '  if H >= L then'
      '  begin'
      '    { Start at the beggining of the array }'
      '    for I := L to H do'
      '    begin'
      '      { Skip to the relevant part }'
      '      Inc(PByte(TypInfo), PDynArrayTypeInfo(TypInfo)^.name);'
      ''
      
        '      { Jump into the array at the given position using the indi' +
        'ces and element size }'
      
        '      Inc(PByte(P), Indices[I] * PDynArrayTypeInfo(TypInfo)^.elS' +
        'ize);'
      ''
      
        '      { Go one step deeper into the child arrays only if it'#39's no' +
        't the last dimension }'
      '      if I < H then'
      '      begin'
      '        if PDynArrayTypeInfo(TypInfo)^.elType <> nil then'
      '          TypInfo := PDynArrayTypeInfo(TypInfo)^.elType^;'
      '        if P = nil then'
      '          Exit(nil);'
      '        P := PPointer(P)^;'
      '      end;'
      '    end;'
      '  end;'
      ''
      '  { Result is the input pointer modified }'
      '  Result := P;'
      'end;'
      '{$ENDIF (not WEAK_NATIVEINT) or CPU64BITS}'
      ''
      
        'function DynArrayIndex(P: Pointer; const Indices: array of Integ' +
        'er; TypInfo: Pointer): Pointer; overload;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  I, L, H: Integer;'
      'begin'
      '  L := Low(Indices);'
      '  H := High(Indices);'
      ''
      '  if H >= L then'
      '  begin'
      '    { Start at the beggining of the array }'
      '    for I := L to H do'
      '    begin'
      '      { Skip to the relevant part }'
      '      Inc(PByte(TypInfo), PDynArrayTypeInfo(TypInfo)^.name);'
      ''
      
        '      { Jump into the array at the given position using the indi' +
        'ces and element size }'
      
        '      Inc(PByte(P), Indices[I] * PDynArrayTypeInfo(TypInfo)^.elS' +
        'ize);'
      ''
      
        '      { Go one step deeper into the child arrays only if it'#39's no' +
        't the last dimension }'
      '      if I < H then'
      '      begin'
      '        if PDynArrayTypeInfo(TypInfo)^.elType <> nil then'
      '          TypInfo := PDynArrayTypeInfo(TypInfo)^.elType^;'
      '        if P = nil then'
      '          Exit(nil);'
      '        P := PPointer(P)^;'
      '      end;'
      '    end;'
      '  end;'
      ''
      '  { Result is the input pointer modified }'
      '  Result := P;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        {     ->EAX     P                       }'
      '        {       EDX     Pointer to Indices      }'
      '        {       ECX     High bound of Indices   }'
      '        {       [EBP+8] TypInfo                 }'
      '        PUSH    EBX'
      '        PUSH    ESI'
      '        PUSH    EDI'
      '        PUSH    EBP'
      ''
      '        MOV     ESI,EDX'
      '        MOV     EDI,[EBP+8]'
      '        MOV     EBP,EAX'
      ''
      
        '        XOR     EBX,EBX                 {  for i := 0 to High(In' +
        'dices) do       }'
      '        TEST    ECX,ECX'
      '        JGE     @@start'
      '@@loop:'
      '        TEST    EBP, EBP'
      '        JE      @@loopEnd'
      '        MOV     EBP,[EBP]'
      '@@start:'
      '        XOR     EAX,EAX'
      '        MOV     AL,[EDI].TDynArrayTypeInfo.name'
      '        ADD     EDI,EAX'
      
        '        MOV     EAX,[ESI+EBX*4]         {    P := P + Indices[i]' +
        '*TypInfo.elSize }'
      '        MUL     [EDI].TDynArrayTypeInfo.elSize'
      '        MOV     EDI,[EDI].TDynArrayTypeInfo.elType'
      '        TEST    EDI,EDI'
      '        JE      @@skip'
      '        MOV     EDI,[EDI]'
      '@@skip:'
      '        ADD     EBP,EAX'
      '        INC     EBX'
      '        CMP     EBX,ECX'
      '        JLE     @@loop'
      ''
      '@@loopEnd:'
      ''
      '        MOV     EAX,EBP'
      ''
      '        POP     EBP'
      '        POP     EDI'
      '        POP     ESI'
      '        POP     EBX'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      ''
      
        '{ Returns the DynArrayTypeInfo of the Element Type of the specif' +
        'ied DynArrayTypeInfo }'
      
        'function DynArrayElTypeInfo(typeInfo: PDynArrayTypeInfo): PDynAr' +
        'rayTypeInfo;'
      'begin'
      '  Result := nil;'
      '  if typeInfo <> nil then'
      '  begin'
      '    Inc(PByte(typeInfo), typeInfo.name);'
      '    if typeInfo.elType <> nil then'
      '      Result := typeInfo.elType^;'
      '  end;'
      'end;'
      ''
      
        '{ Returns # of dimemsions of the DynArray described by the speci' +
        'fied DynArrayTypeInfo}'
      'function DynArrayDim(typeInfo: Pointer): Integer;'
      'begin'
      '  Result := 0;'
      
        '  while (typeInfo <> nil) and (PDynArrayTypeInfo(typeInfo)^.kind' +
        ' = tkDynArray) do'
      '  begin'
      '    Inc(Result);'
      '    typeInfo := DynArrayElTypeInfo(typeInfo);'
      '  end;'
      'end;'
      ''
      '{ Returns size of the Dynamic Array}'
      'function DynArraySize(A: Pointer): NativeInt;'
      'begin'
      '  Result := NativeInt(A);'
      
        '  if Result <> 0 then                                         //' +
        ' TDynArrayRec should be used here but a'
      
        '    Result := PNativeInt(PByte(Result) - SizeOf(NativeInt))^; //' +
        ' private symbol cannot be inlined'
      'end;'
      ''
      
        'procedure DynArrayAssign(var Dest: Pointer; Source: Pointer; typ' +
        'eInfo: Pointer);'
      'begin'
      '  _DynArrayAsg(Dest, Source, typeInfo);'
      'end;'
      ''
      '// Returns whether array is rectangular'
      
        'function IsDynArrayRectangular(const DynArray: Pointer; typeInfo' +
        ': Pointer): Boolean;'
      'var'
      '  Dim, I, J, Size, SubSize: Integer;'
      '  P: Pointer;'
      'begin'
      '  // Assume we have a rectangular array'
      '  Result := True;'
      ''
      '  P := DynArray;'
      '  Dim := DynArrayDim(typeInfo);'
      ''
      
        '  {NOTE: Start at 1. Don'#39't need to test the first dimension - it' +
        #39's rectangular by definition}'
      '  for I := 1 to dim-1 do'
      '  begin'
      '    if P <> nil then'
      '    begin'
      '      { Get size of this dimension }'
      '      Size := DynArraySize(P);'
      ''
      '      { Get Size of first sub. dimension }'
      '      SubSize := DynArraySize(PPointerArray(P)[0]);'
      ''
      
        '      { Walk through every dimension making sure they all have t' +
        'he same size}'
      '      for J := 1  to Size-1 do'
      '        if DynArraySize(PPointerArray(P)[J]) <> SubSize then'
      '        begin'
      '          Result := False;'
      '          Exit;'
      '        end;'
      ''
      '      { Point to next dimension}'
      '      P := PPointerArray(P)[0];'
      '    end;'
      '  end;'
      'end;'
      ''
      
        '// Returns Bounds of Dynamic array as an array of integer contai' +
        'ning the '#39'high'#39' of each dimension'
      
        'function DynArrayBounds(const DynArray: Pointer; typeInfo: Point' +
        'er): TBoundArray;'
      'var'
      '  Dim, I: Integer;'
      '  P: Pointer;'
      'begin'
      '  P := DynArray;'
      ''
      '  Dim := DynArrayDim(typeInfo);'
      '  SetLength(Result, Dim);'
      ''
      '  for I := 0 to dim-1 do'
      '    if P <> nil then'
      '    begin'
      '      Result[I] := DynArraySize(P)-1;'
      '      P := PPointerArray(P)[0]; // Assume rectangular arrays'
      '    end;'
      'end;'
      ''
      '{ Decrements to next lower index - Returns True if successful }'
      '{ Indices: Indices to be decremented }'
      '{ Bounds : High bounds of each dimension }'
      
        'function DecIndices(var Indices: TBoundArray; const Bounds: TBou' +
        'ndArray): Boolean;'
      'var'
      '  I, J: Integer;'
      'begin'
      '  { Find out if we'#39're done: all at zeroes }'
      '  Result := False;'
      '  for I := Low(Indices)  to High(Indices) do'
      '    if Indices[I] <> 0  then'
      '    begin'
      '      Result := True;'
      '      break;'
      '    end;'
      '  if not Result then'
      '    Exit;'
      ''
      '  { Two arrays must be of same length }'
      '  Assert(Length(Indices) = Length(Bounds));'
      ''
      '  { Find index of item to tweak }'
      '  for I := High(Indices) downto Low(Bounds) do'
      '  begin'
      '    // If not reach zero, dec and bail out'
      '    if Indices[I] <> 0 then'
      '    begin'
      '      Dec(Indices[I]);'
      '      Exit;'
      '    end'
      '    else'
      '    begin'
      '      J := I;'
      '      while Indices[J] = 0 do'
      '      begin'
      
        '        // Restore high bound when we'#39've reached zero on a parti' +
        'cular dimension'
      '        Indices[J] := Bounds[J];'
      '        // Move to higher dimension'
      '        Dec(J);'
      '        Assert(J >= 0);'
      '      end;'
      '      Dec(Indices[J]);'
      '      Exit;'
      '    end;'
      '  end;'
      'end;'
      ''
      '{ Package/Module registration/unregistration }'
      ''
      '{$IFDEF MSWINDOWS}'
      'const'
      '  LCID_SUPPORTED          = $00000002;  { supported locale ids }'
      
        '  LOCALE_SABBREVLANGNAME  = $00000003;  { abbreviated language n' +
        'ame }'
      
        '  LOCALE_SISO639LANGNAME  = $00000059;  { ISO abbreviated langua' +
        'ge name }'
      
        '  LOCALE_SISO3166CTRYNAME = $0000005A;  { ISO abbreviated countr' +
        'y name }'
      
        '  LOCALE_SNAME            = $0000005c;  { locale name (ie: en-us' +
        ') }'
      
        '  LOCALE_SPARENT          = $0000006d;  { Fallback name for reso' +
        'urces }'
      '  LOCALE_NAME_MAX_LENGTH  = 85;'
      
        '  MUI_LANGUAGE_ID         = $4;  { Use traditional language ID c' +
        'onvention }'
      
        '  MUI_LANGUAGE_NAME       = $8;  { Use ISO language (culture) na' +
        'me convention }'
      
        '  MUI_UI_FALLBACK         = $30; { Retrieve a complete thread pr' +
        'eferred UI languages list }'
      '  LOAD_LIBRARY_AS_DATAFILE = 2;'
      '  HKEY_CURRENT_USER = HKEY(NativeUInt($80000001));'
      '  HKEY_LOCAL_MACHINE = HKEY(NativeUInt($80000002));'
      '  KEY_ALL_ACCESS = $000F003F;'
      '  KEY_READ = $00020019; { Winapi.Windows.KEY_ALL_ACCESS }'
      ''
      
        '  OlderLocaleOverrideKey = '#39'Software\Borland\Delphi\Locales'#39'; //' +
        ' do not localize'
      
        '  OldLocaleOverrideKey = '#39'Software\Borland\Locales'#39'; // do not l' +
        'ocalize'
      
        '  NewLocaleOverrideKey = '#39'Software\CodeGear\Locales'#39'; // do not ' +
        'localize'
      
        '  NewerLocaleOverrideKey = '#39'Software\Embarcadero\Locales'#39'; // do' +
        ' not localize'
      '{$ENDIF}'
      ''
      'function FindModule(Instance: HINST): PLibModule;'
      'begin'
      '  Result := LibModuleList;'
      '  while Result <> nil do'
      '  begin'
      '    if (Instance = Result.Instance) or'
      '       (Instance = Result.CodeInstance) or'
      '       (Instance = Result.DataInstance) or'
      '       (Instance = Result.ResInstance) then'
      '      Exit;'
      '    Result := Result.Next;'
      '  end;'
      'end;'
      ''
      'function FindHInstance(Address: Pointer): HINST;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  MemInfo: TMemoryBasicInformation;'
      'begin'
      '  VirtualQuery(Address, MemInfo, SizeOf(MemInfo));'
      '  if MemInfo.State = $1000{MEM_COMMIT} then'
      '    Result := UIntPtr(MemInfo.AllocationBase)'
      '  else'
      '    Result := 0;'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'var'
      '  Info: dl_info;'
      'begin'
      '{$IFDEF MACOS64}                                     '
      '  if (dladdr(UIntPtr(Address), Info) = 0) then'
      
        '    Info.dli_fname := nil;   // if it'#39's not in a library, assume' +
        ' the exe'
      '{$ELSE !MACOS64}'
      
        '  if (dladdr(UIntPtr(Address), Info) = 0) or (Info.dli_fbase = E' +
        'xeBaseAddress) then'
      
        '    Info.dli_fname := nil;   // if it'#39's not in a library, assume' +
        ' the exe'
      '{$ENDIF MACOS64}'
      
        '  Result := NativeUInt(dlopen(_PAnsiChr(UTF8Encode(Info.dli_fnam' +
        'e)), RTLD_LAZY));'
      '{$IFDEF LINUX64}'
      '  if Result = 0 then'
      
        '    Result := NativeUInt(dlopen(NIL, RTLD_LAZY)); // Try to get ' +
        'main app handle.'
      '{$ENDIF LINUX64}'
      '  if Result <> 0 then'
      '    dlclose(Result);'
      'end;'
      '{$ENDIF}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      'begin'
      '   Error(rePlatformNotImplemented);'
      'end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      'function FindClassHInstance(ClassType: TClass): HINST;'
      'begin'
      '  Result := FindHInstance(Pointer(ClassType));'
      'end;'
      ''
      '{$IFDEF POSIX}'
      
        'function GetModuleFileName(Module: HMODULE; Buffer: PChar; BufLe' +
        'n: Integer): Integer;'
      'var'
      '  Addr: Pointer;'
      '  Info: dl_info;'
      '{$IFDEF LINUX}'
      '  Temp: Integer;'
      '  ProcBuff: array [0..MAX_PATH] of _AnsiChr;'
      '  FoundInModule: HMODULE;'
      '  fname: string;'
      '{$ENDIF}'
      '{$IFDEF MACOS}'
      '  LoadedModule: HMODULE;'
      '  Name: _PAnsiChr;'
      '  Index: Integer;'
      '{$ENDIF MACOS}'
      'begin'
      '  Result := 0;'
      '  if BufLen <= 0 then Exit;'
      '  Buffer^ := #0;'
      '  if (Module = MainInstance) or (Module = 0) then'
      '  begin'
      '    // First, try the dlsym approach.'
      '    // dladdr fails to return the name of the main executable'
      '    // in glibc prior to 2.1.91'
      ''
      '{   Look for a dynamic symbol exported from this program.'
      '    _DYNAMIC is not required in a main program file.'
      '    If the main program is compiled with Delphi, it will always'
      '    have a resource section, named @Sysinit@ResSym.'
      '    If the main program is not compiled with Delphi, dlsym'
      '    will search the global name space, potentially returning'
      '    the address of a symbol in some other shared object library'
      '    loaded by the program.  To guard against that, we check'
      '    that the address of the symbol found is within the'
      '    main program address range.  }'
      ''
      '    dlerror;   // clear error state;  dlsym doesn'#39't'
      '//    Addr := dlsym(Module, '#39'@Sysinit@ResSym'#39');'
      '    if Module = 0 then Module := RTLD_DEFAULT;'
      '    Addr := dlsym(Module, '#39'SysinitResSym'#39');'
      '{$IFDEF MACOS64}                                     '
      '    if (Addr <> nil) and (dlerror = nil)'
      '      and (dladdr(UIntPtr(Addr), Info) <> 0)'
      '      and (Info.dli_fname <> nil) then'
      '{$ELSE !MACOS64}'
      '    if (Addr <> nil) and (dlerror = nil)'
      '      and (dladdr(UIntPtr(Addr), Info) <> 0)'
      '      and (Info.dli_fname <> nil)'
      '      and (Info.dli_fbase = ExeBaseAddress) then'
      '{$ENDIF MACOS64}'
      '    begin'
      '      Result := strlen(Info.dli_fname);'
      '      if Result >= BufLen then Result := BufLen-1;'
      ''
      
        '      // dlinfo may not give a full path.  Compare to /proc/self' +
        '/exe,'
      '      // take longest result.'
      '{$IFDEF LINUX}'
      '//      Temp := readlink('#39'/proc/self/exe'#39', Buffer, BufLen);'
      '      Temp := readlink('#39'/proc/self/exe'#39', ProcBuff, MAX_PATH);'
      '      if Temp >= BufLen then Temp := BufLen-1;'
      '      if Temp > Result then'
      '      begin'
      '        Utf8ToUnicode(Buffer, BufLen, ProcBuff, Temp);'
      '        Result := Temp;'
      '      end'
      '      else'
      '        Move(Info.dli_fname^, Buffer^, Result);'
      '{$ENDIF LINUX}'
      '{$IFDEF MACOS}'
      '      Utf8ToUnicode(Buffer, BufLen, Info.dli_fname, Result);'
      '{$ENDIF MACOS}'
      '      Buffer[Result] := #0;'
      '      Exit;'
      '    end;'
      ''
      '{$IFDEF LINUX}'
      '    // Try inspecting the /proc/ virtual file system'
      '    // to find the program filename in the process info'
      
        '    Result := readlink(_AnsiStr('#39'/proc/self/exe'#39'), ProcBuff, MAX' +
        '_PATH);'
      '    if Result <> -1 then'
      '    begin'
      '      if Result >= BufLen then Result := BufLen-1;'
      '      ProcBuff[Result] := #0;'
      '      Utf8ToUnicode(Buffer, BufLen, ProcBuff, Result);'
      '    end;'
      '{$ENDIF LINUX}'
      '{$IFDEF AllowParamStrModuleName}'
      
        '{   Using ParamStr(0) to obtain a module name presents a potenti' +
        'al'
      
        '    security hole.  Resource modules are loaded based upon the f' +
        'ilename'
      
        '    of a given module.  We use dlopen() to load resource modules' +
        ', which'
      
        '    means the .init code of the resource module will be executed' +
        '.'
      
        '    Normally, resource modules contain no code at all - they'#39're ' +
        'just'
      '    carriers of resource data.'
      '    An unpriviledged user program could launch our trusted,'
      '    priviledged program with a bogus parameter list, tricking us'
      '    into loading a module that contains malicious code in its'
      '    .init section.'
      
        '    Without this ParamStr(0) section, GetModuleFilename cannot b' +
        'e'
      
        '    misdirected by unpriviledged code (unless the system program' +
        ' loader'
      
        '    or the /proc file system or system root directory has been c' +
        'ompromised).'
      
        '    Resource modules are always loaded from the same directory a' +
        's the'
      
        '    given module.  Trusted code (programs, packages, and librari' +
        'es)'
      
        '    should reside in directories that unpriviledged code cannot ' +
        'alter.'
      ''
      
        '    If you need GetModuleFilename to have a chance of working on' +
        ' systems'
      '    where glibc < 2.1.91 and /proc is not available, and your'
      
        '    program will not run as a priviledged user (or you don'#39't car' +
        'e),'
      
        '    you can define AllowParamStrModuleNames and rebuild the Syst' +
        'em unit'
      
        '    and baseCLX package.  Note that even with ParamStr(0) suppor' +
        't'
      
        '    enabled, GetModuleFilename can still fail to find the name o' +
        'f'
      '    a module.  C'#39'est la Unix.  }'
      ''
      '    if Result = 0 then // couldn'#39't access the /proc filesystem'
      
        '//    if Result = -1 then // couldn'#39't access the /proc filesyste' +
        'm'
      '    begin               // return less accurate ParamStr(0)'
      ''
      '{     ParamStr(0) returns the name of the link used'
      '      to launch the app, not the name of the app itself.'
      '      Also, if this app was launched by some other program,'
      '      there is no guarantee that the launching program has set'
      '      up our environment at all.  (example: Apache CGI) }'
      ''
      '      if (ArgValues = nil) or (ArgValues^ = nil) or'
      '        (PAnsiCharArray(ArgValues^)[0] = nil) then'
      '      begin'
      '        Result := 0;'
      '        Exit;'
      '      end;'
      '      Utf8ToUnicode(Buffer, ArgValues^, BufLen);'
      '    end;'
      '{$ENDIF AllowParamStrModuleName}'
      '  end'
      '  else'
      '  begin'
      '{$IFDEF LINUX}'
      
        '{   For shared object libraries, we can rely on the dlsym techni' +
        'que.'
      '    Look for a dynamic symbol in the requested module.'
      '    Don'#39't assume the module was compiled with Delphi.'
      '    We look for a dynamic symbol with the name _DYNAMIC.  This'
      '    exists in all ELF shared object libraries that export'
      
        '    or import symbols;  If someone has a shared object library t' +
        'hat'
      
        '    contains no imports or exports of any kind, this will probab' +
        'ly fail.'
      
        '    If dlsym can'#39't find the requested symbol in the given module' +
        ', it'
      
        '    will search the global namespace and could return the addres' +
        's'
      '    of a symbol from some other module that happens to be loaded'
      '    into this process.  That would be bad, so we double check'
      '    that the module handle of the symbol found matches the'
      '    module handle we asked about.}'
      ''
      '    dlerror;   // clear error state;  dlsym doesn'#39't'
      '    //Addr := dlsym(Module, '#39'_DYNAMIC'#39');'
      '    Addr := dlsym(Module, '#39'dbkFCallWrapperAddr'#39');'
      '    if (Addr <> nil) and (dlerror = nil)'
      '      and (dladdr(UIntPtr(Addr), Info) <> 0) then'
      '    begin'
      '      if Info.dli_fbase = ExeBaseAddress then'
      '        Info.dli_fname := nil;'
      
        '      FoundInModule := HMODULE(dlopen(_PAnsiChr(UTF8Encode(Info.' +
        'dli_fname)), RTLD_LAZY));'
      '      if FoundInModule <> 0 then'
      '        dlclose(FoundInModule);'
      '      if Module = FoundInModule then'
      '      begin'
      '        if Assigned(Info.dli_fname) then'
      '        begin'
      '          fname := string(PUTF8Char(Info.dli_fname));'
      '          Result := Length(fname);'
      '          if Result >= BufLen then Result := BufLen-1;'
      '          Move(PChar(fname)^, Buffer^, Result*sizeof(Char));'
      '        end'
      '        else'
      '          Result := 0;'
      '        Buffer[Result] := #0;'
      '      end;'
      '    end;'
      '{$ENDIF LINUX}'
      '{$IFDEF MACOS}'
      
        '{   Iterate through the loaded modules using _dyld_get_image_nam' +
        'e,'
      '    comparing those module handles to the handle provided.'
      
        '    Note that this function is not thread safe as indicies into ' +
        'the'
      
        '    loaded object list may change if other threads are loading o' +
        'r'
      
        '    unloading modules. Most of the time this will not be the cas' +
        'e;'
      '    failure mode is to just return an empty string. }'
      ''
      '    Index := 0;'
      '    Name := _dyld_get_image_name(Index);'
      '    while Name <> nil do'
      '    begin'
      '      LoadedModule := dlopen(Name, RTLD_LAZY);'
      '      dlclose(LoadedModule);'
      ''
      '      if LoadedModule = Module then'
      '      begin'
      '        Result := StrLen(Name);'
      '        if Result >= BufLen then Result := BufLen - 1;'
      '        Result := UTF8ToUnicode(Buffer, BufLen, Name, Result);'
      '        Exit(Result);'
      '      end;'
      ''
      '      Inc(Index);'
      '      Name := _dyld_get_image_name(Index);'
      '    end;'
      '    Result := 0;'
      '{$ENDIF MACOS}'
      '  end;'
      ''
      '  if Result < 0 then Result := 0;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      'function DelayLoadResourceModule(Module: PLibModule): HINST;'
      'var'
      '  FileName: array[0..MAX_PATH] of Char;'
      'begin'
      '  if Module.ResInstance = 0 then'
      '  begin'
      
        '    GetModuleFileName(Module.Instance, FileName, Length(FileName' +
        '));'
      '    Module.ResInstance := LoadResourceModule(FileName);'
      '    if Module.ResInstance = 0 then'
      '      Module.ResInstance := Module.Instance;'
      '  end;'
      '  Result := Module.ResInstance;'
      'end;'
      ''
      'function FindResourceHInstance(Instance: HINST): HINST;'
      'var'
      '  CurModule: PLibModule;'
      'begin'
      '  CurModule := LibModuleList;'
      '  while CurModule <> nil do'
      '  begin'
      '    if (Instance = CurModule.Instance) or'
      '       (Instance = CurModule.CodeInstance) or'
      '       (Instance = CurModule.DataInstance) then'
      '    begin'
      '      Result := DelayLoadResourceModule(CurModule);'
      '      Exit;'
      '    end;'
      '    CurModule := CurModule.Next;'
      '  end;'
      '  Result := Instance;'
      'end;'
      ''
      '{$IF defined(LINUX) or defined(ANDROID)}'
      'function GetUILanguages(const LANGID: WORD): string;'
      'var'
      '  Lang: _AnsiStr;'
      '  Ind: integer;'
      '  languagePart: string;'
      'begin'
      '  // language[_territory][.codeset][@modifiers]'
      '  // language and territory shall consist of LETTERS only.'
      '  Lang := _AnsiStr(getenv('#39'LANG'#39'));'
      '  Result := '#39#39';'
      '  if Lang = '#39#39' then exit;'
      ''
      '  languagePart := '#39#39';'
      ''
      '  for ind := 1 to length(Lang) do'
      '  begin'
      '    if not(Lang[Ind] in ['#39'a'#39'..'#39'z'#39', '#39'A'#39'..'#39'Z'#39', '#39'_'#39']) then'
      '      break;'
      '    if Lang[Ind] = '#39'_'#39' then languagePart := Result;'
      '    Result := Result + WideChar(Lang[Ind]);'
      '  end;'
      ''
      '  if languagePart <> '#39#39' then'
      '    Result :=  Result + '#39','#39' + languagePart;'
      'end;'
      ''
      'function InternalGetLocaleOverride(AppName: string): string;'
      'begin'
      '  Result := '#39#39'; // no override mechanism'
      'end;'
      '{$ENDIF LINUX or ANDROID}'
      '{$IFDEF MACOS}'
      'function StringRefToString(StringRef: CFStringRef): string;'
      'var'
      '  Range: CFRange;'
      'begin'
      '  Range.location := 0;'
      '  Range.length := CFStringGetLength(StringRef);'
      '  if Range.length > 0 then'
      '  begin'
      '    SetLength(Result, Range.length);'
      
        '    CFStringGetCharacters(StringRef, Range, @Result[Low(string)]' +
        ');'
      '  end'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      'function GetUILanguages(const LANGID: WORD): string;'
      'const'
      '  FirstIndex = Low(string);'
      '  LengthOffset = FirstIndex - 1;'
      ''
      
        '  function GetFallbackLanguage(const BaseLanguage: string): stri' +
        'ng;'
      '  var'
      '    Ind: Integer;'
      '  begin'
      '    Result := '#39#39';'
      '    if BaseLanguage = '#39#39' then'
      '      Exit;'
      
        '    for Ind := Length(BaseLanguage) + LengthOffset downto FirstI' +
        'ndex do'
      '      If BaseLanguage[Ind] = '#39'-'#39' then'
      '        Exit( Copy(BaseLanguage, FirstIndex, Ind-FirstIndex) );'
      '  end;'
      ''
      'var'
      '  PL : CFArrayRef;'
      '  I: integer;'
      '  LanguageList: array of string;'
      'begin'
      '  Result := '#39#39';'
      '  PL := CFLocaleCopyPreferredLanguages;'
      '  try'
      '    if CFArrayGetCount(PL) > 0 then'
      '    begin'
      '      // Copy preferred language list to local array.'
      '      SetLength(LanguageList, CFArrayGetCount(PL));'
      '      for I := 0 to Length(LanguageList)-1 do'
      
        '        LanguageList[I] := StringRefToString(CFArrayGetValueAtIn' +
        'dex(PL, I));'
      '      // assemble original preferred languages'
      '      Result := LanguageList[0];'
      '      for I := 1 to Length(LanguageList)-1 do'
      '        Result := Result + '#39','#39' + LanguageList[I];'
      '      // collect and append fall-back languages.'
      '      while True do'
      '      begin'
      
        '        // remove '#39'-XXX'#39' portion from each language entries to c' +
        'reate fall-back language.'
      
        '        // If the entries doesn'#39't contains '#39'-'#39', empty string is ' +
        'stored.'
      '        for I := 0 to Length(LanguageList)-1 do'
      '          if LanguageList[I] <> '#39#39' then'
      
        '            LanguageList[I] := GetFallbackLanguage(LanguageList[' +
        'I]);'
      '        // find first fall-back entry.'
      '        I := 0;'
      
        '        while (LanguageList[I] = '#39#39') and (I < Length(LanguageLis' +
        't)) do Inc(I);'
      '        // if all entries are empty, done.'
      '        if I >= Length(LanguageList) then'
      '          Break;'
      '        // append fall-back languages after prior langauge list.'
      '        while (I < Length(LanguageList)) do'
      '        begin'
      '          if LanguageList[I] <> '#39#39' then'
      '            Result := Result + '#39','#39' + LanguageList[I];'
      '          Inc(I);'
      '        end;'
      '      end;'
      '    end;'
      '  finally'
      '    CFRelease(PL);'
      '  end;'
      'end;'
      ''
      'function InternalGetLocaleOverride(AppName: string): string;'
      'begin'
      '  Result := '#39#39'; // no override mechanism'
      'end;'
      '{$ENDIF MACOS}'
      ''
      '{$IFDEF MSWINDOWS}'
      'type'
      '  TLanguageEntry = record'
      '    ID: WORD;'
      '    List: _PAnsiChr;'
      '  end;'
      ''
      '{$I LocaleData.INC }'
      ''
      'var'
      
        '  GetThreadPreferredUILanguages : function(dwFlags: LONGWORD; pu' +
        'lNumLanguages: Pointer;'
      
        '    pwszLanguagesBuffer: PWideChar; pcchLanguagesBuffer: Pointer' +
        '): Boolean; stdcall;'
      
        '  SetThreadPreferredUILanguages : function(dwFlags: LONGWORD; pw' +
        'szLanguagesBuffer: Pointer;'
      '    pulNumLanguages: Pointer): Boolean; stdcall;'
      '  GetThreadUILanguage : function : WORD; stdcall;'
      '  UseThreadUILanguageAPI: Boolean;'
      '  CrSec: TRTLCriticalSection;'
      '  CachedLangID: Word;'
      
        '  CachedLanguageNames: array[0.. LOCALE_NAME_MAX_LENGTH-1] of Ch' +
        'ar;'
      ''
      'procedure InitializeLocaleData;'
      'begin'
      '  InitializeCriticalSection(CrSec);'
      '  CachedLangID := $7f; //  LANG_INVARIANT'
      '  UseThreadUILanguageAPI := (GetVersion and $000000FF) >= 6;'
      '  if UseThreadUILanguageAPI then'
      '  begin'
      
        '    @GetThreadPreferredUILanguages := GetProcAddress(GetModuleHa' +
        'ndle(kernel), '#39'GetThreadPreferredUILanguages'#39');'
      
        '    @SetThreadPreferredUILanguages := GetProcAddress(GetModuleHa' +
        'ndle(kernel), '#39'SetThreadPreferredUILanguages'#39');'
      
        '    @GetThreadUILanguage:= GetProcAddress(GetModuleHandle(kernel' +
        '), '#39'GetThreadUILanguage'#39');'
      '  end;'
      'end;'
      ''
      'procedure FinalizeLocaleDate;'
      'begin'
      '  DeleteCriticalSection(CrSec);'
      'end;'
      ''
      
        'procedure StringCopy(Dest: PWideChar; DestSize: integer; Src: PW' +
        'ideChar);'
      'var'
      '  Ch: Char;'
      'begin'
      '  if DestSize = 0 then'
      '    Dest^ := #$0'
      '  else'
      '  begin'
      '    while DestSize > 0 do'
      '    begin'
      '      Ch := Src^;'
      '      Dest^ := Ch;'
      '      if Ch = #$0 then'
      '        exit;'
      '      Inc(Dest);'
      '      Inc(Src);'
      '      Dec(DestSize);'
      '    end;'
      '    if DestSize = 0 then'
      '      (Dest-1)^ := #$0;'
      '  end;'
      'end;'
      ''
      'function GetUILanguages(const LANGID: WORD): string;'
      ''
      '  function LastHyphenPos(S : String) : integer;'
      '  var'
      '    I: integer;'
      '  begin'
      '    for I := Length(S) downto 1 do'
      '      if S[I] = '#39'-'#39' then exit (I-1);'
      '    Result := 0;'
      '  end;'
      ''
      
        '  function ConvertResToUILanguages(ResBuffer: _PAnsiChr): String' +
        ';'
      '  var'
      '    I: Integer;'
      '    Separator,'
      '    ALanguage: String;'
      '  begin'
      '    Result := String(_PAnsiChr(ResBuffer));'
      '    for I := 1 to Length(Result) do'
      '      if Result[I] = '#39','#39' then exit;'
      '    ALanguage := Result;'
      '    Result := '#39#39';'
      '    while ALanguage <> '#39#39' do'
      '    begin'
      '      Result := Result + Separator + ALanguage;'
      '      Separator := '#39','#39';'
      '      ALanguage := Copy(ALanguage, 1, LastHyphenPos(ALanguage));'
      '    end;'
      '  end;'
      ''
      '  function GetPreferredLangForOldOS(LANGID: Word): string;'
      '  var'
      
        '    Language, Region : array[0.. LOCALE_NAME_MAX_LENGTH-1] of Ch' +
        'ar;'
      '    H, L, I: Cardinal;'
      '  begin'
      '    Result := '#39#39';'
      '    // Lookup exceptional languages table.'
      
        '    if (NumberOfLocaleData > 0) and (LocaleTable[0].ID <= LANGID' +
        ') and (LANGID <= LocaleTable[NumberOfLocaleData-1].ID) then'
      '    begin'
      '      H := NumberOfLocaleData-1;'
      '      L := 0;'
      '      while H >= L do'
      '      begin'
      '        I := (H + L) div 2;'
      '        if LocaleTable[I].ID > LANGID then H := I - 1'
      '        else if LocaleTable[I].ID < LANGID then L :=  I + 1'
      '        else'
      '        begin'
      
        '          Result := ConvertResToUILanguages(LocaleTable[I].List)' +
        ';'
      '          Break;'
      '        end;'
      '      end;'
      '    end;'
      
        '    if (Result = '#39#39') and IsValidLocale(LANGID, LCID_SUPPORTED) t' +
        'hen'
      '    begin'
      
        '      // Generate language names: <language>-<country> and <lang' +
        'uage>'
      
        '      GetLocaleInfo(LANGID, LOCALE_SISO639LANGNAME, Language, LO' +
        'CALE_NAME_MAX_LENGTH);'
      
        '      GetLocaleInfo(LANGID, LOCALE_SISO3166CTRYNAME, Region, LOC' +
        'ALE_NAME_MAX_LENGTH);'
      
        '      Result := String(Language) + '#39'-'#39' + String(Region) + '#39','#39' + ' +
        'String(Language);'
      '    end;'
      '  end;'
      ''
      
        '  function CheckDifferentLanguageList(src1, src2: PWideChar; len' +
        ': integer): Boolean;'
      '  begin'
      '    Result := True;'
      '    while len > 0 do'
      '    begin'
      '      if (src1^ <> src2^) then exit;'
      '      inc(src1);'
      '      inc(src2);'
      '      dec(len);'
      '    end;'
      '    Result := False;'
      '  end;'
      ''
      '  function ThreadUILanguages(var bufsize: Integer): PWideChar;'
      '  var'
      '    I: Integer;'
      '  begin'
      '    Result := nil;'
      '    bufsize := 0;'
      
        '    if GetThreadPreferredUILanguages(MUI_LANGUAGE_NAME or MUI_UI' +
        '_FALLBACK, @I, nil, @bufsize) then'
      '    begin'
      '      GetMem(Result, bufsize * sizeof(Char));'
      
        '      GetThreadPreferredUILanguages(MUI_LANGUAGE_NAME or MUI_UI_' +
        'FALLBACK, @I, Result, @bufsize);'
      '    end;'
      '  end;'
      ''
      '  function GetPreferredLangForNewOS(const LANGID: WORD): string;'
      '  var'
      '    SavedBufSize, BufSize: Integer;'
      '    SavedUILanguages, UILanguages: PChar;'
      '    I: integer;'
      '    W: WORD;'
      '    IDBuf: array[0..5] of WideChar; // four digits + two #0'
      '  begin'
      '    SavedUILanguages := nil;'
      '    if GetThreadUILanguage <> LANGID then'
      '    begin'
      '      SavedUILanguages := ThreadUILanguages(SavedBufSize);'
      '      W := LANGID;'
      '      for I := 3 downto 0 do'
      '      begin'
      '        IDBuf[I] := WideChar(Ord(hexDigits[W and $0F]));'
      '        W := W div 16;'
      '      end;'
      '      IDBuf[4] := #0; // Double null-terminator.'
      '      IDBuf[5] := #0;'
      
        '      SetThreadPreferredUILanguages(MUI_LANGUAGE_ID, @IDBuf, @I)' +
        ';'
      '    end;'
      ''
      '    UILanguages := ThreadUILanguages(BufSize);'
      '    if UILanguages <> nil then'
      '    begin'
      '      for I := 0 to BufSize - 2 do'
      '        if UILanguages[I] = #0 then UILanguages[I] := '#39','#39';'
      '      Result := UILanguages;'
      '      FreeMem(UILanguages);'
      '    end;'
      ''
      '    if SavedUILanguages <> nil then'
      '    begin'
      '      SetThreadPreferredUILanguages(0, nil, @I);'
      '      UILanguages := ThreadUILanguages(BufSize);'
      
        '      if (SavedBufSize <> BufSize) or CheckDifferentLanguageList' +
        '(SavedUILanguages, UILanguages, BufSize) then'
      
        '        SetThreadPreferredUILanguages(MUI_LANGUAGE_NAME, SavedUI' +
        'Languages, @I);'
      '      FreeMem(UILanguages);'
      '      FreeMem(SavedUILanguages);'
      '    end;'
      '  end;'
      ''
      'begin'
      '  EnterCriticalSection(CrSec);'
      '  if CachedLangID = LANGID then'
      '  begin'
      '    Result := CachedLanguageNames;'
      '    LeaveCriticalSection(CrSec);'
      '    exit;'
      '  end;'
      '  LeaveCriticalSection(CrSec);'
      ''
      '  Result := '#39#39';'
      '  if IsValidLocale(LANGID, LCID_SUPPORTED) then'
      '  begin'
      '    if UseThreadUILanguageAPI then'
      '      Result := GetPreferredLangForNewOS(LANGID)'
      '    else'
      '    begin'
      '      Result := GetPreferredLangForOldOS(LANGID);'
      '      if LangID <> GetSystemDefaultUILanguage then'
      '      begin'
      '        if Result <> '#39#39' then Result := Result + '#39','#39';'
      
        '        Result := Result + GetPreferredLangForOldOS(GetSystemDef' +
        'aultUILanguage);'
      '      end;'
      '    end;'
      '  end;'
      ''
      '  EnterCriticalSection(CrSec);'
      '  CachedLangID := LANGID;'
      
        '  StringCopy(CachedLanguageNames, SizeOf(CachedLanguageNames), P' +
        'Char(Result));'
      '  LeaveCriticalSection(CrSec);'
      'end;'
      ''
      'function InternalGetLocaleOverride(AppName: string): string;'
      ''
      '  function FindBS(Current: PChar): PChar;'
      '  begin'
      '    Result := Current;'
      '    while (Result^ <> #0) and (Result^ <> '#39'\'#39') do'
      '      Result := CharNext(Result);'
      '  end;'
      ''
      
        '  function ToLongPath(AFileName: PChar; var AStr: string): PChar' +
        ';'
      '  var'
      '    CurrBS, NextBS: PChar;'
      '    {$IFDEF CPU386}'
      '    Module: Integer;'
      '    {$ELSE}'
      '    Module: HMODULE;'
      '    {$ENDIF}'
      '    Handle: THandle;'
      '    L: Integer;'
      '    FindData: TWin32FindData;'
      '    Buffer: array[0..MAX_PATH] of Char;'
      
        '    GetLongPathName: function (ShortPathName: PChar; LongPathNam' +
        'e: PChar;'
      '      cchBuffer: Integer): Integer stdcall;'
      '  const'
      '    longPathName = '#39'GetLongPathNameW'#39';'
      '  begin'
      '    Result := AFileName;'
      '    Module := GetModuleHandle(kernel);'
      '    if Module <> 0 then'
      '    begin'
      '      @GetLongPathName := GetProcAddress(Module, longPathName);'
      '      if Assigned(GetLongPathName) then'
      '      begin'
      '        L := GetLongPathName(AFileName, nil, 0);'
      '        if L > 0 then'
      '        begin'
      '          SetLength(AStr, L - 1);'
      '          Result := PChar(AStr);'
      '          GetLongPathName(AFileName, Result, L);'
      '          Exit;'
      '        end;'
      '      end;'
      '    end;'
      ''
      '    if AFileName[0] = '#39'\'#39' then'
      '    begin'
      '      if AFileName[1] <> '#39'\'#39' then Exit;'
      '      CurrBS := FindBS(AFileName + 2);  // skip server name'
      '      if CurrBS^ = #0 then Exit;'
      '      CurrBS := FindBS(CurrBS + 1);     // skip share name'
      '      if CurrBS^ = #0 then Exit;'
      '    end else'
      '      CurrBS := AFileName + 2;          // skip drive name'
      ''
      '    L := CurrBS - AFileName;'
      '    if L + 1 > Length(Buffer) then Exit;'
      '    StringCopy(Buffer, L + 1, AFileName);'
      '    while CurrBS^ <> #0 do'
      '    begin'
      '      NextBS := FindBS(CurrBS + 1);'
      '      if L + (NextBS - CurrBS) + 1 > Length(Buffer) then Exit;'
      '      StringCopy(Buffer + L, (NextBS - CurrBS) + 1, CurrBS);'
      ''
      '      Handle := FindFirstFile(Buffer, FindData);'
      '      if Handle = THandle(-1) then Exit;'
      '      FindClose(Handle);'
      ''
      
        '      if L + 1 + _strlen(FindData.cFileName) + 1 > Length(Buffer' +
        ') then Exit;'
      '      Buffer[L] := '#39'\'#39';'
      
        '      StringCopy(Buffer + L + 1, Length(Buffer) - L - 1, FindDat' +
        'a.cFileName);'
      '      Inc(L, _strlen(FindData.cFileName) + 1);'
      '      CurrBS := NextBS;'
      '    end;'
      '    StringCopy(AFileName, MAX_PATH + 1, Buffer);'
      '  end;'
      ''
      'var'
      '  HostAppName: array [0..MAX_PATH] of Char;'
      '  HostAppStr: string;'
      '  HostApp: PChar;'
      '  LocaleOverride: PChar;'
      '  Key: HKEY;'
      '  LocSize: Integer;'
      'begin'
      '  if AppName = '#39#39' then'
      
        '    GetModuleFileName(0, HostAppName, Length(HostAppName)) // Ge' +
        't host application name'
      '  else'
      
        '    StringCopy(HostAppName, Length(HostAppName), PChar(AppName))' +
        ';'
      '  if HostAppName[0] = #$0 then exit;'
      '  LocaleOverride := nil;'
      ''
      
        '  if (RegOpenKeyEx(HKEY_CURRENT_USER, NewerLocaleOverrideKey, 0,' +
        ' KEY_READ, Key) = 0) or'
      
        '   (RegOpenKeyEx(HKEY_LOCAL_MACHINE, NewerLocaleOverrideKey, 0, ' +
        'KEY_READ, Key) = 0) or'
      
        '   (RegOpenKeyEx(HKEY_CURRENT_USER, NewLocaleOverrideKey, 0, KEY' +
        '_READ, Key) = 0) or'
      
        '   (RegOpenKeyEx(HKEY_LOCAL_MACHINE, NewLocaleOverrideKey, 0, KE' +
        'Y_READ, Key) = 0) or'
      
        '   (RegOpenKeyEx(HKEY_CURRENT_USER, OldLocaleOverrideKey, 0, KEY' +
        '_READ, Key) = 0) or'
      
        '   (RegOpenKeyEx(HKEY_CURRENT_USER, OlderLocaleOverrideKey, 0, K' +
        'EY_READ, Key) = 0) then'
      '  try'
      '    HostApp := ToLongPath(HostAppName, HostAppStr);'
      
        '    if RegQueryValueEx(Key, HostApp, nil, nil, nil, @LocSize) = ' +
        '0 then'
      '    begin'
      '      GetMem(LocaleOverride, LocSize);'
      
        '      RegQueryValueEx(Key, HostApp, nil, nil, PByte(LocaleOverri' +
        'de), @LocSize);'
      '      Result := LocaleOverride;'
      '    end'
      
        '    else if RegQueryValueEx(Key, '#39#39', nil, nil, nil, @LocSize) = ' +
        '0 then'
      '    begin'
      '      GetMem(LocaleOverride, LocSize);'
      
        '      RegQueryValueEx(Key, '#39#39', nil, nil, PByte(LocaleOverride), ' +
        '@LocSize);'
      '      Result := LocaleOverride;'
      '    end;'
      '  finally'
      '    if LocaleOverride <> nil then'
      '      FreeMem(LocaleOverride);'
      '    RegCloseKey(Key);'
      '  end;'
      'end;'
      '{$ENDIF MSWINDOWS}'
      ''
      'var'
      '  PreferredLanguagesOverride: PChar = nil;'
      ''
      'function GetLocaleOverride(const AppName: string): string;'
      'begin'
      '  if PreferredLanguagesOverride = nil then'
      '    SetLocaleOverride(InternalGetLocaleOverride(AppName));'
      '  Result := PreferredLanguagesOverride;'
      'end;'
      ''
      
        'procedure SetLocaleOverride(const NewPreferredLanguages: string)' +
        ';'
      'var'
      '  L: Integer;'
      'begin'
      '  if PreferredLanguagesOverride <> nil then'
      '    SysFreeMem(PreferredLanguagesOverride);'
      '  L := Length(NewPreferredLanguages);'
      '  if L > 0 then'
      '  begin'
      '    Inc(L);'
      '    PreferredLanguagesOverride := SysGetMem(L * SizeOf(Char));'
      
        '    MoveChars(NewPreferredLanguages[Low(string)], PreferredLangu' +
        'agesOverride^, L);'
      '  end'
      '  else'
      '    PreferredLanguagesOverride := nil;'
      'end;'
      ''
      
        '                                                                ' +
        '                    '
      
        'function GetResourceModuleName(HostAppName, ModuleName: string):' +
        ' string;'
      ''
      '  function ResouceDLLExists(S: string): Boolean;'
      '{$IFDEF POSIX}'
      '  var'
      '    st1: _stat;'
      '  begin'
      '    Result := stat(_PAnsiChr(UTF8Encode(S)), st1) <> -1;'
      '  end;'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      '  var'
      '    Handle: THandle;'
      '    FindData: TWin32FindData;'
      '  begin'
      '    Handle := FindFirstFile(PWideChar(S), FindData);'
      '    Result := Handle <> THandle(-1);'
      '    if Result then'
      '      FindClose(Handle);'
      '  end;'
      '{$ENDIF}'
      '{$IF (not defined(MSWINDOWS)) and (not defined(POSIX))}'
      '  begin'
      '    Error(rePlatformNotImplemented);'
      '    Result := False;'
      '  end;'
      '{$ENDIF !MSWINDOWS and !POSIX}'
      ''
      '  function LoadLanguageList(FileNameBody, List: String): string;'
      '  Var'
      '    s, ind : integer;'
      '  begin'
      '    Result := '#39#39';'
      '    ind := 1;'
      '    while (ind <= length(List)) do'
      '    begin'
      '      s := ind;'
      
        '      while (ind <= Length(List)) and (List[ind] <> '#39','#39') do inc(' +
        'ind);'
      '      if s <> ind then'
      '      begin'
      '        Result := FileNameBody + Copy(List, s, ind-s);'
      '        if ResouceDLLExists(Result) then exit;'
      '{$IFDEF MACOS}'
      '        // workaround for 282039.'
      '        if Copy(List, s, ind-s) = '#39'en'#39' then exit('#39#39');'
      '{$ENDIF MACOS}'
      '      end;'
      '      inc(ind);'
      '    end;'
      '    Result := '#39#39';'
      '  end;'
      ''
      '{$IFDEF MACOS}'
      '  function LoadLocalizedBundle(ModuleName: string): string;'
      ''
      '    function CFSTR(const s: string): CFStringRef;'
      '    begin'
      
        '      Result := CFStringCreateWithCharacters(nil, PChar(s), Leng' +
        'th(s));'
      '    end;'
      ''
      '  var'
      '    ind: integer;'
      '    resourceName, resourceType : CFStringRef;'
      '    resourceDirectoryURL: CFURLRef;'
      '    resourceDirectoryPath: CFStringRef;'
      '  begin'
      '    Result := '#39#39';'
      '    for ind := length(ModuleName) downto 1 do'
      '      if ModuleName[ind] = '#39'/'#39' then'
      '      begin'
      '        ModuleName := copy(ModuleName, ind+1, MAXINT);'
      '        break;'
      '      end;'
      ''
      '    resourceName := CFSTR(ModuleName);'
      '    resourceType := CFSTR('#39'resources'#39');'
      '    try'
      
        '      resourceDirectoryURL := CFBundleCopyResourceURL(CFBundleGe' +
        'tMainBundle, resourceName, resourceType, nil);'
      '      if resourceDirectoryURL <> nil then'
      '      try'
      
        '        resourceDirectoryPath := CFURLCopyFileSystemPath(resourc' +
        'eDirectoryURL, 0); // kCFURLPOSIXPathStyle'
      '        try'
      '          Result := StringRefToString(resourceDirectoryPath);'
      '          if ResouceDLLExists(Result) then exit;'
      '        finally'
      '          CFRelease(resourceDirectoryPath);'
      '        end;'
      '      finally'
      '        CFRelease(resourceDirectoryURL);'
      '      end;'
      '    finally'
      '      CFRelease(resourceType);'
      '      CFRelease(resourceName);'
      '    end;'
      '    Result := '#39#39';'
      '  end;'
      '{$ENDIF MACOS}'
      '{$IFDEF MSWINDOWS}'
      '  function Load3LettersModule(FileNameBody: string): string;'
      '  var'
      '    ExtPart : array[0..3] of char;'
      '  begin'
      
        '    GetLocaleInfo(GetUserDefaultUILanguage, LOCALE_SABBREVLANGNA' +
        'ME, ExtPart, SizeOf(ExtPart) div SizeOf(ExtPart[0]));'
      '    Result := FileNameBody + string(ExtPart);'
      '    if ResouceDLLExists(Result) then Exit;'
      '    ExtPart[2] := #$0;'
      '    Result := FileNameBody + string(ExtPart);'
      '    if ResouceDLLExists(Result) then Exit;'
      '    Result := '#39#39';'
      '  end;'
      '{$ENDIF MSWINDOWS}'
      ''
      'var'
      '  LocaleOverrideKey: string;'
      '  FileNameBody : string;'
      '  Ind: integer;'
      'begin'
      '  Result := '#39#39';'
      '  if ModuleName = '#39#39' then Exit;'
      '{$IFDEF MSWINDOWS}'
      '  FileNameBody := ModuleName;'
      '  for ind := Length(ModuleName) downto 1 do'
      '  begin'
      '    if ModuleName[ind + (Low(ModuleName)-1)] = '#39'.'#39' then'
      '    begin'
      '      FileNameBody := Copy(ModuleName, 1, ind);'
      '      break;'
      '    end;'
      '  end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      '  FileNameBody := ModuleName;'
      '  for ind := Length(ModuleName) downto 1 do'
      '  begin'
      '    if ModuleName[ind + (Low(ModuleName) - 1)] = '#39'.'#39' then'
      '    begin'
      '      if Copy(ModuleName, ind, MaxInt) = '#39'.dylib'#39' then'
      '        FileNameBody := Copy(ModuleName, 1, ind);'
      '      break;'
      '    end;'
      '  end;'
      
        '  if FileNameBody[Length(FileNameBody) + (Low(FileNameBody) -1 )' +
        '] <> '#39'.'#39' then'
      '    FileNameBody := FileNameBody + '#39'.'#39';'
      '{$ENDIF}'
      '  LocaleOverrideKey := GetLocaleOverride(HostAppName);'
      '  if LocaleOverrideKey <> '#39#39' then'
      '    Result := LoadLanguageList(FileNameBody, LocaleOverrideKey)'
      '  else'
      '  begin'
      '{$IFDEF POSIX}'
      '    Result := LoadLanguageList(FileNameBody, GetUILanguages(0));'
      '{$ENDIF POSIX}'
      '{$IFDEF MSWINDOWS}'
      
        '    Result := LoadLanguageList(FileNameBody, GetUILanguages(GetU' +
        'serDefaultUILanguage));'
      '    if (Result = '#39#39') and (not UseThreadUILanguageAPI) then'
      
        '      Result := LoadLanguageList(FileNameBody, GetUILanguages(Ge' +
        'tSystemDefaultUILanguage));'
      '    if Result = '#39#39' then'
      '      Result := Load3LettersModule(FileNameBody);'
      '{$ENDIF}'
      '  end;'
      '{$IF defined(MACOS)}'
      '  if Result = '#39#39' then'
      '    Result := LoadLocalizedBundle(ModuleName);'
      '{$ENDIF}'
      ''
      'end;'
      ''
      '{$IFDEF POSIX}'
      
        'function LoadModule(ModuleName, ResModuleName: string; CheckOwne' +
        'r: Boolean): THandle;'
      'var'
      '  st1, st2: _stat;'
      '  ModuleFileName, ResModuleFileName: _UTF8Str;'
      'begin'
      '{ Security check:  make sure the user id (owner) and group id of'
      
        '  the base module matches the user id and group id of the resour' +
        'ce'
      '  module we'#39're considering loading.  This is to prevent loading'
      '  of malicious code dropped into the base module'#39's directory by'
      '  a hostile user.  The app and all its resource modules must'
      
        '  have the same owner and group.  To disable this security check' +
        ','
      '  call this function with CheckOwner set to False. }'
      ''
      '  Result := 0;'
      ''
      '  ModuleFileName := UTF8Encode(ModuleName);'
      
        '  if CheckOwner and (stat(_PAnsiChr(ModuleFileName), st1) = -1) ' +
        'then'
      '    Exit;'
      ''
      '  ResModuleFileName := UTF8Encode(ResModuleName);'
      ''
      '  if (not CheckOwner) or'
      '    ((stat(_PAnsiChr(ResModuleFileName), st2) <> -1)'
      '     and (st1.st_uid = st2.st_uid)'
      '     and (st1.st_gid = st2.st_gid)) then'
      
        '    Result := THandle(dlopen(_PAnsiChr(ResModuleFileName), RTLD_' +
        'LAZY));'
      'end;'
      '{$ENDIF}'
      ''
      
        'function LoadResourceModule(ModuleName: PChar; CheckOwner: Boole' +
        'an): THandle;'
      'var'
      '  HostAppName: array [0..MAX_PATH] of Char;'
      '  ResModuleName : string;'
      'begin'
      '  Result := 0;'
      '  GetModuleFileName(0, HostAppName, Length(HostAppName));'
      
        '  ResModuleName := GetResourceModuleName(HostAppName, ModuleName' +
        ');'
      '  if ResModuleName <> '#39#39' then'
      '{$IFDEF MSWINDOWS}'
      
        '    Result := LoadLibraryEx(PChar(ResModuleName), 0, LOAD_LIBRAR' +
        'Y_AS_DATAFILE)'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      '    Result := LoadModule(ModuleName, ResModuleName, CheckOwner);'
      '{$ENDIF}'
      'end;'
      ''
      'procedure EnumModules(Func: TEnumModuleFunc; Data: Pointer);'
      'begin'
      '  EnumModules(TEnumModuleFuncLW(Func), Data);'
      'end;'
      ''
      
        'procedure EnumResourceModules(Func: TEnumModuleFunc; Data: Point' +
        'er);'
      'begin'
      '  EnumResourceModules(TEnumModuleFuncLW(Func), Data);'
      'end;'
      ''
      'procedure EnumModules(Func: TEnumModuleFuncLW; Data: Pointer);'
      'var'
      '  CurModule: PLibModule;'
      'begin'
      '  CurModule := LibModuleList;'
      '  while CurModule <> nil do'
      '  begin'
      '    if not Func(CurModule.Instance, Data) then Exit;'
      '    CurModule := CurModule.Next;'
      '  end;'
      'end;'
      ''
      
        'procedure EnumResourceModules(Func: TEnumModuleFuncLW; Data: Poi' +
        'nter);'
      'var'
      '  CurModule: PLibModule;'
      'begin'
      '  CurModule := LibModuleList;'
      '  while CurModule <> nil do'
      '  begin'
      
        '    if not Func(DelayLoadResourceModule(CurModule), Data) then E' +
        'xit;'
      '    CurModule := CurModule.Next;'
      '  end;'
      'end;'
      ''
      'procedure AddModuleUnloadProc(Proc: TModuleUnloadProc);'
      'begin'
      '  AddModuleUnloadProc(TModuleUnloadProcLW(Proc));'
      'end;'
      ''
      'procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProc);'
      'begin'
      '  RemoveModuleUnloadProc(TModuleUnloadProcLW(Proc));'
      'end;'
      ''
      'procedure AddModuleUnloadProc(Proc: TModuleUnloadProcLW);'
      'var'
      '  P: PModuleUnloadRec;'
      'begin'
      '  New(P);'
      '  P.Next := ModuleUnloadList;'
      '  @P.Proc := @Proc;'
      '  ModuleUnloadList := P;'
      'end;'
      ''
      'procedure RemoveModuleUnloadProc(Proc: TModuleUnloadProcLW);'
      'var'
      '  P, C: PModuleUnloadRec;'
      'begin'
      '  P := ModuleUnloadList;'
      '  if (P <> nil) and (@P.Proc = @Proc) then'
      '  begin'
      '    ModuleUnloadList := ModuleUnloadList.Next;'
      '    Dispose(P);'
      '  end else'
      '  begin'
      '    C := P;'
      '    while C <> nil do'
      '    begin'
      '      if (C.Next <> nil) and (@C.Next.Proc = @Proc) then'
      '      begin'
      '        P := C.Next;'
      '        C.Next := C.Next.Next;'
      '        Dispose(P);'
      '        Break;'
      '      end;'
      '      C := C.Next;'
      '    end;'
      '  end;'
      'end;'
      ''
      'procedure NotifyModuleUnload(HInstance: THandle);'
      'var'
      '  P, PNext: PModuleUnloadRec;'
      'begin'
      '  P := ModuleUnloadList;'
      '  while P <> nil do'
      '  begin'
      '    PNext := P.Next;'
      '    try'
      '      P.Proc(HInstance);'
      '    except'
      '      // Make sure it doesn'#39't stop notifications'
      '    end;'
      '    P := PNext;'
      '  end;'
      '{$IFDEF LINUX}'
      '  InvalidateModuleCache;'
      '{$ENDIF}'
      'end;'
      ''
      'procedure RegisterModule(LibModule: PLibModule);'
      'var'
      '  CurModule: PLibModule;'
      'begin'
      '  CurModule := LibModuleList;'
      '  while CurModule <> nil do'
      '  begin'
      '    if CurModule = LibModule then Exit;'
      '    CurModule := CurModule.Next;'
      '  end;'
      '  LibModule.Next := LibModuleList;'
      '  LibModuleList := LibModule;'
      'end;'
      ''
      'procedure UnregisterModule(LibModule: PLibModule);'
      'var'
      '  CurModule: PLibModule;'
      'begin'
      '  try'
      '    NotifyModuleUnload(LibModule.Instance);'
      '  finally'
      '    if LibModule = LibModuleList then'
      '      LibModuleList := LibModule.Next'
      '    else'
      '    begin'
      '      CurModule := LibModuleList;'
      '      while CurModule <> nil do'
      '      begin'
      '        if CurModule.Next = LibModule then'
      '        begin'
      '          CurModule.Next := LibModule.Next;'
      '          Break;'
      '        end;'
      '        CurModule := CurModule.Next;'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      'function _IntfClear(var Dest: IInterface): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: Pointer;'
      'begin'
      '  Result := @Dest;'
      '  if Dest <> nil then'
      '  begin'
      '    P := Pointer(Dest);'
      '    Pointer(Dest) := nil;'
      '    IInterface(P)._Release;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF CPUX86}'
      'asm'
      '        MOV     EDX,[EAX]'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      '        MOV     DWORD PTR [EAX],0'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        PUSH    EDX'
      '        MOV     EAX,[EDX]'
      '        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '@@1:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _IntfCopy(var Dest: IInterface; const Source: IInterfa' +
        'ce);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: Pointer;'
      'begin'
      '  P := Pointer(Dest);'
      '  if Source <> nil then'
      '    Source._AddRef;'
      '  Pointer(Dest) := Pointer(Source);'
      '  if P <> nil then'
      '    IInterface(P)._Release;'
      'end;'
      '{$ELSE}'
      '{$IFDEF CPUX86}'
      'asm'
      '{'
      
        '  The most common case is the single assignment of a non-nil int' +
        'erface'
      
        '  to a nil interface.  So we streamline that case here.  After t' +
        'his,'
      '  we give essentially equal weight to other outcomes.'
      ''
      
        '    The semantics are:  The source intf must be addrefed *before' +
        '* it'
      
        '    is assigned to the destination.  The old intf must be releas' +
        'ed'
      
        '    after the new intf is addrefed to support self assignment (I' +
        ' := I).'
      
        '    Either intf can be nil.  The first requirement is really to ' +
        'make an'
      
        '    error case function a little better, and to improve the beha' +
        'viour'
      
        '    of multithreaded applications - if the addref throws an exce' +
        'ption,'
      
        '    you don'#39't want the interface to have been assigned here, and' +
        ' if the'
      
        '    assignment is made to a global and another thread references' +
        ' it,'
      
        '    again you don'#39't want the intf to be available until the refe' +
        'rence'
      '    count is bumped.'
      '}'
      '        TEST    EDX,EDX         // is source nil?'
      '        JE      @@NilSource'
      '        PUSH    EDX             // save source'
      '        PUSH    EAX             // save dest'
      '        MOV     EAX,[EDX]       // get source vmt'
      '        PUSH    EDX             // source as arg'
      '        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._AddRef'
      '        POP     EAX             // retrieve dest'
      '        MOV     ECX, [EAX]      // get current value'
      '        POP     [EAX]           // set dest in place'
      '        TEST    ECX, ECX        // is current value nil?'
      '        JNE     @@ReleaseDest   // no, release it'
      
        '        RET                     // most common case, we return h' +
        'ere'
      '@@ReleaseDest:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EAX,[ECX]       // get current value vmt'
      '        PUSH    ECX             // current value as arg'
      '        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        RET'
      ''
      '{   Now we'#39're into the less common cases.  }'
      '@@NilSource:'
      '        MOV     ECX, [EAX]      // get current value'
      '        TEST    ECX, ECX        // is it nil?'
      '        MOV     [EAX], EDX      // store in dest (which is nil)'
      '        JE      @@Done'
      '        MOV     EAX, [ECX]      // get current vmt'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    ECX             // current value as arg'
      '        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '@@Done:'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL}'
      ''
      
        'procedure _IntfCast(var Dest: IInterface; const Source: IInterfa' +
        'ce; const IID: TGUID);'
      '{$IF defined(PUREPASCAL) or defined(PIC)}'
      '// PIC:  EBX must be correct before calling QueryInterface'
      'var'
      '  Temp: Pointer;'
      'begin'
      '  if Source = nil then'
      '    Dest := nil'
      '  else'
      '  begin'
      '    Temp := nil;'
      '    if Source.QueryInterface(IID, IInterface(Temp)) <> 0 then'
      '      ErrorAt(byte(reIntfCastError), ReturnAddress)'
      '    else'
      '    begin'
      '      if Assigned(Dest) then'
      '        Dest._Release;'
      '      Pointer(Dest) := Temp;'
      '    end;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL or !PIC}'
      '{$IFDEF CPUX86}'
      'asm'
      '        TEST    EDX,EDX'
      '        JE      _IntfClear'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDI'
      '        MOV     EDI, EAX   // ptr to dest'
      '        PUSH    0'
      '        PUSH    ESP        // ptr to temp'
      '        PUSH    ECX        // ptr to GUID'
      '        PUSH    EDX        // ptr to source'
      '@@1:    MOV     EAX,[EDX]'
      
        '        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface.QueryInte' +
        'rface'
      '        TEST    EAX,EAX'
      '        JE      @@2'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 16'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     AL,reIntfCastError'
      '        JMP     Error'
      '@@2:    MOV     EAX, [EDI]'
      '        TEST    EAX, EAX'
      '        JE      @@3'
      '        PUSH    EAX'
      '        MOV     EAX,[EAX]'
      '        CALL    DWORD PTR [EAX] + VMTOFFSET IInterface._Release'
      '@@3:    POP     EAX          // value of temp'
      '        MOV     [EDI], EAX'
      '        POP     EDI'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      'end;'
      '{$ENDIF CPUX86}'
      '{$ENDIF !PUREPASCAL or !PIC}'
      ''
      'procedure _IntfAddRef(const Dest: IInterface);'
      'begin'
      '  if Dest <> nil then Dest._AddRef;'
      'end;'
      ''
      
        'procedure _IntfOfsCast(var Dest: IInterface; const Source: TObje' +
        'ct; const Offset: Integer);'
      'begin'
      '  if Source <> nil then'
      '    _IntfCopy(Dest, IInterface(PByte(Source) + Offset))'
      '  else'
      '    _IntfClear(Dest);'
      'end;'
      ''
      '{$IFDEF AUTOREFCOUNT}'
      ''
      'function _InstClear(var Dest: TObject): Pointer;'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: Pointer;'
      'begin'
      '  Result := @Dest;'
      '  if Dest <> nil then'
      '  begin'
      '    P := Pointer(Dest);'
      '    Pointer(Dest) := nil;'
      '    TObject(P).__ObjRelease;'
      '  end;'
      'end;'
      '{$ELSE}'
      'asm'
      '        MOV     EDX,[EAX]'
      '        TEST    EDX,EDX'
      '        JE      @@1'
      '        MOV     DWORD PTR [EAX],0'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EAX'
      '        MOV     EAX,EDX'
      '        MOV     EDX,[EDX]'
      '        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjRelease'
      '        POP     EAX'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 8'
      '{$ENDIF ALIGN_STACK}'
      '@@1:'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _InstCopy(var Dest: TObject; const Source: TObject);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  P: Pointer;'
      'begin'
      '  P := Pointer(Dest);'
      '  if Source <> nil then'
      '    Source.__ObjAddRef;'
      '  Pointer(Dest) := Pointer(Source);'
      '  if P <> nil then'
      '    TObject(P).__ObjRelease;'
      'end;'
      '{$ELSE}'
      'asm'
      '{'
      
        '  The most common case is the single assignment of a non-nil int' +
        'erface'
      
        '  to a nil interface.  So we streamline that case here.  After t' +
        'his,'
      '  we give essentially equal weight to other outcomes.'
      ''
      
        '    The semantics are:  The source intf must be addrefed *before' +
        '* it'
      
        '    is assigned to the destination.  The old intf must be releas' +
        'ed'
      
        '    after the new intf is addrefed to support self assignment (I' +
        ' := I).'
      
        '    Either intf can be nil.  The first requirement is really to ' +
        'make an'
      
        '    error case function a little better, and to improve the beha' +
        'viour'
      
        '    of multithreaded applications - if the addref throws an exce' +
        'ption,'
      
        '    you don'#39't want the interface to have been assigned here, and' +
        ' if the'
      
        '    assignment is made to a global and another thread references' +
        ' it,'
      
        '    again you don'#39't want the intf to be available until the refe' +
        'rence'
      '    count is bumped.'
      '}'
      '        TEST    EDX,EDX         // is source nil?'
      '        JE      @@NilSource'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        PUSH    EDX             // save source'
      '        PUSH    EAX             // save dest'
      '        MOV     EAX,EDX         // source as arg'
      '        MOV     EDX,[EAX]       // get source vmt'
      '        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjAddRef'
      '        POP     EAX             // retrieve dest'
      '        MOV     ECX, [EAX]      // get current value'
      '        POP     [EAX]           // set dest in place'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 4'
      '{$ENDIF ALIGN_STACK}'
      '        TEST    ECX, ECX        // is current value nil?'
      '        JNE     @@ReleaseDest   // no, release it'
      
        '        RET                     // most common case, we return h' +
        'ere'
      '@@ReleaseDest:'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EDX,[ECX]       // get current value vmt'
      '        MOV     EAX,ECX         // current value as arg'
      '        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjRelease'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        RET'
      ''
      '{   Now we'#39're into the less common cases.  }'
      '@@NilSource:'
      '        MOV     ECX,[EAX]      // get current value'
      '        TEST    ECX,ECX        // is it nil?'
      '        MOV     [EAX],EDX      // store in dest (which is nil)'
      '        JE      @@Done'
      '        MOV     EDX,[ECX]      // get current vmt'
      '{$IFDEF ALIGN_STACK}'
      '        SUB     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '        MOV     EAX,ECX        // current value as arg'
      '        CALL    DWORD PTR [EDX] + VMTOFFSET TObject.__ObjRelease'
      '{$IFDEF ALIGN_STACK}'
      '        ADD     ESP, 12'
      '{$ENDIF ALIGN_STACK}'
      '@@Done:'
      'end;'
      '{$ENDIF !PUREPASCAL}'
      ''
      'procedure _InstAddRef(const Dest: TObject);'
      'begin'
      '  if Dest <> nil then Dest.__ObjAddRef;'
      'end;'
      '{$ENDIF AUTOREFCOUNT}'
      ''
      '{$IFDEF WEAKREF}'
      'type'
      '  TBucket = TArray<PPointer>;'
      ''
      '  PInstItem = ^TInstItem;'
      '  TInstItem = record'
      '  const'
      '    BucketHashSize = 31;'
      '  type'
      '    TBucketArray = array[0..BucketHashSize - 1] of TBucket;'
      '  private'
      '    FInstance: Pointer;'
      '    FLock: PMonitor;'
      '    FBuckets: TBucketArray;'
      '    FMethodBuckets: TBucketArray;'
      '    procedure ClearWeakRefs;'
      '    function GetValue: UIntPtr; inline;'
      '    function Hash(Address: Pointer): Integer; inline;'
      '    procedure Lock;'
      '    procedure Unlock;'
      
        '    procedure RegisterRef(var Buckets: TBucketArray; Address: Po' +
        'inter);'
      
        '    procedure UnregisterRef(var Buckets: TBucketArray; Address: ' +
        'Pointer);'
      '  public'
      '    class function Create: PInstItem; static;'
      '    procedure Destroy;'
      '    function Free: Boolean;'
      '    procedure RegisterWeakRef(Address: Pointer); inline;'
      '    procedure UnregisterWeakRef(Address: Pointer); inline;'
      '    procedure RegisterWeakMethodRef(Address: Pointer); inline;'
      '    procedure UnregisterWeakMethodRef(Address: Pointer); inline;'
      '    property Instance: Pointer read FInstance write FInstance;'
      '    property Value: UIntPtr read GetValue;'
      '  end;'
      ''
      '  TInstItems = TArray<PInstItem>;'
      ''
      '  TInstBucket = record'
      '  private'
      '    FLock: PMonitor;'
      '    FCount: Integer;'
      '    FInstItems: TInstItems;'
      '  public'
      '    procedure Initialize;'
      '    procedure Finalize;'
      '    procedure Lock;'
      '    procedure Unlock;'
      '    procedure AddInstItem(AIndex: Integer; AItem: PInstItem);'
      
        '    function FindInstItem(AInstance: Pointer; out AIndex: Intege' +
        'r): PInstItem;'
      '    function RemoveInstItem(AInstance: Pointer): PInstItem;'
      '  end;'
      ''
      '  TFreeInstItem = record'
      '    Item: PInstItem;'
      '    Tag: NativeUInt;'
      
        '  end align {$IFDEF CPU64BITS} 16 {$ELSE !CPU64BITS} 8 {$ENDIF C' +
        'PU64BITS};'
      ''
      '  TInstHashMap = record'
      '  const'
      '    BucketHashSize = 197;'
      
        '    MaxFreeInstItems = {$IF Defined(ANDROID) or Defined(IOS)}128' +
        '{$ELSE }512{$ENDIF};'
      '  private'
      '    [Volatile] FFreeInstItems: TFreeInstItem;'
      '    [Volatile] FTagCounter: NativeUInt;'
      '    FFreeCount: Integer;'
      '    FInitLock: PMonitor;'
      '    FBuckets: array[0..BucketHashSize - 1] of TInstBucket;'
      '    FInitialized: Boolean;'
      '    function Hash(Address: Pointer): Integer; inline;'
      '    procedure FreeInstItem(AItem: PInstItem);'
      '    function NewInstItem(Instance: Pointer): PInstItem;'
      
        '    function FindInstItem(Instance: Pointer; H: Integer; out AIn' +
        'dex: Integer): PInstItem; inline;'
      
        '    function AddInstItem(Instance: Pointer; H: Integer; AIndex: ' +
        'Integer): PInstItem; inline;'
      '    function PopInstItem: PInstItem;'
      '  public'
      '    procedure Destroy(Instance: Pointer);'
      '    procedure Initialize;'
      '    procedure Finalize;'
      
        '    procedure RegisterWeakRef(Address: Pointer; Instance: Pointe' +
        'r);'
      
        '    procedure UnregisterWeakRef(Address: Pointer; Instance: Poin' +
        'ter);'
      
        '    procedure RegisterWeakMethodRef(Address: Pointer; Instance: ' +
        'Pointer);'
      
        '    procedure UnregisterWeakMethodRef(Address: Pointer; Instance' +
        ': Pointer);'
      '    function IsRegistered(Instance: Pointer): Boolean;'
      
        '  end align {$IFDEF CPU64BITS} 16 {$ELSE !CPU64BITS} 8 {$ENDIF C' +
        'PU64BITS};'
      ''
      'procedure ArrayOfPointerClear(const ptr: PPointer);'
      'var'
      '  p: Pointer;'
      'begin'
      '  p := ptr^;'
      '  if p <> nil then'
      '  begin'
      '    ptr^ := nil;'
      '    if __DynArrayRefCnt(p) > 0 then'
      '    begin'
      
        '      if AtomicDecrement(PDynArrayRec(PByte(p) - SizeOf(TDynArra' +
        'yRec))^.RefCnt) = 0 then'
      '      begin'
      '        Dec(PByte(p), SizeOf(TDynArrayRec));'
      '        SysFreeMem(p);'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure ArrayOfPointerSetLength(ptr: PPointer; const NewLength' +
        ': NativeInt);'
      'const'
      '  elSize = SizeOf(Pointer);'
      'var'
      '  oldLength, minLength: NativeInt;'
      '  neededSize: NativeInt;'
      '  p: Pointer;'
      'begin'
      '  p := ptr^;'
      '  neededSize := newLength*elSize + SizeOf(TDynArrayRec);'
      '  if p = nil then'
      '    p := SysAllocMem(neededSize)'
      '  else'
      '  begin'
      '    Dec(PByte(p), SizeOf(TDynArrayRec));'
      '    oldLength := PDynArrayRec(p).Length;'
      ''
      '    if PDynArrayRec(p).RefCnt = 1 then'
      '{$IFDEF ANDROID}'
      
        '      p := SysReallocMem(p, CalcReallocMemorySizeWithGap(neededS' +
        'ize, elSize))'
      '{$ELSE !ANDROID}'
      '      p := SysReallocMem(p, neededSize)'
      '{$ENDIF ANDROID}'
      '    else'
      '    begin'
      '      p := SysGetMem(neededSize);'
      '      minLength := oldLength;'
      '      if minLength > newLength then'
      '        minLength := newLength;'
      
        '      Move(PByte(ptr^)^, (PByte(p) + SizeOf(TDynArrayRec))^, min' +
        'Length*elSize);'
      '      ArrayOfPointerClear(ptr^);'
      '    end;'
      '    if newLength > oldLength then'
      
        '      FillChar((PByte(p) + SizeOf(TDynArrayRec) + elSize*oldLeng' +
        'th)^, elSize * (newLength - oldLength), 0);'
      '  end;'
      ''
      '  PDynArrayRec(p).RefCnt := 1;'
      '  PDynArrayRec(p).Length := newLength;'
      '  Inc(PByte(p), SizeOf(TDynArrayRec));'
      ''
      '  ptr^ := p;'
      'end;'
      ''
      '{ TInstItem }'
      ''
      'class function TInstItem.Create: PInstItem;'
      'begin'
      '  Result := SysAllocMem(SizeOf(Result^));'
      '  Result.FLock := TMonitor.Create;'
      'end;'
      ''
      'procedure TInstItem.ClearWeakRefs;'
      'var'
      '  I, J: Integer;'
      '  Loc: PPointer;'
      'begin'
      '  for I := Low(FBuckets) to High(FBuckets) do'
      '  begin'
      '    for J := Low(FBuckets[I]) to High(FBuckets[I]) do'
      '    begin'
      '      Loc := FBuckets[I][J];'
      '      if Loc <> nil then'
      '      begin'
      '        Loc^ := nil;'
      '        FBuckets[I][J] := nil;'
      '      end;'
      '    end;'
      
        '    for J := Low(FMethodBuckets[I]) to High(FMethodBuckets[I]) d' +
        'o'
      '    begin'
      '      Loc := FMethodBuckets[I][J];'
      '      if Loc <> nil then'
      '      begin'
      '        TMethod(Pointer(Loc)^).Code := nil;'
      '        TMethod(Pointer(Loc)^).Data := nil;'
      '        FMethodBuckets[I][J] := nil;'
      '      end;'
      '    end;'
      '  end;'
      'end;'
      ''
      'function TInstItem.GetValue: UIntPtr;'
      'begin'
      '  Result := UIntPtr(FInstance);'
      'end;'
      ''
      'function TInstItem.Hash(Address: Pointer): Integer;'
      'begin'
      
        '  Result := ((IntPtr(Address) shr 13) + (IntPtr(Address) shr 5))' +
        ' mod BucketHashSize;'
      'end;'
      ''
      'procedure TInstItem.Lock;'
      'begin'
      '  if MonitorSupport <> nil then'
      '    FLock.Enter(INFINITE);'
      'end;'
      ''
      'procedure TInstItem.Unlock;'
      'begin'
      '  if MonitorSupport <> nil then'
      '    FLock.Exit;'
      'end;'
      ''
      'procedure TInstItem.Destroy;'
      'begin'
      '  ClearWeakRefs;'
      '  FInstance := nil;'
      'end;'
      ''
      'function TInstItem.Free: Boolean;'
      'var'
      '  H: Integer;'
      'begin'
      '  Result := @Self <> nil;'
      '  if Result then'
      '  begin'
      '    ClearWeakRefs;'
      '    for H := 0 to Length(FBuckets)-1 do'
      '      ArrayOfPointerClear(@FBuckets[H]);'
      '    for H := 0 to Length(FMethodBuckets)-1 do'
      '      ArrayOfPointerClear(@FMethodBuckets[H]);'
      '    FLock.Destroy; // SysMemFree.'
      '    FLock := nil;'
      '    SysFreeMem(@Self);'
      '  end;'
      'end;'
      ''
      
        'procedure TInstItem.RegisterRef(var Buckets: TBucketArray; Addre' +
        'ss: Pointer);'
      'var'
      '  I, H: Integer;'
      'begin'
      '  H := Hash(Address);'
      '  Lock;'
      '  try'
      '    for I := Low(Buckets[H]) to High(Buckets[H]) do'
      '      if Buckets[H][I] = nil then'
      '      begin'
      '        Buckets[H][I] := Address;'
      '        Exit;'
      '      end;'
      '    I := Length(Buckets[H]);'
      '    if I = 0 then'
      '      ArrayOfPointerSetLength(@Buckets[H], 10)'
      '    else'
      '      ArrayOfPointerSetLength(@Buckets[H], I * 2);'
      '    Buckets[H][I] := Address;'
      '  finally'
      '    Unlock;'
      '  end;'
      'end;'
      ''
      
        'procedure TInstItem.UnregisterRef(var Buckets: TBucketArray; Add' +
        'ress: Pointer);'
      'var'
      '  I, H: Integer;'
      'begin'
      '  H := Hash(Address);'
      '  Lock;'
      '  try'
      '    for I := Low(Buckets[H]) to High(Buckets[H]) do'
      '      if Buckets[H][I] = Address then'
      '      begin'
      '        Buckets[H][I] := nil;'
      '        Exit;'
      '      end;'
      '  finally'
      '    Unlock;'
      '  end;'
      'end;'
      ''
      'procedure TInstItem.RegisterWeakRef(Address: Pointer);'
      'begin'
      '  RegisterRef(FBuckets, Address);'
      'end;'
      ''
      'procedure TInstItem.UnregisterWeakRef(Address: Pointer);'
      'begin'
      '  UnregisterRef(FBuckets, Address);'
      'end;'
      ''
      'procedure TInstItem.RegisterWeakMethodRef(Address: Pointer);'
      'begin'
      '  RegisterRef(FMethodBuckets, Address);'
      'end;'
      ''
      'procedure TInstItem.UnregisterWeakMethodRef(Address: Pointer);'
      'begin'
      '  UnregisterRef(FMethodBuckets, Address);'
      'end;'
      ''
      '{ TInstBucket }'
      ''
      
        'procedure TInstBucket.AddInstItem(AIndex: Integer; AItem: PInstI' +
        'tem);'
      'begin'
      '  if Length(FInstItems) = 0 then'
      '    ArrayOfPointerSetLength(@FInstItems, 10)'
      '  else if FCount = Length(FInstItems) then'
      
        '    ArrayOfPointerSetLength(@FInstItems, Length(FInstItems) * 2)' +
        ';'
      '  if AIndex >= FCount then'
      '    FInstItems[FCount] := AItem'
      '  else'
      '  begin'
      
        '    Move(FInstItems[AIndex], FInstItems[AIndex + 1], (FCount - A' +
        'Index) * SizeOf(PInstItem));'
      '    FInstItems[AIndex] := AItem;'
      '  end;'
      '  Inc(FCount);'
      'end;'
      ''
      
        'function TInstBucket.FindInstItem(AInstance: Pointer; out AIndex' +
        ': Integer): PInstItem;'
      'var'
      '  Low, High, Mid: Integer;'
      '  Test: IntPtr;'
      'begin'
      '  Result := nil;'
      '  if FCount > 0 then'
      '  begin'
      '    Low := 0;'
      '    High := FCount - 1;'
      '    while Low <= High do'
      '    begin'
      '      Mid := (Low + High) shr 1;'
      '      Test := FInstItems[Mid].Value - UIntPtr(AInstance);'
      '      if Test < 0 then'
      '        Low := Mid + 1'
      '      else'
      '      begin'
      '        High := Mid - 1;'
      '        if Test = 0 then'
      '        begin'
      '          Result := FInstItems[Mid];'
      '          Low := Mid;'
      '        end;'
      '      end'
      '    end;'
      '    AIndex := Low;'
      '  end else'
      '    AIndex := 0;'
      'end;'
      ''
      'procedure TInstBucket.Finalize;'
      'var'
      '  I: Integer;'
      'begin'
      '  for I := 0 to FCount - 1 do'
      '    FInstItems[I].Free;'
      '  FCount := 0;'
      '  FLock.Destroy;'
      '  ArrayOfPointerClear(@FInstItems);'
      'end;'
      ''
      'procedure TInstBucket.Initialize;'
      'begin'
      '  FLock := TMonitor.Create;'
      '  FCount := 0;'
      'end;'
      ''
      'procedure TInstBucket.Lock;'
      'begin'
      '  if MonitorSupport <> nil then'
      '    FLock.Enter(INFINITE);'
      'end;'
      ''
      
        'function TInstBucket.RemoveInstItem(AInstance: Pointer): PInstIt' +
        'em;'
      'var'
      '  Index: Integer;'
      'begin'
      '  Result := FindInstItem(AInstance, Index);'
      '  if (Result <> nil) and (Index < FCount) then'
      '  begin'
      '    if Index < FCount - 1 then'
      
        '      Move(FInstItems[Index + 1], FInstItems[Index], (FCount - I' +
        'ndex - 1) * SizeOf(PInstItem));'
      '    Dec(FCount);'
      '  end;'
      'end;'
      ''
      'procedure TInstBucket.Unlock;'
      'begin'
      '  if MonitorSupport <> nil then'
      '    FLock.Exit;'
      'end;'
      ''
      '{ TInstHashMap }'
      ''
      'function TInstHashMap.Hash(Address: Pointer): Integer;'
      'begin'
      
        '  Result := ((IntPtr(Address) shr 13) + (IntPtr(Address) shr 5))' +
        ' mod BucketHashSize;'
      'end;'
      ''
      'procedure TInstHashMap.FreeInstItem(AItem: PInstItem);'
      'var'
      '  RawData, NewData: TFreeInstItem;'
      'begin'
      '  if AtomicIncrement(FFreeCount) <= MaxFreeInstItems then'
      '  begin'
      '    NewData.Tag := AtomicIncrement(FTagCounter);'
      '    NewData.Item := AItem;'
      '    RawData := FFreeInstItems;'
      '    repeat'
      '      AItem.Instance := RawData.Item;'
      '{$IFDEF CPU64BITS}'
      
        '    until AtomicCmpExchange128(FFreeInstItems, NewData.Tag, Nati' +
        'veUInt(NewData.Item), RawData);'
      '{$ENDIF CPU64BITS}'
      '{$IFDEF CPU32BITS}'
      
        '    until AtomicCmpExchange(UInt64(FFreeInstItems), UInt64(NewDa' +
        'ta), UInt64(RawData)) = UInt64(RawData);'
      '{$ENDIF CPU32BITS}'
      '  end else'
      '  begin'
      '    AtomicDecrement(FFreeCount);'
      '    AItem.Free;'
      '  end;'
      'end;'
      ''
      'function TInstHashMap.NewInstItem(Instance: Pointer): PInstItem;'
      'begin'
      '  Result := PopInstItem;'
      '  if Result = nil then'
      '    Result := TInstItem.Create;'
      '  Result.Instance := Instance;'
      'end;'
      ''
      'function TInstHashMap.PopInstItem: PInstItem;'
      'var'
      '  RawData, NewData: TFreeInstItem;'
      'begin'
      '  NewData.Tag := AtomicIncrement(FTagCounter);'
      '  RawData := FFreeInstItems;'
      '  repeat'
      '    Result := RawData.Item;'
      '    if Result = nil then'
      '      Break;'
      '    NewData.Item := Result.Instance;'
      '{$IFDEF CPU64BITS}'
      
        '  until AtomicCmpExchange128(FFreeInstItems, NewData.Tag, Native' +
        'UInt(NewData.Item), RawData);'
      '{$ENDIF CPU64BITS}'
      '{$IFDEF CPU32BITS}'
      
        '  until AtomicCmpExchange(UInt64(FFreeInstItems), UInt64(NewData' +
        '), UInt64(RawData)) = UInt64(RawData);'
      '{$ENDIF CPU32BITS}'
      '  if Result <> nil then'
      '    AtomicDecrement(FFreeCount);'
      'end;'
      ''
      
        'function TInstHashMap.FindInstItem(Instance: Pointer; H: Integer' +
        '; out AIndex: Integer): PInstItem;'
      'begin'
      '  Result := FBuckets[H].FindInstItem(Instance, AIndex);'
      'end;'
      ''
      
        'function TInstHashMap.AddInstItem(Instance: Pointer; H: Integer;' +
        ' AIndex: Integer): PInstItem;'
      'begin'
      '  Result := NewInstItem(Instance);'
      '  FBuckets[H].AddInstItem(AIndex, Result);'
      'end;'
      ''
      'procedure TInstHashMap.Finalize;'
      'var'
      '  I: Integer;'
      'begin'
      '  if FInitialized then'
      '  begin'
      '    for I := Low(FBuckets) to High(FBuckets) do'
      '      FBuckets[I].Finalize;'
      '    while PopInstItem.Free do ; // SysMemFree.'
      '    if FInitLock <> nil then'
      '      FInitLock.Destroy; // SysMemFree.'
      '  end;'
      'end;'
      ''
      'procedure TInstHashMap.Initialize;'
      'var'
      '  I: Integer;'
      '  Lock: PMonitor;'
      'begin'
      '  if not FInitialized then'
      '  begin'
      '    if FInitLock = nil then'
      '    begin'
      '      Lock := TMonitor.Create;'
      '      Lock := AtomicCmpExchange(FInitLock, Lock, nil);'
      '      if Lock <> nil then'
      '        Lock.Destroy;'
      '    end;'
      '    FInitLock.Enter(INFINITE);'
      '    try'
      '      if not FInitialized then'
      '      begin'
      '        for I := Low(FBuckets) to High(FBuckets) do'
      '          FBuckets[I].Initialize;'
      '        FInitialized := True;'
      '      end;'
      '    finally'
      '      FInitLock.Exit;'
      '    end;'
      '  end;'
      'end;'
      ''
      'procedure TInstHashMap.Destroy(Instance: Pointer);'
      'var'
      '  H: Integer;'
      '  Item: PInstItem;'
      'begin'
      '  if not FInitialized then Exit;'
      '  H := Hash(Instance);'
      '  FBuckets[H].Lock;'
      '  try'
      '    Item := FBuckets[H].RemoveInstItem(Instance);'
      '  finally'
      '    FBuckets[H].Unlock;'
      '  end;'
      '  if Item <> nil then'
      '  begin'
      '    Item.Destroy;'
      '    FreeInstItem(Item);'
      '  end;'
      'end;'
      ''
      
        'procedure TInstHashMap.RegisterWeakRef(Address: Pointer; Instanc' +
        'e: Pointer);'
      'var'
      '  H, Index: Integer;'
      '  Item: PInstItem;'
      'begin'
      '  if not FInitialized then Initialize;'
      '  H := Hash(Instance);'
      '  FBuckets[H].Lock;'
      '  try'
      '    Item := FindInstItem(Instance, H, Index);'
      '    if Item = nil then'
      '      Item := AddInstItem(Instance, H, Index);'
      '  finally'
      '    FBuckets[H].Unlock;'
      '  end;'
      '  Item.RegisterWeakRef(Address);'
      'end;'
      ''
      
        'procedure TInstHashMap.UnregisterWeakRef(Address: Pointer; Insta' +
        'nce: Pointer);'
      'var'
      '  H, Index: Integer;'
      '  Item: PInstItem;'
      'begin'
      '  if not FInitialized then Exit;'
      '  H := Hash(Instance);'
      '  FBuckets[H].Lock;'
      '  try'
      '    Item := FindInstItem(Instance, H, Index);'
      '  finally'
      '    FBuckets[H].Unlock;'
      '  end;'
      '  if Item <> nil then'
      '    Item.UnregisterWeakRef(Address);'
      'end;'
      ''
      
        'procedure TInstHashMap.RegisterWeakMethodRef(Address: Pointer; I' +
        'nstance: Pointer);'
      'var'
      '  H, Index: Integer;'
      '  Item: PInstItem;'
      'begin'
      '  if not FInitialized then Initialize;'
      '  H := Hash(Instance);'
      '  FBuckets[H].Lock;'
      '  try'
      '    Item := FindInstItem(Instance, H, Index);'
      '    if Item = nil then'
      '      Item := AddInstItem(Instance, H, Index);'
      '  finally'
      '    FBuckets[H].Unlock;'
      '  end;'
      '  Item.RegisterWeakMethodRef(Address);'
      'end;'
      ''
      
        'procedure TInstHashMap.UnregisterWeakMethodRef(Address: Pointer;' +
        ' Instance: Pointer);'
      'var'
      '  H, Index: Integer;'
      '  Item: PInstItem;'
      'begin'
      '  if not FInitialized then Exit;'
      '  H := Hash(Instance);'
      '  FBuckets[H].Lock;'
      '  try'
      '    Item := FindInstItem(Instance, H, Index);'
      '  finally'
      '    FBuckets[H].Unlock;'
      '  end;'
      '  if Item <> nil then'
      '    Item.UnregisterWeakMethodRef(Address);'
      'end;'
      ''
      'function TInstHashMap.IsRegistered(Instance: Pointer): Boolean;'
      'var'
      '  H, Index: Integer;'
      '  Item: PInstItem;'
      'begin'
      '  Result := False;'
      '  if not FInitialized then Exit;'
      '  H := Hash(Instance);'
      '  FBuckets[H].Lock;'
      '  try'
      '    Item := FindInstItem(Instance, H, Index);'
      '  finally'
      '    FBuckets[H].Unlock;'
      '  end;'
      '  Result := Item <> nil;'
      'end;'
      ''
      'var'
      '  InstHashMap: TInstHashMap;'
      ''
      'function IsWeakReferenced(const Obj: TObject): Boolean; inline;'
      'begin'
      
        '  Result := (PNativeInt(GetMonitorFieldAddress(Obj))^ and monWea' +
        'kReferencedFlag) <> 0;'
      'end;'
      ''
      'procedure MarkWeakReferenced(const Obj: TObject);'
      '{$IFDEF PUREPASCAL}'
      'var'
      '  MonitorFld: PNativeInt;'
      '  [Volatile] Flags: NativeInt;'
      'begin'
      '  MonitorFld := PNativeInt(GetMonitorFieldAddress(Obj));'
      '  Flags := MonitorFld^;'
      '  while (Flags and monWeakReferencedFlag) = 0 do'
      '  begin'
      
        '    AtomicCmpExchange(MonitorFld^, Flags or monWeakReferencedFla' +
        'g, Flags);'
      '    Flags := MonitorFld^;'
      '  end;'
      'end;'
      '{$ELSE !PUREPASCAL}'
      '{$IFDEF  CPUX86}'
      'asm'
      '      CALL GetMonitorFieldAddress'
      ' LOCK BTS [EAX], 0'
      'end;'
      '{$ELSEIF CPUX64}'
      'asm'
      '      CALL GetMonitorFieldAddress'
      ' LOCK BTS [RAX], 0'
      'end;'
      '{$ENDIF}'
      '{$ENDIF PUREPASCAL}'
      ''
      ''
      
        'procedure RegisterWeakRef(Address: Pointer; const Instance: TObj' +
        'ect);'
      'begin'
      '  if Instance <> nil then'
      '  begin'
      '    if not IsWeakReferenced(Instance) then'
      '      MarkWeakReferenced(Instance);'
      '    InstHashMap.RegisterWeakRef(Address, Pointer(Instance));'
      '  end;'
      'end;'
      ''
      
        'procedure UnregisterWeakRef(Address: Pointer; const Instance: TO' +
        'bject);'
      'begin'
      '  if Instance <> nil then'
      '    InstHashMap.UnregisterWeakRef(Address, Pointer(Instance));'
      'end;'
      ''
      
        'procedure RegisterWeakMethodRef(Address: Pointer; const Instance' +
        ': TObject);'
      'begin'
      '  if Instance <> nil then'
      '  begin'
      '    if not IsWeakReferenced(Instance) then'
      '      MarkWeakReferenced(Instance);'
      
        '    InstHashMap.RegisterWeakMethodRef(Address, Pointer(Instance)' +
        ');'
      '  end;'
      'end;'
      ''
      
        'procedure UnregisterWeakMethodRef(Address: Pointer; const Instan' +
        'ce: TObject);'
      'begin'
      '  if Instance <> nil then'
      
        '    InstHashMap.UnregisterWeakMethodRef(Address, Pointer(Instanc' +
        'e));'
      'end;'
      ''
      'procedure _CleanupInstance(Instance: Pointer);'
      'begin'
      '  if IsWeakReferenced(Instance) then'
      '    InstHashMap.Destroy(Instance);'
      'end;'
      ''
      '{$IFDEF WEAKINSTREF}'
      'function _InstWeakClear(var Dest: TObject): Pointer;'
      'var'
      '  L: TObject;'
      'begin'
      '  Result := @Dest;'
      '  if Dest <> nil then'
      '  begin'
      '    L := Dest;'
      '    Pointer(Dest) := nil;'
      '    UnregisterWeakRef(Result, L);'
      '  end;'
      'end;'
      ''
      'procedure _InstWeakArrayClear(var Dest; Count: Integer);'
      'var'
      '  P: Pointer;'
      'begin'
      '  P := @Dest;'
      '  while Count > 0 do'
      '  begin'
      '    _InstWeakClear(TObject(P^));'
      '    Inc(PByte(P), SizeOf(Pointer));'
      '    Dec(Count);'
      '  end;'
      'end;'
      ''
      'procedure _InstWeakCopy(var Dest: TObject; Source: TObject);'
      'begin'
      '  RegisterWeakRef(_InstWeakClear(Dest), Source);'
      '  Pointer(Dest) := Pointer(Source);'
      'end;'
      '{$ENDIF WEAKINSTREF}'
      ''
      '{$IFDEF WEAKINTFREF}'
      'function _IntfWeakClear(var Dest: IInterface): Pointer;'
      'var'
      '  L: TObject;'
      'begin'
      '  Result := @Dest;'
      '  if Dest <> nil then'
      '  begin'
      '    L := Dest as TObject;'
      '    Pointer(Dest) := nil;'
      '    UnregisterWeakRef(Result, L);'
      '  end;'
      'end;'
      ''
      'procedure _IntfWeakArrayClear(var Dest; Count: Integer);'
      'var'
      '  P: Pointer;'
      'begin'
      '  P := @Dest;'
      '  while Count > 0 do'
      '  begin'
      '    _IntfWeakClear(IInterface(P^));'
      '    Inc(PByte(P), SizeOf(Pointer));'
      '    Dec(Count);'
      '  end;'
      'end;'
      ''
      
        'procedure _IntfWeakCopy(var Dest: IInterface; const Source: IInt' +
        'erface);'
      'begin'
      '  RegisterWeakRef(_IntfWeakClear(Dest), Source as TObject);'
      '  Pointer(Dest) := Pointer(Source);'
      'end;'
      '{$ENDIF WEAKINTFREF}'
      ''
      'function _ClosureRemoveWeakRef(var Closure: TMethod): Pointer;'
      'var'
      '  L: Pointer;'
      'begin'
      '  Result := @Closure;'
      '  if Closure.Data <> nil then'
      '  begin'
      '    L := Closure.Data;'
      '    Closure.Data := nil;'
      '    Closure.Code := nil;'
      '    UnregisterWeakMethodRef(Result, TObject(L));'
      '  end;'
      'end;'
      ''
      'procedure _ClosureAddWeakRef(var Closure: TMethod);'
      'begin'
      '  if InstHashMap.IsRegistered(Closure.Data) then'
      '    RegisterWeakMethodRef(@Closure, TObject(Closure.Data));'
      'end;'
      ''
      
        'procedure _ClosureArrayRemoveWeakRef(var Closure: TMethod; Count' +
        ': Integer);'
      'var'
      '  P: Pointer;'
      'begin'
      '  P := @Closure;'
      '  while Count > 0 do'
      '  begin'
      '    _ClosureRemoveWeakRef(TMethod(P^));'
      '    Inc(PByte(P), SizeOf(TMethod));'
      '    Dec(Count);'
      '  end;'
      'end;'
      ''
      
        'procedure _CopyClosure(var Dest: TMethod; const [Ref] Source: TM' +
        'ethod);'
      'begin'
      '  _ClosureRemoveWeakRef(Dest);'
      '  if InstHashMap.IsRegistered(Source.Data) then'
      '    RegisterWeakMethodRef(@Dest, TObject(Source.Data));'
      '  Dest := Source;'
      'end;'
      ''
      
        'function _AsgClosureClassMethod(var Dest: TMethod; const Obj: Po' +
        'inter; const MethodAddr: Pointer): Pointer;'
      'begin'
      '  Result := Obj;'
      '  Dest.Data := Result;'
      '  Dest.Code := MethodAddr;'
      'end;'
      ''
      
        'function _AsgClosureObj(var Dest: TMethod; const Obj: Pointer; c' +
        'onst MethodAddr: Pointer): Pointer;'
      'begin'
      '  Result := Obj;'
      
        '  RegisterWeakMethodRef(_ClosureRemoveWeakRef(Dest), TObject(Res' +
        'ult));'
      '  Dest.Data := Result;'
      '  Dest.Code := MethodAddr;'
      'end;'
      '{$ENDIF WEAKREF}'
      ''
      '{$IFNDEF AUTOREFCOUNT}'
      'function TInterfacedObject.GetRefCount: Integer;'
      'begin'
      '  Result := FRefCount and not objDestroyingFlag;'
      'end;'
      ''
      'class procedure TInterfacedObject.__MarkDestroying(const Obj);'
      'var'
      '  LRef: Integer;'
      'begin'
      '  repeat'
      '    LRef := TInterfacedObject(Obj).FRefCount;'
      
        '  until AtomicCmpExchange(TInterfacedObject(Obj).FRefCount, LRef' +
        ' or objDestroyingFlag, LRef) = LRef;'
      'end;'
      ''
      'procedure TInterfacedObject.AfterConstruction;'
      'begin'
      '// Release the constructor'#39's implicit refcount'
      '  AtomicDecrement(FRefCount);'
      'end;'
      ''
      'procedure TInterfacedObject.BeforeDestruction;'
      'begin'
      '  if RefCount <> 0 then'
      '    Error(reInvalidPtr);'
      'end;'
      ''
      
        '// Set an implicit refcount so that refcounting during construct' +
        'ion won'#39't destroy the object.'
      'class function TInterfacedObject.NewInstance: TObject;'
      'begin'
      '  Result := inherited NewInstance;'
      '  TInterfacedObject(Result).FRefCount := 1;'
      'end;'
      ''
      '{$ENDIF AUTOREFCOUNT}'
      ''
      
        'function TInterfacedObject.QueryInterface(const IID: TGUID; out ' +
        'Obj): HResult;'
      'begin'
      '  if GetInterface(IID, Obj) then'
      '    Result := 0'
      '  else'
      '    Result := E_NOINTERFACE;'
      'end;'
      ''
      'function TInterfacedObject._AddRef: Integer;'
      'begin'
      '{$IFNDEF AUTOREFCOUNT}'
      '  Result := AtomicIncrement(FRefCount);'
      '{$ELSE}'
      '  Result := __ObjAddRef;'
      '{$ENDIF}'
      'end;'
      ''
      'function TInterfacedObject._Release: Integer;'
      'begin'
      '{$IFNDEF AUTOREFCOUNT}'
      '  Result := AtomicDecrement(FRefCount);'
      '  if Result = 0 then'
      '  begin'
      
        '    // Mark the refcount field so that any refcounting during de' +
        'struction doesn'#39't infinitely recurse.'
      '    __MarkDestroying(Self);'
      '    Destroy;'
      '  end;'
      '{$ELSE}'
      '  Result := __ObjRelease;'
      '{$ENDIF}'
      'end;'
      ''
      '{ TAggregatedObject }'
      ''
      
        'constructor TAggregatedObject.Create(const Controller: IInterfac' +
        'e);'
      'begin'
      '  // "unsafe" reference to controller - don'#39't keep it alive'
      '  FController := Controller;'
      'end;'
      ''
      
        'function TAggregatedObject.QueryInterface(const IID: TGUID; out ' +
        'Obj): HResult;'
      'begin'
      '  Result := FController.QueryInterface(IID, Obj);'
      'end;'
      ''
      'function TAggregatedObject._AddRef: Integer;'
      'begin'
      '  Result := FController._AddRef;'
      'end;'
      ''
      'function TAggregatedObject._Release: Integer;'
      'begin'
      '  Result := FController._Release;'
      'end;'
      ''
      '{ TContainedObject }'
      ''
      
        'function TContainedObject.QueryInterface(const IID: TGUID; out O' +
        'bj): HResult;'
      'begin'
      '  if GetInterface(IID, Obj) then'
      '    Result := S_OK'
      '  else'
      '    Result := E_NOINTERFACE;'
      'end;'
      ''
      '{ TClassHelperBase }'
      ''
      'constructor TClassHelperBase._Create(Instance: TObject);'
      'begin'
      '  inherited Create;'
      '  FInstance := Instance;'
      'end;'
      ''
      '{ TNoRefCountObject  }'
      ''
      
        'function TNoRefCountObject.QueryInterface(const IID: TGUID; out ' +
        'Obj): HResult;'
      'begin'
      '  if GetInterface(IID, Obj) then'
      '    Result := S_OK'
      '  else'
      '    Result := E_NOINTERFACE;'
      'end;'
      ''
      'function TNoRefCountObject._AddRef: Integer;'
      'begin'
      '  Result := -1;'
      'end;'
      ''
      'function TNoRefCountObject._Release: Integer;'
      'begin'
      '  Result := -1;'
      'end;'
      ''
      'function _CheckAutoResult(ResultCode: HResult): HResult;'
      'begin'
      '  if ResultCode < 0 then'
      '  begin'
      '    if Assigned(SafeCallErrorProc) then'
      '      SafeCallErrorProc(ResultCode, ReturnAddress);'
      '    ErrorAt(Byte(reSafeCallError), ReturnAddress);'
      '  end;'
      '  Result := ResultCode;'
      'end;'
      ''
      'function  CompToDouble(Value: Comp): Double; cdecl;'
      'begin'
      '  Result := Value;'
      'end;'
      ''
      'procedure  DoubleToComp(Value: Double; var Result: Comp); cdecl;'
      'begin'
      '  Result := Value;'
      'end;'
      ''
      'function  CompToCurrency(Value: Comp): Currency; cdecl;'
      'begin'
      '  Result := Value;'
      'end;'
      ''
      
        'procedure  CurrencyToComp(Value: Currency; var Result: Comp); cd' +
        'ecl;'
      'begin'
      '  Result := Value;'
      'end;'
      ''
      'function GetMemory(Size: NativeInt): Pointer; cdecl;'
      'begin'
      '  Result := MemoryManager.GetMem(Size);'
      'end;'
      ''
      'function FreeMemory(P: Pointer): Integer; cdecl;'
      'begin'
      '  if P = nil then'
      '    Result := 0'
      '  else'
      '    Result := MemoryManager.FreeMem(P);'
      'end;'
      ''
      
        'function ReallocMemory(P: Pointer; Size: NativeInt): Pointer; cd' +
        'ecl;'
      'begin'
      '  if P = nil then'
      '    Result := GetMemory(Size)'
      '  else'
      '  Result := MemoryManager.ReallocMem(P, Size);'
      'end;'
      ''
      '// UnicodeToUTF8(3):'
      
        '// Scans the source data to find the null terminator, up to MaxB' +
        'ytes'
      '// Dest must have MaxBytes available in Dest.'
      ''
      
        'function UnicodeToUtf8(Dest: _PAnsiChr; Source: PWideChar; MaxBy' +
        'tes: Integer): Integer;'
      'begin'
      '  Result := UnicodeToUtf8(Dest, MaxBytes, Source, Cardinal(-1));'
      'end;'
      ''
      '// UnicodeToUtf8(4):'
      
        '// MaxDestBytes includes the null terminator (last char in the b' +
        'uffer will be set to null)'
      '// Function result includes the null terminator.'
      
        '// Nulls in the source data are not considered terminators - Sou' +
        'rceChars must be accurate'
      ''
      '{$IFDEF USE_LIBICU}'
      '{$IFDEF LINUX}'
      
        'function UnicodeToUtf8ICU(Dest: _PAnsiChr; MaxDestBytes: Cardina' +
        'l; Source: PWideChar; SourceChars: Cardinal): Cardinal;'
      '{$ELSE !LINUX}'
      
        'function UnicodeToUtf8(Dest: _PAnsiChr; MaxDestBytes: Cardinal; ' +
        'Source: PWideChar; SourceChars: Cardinal): Cardinal;'
      '{$ENDIF LINUX}'
      'var'
      '  DestLen: Int32;'
      '  ErrorConv: UErrorCode;'
      'begin'
      '  Result := 0;'
      '  if Source = nil then Exit;'
      '  ErrorConv := 0;'
      '  DestLen := 0;'
      
        '  u_strToUTF8(MarshaledAString(Dest), MaxDestBytes, DestLen, PUC' +
        'har(Source), SourceChars, ErrorConv);'
      '  Result := DestLen;'
      '  if Dest <> nil then'
      '  begin'
      '    if (Result > 0) and (Result <= MaxDestBytes) then'
      '    begin'
      '      if Result = MaxDestBytes then'
      '      begin'
      
        '        while (Result > 1) and (Byte(Dest[Result - 1]) > $7F) an' +
        'd (Byte(Dest[Result - 1]) and $80 <> 0) and (Byte(Dest[Result - ' +
        '1]) and $C0 <> $C0) do'
      '          Dec(Result);'
      '      end else'
      '        Inc(Result);'
      '      Dest[Result - 1] := #0;'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IF not Defined(USE_LIBICU) or Defined(LINUX)}'
      '{$IFDEF LINUX}'
      
        'function UnicodeToUtf8ICONV(Dest: _PAnsiChr; MaxDestBytes: Cardi' +
        'nal; Source: PWideChar; SourceChars: Cardinal): Cardinal;'
      '{$ELSE !LINUX}'
      
        'function UnicodeToUtf8(Dest: _PAnsiChr; MaxDestBytes: Cardinal; ' +
        'Source: PWideChar; SourceChars: Cardinal): Cardinal;'
      '{$ENDIF LINUX}'
      'begin'
      '  Result := 0;'
      '  if Source = nil then Exit;'
      '  if Dest <> nil then'
      '  begin'
      
        '    Result := Cardinal(LocaleCharsFromUnicode(CP_UTF8, 0, Source' +
        ', Integer(SourceChars), Dest, Integer(MaxDestBytes), nil, nil));'
      '    if (Result > 0) and (Result <= MaxDestBytes) then'
      '    begin'
      
        '      if (SourceChars = Cardinal(-1)) and (Dest[Result -1] = #0)' +
        ' then Exit;'
      ''
      '      if Result = MaxDestBytes then'
      '      begin'
      
        '        while (Result > 1) and (Byte(Dest[Result - 1]) > $7F) an' +
        'd (Byte(Dest[Result - 1]) and $80 <> 0) and (Byte(Dest[Result - ' +
        '1]) and $C0 <> $C0) do'
      '          Dec(Result);'
      '      end else'
      '        Inc(Result);'
      '      Dest[Result - 1] := #0;'
      '    end;'
      '  end else'
      
        '    Result := Cardinal(LocaleCharsFromUnicode(CP_UTF8, 0, Source' +
        ', Integer(SourceChars), nil, 0, nil, nil));'
      'end;'
      '{$ENDIF not Defined(USE_LIBICU) or Defined(LINUX)}'
      ''
      '{$IFDEF LINUX}'
      
        'function UnicodeToUtf8(Dest: _PAnsiChr; MaxDestBytes: Cardinal; ' +
        'Source: PWideChar; SourceChars: Cardinal): Cardinal;'
      'begin'
      '  if IsICUAvailable then'
      
        '    Result := UnicodeToUtf8ICU(Dest, MaxDestBytes, Source, Sourc' +
        'eChars)'
      '  else'
      
        '    Result := UnicodeToUtf8ICONV(Dest, MaxDestBytes, Source, Sou' +
        'rceChars);'
      'end;'
      '{$ENDIF LINUX}'
      ''
      
        'function Utf8ToUnicode(Dest: PWideChar; Source: _PAnsiChr; MaxCh' +
        'ars: Integer): Integer;'
      'begin'
      '  Result := Utf8ToUnicode(Dest, MaxChars, Source, Cardinal(-1));'
      'end;'
      ''
      '{$IFDEF USE_LIBICU}'
      '{$IFDEF LINUX}'
      
        'function Utf8ToUnicodeICU(Dest: PWideChar; MaxDestChars: Cardina' +
        'l; Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal;'
      '{$ELSE !LINUX}'
      
        'function Utf8ToUnicode(Dest: PWideChar; MaxDestChars: Cardinal; ' +
        'Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal;'
      '{$ENDIF LINUX}'
      'var'
      '  DestLen: Int32;'
      '  ErrorConv: UErrorCode;'
      'begin'
      '  Result := 0;'
      '  if Source = nil then Exit;'
      '  ErrorConv := 0;'
      '  DestLen := 0;'
      
        '  u_strFromUTF8(PUChar(Dest), MaxDestChars, DestLen, MarshaledAS' +
        'tring(Source), SourceBytes, ErrorConv);'
      '  Result := DestLen;'
      '  if Dest <> nil then'
      '  begin'
      '    if (Result > 0) and (Result <= MaxDestChars) then'
      '    begin'
      '      if Result = MaxDestChars then'
      '      begin'
      
        '        if (Result > 1) and (Word(Dest[Result - 1]) >= $DC00) an' +
        'd (Word(Dest[Result - 1]) <= $DFFF) then'
      '          Dec(Result);'
      '      end else'
      '        Inc(Result);'
      '      Dest[Result - 1] := #0;'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IF not Defined(USE_LIBICU) or Defined(LINUX)}'
      '{$IFDEF LINUX}'
      
        'function Utf8ToUnicodeICONV(Dest: PWideChar; MaxDestChars: Cardi' +
        'nal; Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal;'
      '{$ELSE !LINUX}'
      
        'function Utf8ToUnicode(Dest: PWideChar; MaxDestChars: Cardinal; ' +
        'Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal;'
      '{$ENDIF LINUX}'
      'begin'
      '  Result := 0;'
      '  if Source = nil then Exit;'
      '  if (Dest <> nil) and (MaxDestChars > 0) then'
      '  begin'
      
        '    Result := Cardinal(UnicodeFromLocaleChars(CP_UTF8, 0, Source' +
        ', Integer(SourceBytes), Dest, Integer(MaxDestChars)));'
      '    if (Result > 0) and (Result <= MaxDestChars) then'
      '    begin'
      
        '      if (SourceBytes = Cardinal(-1)) and (Dest[Result - 1] = #0' +
        ') then Exit;'
      ''
      '      if Result = MaxDestChars then'
      '      begin'
      
        '        if (Result > 1) and (Word(Dest[Result - 1]) >= $DC00) an' +
        'd (Word(Dest[Result - 1]) <= $DFFF) then'
      '          Dec(Result);'
      '      end else'
      '        Inc(Result);'
      '      Dest[Result - 1] := #0;'
      '    end;'
      '  end else'
      
        '    Result := Cardinal(UnicodeFromLocaleChars(CP_UTF8, 0, Source' +
        ', Integer(SourceBytes), nil, 0));'
      'end;'
      '{$ENDIF not Defined(USE_LIBICU) or Defined(LINUX)}'
      ''
      '{$IFDEF LINUX}'
      
        'function Utf8ToUnicode(Dest: PWideChar; MaxDestChars: Cardinal; ' +
        'Source: _PAnsiChr; SourceBytes: Cardinal): Cardinal;'
      'begin'
      '  if IsICUAvailable then'
      
        '    Result := Utf8ToUnicodeICU(Dest, MaxDestChars, Source, Sourc' +
        'eBytes)'
      '  else'
      
        '    Result := Utf8ToUnicodeICONV(Dest, MaxDestChars, Source, Sou' +
        'rceBytes);'
      'end;'
      '{$ENDIF LINUX}'
      ''
      'function Utf8Encode(const WS: _WideStr): _RawByteStr;'
      'var'
      '  L: Integer;'
      'begin'
      '  if WS = '#39#39' then Exit('#39#39');'
      '  L := Length(WS);'
      
        '  SetLength(Result, L * 3); // SetLength includes space for null' +
        ' terminator'
      ''
      
        '  L := UnicodeToUtf8(_PAnsiChr(Result), Length(Result) + 1, PWid' +
        'eChar(WS), L);'
      '  if L > 0 then'
      '  begin'
      '    SetLength(Result, L - 1);'
      '    PStrRec(PByte(Result) - SizeOf(StrRec)).codePage := CP_UTF8;'
      '  end'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      'function Utf8Encode(const US: UnicodeString): _RawByteStr;'
      'var'
      '  L: Integer;'
      'begin'
      '  if US = '#39#39' then Exit('#39#39');'
      '  L := Length(US);'
      
        '  SetLength(Result, L * 3); // SetLength includes space for null' +
        ' terminator'
      ''
      
        '  L := UnicodeToUtf8(_PAnsiChr(Result), Length(Result) + 1, PWid' +
        'eChar(US), L);'
      '  if L > 0 then'
      '  begin'
      '    SetLength(Result, L - 1);'
      '    PStrRec(PByte(Result) - SizeOf(StrRec)).codePage := CP_UTF8;'
      '  end'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      'function UTF8Encode(const A: _RawByteStr): _RawByteStr;'
      'begin'
      '  if StringCodePage(A) = CP_UTF8 then'
      '    Result := A'
      '  else'
      '    Result := UTF8Encode(UnicodeString(A));'
      'end;'
      ''
      
        'procedure UTF8Encode(const US: UnicodeString; var B: array of By' +
        'te);'
      'begin'
      
        '  B[0] := UnicodeToUtf8(_PAnsiChr(@B[1]), Length(B) - 1, PWideCh' +
        'ar(US), Length(US));'
      'end;'
      ''
      'function Max(I1, I2: Integer): Integer; inline;'
      'begin'
      '  if I1 > I2 then'
      '    Result := I1'
      '  else'
      '    Result := I2;'
      'end;'
      ''
      'function UTF8EncodeToShortString(const WS: _WideStr): _ShortStr;'
      'begin'
      
        '  Result[0] := _AnsiChr(Max(0, UnicodeToUtf8(@Result[1], High(Re' +
        'sult), PWideChar(WS), Length(WS)) - 1));'
      'end;'
      ''
      
        'function UTF8EncodeToShortString(const US: UnicodeString): _Shor' +
        'tStr;'
      'begin'
      
        '  Result[0] := _AnsiChr(Max(0, UnicodeToUtf8(@Result[1], High(Re' +
        'sult), PWideChar(US), Length(US)) - 1));'
      'end;'
      ''
      
        'function UTF8EncodeToShortString(const A: _RawByteStr): _ShortSt' +
        'r;'
      'begin'
      '  if StringCodePage(A) = CP_UTF8 then'
      '    Result := A'
      '  else'
      '    Result := UTF8EncodeToShortString(UnicodeString(A));'
      'end;'
      ''
      'function Utf8Decode(const S: _RawByteStr): _WideStr;'
      'var'
      '  L: Integer;'
      'begin'
      '  if S = '#39#39' then Exit('#39#39');'
      '  L := Length(S);'
      '  SetLength(Result, L);'
      ''
      '  L := Utf8ToUnicode(PWideChar(Result), L + 1, _PAnsiChr(S), L);'
      '  if L > 0 then'
      '    SetLength(Result, L - 1)'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      
        'function UTF8ToWideString(const S: _RawByteStr): _WideStr; inlin' +
        'e;'
      'begin'
      '  Result := UTF8Decode(S);'
      'end;'
      ''
      
        'function UTF8ToUnicodeString(const S: _RawByteStr): UnicodeStrin' +
        'g;'
      'var'
      '  L: Integer;'
      'begin'
      '  if S = '#39#39' then Exit('#39#39');'
      '  L := Length(S);'
      '  SetLength(Result, L);'
      ''
      '  L := Utf8ToUnicode(PWideChar(Result), L + 1, _PAnsiChr(S), L);'
      '  if L > 0 then'
      '    SetLength(Result, L - 1)'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      
        'function UTF8ToUnicodeString(const S: _PAnsiChr): UnicodeString;' +
        ' overload;'
      'var'
      '  L: Integer;'
      'begin'
      '  if S = '#39#39' then Exit('#39#39');'
      '  L := Length(S);'
      '  SetLength(Result, L);'
      ''
      '  L := Utf8ToUnicode(PWideChar(Result), L + 1, S, L);'
      '  if L > 0 then'
      '    SetLength(Result, L - 1)'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      
        'function UTF8ToUnicodeString(const S: _ShortStr): UnicodeString;' +
        ' overload;'
      'var'
      '  L: Integer;'
      'begin'
      '  if S = '#39#39' then Exit('#39#39');'
      '  L := Length(S);'
      '  SetLength(Result, L);'
      ''
      '  L := Utf8ToUnicode(PWideChar(Result), L + 1, @S[1], L);'
      '  if L > 0 then'
      '    SetLength(Result, L - 1)'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      'function UTF8ToString(const S: _RawByteStr): string;'
      'begin'
      '  Result := UTF8ToUnicodeString(S);'
      'end;'
      ''
      'function UTF8ToString(const S: _ShortStr): string;'
      'begin'
      '  Result := UTF8ToUnicodeString(S);'
      'end;'
      ''
      'function UTF8ToString(const S: _PAnsiChr): string;'
      'begin'
      '  Result := UTF8ToUnicodeString(S);'
      'end;'
      ''
      'function UTF8ToString(const S: array of Byte): string; overload;'
      'var'
      '  Dest: array[0..511] of Char;'
      'begin'
      
        '  SetString(Result, Dest, UTF8ToUnicode(Dest, Length(Dest), _PAn' +
        'siChr(@S[1]), S[0])-1);'
      'end;'
      ''
      'function UTF8ArrayToString(const S: array of _AnsiChr): string;'
      'var'
      '  L: Integer;'
      'begin'
      '  L := Length(S);'
      '  if L = 0 then Exit('#39#39');'
      '  SetLength(Result, L);'
      ''
      '  L := Utf8ToUnicode(PWideChar(Result), L + 1, @S[0], L);'
      '  if L > 0 then'
      '    SetLength(Result, L - 1)'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      
        'function UTF8ArrayToString(const S: array of Byte): string; over' +
        'load;'
      'var'
      '  L: Integer;'
      'begin'
      '  L := Length(S);'
      '  if L = 0 then Exit('#39#39');'
      '  SetLength(Result, L);'
      ''
      
        '  L := Utf8ToUnicode(PWideChar(Result), L + 1, PAnsiChar(@S[0]),' +
        ' L);'
      '  if L > 0 then'
      '    SetLength(Result, L - 1)'
      '  else'
      '    Result := '#39#39';'
      'end;'
      ''
      'function AnsiToUtf8(const S: string): _RawByteStr;'
      'begin'
      '  Result := Utf8Encode(S);'
      'end;'
      ''
      'function Utf8ToAnsi(const S: _RawByteStr): string;'
      'begin'
      '  Result := string(Utf8ToUnicodeString(S));'
      'end;'
      ''
      '{$IFDEF LINUX32}'
      ''
      '{$IF Defined(CPUX86)}'
      'function GetCPUType: Integer;'
      'asm'
      '      PUSH      EBX'
      '    // this code assumes ESP is 4 byte aligned'
      
        '    // test for 80386:  see if bit #18 of EFLAGS (Alignment faul' +
        't) can be toggled'
      '      PUSHFD'
      '      POP       EAX'
      '      MOV       ECX, EAX'
      '      XOR       EAX, $40000   // flip AC bit in EFLAGS'
      '      PUSH      EAX'
      '      POPFD'
      '      PUSHFD'
      '      POP       EAX'
      
        '      XOR       EAX, ECX      // zero = 80386 CPU (can'#39't toggle ' +
        'AC bit)'
      '      MOV       EAX, CPUi386'
      '      JZ        @@Exit'
      '      PUSH      ECX'
      
        '      POPFD                    // restore original flags before ' +
        'next test'
      ''
      
        '      // test for 80486:  see if bit #21 of EFLAGS (CPUID suppor' +
        'ted) can be toggled'
      '      MOV       EAX, ECX        // get original EFLAGS'
      '      XOR       EAX, $200000    // flip CPUID bit in EFLAGS'
      '      PUSH      EAX'
      '      POPFD'
      '      PUSHFD'
      '      POP       EAX'
      
        '      XOR       EAX, ECX    // zero = 80486 (can'#39't toggle EFLAGS' +
        ' bit #21)'
      '      MOV       EAX, CPUi486'
      '      JZ        @@Exit'
      ''
      '      // Use CPUID instruction to get CPU family'
      '      XOR       EAX, EAX'
      '      CPUID'
      '      CMP       EAX, 1'
      
        '      JL        @@Exit          // unknown processor response: r' +
        'eport as 486'
      '      XOR       EAX, EAX'
      '      INC       EAX       // we only care about info level 1'
      '      CPUID'
      '      AND       EAX, $F00'
      '      SHR       EAX, 8'
      
        '      // Test8086 values are one less than the CPU model number,' +
        ' for historical reasons'
      '      DEC       EAX'
      ''
      '@@Exit:'
      '      POP       EBX'
      'end;'
      '{$ENDIF}'
      '{$ENDIF LINUX32}'
      ''
      '{$IF defined(LINUX64) and defined(CPUX64)}'
      'function GetCPUType: Integer;'
      'begin'
      
        '                                                                ' +
        '  '
      '  Result := CPUPentium;'
      'end;'
      '{$ENDIF LINUX64 and CPUX64}'
      ''
      '{$IF defined(LINUX_OLD_RESOURCES)}'
      'const'
      '  sResSymExport = '#39'@Sysinit@ResSym'#39';'
      '  sResStrExport = '#39'@Sysinit@ResStr'#39';'
      '  sResHashExport = '#39'@Sysinit@ResHash'#39';'
      ''
      'type'
      '  TElf32Sym = record'
      '    Name: Cardinal;'
      '    Value: Pointer;'
      '    Size: Cardinal;'
      '    Info: Byte;'
      '    Other: Byte;'
      '    Section: Word;'
      '  end;'
      '  PElf32Sym = ^TElf32Sym;'
      ''
      '  TElfSymTab = array [0..0] of TElf32Sym;'
      '  PElfSymTab = ^TElfSymTab;'
      ''
      '  TElfWordTab = array [0..2] of Cardinal;'
      '  PElfWordTab = ^TElfWordTab;'
      ''
      ''
      
        '{ If Name encodes a numeric identifier, return it, else return -' +
        '1.  }'
      'function NameToId(Name: PChar): Longint;'
      'var digit: Longint;'
      'begin'
      '  if LongInt(IntPtr(Name)) and $ffff0000 = 0 then'
      '  begin'
      '    Result := LongInt(IntPtr(Name)) and $ffff;'
      '  end'
      '  else if Name^ = '#39'#'#39' then'
      '  begin'
      '    Result := 0;'
      '    inc (Name);'
      '    while (Ord(Name^) <> 0) do'
      '    begin'
      '      digit := Ord(Name^) - Ord('#39'0'#39');'
      '      if (LongWord(digit) > 9) then'
      '      begin'
      '        Result := -1;'
      '        exit;'
      '      end;'
      '      Result := Result * 10 + digit;'
      '      inc (Name);'
      '    end;'
      '  end'
      '  else'
      '    Result := -1;'
      'end;'
      ''
      ''
      '// Return ELF hash value for NAME converted to lower case.'
      'function ElfHashLowercase(Name: PChar): Cardinal;'
      'var'
      '  g: Cardinal;'
      '  c: Char;'
      'begin'
      '  Result := 0;'
      '  while name^ <> #0 do'
      '  begin'
      '    c := name^;'
      '    c := tolower(c);'
      '    Result := (Result shl 4) + Ord(c);'
      '    g := Result and $f0000000;'
      '    Result := (Result xor (g shr 24)) and not g;'
      '    Inc(name);'
      '  end;'
      'end;'
      ''
      'type'
      '  PFindResourceCache = ^TFindResourceCache;'
      '  TFindResourceCache = record'
      '    ModuleHandle: HMODULE;'
      '    Version: Cardinal;'
      '    SymbolTable: PElfSymTab;'
      '    StringTable: PChar;'
      '    HashTable: PElfWordTab;'
      '    BaseAddress: Pointer;'
      '  end;'
      ''
      'threadvar'
      '  FindResourceCache: TFindResourceCache;'
      ''
      
        'function GetResourceCache(ModuleHandle: HMODULE): PFindResourceC' +
        'ache;'
      'var'
      '  Info: dl_info;'
      'begin'
      '  Result := @FindResourceCache;'
      
        '  if (ModuleHandle <> Result^.ModuleHandle) or (ModuleCacheVersi' +
        'on <> Result^.Version) then'
      '  begin'
      '    Result^.SymbolTable := dlsym(ModuleHandle, sResSymExport);'
      '    Result^.StringTable := dlsym(ModuleHandle, sResStrExport);'
      '    Result^.HashTable := dlsym(ModuleHandle, sResHashExport);'
      '    Result^.ModuleHandle := ModuleHandle;'
      
        '    if (dladdr(Result^.HashTable, Info) = 0) or (Info.dli_fbase ' +
        '= ExeBaseAddress) then'
      
        '      Result^.BaseAddress := nil   // if it'#39's not in a library, ' +
        'assume the exe'
      '    else'
      '      Result^.BaseAddress := Info.dli_fbase;'
      '    Result^.Version := ModuleCacheVersion;'
      '  end;'
      'end;'
      ''
      
        'function FindResource(ModuleHandle: HMODULE; ResourceName: PChar' +
        '; ResourceType: PChar): TResourceHandle;'
      'var'
      '  P: PFindResourceCache;'
      '  nid, tid: Longint;'
      '  ucs2_key: array [0..2] of WideChar;'
      '  key: array [0..127] of Char;'
      '  len: Integer;'
      '  pc: PChar;'
      '  ch: Char;'
      '  nbucket: Cardinal;'
      '  bucket, chain: PElfWordTab;'
      '  syndx: Cardinal;'
      'begin'
      '  Result := 0;'
      '  if ResourceName = nil then Exit;'
      '  P := GetResourceCache(ModuleHandle);'
      ''
      '  tid := NameToId (ResourceType);'
      '  if tid = -1 then Exit;  { not supported (yet?) }'
      ''
      '  { This code must match util-common/elfres.c }'
      '  nid := NameToId (ResourceName);'
      '  if nid = -1 then'
      '  begin'
      '    ucs2_key[0] := WideChar(2*tid+2);'
      '    ucs2_key[1] := WideChar(0);'
      '    len := UnicodeToUtf8 (key, ucs2_key, SizeOf (key)) - 1;'
      '    pc := key+len;'
      '    while Ord(ResourceName^) <> 0 do'
      '    begin'
      '      ch := ResourceName^;'
      
        '      if Ord(ch) > 127 then exit; { insist on 7bit ASCII for now' +
        ' }'
      
        '      if ('#39'A'#39' <= ch) and (ch <= '#39'Z'#39') then Inc(ch, Ord('#39'a'#39') - Ord' +
        '('#39'A'#39'));'
      '      pc^ := ch;'
      '      inc (pc);'
      '      if pc = key + SizeOf(key) then exit;'
      '      inc (ResourceName);'
      '    end;'
      '    pc^ := Char(0);'
      '  end'
      '  else'
      '  begin'
      '    ucs2_key[0] := WideChar(2*tid+1);'
      '    ucs2_key[1] := WideChar(nid);'
      '    ucs2_key[2] := WideChar(0);'
      '    UnicodeToUtf8 (key, ucs2_key, SizeOf (key));'
      '  end;'
      ''
      '  with P^ do'
      '  begin'
      '    nbucket := HashTable[0];'
      '  //  nsym := HashTable[1];'
      '    bucket := @HashTable[2];'
      '    chain := @HashTable[2+nbucket];'
      ''
      '    syndx := bucket[ElfHashLowercase(key) mod nbucket];'
      '    while (syndx <> 0)'
      
        '      and (strcasecmp(key, @StringTable[SymbolTable[syndx].Name]' +
        ') <> 0) do'
      '      syndx := chain[syndx];'
      ''
      '    if syndx = 0 then'
      '      Result := 0'
      '    else'
      '      Result := TResourceHandle(@SymbolTable[syndx]);'
      '  end;'
      'end;'
      ''
      
        'function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourc' +
        'eHandle): HGLOBAL;'
      'var'
      '  P: PFindResourceCache;'
      'begin'
      '  if ResHandle <> 0 then'
      '  begin'
      '    P := GetResourceCache(ModuleHandle);'
      '    Result := HGLOBAL(PElf32Sym(ResHandle)^.Value);'
      '    Inc(NativeUInt(Result), UIntPtr(P^.BaseAddress));'
      '  end'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      
        'function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResou' +
        'rceHandle): Integer;'
      'begin'
      '  if ResHandle <> 0 then'
      '    Result := PElf32Sym(ResHandle)^.Size'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      'function LockResource(ResData: HGLOBAL): Pointer;'
      'begin'
      '  Result := Pointer(ResData);'
      'end;'
      ''
      'function UnlockResource(ResData: HGLOBAL): LongBool;'
      'begin'
      '  Result := False;'
      'end;'
      ''
      'function FreeResource(ResData: HGLOBAL): LongBool;'
      'begin'
      '  Result := True;'
      'end;'
      '{$ENDIF LINUX_OLD_RESOURCES}'
      ''
      '{$IF (defined(POSIX) and (not defined(EXTERNALLINKER)))}'
      'const'
      '  sResSymExport = '#39'SysinitResSym'#39';'
      ''
      'type'
      '  TResourceHeader = record'
      '    SymtabOffset: Cardinal;'
      '    SymbolCount: Integer;'
      '    HashtableOffset: Cardinal;'
      '  end;'
      '  PResourceHeader = ^TResourceHeader;'
      '  TResourceSym = record'
      '    Name:  Cardinal;'
      '    Data:  Cardinal;'
      '    Size:  Cardinal;'
      
        '    Chain: Cardinal;            // link to next hash entry, or -' +
        '1 for end'
      '  end;'
      '  PResourceSym = ^TResourceSym;'
      ''
      '  Hashtable = record'
      '    Size: Cardinal;'
      '    Entries: array [0..0] of Cardinal;'
      '  end;'
      '  PHashtable = ^Hashtable;'
      ''
      '  TResourceSymTab = array [0..0] of TResourceSym;'
      '  PResourceSymTab = ^TResourceSymTab;'
      ''
      
        '{ If Name encodes a numeric identifier, return it, else return -' +
        '1.  }'
      'function NameToId(Name: PChar): Integer;'
      'var digit: Integer;'
      'begin'
      '  if UIntPtr(Name) and (not UIntPtr($ffff)) = 0 then'
      '  begin'
      '    Result := Integer(IntPtr(Name)) and $ffff;'
      '  end'
      '  else if Name^ = '#39'#'#39' then'
      '  begin'
      '    Result := 0;'
      '    inc (Name);'
      '    while (Ord(Name^) <> 0) do'
      '    begin'
      '      digit := Ord(Name^) - Ord('#39'0'#39');'
      '      if (Cardinal(digit) > 9) then'
      '      begin'
      '        Result := -1;'
      '        exit;'
      '      end;'
      '      Result := Result * 10 + digit;'
      '      inc (Name);'
      '    end;'
      '  end'
      '  else'
      '    Result := -1;'
      'end;'
      ''
      ''
      '// Return ELF hash value for NAME converted to lower case.'
      'function ElfHashLowercase(Name: _PAnsiChr): Cardinal;'
      'var'
      '  g: Cardinal;'
      '  c: _AnsiChr;'
      'begin'
      '  Result := 0;'
      '  while name^ <> #0 do'
      '  begin'
      '    c := name^;'
      '    c := _AnsiChr(towlower(UCS4Char(c)));'
      '    Result := (Result shl 4) + Ord(c);'
      '    g := Result and $f0000000;'
      '    Result := (Result xor (g shr 24)) and not g;'
      '    Inc(name);'
      '  end;'
      'end;'
      ''
      'type'
      '  PFindResourceCache = ^TFindResourceCache;'
      '  TFindResourceCache = record'
      '    ModuleHandle: HMODULE;'
      '    Version: Cardinal;'
      '    ResourceHeader: PResourceHeader;'
      '    SymbolTable: PResourceSymTab;'
      '    StringTable: _PAnsiChr;'
      '    BaseAddress: Pointer;'
      '    Hashtable: PHashtable;'
      '  end;'
      ''
      'threadvar'
      '  FindResourceCache: TFindResourceCache;'
      ''
      
        'function GetResourceCache(ModuleHandle: HMODULE): PFindResourceC' +
        'ache;'
      'var'
      '  info: dl_info;'
      'begin'
      '  Result := @FindResourceCache;'
      
        '  if (ModuleHandle <> Result^.ModuleHandle) or (ModuleCacheVersi' +
        'on <> Result^.Version) then'
      '  begin'
      
        '    Result^.ResourceHeader := dlsym(ModuleHandle, sResSymExport)' +
        ';'
      
        '    Result^.SymbolTable := PResourceSymTab((PByte(Result^.Resour' +
        'ceHeader) +'
      
        '                                               SizeOf(TResourceH' +
        'eader)));'
      
        '    Result^.StringTable := _PAnsiChr((PByte(Result^.ResourceHead' +
        'er) +'
      
        '                                         SizeOf(TResourceHeader)' +
        ' +'
      
        '                                         SizeOf(TResourceSym) * ' +
        'Result^.ResourceHeader^.SymbolCount));'
      '    Result^.ModuleHandle := ModuleHandle;'
      ''
      '{$IFDEF MACOS64}                                      '
      '    if (dladdr(UIntPtr(Result^.ResourceHeader), Info) = 0) then'
      
        '      Result^.BaseAddress := nil   // if it'#39's not in a library, ' +
        'assume the exe'
      '    else'
      '      Result^.BaseAddress := Info.dli_fbase;'
      '{$ELSE !MACOS64}'
      
        '    if (dladdr(UIntPtr(Result^.ResourceHeader), Info) = 0) or (I' +
        'nfo.dli_fbase = ExeBaseAddress) then'
      
        '      Result^.BaseAddress := nil   // if it'#39's not in a library, ' +
        'assume the exe'
      '    else'
      '      Result^.BaseAddress := Info.dli_fbase;'
      '{$ENDIF MACOS64}'
      ''
      '    Result^.Version := ModuleCacheVersion;'
      
        '    Result^.Hashtable := PHashtable( PByte(Result^.ResourceHeade' +
        'r)'
      
        '                                        +  Result^.ResourceHeade' +
        'r^.HashtableOffset);'
      '  end;'
      'end;'
      ''
      
        '// UCS4cToUTF8c matches code in util-common, and must be kept in' +
        ' sync.'
      'function UCS4cToUTF8c(Dest: _PAnsiChr; Src: UInt32): Integer;'
      'begin'
      '  if ((Src and not $7F) = 0) then'
      '  begin'
      '    Dest^ := _AnsiChr(Src);'
      '    Result := 1;'
      '  end'
      '  else if ((Src and not $7FF) = 0) then'
      '  begin'
      '    Dest^ := _AnsiChr($C0 or (Src shr 6));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or (Src and $3F));'
      '    Result := 2;'
      '  end'
      '  else if ((Src and not $FFFF) = 0) then'
      '  begin'
      '    Dest^ := _AnsiChr($E0 or (Src shr 12));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 6) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or (Src and $3F));'
      '    Result := 3;'
      '  end'
      '  else if ((Src and not $1FFFFF) = 0) then'
      '  begin'
      '    Dest^ := _AnsiChr($F0 or (Src shr 18));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 12) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 6) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or (Src and $3F));'
      '    Result := 4;'
      '  end'
      '  else if ((Src and not $3FFFFFF) = 0) then'
      '  begin'
      '    Dest^ := _AnsiChr($F8 or (Src shr 24));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 18) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 12) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 16) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or (Src and $3F));'
      '    Result := 5;'
      '  end'
      '  else if ((Src and not $7FFFFFFFF) = 0) then'
      '  begin'
      '    Dest^ := _AnsiChr($F0 or (Src shr 30));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 24) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 18) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 12) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or ((Src shr 16) and $3F));'
      '    Inc(Dest);'
      '    Dest^ := _AnsiChr($80 or (Src and $3F));'
      '    Result := 6;'
      '  end'
      '  else'
      '     Result := -1;'
      'end;'
      ''
      
        'function FindResource(ModuleHandle: HMODULE; ResourceName: PChar' +
        '; ResourceType: PChar): TResourceHandle;'
      'var'
      '  ResCacheEntry: PFindResourceCache;'
      '  nid, tid: Integer;'
      '  ucs2_key: array [0..2] of WideChar;'
      '  key: array [0..127] of _AnsiChr;'
      '  len: Integer;'
      '  pc: _PAnsiChr;'
      '  ch: _AnsiChr;'
      '  symName: _PAnsiChr;'
      '  utf8ResName: _PAnsiChr;'
      '  I: Integer;'
      '  syndx: Cardinal;'
      'begin'
      '  Result := 0;'
      '  if ResourceName = nil then Exit;'
      '  ResCacheEntry := GetResourceCache(ModuleHandle);'
      ''
      '  tid := NameToId (ResourceType);'
      '  if tid = -1 then Exit;  { not supported (yet?) }'
      ''
      '  { This code must match util-common/elfres.c }'
      '  nid := NameToId (ResourceName);'
      '  if nid = -1 then'
      '  begin'
      '    ucs2_key[0] := WideChar(2*tid+2);'
      '    ucs2_key[1] := WideChar(0);'
      '    len := UCS4cToUTF8c(key, 2*tid+2);'
      '    pc := key+len;'
      '    utf8ResName := _PAnsiChr(_AnsiStr(ResourceName));'
      '    while Ord(utf8ResName^) <> 0 do'
      '    begin'
      '      ch := utf8ResName^;'
      
        '      if Ord(ch) > 127 then exit; { insist on 7bit ASCII for now' +
        ' }'
      
        '      if ('#39'A'#39' <= ch) and (ch <= '#39'Z'#39') then Inc(ch, Ord('#39'a'#39') - Ord' +
        '('#39'A'#39'));'
      '      pc^ := ch;'
      '      inc (pc);'
      '      if pc = key + SizeOf(key) then exit;'
      '      inc (utf8ResName);'
      '    end;'
      '    pc^ := Char(0);'
      '  end'
      '  else'
      '  begin'
      '    len := UCS4cToUTF8c(key, 2*tid+1);'
      '    len := len + UCS4cToUTF8c(key + len, nid);'
      '    key[len] := #0;'
      '  end;'
      ''
      '  with ResCacheEntry^ do'
      '  begin'
      '    syndx := ElfHashLowercase(key) mod Hashtable^.Size;'
      '    I := Hashtable^.Entries[syndx];'
      '    while I <> -1 do'
      '    begin'
      '      symName := StringTable + SymbolTable[I].Name;'
      '      if (strcasecmp(key, symName) = 0) then'
      '      begin'
      '        Result := TResourceHandle(@SymbolTable[I]);'
      '        Exit;'
      '      end'
      '      else'
      '      begin'
      '        I := SymbolTable[I].Chain;'
      '      end;'
      '    end;'
      '  end;'
      ''
      'end;'
      ''
      
        'function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourc' +
        'eHandle): HGLOBAL;'
      'var'
      '  ResCacheEntry: PFindResourceCache;'
      'begin'
      '  if ResHandle <> 0 then'
      '  begin'
      '    ResCacheEntry := GetResourceCache(ModuleHandle);'
      
        '    Result := HGLOBAL(PResourceSym(ResHandle)^.Data + HGLOBAL(Re' +
        'sCacheEntry^.ResourceHeader));'
      '  end'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      
        'function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResou' +
        'rceHandle): Integer;'
      'begin'
      '  if ResHandle <> 0 then'
      '    Result := PResourceSym(ResHandle)^.Size'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      'function LockResource(ResData: HGLOBAL): Pointer;'
      'begin'
      '  Result := Pointer(ResData);'
      'end;'
      ''
      'function UnlockResource(ResData: HGLOBAL): LongBool;'
      'begin'
      '  Result := False;'
      'end;'
      ''
      'function FreeResource(ResData: HGLOBAL): LongBool;'
      'begin'
      '  Result := True;'
      'end;'
      '{$ENDIF POSIX and !EXTERNALLINKER}'
      ''
      '{ ResString support function }'
      ''
      '{$IFDEF MSWINDOWS}'
      'function LoadResString(ResStringRec: PResStringRec): string;'
      'var'
      '  Buffer: array [0..4095] of Char;'
      'begin'
      '  if ResStringRec = nil then Exit;'
      '  if Assigned(LoadResStringFunc) then'
      '    Exit(LoadResStringFunc(ResStringRec));'
      '  if ResStringRec.Identifier < 64*1024 then'
      '    SetString(Result, Buffer,'
      '      LoadString(FindResourceHInstance(ResStringRec.Module^),'
      '        ResStringRec.Identifier, Buffer, Length(Buffer)))'
      '  else'
      '    Result := PChar(ResStringRec.Identifier);'
      'end;'
      '{$ENDIF}'
      ''
      '{$IF (defined(POSIX) and (not defined(EXTERNALLINKER)))}'
      'const'
      '  ResStringTableLen = 16;'
      ''
      'type'
      '  ResStringTable = array [0..ResStringTableLen-1] of UInt32;'
      ''
      'function LoadResString(ResStringRec: PResStringRec): string;'
      'var'
      '  Handle: TResourceHandle;'
      '  Tab: ^ResStringTable;'
      '  ResMod: HMODULE;'
      '  blk: Integer;'
      'begin'
      '  if ResStringRec = nil then Exit;'
      '  if Assigned(LoadResStringFunc) then'
      '    Exit(LoadResStringFunc(ResStringRec));'
      '  ResMod := FindResourceHInstance(ResStringRec^.Module^);'
      '  //P := GetResourceCache(ModuleHandle);'
      '  blk := ResStringRec^.Identifier div ResStringTableLen;'
      
        '  if blk = 0 then    // can'#39't pass '#39'nil'#39' to FindResource. use al' +
        'ternate scheme for 0 instead'
      '    Handle := FindResource(ResMod, '#39'#0'#39', PChar(6)) // RT_STRING'
      '  else'
      '    Handle := FindResource(ResMod,'
      '//         PChar(ResStringRec^.Identifier),'
      '       PChar(PByte(blk)),'
      '//       PChar(((blk + 1) shl 16) or $FFFF),'
      '       PChar(6));   // RT_STRING'
      '  Tab := Pointer(LoadResource(ResMod, Handle));'
      '  if Tab = nil then'
      '    Result := '#39#39
      '  else'
      '  begin'
      
        '    Result := PWideChar(_PAnsiChr(Tab) + Tab[ResStringRec^.Ident' +
        'ifier mod ResStringTableLen]);'
      '  end;'
      'end;'
      '{$ENDIF POSIX and !EXTERNALLINKER}'
      ''
      '{$IF defined(EXTERNALLINKER)}'
      'function LoadResString(ResStringRec: PResStringRec): string;'
      'type'
      '  TWCharArray = array[0..$FFFF] of WideChar;'
      '  PResStringResource = ^TResStringResource;'
      '  TResStringResource = packed record'
      '    Len: Word;'
      '    case Integer of'
      '    0: ( CharData: TWCharArray; );'
      '    1: ( LongLen: UInt32;'
      '         LongCharData: TWCharArray; );'
      '  end;'
      'var'
      '  Handle, NeutralResourceHandle: NativeUInt;'
      '  P: PResStringResource;'
      '  L: Integer;'
      '  Info: dl_info;'
      'begin'
      '  Result := '#39#39';'
      '  if ResStringRec = nil then Exit;'
      '  if Assigned(LoadResStringFunc) then'
      '    Exit(LoadResStringFunc(ResStringRec));'
      '  // Load neutral resource'
      
        '  if dladdr(UIntPtr(dlsym(RTLD_DEFAULT, ResStringRec^.Key)), Inf' +
        'o) <> 0 then'
      '  begin'
      '    NeutralResourceHandle := dlopen(Info.dli_fname, RTLD_LAZY);'
      '    if NeutralResourceHandle <> 0 then'
      '    begin'
      '      Handle := FindResourceHInstance(NeutralResourceHandle);'
      '      dlclose(NeutralResourceHandle);'
      '    end'
      '    else'
      '      Handle := RTLD_DEFAULT;'
      '  end'
      '  else'
      '    Handle := FindResourceHInstance(HInstance);'
      '  dlerror; // clear error state;  dlsym doesn'#39't'
      '  P := dlsym(Handle, ResStringRec^.Key);'
      '  if (P <> nil) and (dlerror = nil) then'
      '  begin'
      '    L := P^.Len;'
      '    if L <> $FFFF then'
      '      SetString(Result, P^.CharData, L)'
      '    else'
      '      SetString(Result, P^.LongCharData, P^.LongLen);'
      '  end;'
      'end;'
      ''
      
        'function FindResource(ModuleHandle: HMODULE; ResourceName: PChar' +
        '; ResourceType: PChar): TResourceHandle;'
      'const'
      
        '  ResMangles: array[1..24] of string = ('#39'6CURSOR'#39', '#39'6BITMAP'#39', '#39'4' +
        'ICON'#39', '#39'4MENU'#39','
      
        '    '#39'6DIALOG'#39', '#39'6STRING'#39', '#39'7FONTDIR'#39', '#39'4FONT'#39', '#39'11ACCELERATOR'#39', ' +
        #39'6RCDATA'#39','
      
        '    '#39'12MESSAGETABLE'#39', '#39'12GROUP_CURSOR'#39', '#39#39', '#39'9GROUP_ICON'#39', '#39#39', '#39 +
        '7VERSION'#39','
      
        '    '#39'10DLGINCLUDE'#39', '#39#39', '#39'8PLUGPLAY'#39', '#39'3VXD'#39', '#39'9ANICURSOR'#39', '#39'7ANI' +
        'ICON'#39', '#39'4HTML'#39', '#39'8MANIFEST'#39');'
      '  ManglePrefix = '#39'__rsrc_N'#39';'
      '  MangleSuffix = '#39'E'#39';'
      'var'
      '  Mangle: TPtrWrapper;'
      '  ResType: NativeInt;'
      '  ResName: PChar;'
      '  NameLength: Integer;'
      '  LowerName: string;'
      '  Ch: Integer;'
      'begin'
      '  Result := 0;'
      '  ResType := NativeInt(ResourceType);'
      
        '  if (ResType >= Low(ResMangles)) and (ResType <= High(ResMangle' +
        's)) then'
      '  begin'
      '    LowerName := string(ResourceName);'
      '    ResName := PChar(LowerName);'
      '    while Ord(ResName^) <> 0 do'
      '    begin'
      '      Ch := Ord(ResName^);'
      '      if (Ch >= Ord('#39'A'#39')) and (Ch <= Ord('#39'Z'#39')) then'
      '        ResName^ := Chr(Ch or $0020);'
      '      Inc(ResName);'
      '    end;'
      
        '    NameLength := Length(UTF8Encode(LowerName));  // We need the' +
        ' length of utf8 characters'
      
        '    Mangle := TMarshal.AllocStringAsUtf8(ManglePrefix + ResMangl' +
        'es[ResType] +'
      
        '      string(_Str0Int64(NameLength)) + LowerName + MangleSuffix)' +
        ';'
      '    Result := NativeUInt(dlsym(ModuleHandle, Mangle.ToPointer));'
      '    if Result > 0 then'
      '      Inc(Result, SizeOf(Integer)); // 32-bit data size'
      '    TMarshal.FreeMem(Mangle);'
      '  end;'
      'end;'
      ''
      
        'function LoadResource(ModuleHandle: HMODULE; ResHandle: TResourc' +
        'eHandle): HGLOBAL;'
      'begin'
      '  Result := ResHandle;'
      'end;'
      ''
      
        'function SizeofResource(ModuleHandle: HMODULE; ResHandle: TResou' +
        'rceHandle): Integer;'
      'begin'
      '  if ResHandle > 0 then'
      '    Result := PInteger(PByte(ResHandle) - SizeOf(Integer))^'
      '  else'
      '    Result := 0;'
      'end;'
      ''
      'function LockResource(ResData: HGLOBAL): Pointer;'
      'begin'
      '  Result := Pointer(ResData);'
      'end;'
      ''
      'function UnlockResource(ResData: HGLOBAL): LongBool;'
      'begin'
      '  Result := False;'
      'end;'
      ''
      'function FreeResource(ResData: HGLOBAL): LongBool;'
      'begin'
      '  Result := True;'
      'end;'
      '{$ENDIF !EXTERNALLINKER}'
      ''
      '{$IFDEF LINUX}'
      
        '{ The Win32 program loader sets up the first 64k of process addr' +
        'ess space'
      
        '  with no read or write access, to help detect use of invalid po' +
        'inters'
      
        '  (whose integer value is 0..64k).  Linux doesn'#39't do this.  Mac ' +
        'OS/X'
      
        '  does allow this, and the linker will ensure that this is the c' +
        'ase by'
      '  reserving 64k at the start of the image.'
      ''
      '  Parts of the Delphi RTL and IDE design environment'
      
        '  rely on the notion that pointer values in the [0..64k] range a' +
        're'
      
        '  invalid pointers.  To accomodate this in Linux, we reserve the' +
        ' range'
      
        '  at startup.  If the range is already allocated, we keep going ' +
        'anyway. }'
      ''
      'var'
      '  ZeroPageReserved: Boolean = False;'
      ''
      'procedure ReserveZeroPage;'
      'const'
      '  PROT_NONE = 0;'
      '  MAP_PRIVATE   = $02;'
      '  MAP_FIXED     = $10;'
      '  MAP_ANONYMOUS = $20;'
      'var'
      '  P: Pointer;'
      'begin'
      
        '  if IsLibrary then Exit;  // page reserve is app'#39's job, not .so' +
        #39's'
      ''
      '  if not ZeroPageReserved then'
      '  begin'
      '    P := mmap(nil, High(Word), PROT_NONE,'
      '      MAP_ANONYMOUS or MAP_PRIVATE or MAP_FIXED, 0, 0);'
      '    ZeroPageReserved := P = nil;'
      
        '    if (IntPtr(P) <> -1) and (P <> nil) then  // we didn'#39't get i' +
        't'
      '      munmap(P, High(Word));'
      '  end;'
      'end;'
      ''
      'procedure ReleaseZeroPage;'
      'begin'
      '  if ZeroPageReserved then'
      '  begin'
      '    munmap(nil, High(Word) - 4096);'
      '    ZeroPageReserved := False;'
      '  end;'
      'end;'
      '{$ENDIF LINUX}'
      ''
      'var'
      '  xxNull: UCS4Char = 0;'
      '  xxPNull: PUCS4Char = @xxNull;'
      ''
      'function PUCS4Chars(const S: UCS4String): PUCS4Char;'
      'begin'
      '  if Length(S) > 0 then'
      '    Result := @S[0]'
      '  else'
      '    Result := xxPNull;'
      'end;'
      ''
      'function WideStringToUCS4String(const S: _WideStr): UCS4String;'
      'const'
      '  Offset = Low(_WideStr);'
      'var'
      '  I: Integer;'
      '  CharCount: Integer;'
      'begin'
      '  CharCount := 0;'
      '  SetLength(Result, Length(S) + 1);'
      '  I := Offset;'
      ''
      '  while I < (Length(S) + Offset) do'
      '  begin'
      ''
      
        '    if ((S[I] >= #$D800) and (S[I] <= #$DFFF)) and (I < Length(S' +
        ')) then'
      '    begin'
      
        '      Result[CharCount] := UCS4Char((Cardinal(S[I]) and $000003F' +
        'F) shl 10 or (Cardinal(S[I + 1]) and $000003FF) + $00010000);'
      '      Inc(I);'
      '    end'
      '    else'
      '      Result[CharCount] := UCS4Char(S[I]);'
      '    Inc(CharCount);'
      '    Inc(I);'
      '  end;'
      '  Result[CharCount] := 0;'
      '  SetLength(Result, CharCount + 1);'
      'end;'
      ''
      'function UCS4StringToWideString(const S: UCS4String): _WideStr;'
      'var'
      '  I: Integer;'
      '  CharCount: Integer;'
      'begin'
      
        '  SetLength(Result, Length(S) * 2 - 1); //Maximum possible numbe' +
        'r of characters'
      '  CharCount := 0;'
      ''
      '  I := 0;'
      '  while I < Length(S) - 1 do'
      '  begin'
      '    if S[I] >= $10000 then'
      '    begin'
      '      Inc(CharCount);'
      
        '      Result[CharCount] := WideChar((((S[I] - $00010000) shr 10)' +
        ' and $000003FF) or $D800);'
      '      Inc(CharCount);'
      
        '      Result[CharCount] := WideChar(((S[I] - $00010000) and $000' +
        '003FF)or $DC00);'
      '    end'
      '    else'
      '    begin'
      '      Inc(CharCount);'
      '      Result[CharCount] := WideChar(S[I]);'
      '    end;'
      ''
      '    Inc(I);'
      '  end;'
      ''
      '  SetLength(Result, CharCount);'
      'end;'
      ''
      '{$IFDEF POSIX}'
      'type'
      '  TCodePageMapEntry = record'
      '    LocaleName: string;'
      '    CodePage: Cardinal;'
      '  end;'
      ''
      'const'
      '  // Predefined set of Name <=> CP mappings for POSIX'
      '  CodePageMapA: array[0..2] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'ar'#39'; CodePage: 1256),'
      '    (LocaleName: '#39'az-cyrl'#39'; CodePage: 1251),'
      '    (LocaleName: '#39'az-latn'#39'; CodePage: 1254));'
      ''
      '  CodePageMapBC: array[0..2] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'be'#39'; CodePage: 1251),'
      '    (LocaleName: '#39'bg'#39'; CodePage: 1251),'
      '    (LocaleName: '#39'cs'#39'; CodePage: 1250));'
      ''
      '  CodePageMapEF: array[0..2] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'el'#39'; CodePage: 1253),'
      '    (LocaleName: '#39'et'#39'; CodePage: 1257),'
      '    (LocaleName: '#39'fa'#39'; CodePage: 1256));'
      ''
      '  CodePageMapH: array[0..2] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'he'#39'; CodePage: 1255),'
      '    (LocaleName: '#39'hr'#39'; CodePage: 1250),'
      '    (LocaleName: '#39'hu'#39'; CodePage: 1250));'
      ''
      '  CodePageMapJK: array[0..2] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'ja'#39'; CodePage: 932),'
      '    (LocaleName: '#39'kk'#39'; CodePage: 1251),'
      '    (LocaleName: '#39'ko'#39'; CodePage: 949));'
      ''
      '  CodePageMapLM: array[0..2] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'lt'#39'; CodePage: 1257),'
      '    (LocaleName: '#39'lv'#39'; CodePage: 1257),'
      '    (LocaleName: '#39'mk'#39'; CodePage: 1251));'
      ''
      '  CodePageMapP: array[0..1] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'pa-arab'#39'; CodePage: 1256),'
      '    (LocaleName: '#39'pl'#39'; CodePage: 1250));'
      ''
      '  CodePageMapR: array[0..1] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'ro'#39'; CodePage: 1250),'
      '    (LocaleName: '#39'ru'#39'; CodePage: 1251));'
      ''
      '  CodePageMapS: array[0..4] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'sk'#39'; CodePage: 1250),'
      '    (LocaleName: '#39'sl'#39'; CodePage: 1250),'
      '    (LocaleName: '#39'sq'#39'; CodePage: 1250),'
      '    (LocaleName: '#39'sr-cyrl'#39'; CodePage: 1251),'
      '    (LocaleName: '#39'sr-latn'#39'; CodePage: 1250));'
      ''
      '  CodePageMapT: array[0..1] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'th'#39'; CodePage: 874),'
      '    (LocaleName: '#39'tr'#39'; CodePage: 1254));'
      ''
      '  CodePageMapUV: array[0..5] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'uk'#39'; CodePage: 1251),'
      '    (LocaleName: '#39'ur'#39'; CodePage: 1256),'
      '    (LocaleName: '#39'uz-arab'#39'; CodePage: 1256),'
      '    (LocaleName: '#39'uz-cyrl'#39'; CodePage: 1251),'
      '    (LocaleName: '#39'uz-latn'#39'; CodePage: 1254),'
      '    (LocaleName: '#39'vi'#39'; CodePage: 1258));'
      ''
      
        '  // Special case - needs full LANG_CNTRY to determine proper co' +
        'depage'
      '  CodePageMapZH: array[0..6] of TCodePageMapEntry = ('
      '    (LocaleName: '#39'zh_cn'#39'; CodePage: 936),'
      '    (LocaleName: '#39'zh_hk'#39'; CodePage: 950),'
      '    (LocaleName: '#39'zh-hans_hk'#39'; CodePage: 936),'
      '    (LocaleName: '#39'zh_mo'#39'; CodePage: 950),'
      '    (LocaleName: '#39'zh-hans_mo'#39'; CodePage: 936),'
      '    (LocaleName: '#39'zh_sg'#39'; CodePage: 936),'
      '    (LocaleName: '#39'zh_tw'#39'; CodePage: 950));'
      ''
      '{$IFDEF OSX64}'
      '                      '
      'const'
      '  libobjc = '#39'/usr/lib/libobjc.dylib'#39';'
      
        'function sel_getUid(const str: MarshaledAString): Pointer; cdecl' +
        '; external libobjc name _PU + '#39'sel_getUid'#39';'
      '{$ENDIF _OSX64}'
      ''
      'function GetPosixLocaleName: string;'
      '{$IFDEF MACOS}'
      'var'
      '  Locale: CFLocaleRef;'
      'begin'
      '  Locale := CFLocaleCopyCurrent;'
      '  try'
      '    Result := StringRefToString(CFLocaleGetIdentifier(Locale));'
      '  finally'
      '    CFRelease(Locale);'
      '  end;'
      'end;'
      '{$ELSEIF defined(ANDROID)}'
      'begin'
      '  Result := GetAndroidLocaleName;'
      'end;'
      '{$ELSEIF defined(LINUX)}'
      'const'
      '  defaultLocale = '#39'en_US'#39';'
      'var'
      '  Env: _PAnsiChr;'
      '  Temp: Pointer;'
      '  I, Len: Integer;'
      '  LHasDot: Boolean;'
      'begin'
      '  LHasDot := False;'
      '  Env := getenv(_PAnsiChr('#39'LANG'#39')); // do not localize'
      '  if Env = nil then'
      '    Env := defaultLocale;'
      ''
      
        '  // LANG environment variable is treated as 7-bit ASCII encodin' +
        'g'
      '  Len := 0;'
      '  while (Env[Len] <> #0) and (Env[Len] <> '#39'.'#39') do'
      '  begin'
      '    Inc(Len);'
      '    if Env[Len] = '#39'.'#39' then'
      '      LHasDot := True;'
      '  end;'
      ''
      '  SetLength(Result, Len);'
      '  Temp := PChar(Result);'
      '  for I := 0 to Len - 1 do'
      '    PWideChar(Temp)[I] := WideChar(Ord(Env[I]));'
      '  if LHasDot then'
      '    Result := Result + '#39'.utf8'#39';'
      'end;'
      '{$ELSE !MACOS and !ANDROID and !LINUX}'
      'begin'
      '  Error(rePlatformNotImplemented);'
      'end;'
      '{$ENDIF !MACOS and !ANDROID and !LINUX}'
      ''
      'function GetACP: Cardinal;'
      ''
      
        '  function FindCodePage(const Name: string; const Map: array of ' +
        'TCodePageMapEntry;'
      '    var CodePage: Cardinal): Boolean;'
      '  var'
      '    I: Integer;'
      '  begin'
      '    for I := Low(Map) to High(Map) do'
      '      if Map[I].LocaleName = Name then'
      '      begin'
      '        CodePage := Map[I].CodePage;'
      '        Exit(True);'
      '      end;'
      '    Result := False;'
      '  end;'
      ''
      'var'
      '  I: Integer;'
      '  LName: string;'
      '  LCodePage: Cardinal;'
      'begin'
      '  LName := GetPosixLocaleName;'
      '  I := Low(string);'
      '  while I <= High(LName) do'
      '  begin'
      
        '    if _AnsiChr(LName[I]) in ['#39'A'#39'..'#39'Z'#39'] then         // do not l' +
        'ocalize'
      '      Inc(LName[I], Ord('#39'a'#39') - Ord('#39'A'#39'))   // do not localize'
      '    else if LName[I] = '#39'_'#39' then            // do not localize'
      '    begin'
      '      SetLength(LName, I - Low(string));'
      '      Break;'
      '    end;'
      '    Inc(I);'
      '  end;'
      ''
      '  Result := 1252; // Default codepage'
      '  if Length(LName) > 0 then'
      '    case LName[Low(string)] of'
      '      '#39'a'#39':'
      '        if FindCodePage(LName, CodePageMapA, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'b'#39','#39'c'#39':'
      '        if FindCodePage(LName, CodePageMapBC, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'e'#39','#39'f'#39':'
      '        if FindCodePage(LName, CodePageMapEF, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'h'#39':'
      '        if FindCodePage(LName, CodePageMapH, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'j'#39','#39'k'#39':'
      '        if FindCodePage(LName, CodePageMapJK, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'l'#39','#39'm'#39':'
      '        if FindCodePage(LName, CodePageMapLM, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'p'#39':'
      '        if FindCodePage(LName, CodePageMapP, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'r'#39':'
      '        if FindCodePage(LName, CodePageMapR, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39's'#39':'
      '        if FindCodePage(LName, CodePageMapS, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39't'#39':'
      '        if FindCodePage(LName, CodePageMapT, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'u'#39','#39'v'#39':'
      '        if FindCodePage(LName, CodePageMapUV, LCodePage) then'
      '          Result := LCodePage;'
      '      '#39'z'#39':'
      '        begin'
      '          LName := GetPosixLocaleName;'
      '          I := Low(string);'
      '          while I <= High(LName) do'
      '          begin'
      
        '            if _AnsiChr(LName[I]) in ['#39'A'#39'..'#39'Z'#39'] then         // ' +
        'do not localize'
      
        '              Inc(LName[I], Ord('#39'a'#39') - Ord('#39'A'#39'))   // do not loc' +
        'alize'
      
        '            else if LName[I] = '#39'@'#39' then            // do not loc' +
        'alize'
      
        '            // Non Gregorian calendars include "@calendar=<calen' +
        'dar>" on MACOS'
      '            begin'
      '              SetLength(LName, I - Low(string));'
      '              Break;'
      '            end;'
      '            Inc(I);'
      '          end;'
      '          if FindCodePage(LName, CodePageMapZH, LCodePage) then'
      '            Result := LCodePage'
      
        '          else if (Length(LName) >= 2) and (LName[Low(string) + ' +
        '1] = '#39'h'#39') then'
      
        '            // Fallback for Chinese in countries other than cn, ' +
        'hk, mo, tw, sg'
      '            Result := 936;'
      '        end;'
      '    end;'
      'end;'
      '{$ENDIF POSIX}'
      ''
      'function LocaleCharsFromUnicode(CodePage, Flags: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      '{$IFDEF MSWINDOWS}'
      'begin'
      
        '  Result := WideCharToMultiByte(CodePage, Flags, UnicodeStr, Uni' +
        'codeStrLen, LocaleStr,'
      '    LocaleStrLen, DefaultChar, PBOOL(UsedDefaultChar));'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      
        '  Result := LocaleCharsFromUnicode(LocaleNameFromCodePage(CodePa' +
        'ge), Flags,'
      
        '    UnicodeStr, UnicodeStrLen, LocaleStr, LocaleStrLen, DefaultC' +
        'har, UsedDefaultChar);'
      'end;'
      '{$ENDIF POSIX}'
      ''
      
        'function UnicodeFromLocaleChars(CodePage, Flags: Cardinal; Local' +
        'eStr: _PAnsiChr;'
      
        '  LocaleStrLen: Integer; UnicodeStr: PWideChar; UnicodeStrLen: I' +
        'nteger): Integer; overload;'
      '{$IFDEF MSWINDOWS}'
      'begin'
      
        '  Result := MultiByteToWideChar(CodePage, Flags, LocaleStr, Loca' +
        'leStrLen, UnicodeStr, UnicodeStrLen);'
      'end;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      'begin'
      
        '  Result := UnicodeFromLocaleChars(LocaleNameFromCodePage(CodePa' +
        'ge), Flags, LocaleStr, LocaleStrLen, UnicodeStr, UnicodeStrLen);'
      'end;'
      '{$ENDIF POSIX}'
      ''
      '{$IFDEF POSIX}'
      'const'
      '  MB_ERR_INVALID_CHARS = 8;'
      ''
      '{$IFDEF USE_LIBICU}'
      'threadvar'
      '  LastConverter: PUConverter;'
      '  LastConverterName: _AnsiStr;'
      ''
      ''
      'type'
      '  SubContext = record'
      '    Sub: Byte;'
      '    Used: Boolean;'
      '  end;'
      ''
      'procedure ReleaseICUThreadResources;'
      'begin'
      '  if LastConverter <> nil then'
      '    ucnv_close(LastConverter);'
      '  LastConverterName := '#39#39';'
      'end;'
      ''
      
        'procedure UcnvFromUCallbackSubstitute(const context: Pointer; fr' +
        'omArgs: PUConverterFromUnicodeArgs;'
      
        '  const codeUnits: PUChar; length: Int32; codePoint: UChar32; re' +
        'ason: UConverterCallbackReason; var Err: UErrorCode);cdecl;'
      'begin'
      '  if reason <= UCNV_CB_IRREGULAR then'
      '  begin'
      '    Err := U_ZERO_ERROR;'
      '    SubContext(context^).Used := True;'
      
        '    ucnv_cbFromUWriteBytes(fromArgs, @SubContext(context^).Sub, ' +
        '1, 0, Err);'
      ''
      '    if Err <= U_ZERO_ERROR then'
      
        '      Err := UErrorCode(-1000); // We return -1000 to identify a' +
        ' bad encoding'
      '  end;'
      'end;'
      ''
      
        'procedure UcnvFromUCallbackErrorEncoding(const context: Pointer;' +
        ' fromArgs: PUConverterFromUnicodeArgs;'
      
        '  const codeUnits: PUChar; length: Int32; codePoint: UChar32; re' +
        'ason: UConverterCallbackReason; var Err: UErrorCode);cdecl;'
      'begin'
      '  if reason <= UCNV_CB_IRREGULAR then'
      '  begin'
      '    if (context = nil) or'
      
        '       ((Ord(PByte(context)^) = UCNV_PRV_STOP_ON_ILLEGAL) and (r' +
        'eason = UCNV_CB_UNASSIGNED)) then'
      '    begin'
      
        '      Err := UErrorCode(1000); // We return 1000 to identify a b' +
        'ad encoding and stop converting'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IFDEF USE_LIBICU}'
      '{$IFDEF LINUX}'
      
        'function LocaleCharsFromUnicodeICU(const LocaleName: _AnsiStr; F' +
        'lags: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      '{$ELSE !LINUX}'
      
        'function LocaleCharsFromUnicode(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      '{$ENDIF LINUX}'
      'var'
      '  Err: UErrorCode;'
      '  Conv: PUConverter;'
      '  NSubs: Int32;'
      '  sub: UChar32;'
      '  ctx: SubContext;'
      'begin'
      '  Result := 0;'
      
        '  // DefaultChar and UsedDefaultChar are not valid with UTF-7 or' +
        ' UTF-8'
      '  if ((DefaultChar <> nil) or (UsedDefaultChar <> nil)) and'
      
        '     ((LocaleName = '#39'UTF-8'#39') or (LocaleName = '#39'UTF-7'#39')) then // ' +
        'do not localize'
      '    Exit(0);'
      ''
      
        '  // When UnicodeStrLen is -1 treat UnicodeStr as a null termina' +
        'ted string'
      '  if UnicodeStrLen = -1 then'
      
        '    UnicodeStrLen := Length(UnicodeStr) + 1; // include terminat' +
        'ing null'
      ''
      '  Err := 0;'
      '  if LocaleName = '#39'UTF-8'#39' then'
      '  begin'
      '    if DefaultChar = nil then'
      '      sub := UChar32('#39'?'#39')'
      '    else'
      '      sub := UChar32(DefaultChar^);'
      
        '    u_strToUTF8WithSub(LocaleStr, LocaleStrLen, Result, UnicodeS' +
        'tr, UnicodeStrLen, sub, NSubs, Err);'
      '    if (LocaleStrLen > 0) and (Err > 0) then Result := 0;'
      
        '    if (NSubs > 0) and (Flags and MB_ERR_INVALID_CHARS = MB_ERR_' +
        'INVALID_CHARS) then'
      '      Result := 0; // Return 0 if an invalid character was found'
      '    if (UsedDefaultChar <> nil) then'
      '      UsedDefaultChar^ := (NSubs > 0);'
      '  end'
      '  else'
      '  begin'
      
        '    if (LastConverter = nil) or (LastConverterName <> LocaleName' +
        ') then   // Cached last converter'
      '    begin'
      '      Conv := ucnv_open(_PAnsiChr(LocaleName), Err);'
      ''
      '      if Err > 0 then Exit;'
      ''
      '      if LastConverter <> nil then'
      '        ucnv_close(LastConverter);'
      ''
      '      LastConverter := Conv;'
      '      LastConverterName := LocaleName;'
      '    end'
      '    else'
      '    begin'
      '      Conv := LastConverter;'
      '      ucnv_reset(Conv);'
      '    end;'
      ''
      '    Err := U_ZERO_ERROR;'
      
        '    if (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) t' +
        'hen'
      
        '      ucnv_setFromUCallBack(Conv, @UcnvFromUCallbackErrorEncodin' +
        'g, nil, nil, nil, Err)'
      '    else'
      '    begin'
      '      if DefaultChar = nil then'
      '        ctx.Sub := Ord('#39'?'#39')'
      '      else'
      '        ctx.Sub := Byte(DefaultChar^);'
      '      ctx.Used := False;'
      
        '      ucnv_setFromUCallBack(Conv, @UcnvFromUCallbackSubstitute, ' +
        '@ctx, nil, nil, Err);'
      '    end;'
      ''
      '    Err := U_ZERO_ERROR;'
      
        '    Result := ucnv_fromUChars(Conv, LocaleStr, LocaleStrLen, PUC' +
        'HAR(UnicodeStr), UnicodeStrLen, Err);'
      ''
      
        '    if ((LocaleStrLen > 0) and (Err > 0)) or (Err = 1000) then R' +
        'esult := 0;'
      '    if (UsedDefaultChar <> nil) then'
      '      UsedDefaultChar^ := ctx.Used;'
      '  end;'
      'end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IF not Defined(USE_LIBICU) or Defined(LINUX)}'
      '{$IFDEF LINUX}'
      
        'function LocaleCharsFromUnicodeICONV(const LocaleName: _AnsiStr;' +
        ' Flags: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      '{$ELSE !LINUX}'
      
        'function LocaleCharsFromUnicode(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      '{$ENDIF LINUX}'
      'var'
      '  LContext: iconv_t;'
      '  LSourcePtr, LDestPtr: Pointer;'
      '  LCalcSizeBuf: array of _AnsiChr;'
      '  LDestLen, LSourceLen, LSize: size_t;'
      '  InvalidCharFound: Boolean;'
      '  LastError: Integer;'
      'begin'
      '  Result := 0;'
      
        '  // DefaultChar and UsedDefaultChar are not valid with UTF-7 or' +
        ' UTF-8'
      '  if ((DefaultChar <> nil) or (UsedDefaultChar <> nil)) and'
      
        '     ((LocaleName = '#39'UTF-8'#39') or (LocaleName = '#39'UTF-7'#39')) then // ' +
        'do not localize'
      '    Exit(0);'
      ''
      
        '  // When UnicodeStrLen is -1 treat UnicodeStr as a null termina' +
        'ted string'
      '  if UnicodeStrLen = -1 then'
      
        '    UnicodeStrLen := Length(UnicodeStr) + 1; // include terminat' +
        'ing null'
      ''
      
        '  LContext := iconv_open(_PAnsiChr(LocaleName), '#39'UTF-16LE'#39'); // ' +
        'do not localize'
      '  if LContext <> iconv_t(-1) then'
      '    try'
      
        '      // LocaleStrLen = 0 is a request to calculate the required' +
        ' buffer size,'
      '      // use a local destination buffer for the conversion.'
      '      if LocaleStrLen = 0 then'
      '      begin'
      '        SetLength(LCalcSizeBuf, 1024);'
      '        LDestLen := Length(LCalcSizeBuf);'
      '        LDestPtr := Pointer(@LCalcSizeBuf[0]);'
      '      end'
      '      else'
      '      begin'
      '        LDestLen := LocaleStrLen;'
      '        LDestPtr := Pointer(LocaleStr);'
      '      end;'
      ''
      '      LSourceLen := UnicodeStrLen * SizeOf(WideChar);'
      '      LSourcePtr := Pointer(UnicodeStr);'
      ''
      '      LSize := 0;'
      '      if UsedDefaultChar <> nil then'
      '        UsedDefaultChar^ := False;'
      ''
      '      InvalidCharFound := False;'
      ''
      '      while True do'
      '      begin'
      
        '        Result := iconv(LContext, @LSourcePtr, @LSourceLen, @LDe' +
        'stPtr, @LDestLen);'
      
        '        // This check is added because iconv returns success, bu' +
        't fails to decode the last character if it is'
      
        '        // an upper char. Flushing the output buffer solves this' +
        ' issue.'
      '        if (Result = 0) and (LocaleName = '#39'UTF-7'#39') then'
      
        '          Result := iconv(LContext, nil, nil, @LDestPtr, @LDestL' +
        'en);'
      '        if Result <> -1 then'
      '          Break'
      '        else'
      '        begin'
      '          LastError := GetLastError;'
      '          if (LastError = E2BIG) or (LDestLen = 0) then'
      '          begin'
      '            if LocaleStrLen = 0 then'
      '            begin'
      
        '              // Save converted buffer size and reset to beginni' +
        'ng of local buffer'
      
        '              Inc(LSize, size_t(Length(LCalcSizeBuf)) - LDestLen' +
        ');'
      '              LDestPtr := Pointer(@LCalcSizeBuf[0]);'
      '              LDestLen := Length(LCalcSizeBuf);'
      '            end'
      '            else'
      '            begin'
      '              LDestLen := LocaleStrLen; // Return a length of 0'
      '              Break;'
      '            end;'
      '          end;'
      '          case LastError of'
      '            E2BIG: // Insufficient destination buffer'
      '              ;'
      
        '            EILSEQ: // Invalid character for destination charact' +
        'er set'
      '              begin'
      
        '                // Increment pointers and insert '#39'?'#39' (or the Def' +
        'aultChar'
      '                // if specified) into the destination string.'
      '                Inc(PByte(LSourcePtr), SizeOf(WideChar));'
      '                Dec(LSourceLen, SizeOf(WideChar));'
      '                if LocaleStrLen <> 0 then'
      '                begin'
      '                  if DefaultChar = nil then'
      
        '                    _PAnsiChr(LDestPtr)^ := _AnsiChr('#39'?'#39') // do ' +
        'not localize'
      '                  else'
      '                    _PAnsiChr(LDestPtr)^ := DefaultChar^;'
      '                  if UsedDefaultChar <> nil then'
      '                    UsedDefaultChar^ := True;'
      '                  InvalidCharFound := True;'
      '                end;'
      '                Inc(PByte(LDestPtr));'
      '                Dec(LDestLen);'
      '              end;'
      '          else'
      '            Exit(0); // Return a length of 0'
      '          end;'
      '        end;'
      '      end;'
      ''
      
        '      if InvalidCharFound and (Flags and MB_ERR_INVALID_CHARS = ' +
        'MB_ERR_INVALID_CHARS) then'
      
        '        Exit(0); // Return 0 if an invalid character was encount' +
        'ered'
      ''
      '      if LocaleStrLen = 0 then'
      
        '        Result := LSize + size_t(Length(LCalcSizeBuf)) - LDestLe' +
        'n'
      '      else'
      '        Result := size_t(LocaleStrLen) - LDestLen'
      '    finally'
      '      iconv_close(LContext);'
      '    end;'
      'end;'
      '{$ENDIF not Defined(USE_LIBICU) or Defined(LINUX)}'
      ''
      '{$IFDEF LINUX}'
      
        'function LocaleCharsFromUnicode(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  UnicodeStr: PWideChar; UnicodeStrLen: Integer; LocaleStr: _PAn' +
        'siChr;'
      
        '  LocaleStrLen: Integer; DefaultChar: _PAnsiChr; UsedDefaultChar' +
        ': PLongBool): Integer; overload;'
      'begin'
      '  if IsICUAvailable then'
      
        '    Result := LocaleCharsFromUnicodeICU(LocaleName, Flags, Unico' +
        'deStr, UnicodeStrLen, LocaleStr, LocaleStrLen, DefaultChar, Used' +
        'DefaultChar)'
      '  else'
      
        '    Result := LocaleCharsFromUnicodeICONV(LocaleName, Flags, Uni' +
        'codeStr, UnicodeStrLen, LocaleStr, LocaleStrLen, DefaultChar, Us' +
        'edDefaultChar);'
      'end;'
      '{$ENDIF LINUX}'
      ''
      ''
      
        '{$IFDEF USE_LIBICU}                                             ' +
        '                   '
      
        'procedure UcnvToUCallbackSubstitute(const context: Pointer; toAr' +
        'gs: PUConverterToUnicodeArgs;'
      
        '  const codeUnits: MarshaledAString; length: Int32; reason: UCon' +
        'verterCallbackReason; var err: UErrorCode);cdecl;'
      'var'
      '  sub: Char;'
      'begin'
      '  if reason <= UCNV_CB_IRREGULAR then'
      '  begin'
      '    if (context = nil) or'
      
        '      ( (Ord(PByte(context)^) = UCNV_PRV_STOP_ON_ILLEGAL) and (r' +
        'eason = UCNV_CB_UNASSIGNED) ) then'
      '    begin'
      '      sub:= '#39'?'#39';'
      '      Err := U_ZERO_ERROR;'
      '      ucnv_cbToUWriteUChars(toArgs, @sub, 1, 0, Err);'
      
        '      if Err <= U_ZERO_ERROR then Err := UErrorCode(-1000); // W' +
        'e return -1000 to identify a bad encoding'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure UcnvToUCallbackErrorEncoding(const context: Pointer; t' +
        'oArgs: PUConverterToUnicodeArgs;'
      
        '  const codeUnits: MarshaledAString; length: Int32; reason: UCon' +
        'verterCallbackReason; var err: UErrorCode);cdecl;'
      'begin'
      '  if reason <= UCNV_CB_IRREGULAR then'
      '  begin'
      '    if (context = nil) or'
      
        '      ( (Ord(PByte(context)^) = UCNV_PRV_STOP_ON_ILLEGAL) and (r' +
        'eason = UCNV_CB_UNASSIGNED) ) then'
      '    begin'
      
        '      Err := UErrorCode(1000); // We return 1000 to identify a b' +
        'ad encoding and stop converting'
      '    end;'
      '  end;'
      'end;'
      ''
      
        'procedure UcnvToUCallbackSkip(const context: Pointer; toArgs: PU' +
        'ConverterToUnicodeArgs;'
      
        '  const codeUnits: MarshaledAString; length: Int32; reason: UCon' +
        'verterCallbackReason; var err: UErrorCode);cdecl;'
      'begin'
      '  if reason <= UCNV_CB_IRREGULAR then'
      '  begin'
      '    if (context = nil) or'
      
        '      ( (Ord(PByte(context)^) = UCNV_PRV_STOP_ON_ILLEGAL) and (r' +
        'eason = UCNV_CB_UNASSIGNED) ) then'
      '    begin'
      '      Err := U_ZERO_ERROR;'
      '    end;'
      '  end;'
      'end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IFDEF USE_LIBICU}'
      '{$IFDEF LINUX}'
      
        'function UnicodeFromLocaleCharsICU(const LocaleName: _AnsiStr; F' +
        'lags: Cardinal;'
      
        '  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWide' +
        'Char;'
      '  UnicodeStrLen: Integer): Integer; overload;'
      '{$ELSE !LINUX}'
      
        'function UnicodeFromLocaleChars(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWide' +
        'Char;'
      '  UnicodeStrLen: Integer): Integer; overload;'
      '{$ENDIF LINUX}'
      'var'
      '  Err: UErrorCode;'
      '  Conv: PUConverter;'
      '  NSubs: Int32;'
      '  UCallBack: UConverterToUCallback;'
      'begin'
      '  Result := 0;'
      '  if LocaleName = '#39'UTF-8'#39' then'
      '  begin'
      '    Err := U_ZERO_ERROR;'
      
        '    u_strFromUTF8WithSub(UnicodeStr, UnicodeStrLen, Result, Loca' +
        'leStr, LocaleStrLen, UChar32('#39'?'#39'), NSubs, Err);'
      '    if (UnicodeStrLen > 0) and (Err > 0) then'
      '      Result := 0;'
      
        '    if (NSubs > 0) and (Flags and MB_ERR_INVALID_CHARS = MB_ERR_' +
        'INVALID_CHARS) then'
      '      Result := 0; // Return 0 if an invalid character was found'
      '  end'
      
        '  else if (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS' +
        ') and (LocaleName = '#39'UTF-7'#39') then'
      '    Result := 0'
      '  else'
      '  begin'
      
        '    if (LastConverter = nil) or (LastConverterName <> LocaleName' +
        ') then   // Cached last converter'
      '    begin'
      '      Err := U_ZERO_ERROR;'
      '      Conv := ucnv_open(_PAnsiChr(LocaleName), Err);'
      ''
      '      if Err > 0 then Exit;'
      '      if LastConverter <> nil then ucnv_close(LastConverter);'
      '      LastConverter := Conv;'
      '      LastConverterName := LocaleName;'
      '    end'
      '    else'
      '    begin'
      '      Conv := LastConverter;'
      '      ucnv_reset(Conv);'
      '    end;'
      '    Err := U_ZERO_ERROR;'
      
        '    if (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVALID_CHARS) t' +
        'hen'
      '      UCallBack :=@UcnvToUCallbackErrorEncoding'
      '    else if LocaleName = '#39'UTF-7'#39' then'
      '      UCallBack :=@UcnvToUCallbackSkip'
      '    else'
      '      UCallBack :=@UcnvToUCallbackSubstitute;'
      '    ucnv_setToUCallBack(Conv, UCallBack, nil, nil, nil, Err);'
      ''
      '    Err := U_ZERO_ERROR;'
      
        '    Result := ucnv_toUChars(Conv, UnicodeStr, UnicodeStrLen, Loc' +
        'aleStr, LocaleStrLen, Err);'
      ''
      
        '    if ((UnicodeStrLen > 0) and (Err > 0)) or (Err = 1000) then ' +
        'Result := 0;'
      '  end;'
      'end;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IF not Defined(USE_LIBICU) or Defined(LINUX)}'
      '{$IFDEF LINUX}'
      
        'function UnicodeFromLocaleCharsICONV(const LocaleName: _AnsiStr;' +
        ' Flags: Cardinal;'
      
        '  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWide' +
        'Char;'
      '  UnicodeStrLen: Integer): Integer; overload;'
      '{$ELSE !LINUX}'
      
        'function UnicodeFromLocaleChars(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWide' +
        'Char;'
      '  UnicodeStrLen: Integer): Integer; overload;'
      '{$ENDIF LINUX}'
      'var'
      '  LContext: iconv_t;'
      '  InvalidCharFound: Boolean;'
      '  LCalcSizeBuf: array of Byte;'
      '  LDestLen, LSourceLen, LSize, LZero: size_t;'
      '  LSourcePtr, LDestPtr, LNil, LastInvalidChar: Pointer;'
      '  LastError: Integer;'
      'begin'
      '  Result := 0;'
      
        '  LContext := iconv_open('#39'UTF-16LE'#39', _PAnsiChr(LocaleName)); // ' +
        'do not localize'
      '  if LContext <> iconv_t(-1) then'
      '    try'
      
        '      // When LocaleStrLen is -1 treat LocaleStr as a null termi' +
        'nated string'
      '      if LocaleStrLen = -1 then'
      
        '        LocaleStrLen := Length(LocaleStr) + 1; // include termin' +
        'ating null'
      ''
      
        '      // UnicodeStrLen = 0 is a request to calculate the require' +
        'd buffer size,'
      '      // use a local destination buffer for the conversion.'
      '      if UnicodeStrLen = 0 then'
      '      begin'
      '        SetLength(LCalcSizeBuf, 1024);'
      '        LDestLen := Length(LCalcSizeBuf);'
      '        LDestPtr := Pointer(@LCalcSizeBuf[0]);'
      '      end'
      '      else'
      '      begin'
      '        LDestLen := UnicodeStrLen * SizeOf(WideChar);'
      '        LDestPtr := Pointer(UnicodeStr);'
      '      end;'
      ''
      '      LSourceLen := LocaleStrLen;'
      '      LSourcePtr := Pointer(LocaleStr);'
      ''
      '      LSize := 0;'
      '      LastInvalidChar := nil;'
      '      InvalidCharFound := False;'
      ''
      '      while True do'
      '      begin'
      
        '        Result := iconv(LContext, @LSourcePtr, @LSourceLen, @LDe' +
        'stPtr, @LDestLen);'
      '        if Result <> -1 then'
      '          Break'
      '        else'
      '        begin'
      '          LastError := GetLastError;'
      '          if (LastError = E2BIG) or (LDestLen = 0) then'
      '          begin'
      '            if UnicodeStrLen = 0 then'
      '            begin'
      
        '              // Save converted buffer size and reset to beginni' +
        'ng of local buffer'
      
        '              Inc(LSize, size_t(Length(LCalcSizeBuf)) - LDestLen' +
        ');'
      '              LDestPtr := Pointer(@LCalcSizeBuf[0]);'
      '              LDestLen := Length(LCalcSizeBuf);'
      '            end'
      '            else'
      '            begin'
      '              // Return a length of Original'
      '              LDestLen := UnicodeStrLen * SizeOf(WideChar);'
      '              Break;'
      '            end;'
      '          end;'
      '          case GetLastError of'
      '            E2BIG: // Insufficient destination buffer'
      '              ;'
      
        '            EILSEQ: // Invalid character sequence in source stri' +
        'ng'
      '              if LocaleName = '#39'UTF-7'#39' then // do not localize'
      '              begin'
      
        '                // Special case for emulating MultiByteToWideCha' +
        'r with UTF-7.'
      
        '                // This does not produce an exact match due to d' +
        'ifferences in the'
      '                // decoders, but it preserves similar behaviour.'
      
        '                if (Flags and MB_ERR_INVALID_CHARS = MB_ERR_INVA' +
        'LID_CHARS) then'
      '                  Exit(0);'
      '                Inc(PByte(LSourcePtr), SizeOf(_AnsiChr));'
      '                Dec(LSourceLen, SizeOf(_AnsiChr));'
      '                // Reset state of context'
      '                LNil := nil;'
      '                LZero := 0;'
      '                iconv(LContext, @LNil, @LZero, @LNil, @LZero);'
      '              end'
      '              else'
      '              begin'
      
        '                // Increment pointers and insert #$FFFD into the' +
        ' destination'
      
        '                // string if the source is a UTF-8 string. Only ' +
        'insert #$FFFD'
      '                // once per invalid UTF-8 character.'
      '                if LSourcePtr <> LastInvalidChar then'
      '                begin'
      '                  if (UnicodeStrLen <> 0) then'
      '                  begin'
      
        '                    if LocaleName = '#39'UTF-8'#39' then // do not local' +
        'ize'
      
        '                      PWideChar(LDestPtr)^ := #$FFFD // Invalid ' +
        'UTF-8 char'
      
        '                    else if LocaleName = '#39'ASCII'#39' then // do not ' +
        'localize'
      
        '                      PWord(LDestPtr)^ := Word(PByte(LSourcePtr)' +
        '^) and $007F // emulate CP-20127'
      '                    else'
      
        '                      PWord(LDestPtr)^ := Word(PByte(LSourcePtr)' +
        '^);'
      '                  end;'
      '                  Inc(PByte(LDestPtr), SizeOf(WideChar));'
      '                  Dec(LDestLen, SizeOf(WideChar));'
      '                end;'
      '                Inc(PByte(LSourcePtr), SizeOf(_AnsiChr));'
      '                Dec(LSourceLen, SizeOf(_AnsiChr));'
      '                LastInvalidChar := LSourcePtr;'
      '                InvalidCharFound := True;'
      '              end;'
      '          else'
      '            Exit(0); // Return a length of 0'
      '          end;'
      '        end;'
      '      end;'
      ''
      
        '      if InvalidCharFound and (Flags and MB_ERR_INVALID_CHARS = ' +
        'MB_ERR_INVALID_CHARS) then'
      
        '        Exit(0); // Return 0 if an invalid character was encount' +
        'ered'
      ''
      '      if UnicodeStrLen = 0 then'
      
        '        Result := (LSize + size_t(Length(LCalcSizeBuf)) - LDestL' +
        'en) div SizeOf(WideChar)'
      '      else'
      '        Result := size_t(UnicodeStrLen) - (LDestLen div 2);'
      '    finally'
      '      iconv_close(LContext);'
      '    end;'
      'end;'
      '{$ENDIF not Defined(USE_LIBICU) or Defined(LINUX)}'
      ''
      '{$IFDEF LINUX}'
      
        'function UnicodeFromLocaleChars(const LocaleName: _AnsiStr; Flag' +
        's: Cardinal;'
      
        '  LocaleStr: _PAnsiChr; LocaleStrLen: Integer; UnicodeStr: PWide' +
        'Char;'
      '  UnicodeStrLen: Integer): Integer; overload;'
      'begin'
      '  if IsICUAvailable then'
      
        '    Result := UnicodeFromLocaleCharsICU(LocaleName, Flags, Local' +
        'eStr, LocaleStrLen, UnicodeStr, UnicodeStrLen)'
      '  else'
      
        '    Result := UnicodeFromLocaleCharsICONV(LocaleName, Flags, Loc' +
        'aleStr, LocaleStrLen, UnicodeStr, UnicodeStrLen);'
      'end;'
      '{$ENDIF LINUX}'
      '{$ENDIF POSIX}'
      ''
      'procedure SetMultiByteConversionCodePage(CodePage: Integer);'
      'begin'
      '  DefaultSystemCodePage := CodePage;'
      'end;'
      ''
      'function GetCPUCount: Integer;'
      '{$IFDEF MSWINDOWS}'
      'var'
      '  SysInfo: TSystemInfo;'
      'begin'
      '  GetSystemInfo(SysInfo);'
      '  Result := SysInfo.dwNumberOfProcessors;'
      'end;'
      '{$ENDIF}'
      '{$IFDEF POSIX}'
      'begin'
      '  Result := sysconf(_SC_NPROCESSORS_ONLN);'
      'end;'
      '{$ENDIF}'
      ''
      '{$IFDEF MSWINDOWS}'
      'procedure SetUtf8CompareLocale;'
      'var'
      '  OSVersion: Cardinal;'
      '  MajorVersion: Cardinal;'
      '  MinorVersion: Cardinal;'
      'begin'
      '  OSVersion := GetVersion;'
      '  MajorVersion := OSVersion and $000000FF;'
      '  MinorVersion := (OSVersion and $0000FF00) shr 8;'
      ''
      '  if ((MajorVersion = 5) and (MinorVersion >= 1)) or'
      '     (MajorVersion > 5) then'
      '    UTF8CompareLocale := LOCALE_INVARIANT'
      '  else'
      '    UTF8CompareLocale := $0409;'
      'end;'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF POSIX}'
      '{$IF defined(USE_LIBICU)}'
      'var'
      '  InternalUTF8CompareCollator: PUCollator = nil;'
      '  InternalUTF8CompareLocale: MarshaledAString = nil;'
      ''
      'function UTF8CompareCollator: Pointer;'
      'begin'
      '  Result := InternalUTF8CompareCollator;'
      'end;'
      ''
      'function UTF8CompareLocale: MarshaledAString;'
      'begin'
      '  Result := InternalUTF8CompareLocale;'
      'end;'
      '{$ELSE}'
      'var'
      '  InternalUTF8CompareLocale: Pointer = nil;'
      ''
      'function UTF8CompareLocale: Pointer;'
      'begin'
      '  Result := InternalUTF8CompareLocale;'
      'end;'
      '{$ENDIF defined(USE_LIBICU)}'
      ''
      '{$IF not defined(USE_LIBICU) or defined(LINUX)}'
      'var'
      '  InternalUTF8CompareLocaleName: MarshaledAString = nil;'
      ''
      'function UTF8CompareLocaleName: MarshaledAString;'
      'begin'
      '  Result := InternalUTF8CompareLocaleName;'
      'end;'
      '{$ENDIF not defined(USE_LIBICU) or defined(LINUX)}'
      ''
      
        'function SetUTF8CompareLocale(const LocaleName: string): Boolean' +
        ';'
      'var'
      '  LNewLocale, OldLocale: Pointer;'
      '{$IF defined(USE_LIBICU)}'
      '  NewCollator, OldCollator: PUCollator;'
      '  LocaleLength: Integer;'
      '  ErrorCode: UErrorCode;'
      '  LNewLocaleWrapper: TPtrWrapper;'
      '{$IFDEF LINUX}'
      '  LNewLocaleName, OldLocaleName: MarshaledAString;'
      '{$ENDIF LINUX}'
      '{$ELSEIF defined(MACOS)}'
      '  StringRef, LocaleIdent: CFStringRef;'
      '{$ELSEIF defined(LINUX)}'
      '  LocaleLength: Integer;'
      '  LNewLocaleWrapper: TPtrWrapper;'
      '  LNewLocaleName, OldLocaleName: MarshaledAString;'
      '{$ENDIF}'
      ''
      '{$IF Defined(USE_LIBICU)}'
      '  procedure GetNewLocalICU;'
      '  begin'
      '    if LocaleName = '#39#39' then'
      
        '      LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(GetPosixLo' +
        'caleName)'
      '    else'
      
        '      LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(LocaleName' +
        ');'
      
        '    LocaleLength := Length(MarshaledAString(LNewLocaleWrapper.To' +
        'Pointer))+1;'
      '    LNewLocale := SysAllocMem(LocaleLength);'
      
        '    System.Move(LNewLocaleWrapper.ToPointer^, LNewLocale^, Local' +
        'eLength);'
      '    TMarshal.FreeMem(LNewLocaleWrapper);'
      ''
      '    // Create the Cached Collator for the New Locale'
      '    ErrorCode := 0;'
      '    OldCollator := nil;'
      
        '    NewCollator := ucol_open(MarshaledAString(LNewLocale), Error' +
        'Code);'
      '    if ErrorCode > 0 then'
      '    begin'
      
        '      // If we cannot create a collator, create a default one fr' +
        'om '#39'en_US'#39
      '      if NewCollator <> nil then ucol_close(NewCollator);'
      '      ErrorCode := 0;'
      
        '      NewCollator := ucol_open('#39'en_US'#39', ErrorCode); // Do not lo' +
        'calize'
      '    end;'
      '    if ErrorCode <= 0 then'
      
        '      OldCollator := AtomicExchange(InternalUTF8CompareCollator,' +
        ' NewCollator);'
      '    if OldCollator <> nil then'
      '      ucol_close(OldCollator);'
      '  end;'
      '{$ENDIF Defined(USE_LIBICU)}'
      ''
      
        '{$IF not (Defined(USE_LIBICU) or Defined(MACOS)) or Defined(LINU' +
        'X) }'
      '// POSIX version'
      '  procedure GetNewLocalPOSIX;'
      '  begin'
      '    LNewLocaleName := nil;'
      '    try'
      '      if LocaleName = '#39#39' then'
      
        '        LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(GetPosix' +
        'LocaleName)'
      '      else'
      
        '        LNewLocaleWrapper := TMarshal.AllocStringAsUtf8(LocaleNa' +
        'me);'
      
        '      LocaleLength := Length(MarshaledAString(LNewLocaleWrapper.' +
        'ToPointer))+1;'
      '      LNewLocaleName := SysAllocMem(LocaleLength);'
      
        '      System.Move(LNewLocaleWrapper.ToPointer^, LNewLocaleName^,' +
        ' LocaleLength);'
      ''
      '      LNewLocale := newlocale(LC_ALL_MASK, LNewLocaleName, nil);'
      '    finally'
      '      TMarshal.FreeMem(LNewLocaleWrapper);'
      '    end;'
      '  end;'
      
        '{$ENDIF not (Defined(USE_LIBICU) or Defined(MACOS)) or Defined(L' +
        'INUX) }'
      ''
      'begin'
      '{$IF defined(USE_LIBICU)}'
      '{$IFDEF LINUX}'
      '  LNewLocaleName := nil;'
      '  if IsICUAvailable then'
      '    GetNewLocalICU'
      '  else'
      '    GetNewLocalPOSIX;'
      '{$ELSE !LINUX}'
      '  GetNewLocalICU;'
      '{$ENDIF LINUX}'
      '{$ELSEIF defined(MACOS)}'
      '  Result := False;'
      '  LocaleIdent := CFSTR(LocaleName);'
      '  if LocaleName = '#39#39' then'
      '    LNewLocale := CFLocaleCopyCurrent'
      '  else'
      '  begin'
      '    if LocaleIdent <> nil then'
      '    try'
      
        '      StringRef := CFLocaleCreateCanonicalLocaleIdentifierFromSt' +
        'ring(nil, LocaleIdent);'
      '      if StringRef <> nil then'
      '      try'
      '        LNewLocale := CFLocaleCreate(nil, LocaleIdent);'
      '      finally'
      '        CFRelease(StringRef);'
      '      end else'
      '        Exit;'
      '    finally'
      '      CFRelease(LocaleIdent);'
      '    end else'
      '      Exit;'
      '  end;'
      '{$ELSEIF defined(POSIX)}'
      '  GetNewLocalPOSIX;'
      '{$ELSE}'
      '{$MESSAGE ERROR '#39'Unknown platform'#39'}'
      '{$ENDIF !USE_LIBICU and !MACOS}'
      ''
      '  Result := LNewLocale <> nil;'
      '  if Result then'
      '  begin'
      '{$IF defined(LINUX)}'
      '    if not IsICUAvailable then'
      '    begin'
      
        '      OldLocaleName := AtomicExchange(InternalUTF8CompareLocaleN' +
        'ame, LNewLocaleName);'
      '      if OldLocaleName <> nil then'
      '      FreeMem(OldLocaleName);'
      '    end;'
      '{$ENDIF defined(LINUX)}'
      
        '    OldLocale := AtomicExchange(InternalUTF8CompareLocale, LNewL' +
        'ocale);'
      ''
      '    if OldLocale <> nil then'
      '{$IF defined(USE_LIBICU)}'
      '      FreeMem(OldLocale);'
      '{$ELSEIF defined(MACOS)}'
      '      CFRelease(OldLocale);'
      '{$ELSE !USE_LIBICU and !MACOS}'
      '      freelocale(OldLocale);'
      '{$ENDIF !USE_LIBICU and !MACOS }'
      '  end'
      '{$IF defined(LINUX)}'
      '  else'
      '    FreeMem(LNewLocaleName);'
      '{$ENDIF defined(LINUX)}'
      'end;'
      '{$ENDIF POSIX}'
      ''
      '{ TPtrWrapper }'
      ''
      'constructor TPtrWrapper.Create(AValue: NativeInt);'
      'begin'
      '  Value := PByte(AValue);'
      'end;'
      ''
      'constructor TPtrWrapper.Create(AValue: Pointer);'
      'begin'
      '  Value := AValue;'
      'end;'
      ''
      'function TPtrWrapper.ToPointer: Pointer;'
      'begin'
      '  Result := Value;'
      'end;'
      ''
      'function TPtrWrapper.ToInteger: NativeInt;'
      'begin'
      '  Result := NativeInt(Value);'
      'end;'
      ''
      'class function TPtrWrapper.GetNilValue: TPtrWrapper;'
      'begin'
      '  Result.Value := nil;'
      'end;'
      ''
      
        'class operator TPtrWrapper.Equal(Left, Right: TPtrWrapper): Bool' +
        'ean;'
      'begin'
      '  Result := Left.Value = Right.Value;'
      'end;'
      ''
      
        'class operator TPtrWrapper.NotEqual(Left, Right: TPtrWrapper): B' +
        'oolean;'
      'begin'
      '  Result := Left.Value <> Right.Value;'
      'end;'
      ''
      '{ TMarshal }'
      ''
      'constructor TMarshal.Create;'
      'begin'
      '  Error(reInvalidPtr);'
      'end;'
      ''
      
        'class function TMarshal.InString(const S: string): MarshaledStri' +
        'ng;'
      'begin'
      '  Result := MarshaledString(S);'
      'end;'
      ''
      
        'class function TMarshal.OutString(const S: string): MarshaledStr' +
        'ing;'
      'begin'
      '  Result := MarshaledString(S);'
      'end;'
      ''
      
        'class function TMarshal.InOutString(const S: string): MarshaledS' +
        'tring;'
      'begin'
      '  Result := MarshaledString(S);'
      'end;'
      ''
      'class function TMarshal.AsAnsi(const S: string): _AnsiStr;'
      'begin'
      '  Result := _AnsiStr(S);'
      'end;'
      ''
      'class function TMarshal.AsAnsi(S: PWideChar): _AnsiStr;'
      'begin'
      '  Result := _AnsiStr(S);'
      'end;'
      ''
      'class function TMarshal.AllocMem(Size: NativeInt): TPtrWrapper;'
      'begin'
      '  Result.Value := System.AllocMem(Size);'
      'end;'
      ''
      
        'class function TMarshal.ReallocMem(OldPtr: TPtrWrapper; NewSize:' +
        ' NativeInt): TPtrWrapper;'
      'begin'
      
        '  System.ReallocMem(OldPtr.Value, NewSize); // ReallocMem should' +
        ' take NativeInt not Integer'
      '  Result := OldPtr;'
      'end;'
      ''
      'class procedure TMarshal.FreeMem(Ptr: TPtrWrapper);'
      'begin'
      '  System.FreeMem(Ptr.Value);'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<Byte>; StartInde' +
        'x: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; var Dest: ' +
        'TArray<Byte>; StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<Char>; StartInde' +
        'x: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; var Dest: ' +
        'TArray<Char>; StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<Word>; StartInde' +
        'x: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; var Dest: ' +
        'TArray<Word>; StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<Shortint>; Start' +
        'Index: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; var Dest: ' +
        'TArray<Shortint>; StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<Smallint>; Start' +
        'Index: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; var Dest: ' +
        'TArray<Smallint>; StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<Integer>; StartI' +
        'ndex: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; var Dest: ' +
        'TArray<Integer>; StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<Int64>; StartInd' +
        'ex: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; var Dest: ' +
        'TArray<Int64>; StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TArray<TPtrWrapper>; St' +
        'artIndex: Integer; Dest: TPtrWrapper;'
      '  Count: Integer);'
      'begin'
      
        '  System.Move(Src[StartIndex], Dest.Value^, Count * SizeOf(Src[0' +
        ']));'
      'end;'
      ''
      
        'class procedure TMarshal.Copy(const Src: TPtrWrapper; Dest: TArr' +
        'ay<TPtrWrapper>;'
      '  StartIndex, Count: Integer);'
      'begin'
      
        '  System.Move(Src.Value^, Dest[StartIndex], Count * SizeOf(Dest[' +
        '0]));'
      'end;'
      ''
      
        'class function TMarshal.ReadByte(const Ptr: TPtrWrapper; Ofs: Na' +
        'tiveInt): Byte;'
      'begin'
      '  Result := PByte(Ptr.Value + Ofs)^;'
      'end;'
      ''
      
        'class function TMarshal.ReadInt16(const Ptr: TPtrWrapper; Ofs: N' +
        'ativeInt): Smallint;'
      'begin'
      '  Result := PSmallint(Ptr.Value + Ofs)^;'
      'end;'
      ''
      
        'class function TMarshal.ReadInt32(const Ptr: TPtrWrapper; Ofs: N' +
        'ativeInt): Integer;'
      'begin'
      '  Result := PInteger(Ptr.Value + Ofs)^;'
      'end;'
      ''
      
        'class function TMarshal.ReadInt64(const Ptr: TPtrWrapper; Ofs: N' +
        'ativeInt): Int64;'
      'begin'
      '  Result := PInt64(Ptr.Value + Ofs)^;'
      'end;'
      ''
      
        'class function TMarshal.ReadPtr(const Ptr: TPtrWrapper; Ofs: Nat' +
        'iveInt): TPtrWrapper;'
      'begin'
      '  Result.Value := PPointer(Ptr.Value + Ofs)^;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteByte(const Ptr: TPtrWrapper; Value' +
        ': Byte);'
      'begin'
      '  PByte(Ptr.Value)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteByte(const Ptr: TPtrWrapper; Ofs: ' +
        'NativeInt; Value: Byte);'
      'begin'
      '  PByte(Ptr.Value + Ofs)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteInt16(const Ptr: TPtrWrapper; Valu' +
        'e: Smallint);'
      'begin'
      '  PSmallint(Ptr.Value)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteInt16(const Ptr: TPtrWrapper; Ofs:' +
        ' NativeInt; Value: Smallint);'
      'begin'
      '  PSmallint(Ptr.Value + Ofs)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteInt32(const Ptr: TPtrWrapper; Valu' +
        'e: Integer);'
      'begin'
      '  PInteger(Ptr.Value)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteInt32(const Ptr: TPtrWrapper; Ofs:' +
        ' NativeInt; Value: Integer);'
      'begin'
      '  PInteger(Ptr.Value + Ofs)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteInt64(const Ptr: TPtrWrapper; Valu' +
        'e: Int64);'
      'begin'
      '  PInt64(Ptr.Value)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WriteInt64(const Ptr: TPtrWrapper; Ofs:' +
        ' NativeInt; Value: Int64);'
      'begin'
      '  PInt64(Ptr.Value + Ofs)^ := Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WritePtr(const Ptr, Value: TPtrWrapper)' +
        ';'
      'begin'
      '  PPointer(Ptr.Value)^ := Value.Value;'
      'end;'
      ''
      
        'class procedure TMarshal.WritePtr(const Ptr: TPtrWrapper; Ofs: N' +
        'ativeInt; const Value: TPtrWrapper);'
      'begin'
      '  PPointer(Ptr.Value + Ofs)^ := Value.Value;'
      'end;'
      ''
      
        'class procedure TMarshal.Move(const Src, Dest: TPtrWrapper; Coun' +
        't: NativeInt);'
      'begin'
      '  System.Move(Src.Value^, Dest.Value^, Count);'
      'end;'
      ''
      
        'class function TMarshal.FixArray<T>(const Arr: TArray<T>): TPtrW' +
        'rapper;'
      'type'
      '  TArray = TArray<T>;'
      '  PArray = ^TArray;'
      'begin'
      '  // Add ref'
      '  Result.Value := nil;'
      '  PArray(@Result.Value)^ := Arr;'
      'end;'
      ''
      'class procedure TMarshal.UnfixArray<T>(ArrPtr: TPtrWrapper);'
      'type'
      '  TArray = TArray<T>;'
      '  PArray = ^TArray;'
      'begin'
      '  // Release ref'
      '  PArray(@ArrPtr.Value)^ := nil;'
      'end;'
      ''
      'const'
      '  NullStr: array[0..0] of Char = ( #0 );'
      ''
      'class function TMarshal.FixString(var Str: string): TPtrWrapper;'
      'begin'
      
        '  // For strings with refcount = 1, we avoid copying but we will' +
        ' copy in all'
      
        '  // other cases. This is different semantics to existing Delphi' +
        ' PChar() cast,'
      '  // but it is more robust - reduces accidental sharing.'
      '  UniqueString(Str);'
      '  // Add reference'
      '  Result.Value := nil;'
      '  PString(@Result.Value)^ := Str;'
      '  // Emulate PChar() cast semantics on empty string.'
      '  if Result.Value = nil then'
      '    Result.Value := @NullStr;'
      'end;'
      ''
      
        'class function TMarshal.UnsafeFixString(const Str: string): TPtr' +
        'Wrapper;'
      'begin'
      '  // Not caring about accidental sharing.'
      '  PString(@Result.Value)^ := Str;'
      '  // Emulate PChar() cast semantics on empty string.'
      '  if Result.Value = nil then'
      '    Result.Value := @NullStr;'
      'end;'
      ''
      'class procedure TMarshal.UnfixString(Ptr: TPtrWrapper);'
      'begin'
      '  if Ptr.Value <> @NullStr then'
      '    PString(@Ptr.Value)^ := '#39#39';'
      'end;'
      ''
      'class function TMarshal.UnsafeAddrOf(var Value): TPtrWrapper;'
      'begin'
      '  Result.Value := @Value;'
      'end;'
      ''
      
        'class function TMarshal.AllocStringAsAnsi(const Str: string): TP' +
        'trWrapper;'
      'begin'
      '  Result := AllocStringAsAnsi(Str, DefaultSystemCodePage);'
      'end;'
      ''
      
        'class function TMarshal.AllocStringAsAnsi(const Str: string; Cod' +
        'ePage: Word): TPtrWrapper;'
      'var'
      '  len: Integer;'
      'begin'
      
        '  len := LocaleCharsFromUnicode(CodePage, 0, PWideChar(Str), Len' +
        'gth(Str) + 1, nil, 0, nil, nil);'
      '  if len > 0 then'
      '  begin'
      '    Result := AllocMem(len);'
      
        '    LocaleCharsFromUnicode(CodePage, 0, PWideChar(Str), Length(S' +
        'tr) + 1, Pointer(Result.Value),'
      '      len, nil, nil);'
      '  end'
      '  else'
      '  begin'
      '    Result.Value := nil;'
      '  end;'
      'end;'
      ''
      
        'class function TMarshal.AllocStringAsUnicode(const Str: string):' +
        ' TPtrWrapper;'
      'begin'
      '  if Length(Str) > 0 then'
      '  begin'
      '    Result := AllocMem((Length(Str) + 1) * SizeOf(WideChar));'
      
        '    System.Move(PWideChar(Str)^, Result.Value^, (Length(Str) + 1' +
        ') * SizeOf(WideChar));'
      '  end'
      '  else'
      '  begin'
      '    Result.Value := nil;'
      '  end;'
      'end;'
      ''
      
        'class function TMarshal.AllocStringAsAnsi(S: PWideChar): TPtrWra' +
        'pper;'
      'begin'
      '  Result := AllocStringAsAnsi(S, DefaultSystemCodePage);'
      'end;'
      ''
      
        'class function TMarshal.AllocStringAsAnsi(S: PWideChar; CodePage' +
        ': Word): TPtrWrapper;'
      'var'
      '  srcLen, len: Integer;'
      'begin'
      '  srcLen := _PWCharLen(S) + 1;'
      
        '  len := LocaleCharsFromUnicode(CodePage, 0, S, srcLen, nil, 0, ' +
        'nil, nil);'
      '  if len > 0 then'
      '  begin'
      '    Result := AllocMem(len);'
      
        '    LocaleCharsFromUnicode(CodePage, 0, S, srcLen, Pointer(Resul' +
        't.Value), len, nil, nil);'
      '  end'
      '  else'
      '  begin'
      '    Result.Value := nil;'
      '  end;'
      'end;'
      ''
      
        'class function TMarshal.AllocStringAsUtf8(const Str: string): TP' +
        'trWrapper;'
      'begin'
      '  Result := AllocStringAsAnsi(Str, CP_UTF8);'
      'end;'
      ''
      
        'class function TMarshal.AllocStringAsUtf8(S: PWideChar): TPtrWra' +
        'pper;'
      'begin'
      '  Result := AllocStringAsAnsi(S, CP_UTF8);'
      'end;'
      ''
      
        'class function TMarshal.ReadStringAsAnsi(Ptr: TPtrWrapper; Len: ' +
        'Integer): string;'
      'begin'
      '  Result := ReadStringAsAnsi(DefaultSystemCodePage, Ptr, Len);'
      'end;'
      ''
      
        'class function TMarshal.ReadStringAsAnsi(CodePage: Word; Ptr: TP' +
        'trWrapper; Len: Integer): string;'
      'var'
      '  dstLen: Integer;'
      'begin'
      '  if Len < 0 then'
      '    if (Ptr.Value = nil) or (_PAnsiChr(Ptr.Value)^ = #0) then'
      '      Exit('#39#39')'
      '    else'
      '      Len := _PCharLen(_PAnsiChr(Ptr.Value));'
      ''
      
        '  dstLen := UnicodeFromLocaleChars(CodePage, 0, Pointer(Ptr.Valu' +
        'e), Len, nil, 0);'
      '  if dstLen > 0 then'
      '  begin'
      '    SetLength(Result, dstLen);'
      
        '    UnicodeFromLocaleChars(CodePage, 0, Pointer(Ptr.Value), Len,' +
        ' Pointer(Result), dstLen);'
      '  end'
      '  else'
      '  begin'
      '    Result := '#39#39';'
      '  end;'
      'end;'
      ''
      
        'class function TMarshal.ReadStringAsUnicode(Ptr: TPtrWrapper; Le' +
        'n: Integer): string;'
      'begin'
      '  if Len < 0 then'
      '    Len := _PWCharLen(PWideChar(Ptr.Value));'
      ''
      '  SetLength(Result, Len);'
      '  if Len > 0 then'
      
        '    System.Move(Ptr.Value^, Pointer(Result)^, Len * SizeOf(Resul' +
        't[Low(string)]));'
      'end;'
      ''
      
        'class function TMarshal.ReadStringAsUtf8(Ptr: TPtrWrapper; Len: ' +
        'Integer): string;'
      'begin'
      '  Result := ReadStringAsAnsi(CP_UTF8, Ptr, Len);'
      'end;'
      ''
      
        'class function TMarshal.ReadStringAsAnsiUpTo(CodePage: Word; Ptr' +
        ': TPtrWrapper;'
      '  MaxLen: Integer): string;'
      'var'
      '  p: PByte;'
      'begin'
      '  p := PByte(Ptr);'
      '  while (MaxLen > 0) and (p^ <> 0) do'
      '  begin'
      '    Dec(MaxLen);'
      '    Inc(p);'
      '  end;'
      '  Result := ReadStringAsAnsi(CodePage, Ptr, p - PByte(Ptr));'
      'end;'
      ''
      
        'class function TMarshal.ReadStringAsUnicodeUpTo(Ptr: TPtrWrapper' +
        '; MaxLen: Integer): string;'
      'var'
      '  p: PWideChar;'
      'begin'
      '  p := PWideChar(Ptr);'
      '  while (MaxLen > 0) and (p^ <> #0) do'
      '  begin'
      '    Dec(MaxLen);'
      '    Inc(p);'
      '  end;'
      '  Result := ReadStringAsUnicode(Ptr, p - PWideChar(Ptr));'
      'end;'
      ''
      
        'class function TMarshal.ReadStringAsUtf8UpTo(Ptr: TPtrWrapper; M' +
        'axLen: Integer): string;'
      'begin'
      '  Result := ReadStringAsAnsiUpTo(CP_UTF8, Ptr, MaxLen);'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; con' +
        'st Value: string;'
      '  MaxCharsIncNull: Integer);'
      'begin'
      
        '  WriteStringAsAnsi(Ptr, Value, MaxCharsIncNull, DefaultSystemCo' +
        'dePage);'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; con' +
        'st Value: string;'
      '  MaxCharsIncNull: Integer; CodePage: Word);'
      'begin'
      '  if MaxCharsIncNull < 0 then'
      
        '    MaxCharsIncNull := LocaleCharsFromUnicode(CodePage, 0, PWide' +
        'Char(Value), Length(Value) + 1,'
      '      nil, 0, nil, nil);'
      
        '  LocaleCharsFromUnicode(CodePage, 0, PWideChar(Value), Length(V' +
        'alue) + 1, Pointer(Ptr.Value),'
      '    MaxCharsIncNull, nil, nil);'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs' +
        ': NativeInt; const Value: string;'
      '  MaxCharsIncNull: Integer);'
      'begin'
      
        '  WriteStringAsAnsi(Ptr, Ofs, Value, MaxCharsIncNull, DefaultSys' +
        'temCodePage);'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsAnsi(Ptr: TPtrWrapper; Ofs' +
        ': NativeInt; const Value: string;'
      '  MaxCharsIncNull: Integer; CodePage: Word);'
      'begin'
      '  if MaxCharsIncNull < 0 then'
      
        '    MaxCharsIncNull := LocaleCharsFromUnicode(CodePage, 0, PWide' +
        'Char(Value), Length(Value) + 1,'
      '      nil, 0, nil, nil);'
      
        '  LocaleCharsFromUnicode(CodePage, 0, PWideChar(Value), Length(V' +
        'alue) + 1,'
      '    Pointer(Ptr.Value + Ofs), MaxCharsIncNull, nil, nil);'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsUnicode(Ptr: TPtrWrapper; ' +
        'const Value: string;'
      '  MaxCharsIncNull: Integer);'
      'begin'
      '  if MaxCharsIncNull < 0 then'
      '    MaxCharsIncNull := Length(Value) + 1;'
      
        '  System.Move(PWideChar(Value)^, Pointer(Ptr.Value)^, MaxCharsIn' +
        'cNull * SizeOf(WideChar));'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsUnicode(Ptr: TPtrWrapper; ' +
        'Ofs: NativeInt;'
      '  const Value: string; MaxCharsIncNull: Integer);'
      'begin'
      '  if MaxCharsIncNull < 0 then'
      '    MaxCharsIncNull := Length(Value) + 1;'
      
        '  System.Move(PWideChar(Value)^, Pointer(Ptr.Value + Ofs)^, MaxC' +
        'harsIncNull * SizeOf(WideChar));'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsUtf8(Ptr: TPtrWrapper; con' +
        'st Value: string;'
      '  MaxCharsIncNull: Integer);'
      'begin'
      '  WriteStringAsAnsi(Ptr, Value, MaxCharsIncNull, CP_UTF8);'
      'end;'
      ''
      
        'class procedure TMarshal.WriteStringAsUtf8(Ptr: TPtrWrapper; Ofs' +
        ': NativeInt; const Value: string;'
      '  MaxCharsIncNull: Integer);'
      'begin'
      '  WriteStringAsAnsi(Ptr, Ofs, Value, MaxCharsIncNull, CP_UTF8);'
      'end;'
      ''
      '{$IF defined(LINUX) or defined(MACOS)}'
      'procedure SetDefaultPosixLocaleName(const ALocaleName: string);'
      'var'
      '  I, L: Integer;'
      '  LTempLocale: MarshaledAString;'
      'begin'
      '  L := Length(ALocaleName);'
      '  LTempLocale := GetMemory(L + 1);'
      '  for I := 0 to L-1 do'
      '    LTempLocale[I] := _AnsiChr(ALocaleName[I + Low(string)]);'
      '  LTempLocale[L] := #0;'
      '  setlocale(LC_ALL, LTempLocale);'
      '  FreeMemory(LTempLocale);'
      'end;'
      '{$ENDIF defined(LINUX) or defined(MACOS)}'
      ''
      'initialization'
      '{$IF Defined(CPUX86) or Defined(CPUX64)}'
      '  InitializeCPUID;'
      '{$ENDIF}'
      '{$IF defined(WIN32) or defined(WIN64)}'
      '  InitializeERMSBThreshold;'
      '{$ENDIF}'
      '{$IF defined(WIN32) or defined(WIN64)}'
      '  InitializeAVX;'
      '{$ENDIF}'
      '{$IF defined(MSWINDOWS) or defined(OSX32)}'
      '  InitializeMemoryManager;'
      '{$ENDIF}'
      '{$IFDEF MSWINDOWS}'
      '  SetThreadLocale(LOCALE_USER_DEFAULT);'
      '  InitializeLocaleData;'
      '{$ENDIF}'
      ''
      '{$IF defined(LINUX) or defined(MACOS)}'
      
        '  // POSIX Locale is always present. Set it to initialize proper' +
        'ly and then try with system configured one.'
      '  SetDefaultPosixLocaleName('#39'POSIX'#39');'
      '  SetDefaultPosixLocaleName(GetPosixLocaleName);'
      '{$ENDIF}'
      ''
      '  FileMode := 2;'
      ''
      '{$IFDEF MSWINDOWS}'
      '  RaiseExceptionProc := @RaiseException;'
      '  RTLUnwindProc := @RTLUnwind;'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF MSWINDOWS}'
      '  Test8086 := 2;'
      '{$ENDIF MSWINDOWS}'
      '{$IFDEF POSIX}'
      '  // Default File Access Rights for Posix Platforms.'
      
        '  FileAccessRights := S_IRUSR or S_IWUSR or S_IRGRP or S_IWGRP o' +
        'r S_IROTH or S_IWOTH;'
      '{$ENDIF POSIX}'
      '{$IFDEF LINUX}'
      '{$IF defined(CPUX86) or defined(CPUX64)}'
      '  Test8086 := GetCPUType;'
      '{$ENDIF defined(CPUX86) or defined(CPUX64)}'
      '  IsConsole := True;'
      '  {$IF defined(LINUX_OLD_RESOURCES)}'
      '  FindResourceCache.ModuleHandle := NativeUInt(NativeInt(-1));'
      '  {$ENDIF}'
      '  ReserveZeroPage;'
      '{$ENDIF LINUX}'
      '{$IFDEF MACOS}'
      '{$IF defined(CPUX86) or defined(CPUX64)}'
      '  Test8086 := 2;'
      '{$ENDIF defined(CPUX86) or defined(CPUX64)}'
      '  IsConsole := True;'
      '//  FindResourceCache.ModuleHandle := NativeUInt(NativeInt(-1));'
      '{$ENDIF MACOS}'
      '  CPUCount := GetCPUCount;'
      '  DispCallByIDProc := @_DispCallByIDError;'
      ''
      '{$IFDEF LINUX64}'
      '  _InitializeThreadInitProc;'
      '{$ENDIF LINUX64}'
      '  _InitializeControlWord;'
      '  _FpuInit();'
      ''
      '  TTextRec(Input).Mode := fmClosed;'
      '  TTextRec(Output).Mode := fmClosed;'
      '  TTextRec(ErrOutput).Mode := fmClosed;'
      ''
      '{$IFDEF MSWINDOWS}'
      '  CmdLine := GetCommandLine;'
      '  CmdShow := GetCmdShow;'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF USE_LIBICU}'
      '  InitICU;'
      '  LastLeadCodePage := 0;'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IFDEF LINUX}'
      '  DefaultSystemCodePage := CP_UTF8;'
      '{$ELSE !LINUX}'
      '  DefaultSystemCodePage := GetACP;'
      '{$ENDIF LINUX}'
      
        '  DefaultUnicodeCodePage := CP_UTF16; // UTF16 - Do not pass to ' +
        'MultiByteToWideChar or WideCharToMultiByte'
      '  MainThreadID := GetCurrentThreadID;'
      ''
      '{$IF defined(MSWINDOWS)}'
      '  SetUtf8CompareLocale;'
      '{$ELSEIF defined(POSIX)}'
      
        '  // Ensure that we at least have a valid compare locale. Enviro' +
        'nment variable can be misconfigured...'
      '  SetUTF8CompareLocale('#39'POSIX'#39');  // POSIX locale;'
      
        '  SetUTF8CompareLocale(GetPosixLocaleName);  // system default l' +
        'ocale;'
      '{$ENDIF}'
      ''
      'finalization'
      '  Close(Input);'
      '  Close(Output);'
      '  Close(ErrOutput);'
      '{$IFDEF LINUX}'
      '  ReleaseZeroPage;'
      '{$ENDIF LINUX}'
      ''
      '{$IFDEF POSIX}'
      '{$IF defined(USE_LIBICU)}'
      ''
      
        '{$IFDEF LINUX}                                                  ' +
        '      '
      '  if InternalUTF8CompareCollator <> nil then'
      '    if IsICUAvailable then'
      '      ucol_close(InternalUTF8CompareCollator);'
      '{$ELSE !LINUX}'
      '  if InternalUTF8CompareCollator <> nil then'
      '    ucol_close(InternalUTF8CompareCollator);'
      '{$ENDIF LINUX}'
      '  if InternalUTF8CompareLocale <> nil then'
      '    SysFreeMem(InternalUTF8CompareLocale);'
      '  InternalUTF8CompareCollator := nil;'
      '  InternalUTF8CompareLocale := nil;'
      '{$ELSE}'
      '  if InternalUTF8CompareLocale <> nil then'
      '    freelocale(InternalUTF8CompareLocale);'
      '  if InternalUTF8CompareLocaleName <> nil then'
      '    SysFreeMem(InternalUTF8CompareLocaleName);'
      '  InternalUTF8CompareLocale := nil;'
      '  InternalUTF8CompareLocaleName := nil;'
      '{$ENDIF}'
      '{$ENDIF}'
      ''
      '{$IFDEF MSWINDOWS}'
      '  FinalizeLocaleDate;'
      '  if PreferredLanguagesOverride <> nil then'
      '    SysFreeMem(PreferredLanguagesOverride);'
      '{$ENDIF MSWINDOWS}'
      ''
      '{$IFDEF USE_LIBICU}'
      '  if IsICUAvailable then'
      '    ReleaseICUThreadResources;'
      '  LibICUSuffix := '#39#39';'
      '{$ENDIF USE_LIBICU}'
      ''
      '{$IFDEF WEAKREF}'
      '  InstHashMap.Finalize;'
      '{$ENDIF}'
      ''
      '{$IF defined(MSWINDOWS) or defined(OSX32)}'
      
        '  {Uninitialize the default memory manager, and free all memory ' +
        'allocated by'
      '   this memory manager.}'
      '  FinalizeMemoryManager;'
      '{$ENDIF}'
      'end.')
    StyledSettings = [Style]
    TextSettings.Font.Family = 'Consolas'
    TextSettings.Font.Size = 14.000000000000000000
    TextSettings.FontColor = claWhitesmoke
    OnChangeTracking = Memo1ChangeTracking
    Align = Client
    Size.Width = 640.000000000000000000
    Size.Height = 480.000000000000000000
    Size.PlatformDefault = False
    StyleLookup = 'memostyle_clear'
    TabOrder = 0
    OnPaint = Memo1Paint
    Viewport.Width = 587.000000000000000000
    Viewport.Height = 472.000000000000000000
  end
  object StyleBook: TStyleBook
    Styles = <
      item
        ResourcesBin = {
          464D585F5354594C4520322E35010613627574746F6E7374796C655F6E657763
          686174036F0506156C697374626F786974656D7374796C655F63686174038B13
          06106D656D6F7374796C655F6E6F726D616C03300A0615627574746F6E737479
          6C655F636C6561726D696E69035B0306126C697374626F787374796C655F636C
          65617203EE050613627574746F6E7374796C655F7072696D617279034C02060F
          656469747374796C655F636C65617203D40406157363726F6C6C626172626F74
          746F6D627574746F6E03700206147363726F6C6C62617268747261636B737479
          6C6503260106137363726F6C6C6261726C656674627574746F6E037A02061473
          63726F6C6C6261727269676874627574746F6E036F02060E7363726F6C6C6261
          727374796C6503D90206127363726F6C6C626172746F70627574746F6E037902
          06147363726F6C6C62617276747261636B7374796C650343010619736D616C6C
          7363726F6C6C62617268747261636B7374796C6503AD010613736D616C6C7363
          726F6C6C6261727374796C650349020619736D616C6C7363726F6C6C62617276
          747261636B7374796C6503AD01060A7468756D627374796C65031502060A7472
          61636B7374796C65030C02060E7363726F6C6C626F787374796C6503CF070610
          627574746F6E7374796C655F6D656E750334050613627574746F6E7374796C65
          5F636F6E6669726D033703060E6D656D6F7374796C655F636F646503E5080611
          627574746F6E7374796C655F636C656172024E060D747261636B626172737479
          6C65030D07060D7468756D626261727374796C650337010613627574746F6E73
          74796C655F77656C636F6D650313040611627574746F6E7374796C655F726574
          7279032409060B636F6D626F5F7374796C6503E906060D64726F70646F776E70
          616E656C03AD00060C706F706F7665727374796C65033E02060C6C697374626F
          787374796C65031E0706106C697374626F786974656D7374796C65035115060D
          6D656E756974656D7374796C6503C00F06146D656E756974656D7374796C655F
          627574746F6E03DA09060D6D656E75766965777374796C6503960206126D656E
          75736570617261746F727374796C6503920006176C65667473656C656374696F
          6E706F696E747374796C65030A020618726967687473656C656374696F6E706F
          696E747374796C650311020611627574746F6E5F7363726F6C6C646F776E038F
          04060B7377697463687374796C65034401061A627574746F6E7374796C655F63
          6C6561726D696E695F6C656674035B03061B627574746F6E7374796C655F636C
          6561726D696E695F7269676874035E03060F6D656D6F7374796C655F636C6561
          7203D2070610627574746F6E7374796C655F69636F6E035E0300545046300754
          4C61796F757400095374796C654E616D650613627574746F6E7374796C655F6E
          65776368617405416C69676E070643656E7465720C50616464696E672E4C6566
          740500000000000000C002400B50616464696E672E546F700500000000000000
          C002400D50616464696E672E52696768740500000000000000C002400E506164
          64696E672E426F74746F6D0500000000000000C002400A53697A652E57696474
          680500000000000000F406400B53697A652E4865696768740500000000000000
          B804401453697A652E506C6174666F726D44656661756C74080756697369626C
          6508085461624F72646572020E000A5452656374616E676C6500095374796C65
          4E616D65060F52656374616E676C65315374796C6505416C69676E0708436F6E
          74656E74730A46696C6C2E436F6C6F7207097830304646464646460748697454
          657374080A53697A652E57696474680500000000000000F406400B53697A652E
          4865696768740500000000000000B804401453697A652E506C6174666F726D44
          656661756C74080C5374726F6B652E436F6C6F72070978333346464646464607
          585261646975730500000000000000C001400759526164697573050000000000
          0000C00140000F54436F6C6F72416E696D6174696F6E00095374796C654E616D
          650614436F6C6F72416E696D6174696F6E315374796C65084475726174696F6E
          050000000000CDCCCCFD3F0C50726F70657274794E616D65060A46696C6C2E43
          6F6C6F720A537461727456616C756507097830304646464646460953746F7056
          616C756507097831394646464646460754726967676572061049734D6F757365
          4F7665723D747275650E54726967676572496E7665727365061149734D6F7573
          654F7665723D66616C73650000000654476C79706800095374796C654E616D65
          060A676C7970687374796C650B4D617267696E732E546F700500000000000000
          80FFBF0D4D617267696E732E52696768740500000000000000C002400E4D6172
          67696E732E426F74746F6D050000000000000080FFBF05416C69676E07044C65
          66740A506F736974696F6E2E580500000000000000C002400A506F736974696F
          6E2E590500000000000000B002400A53697A652E576964746805000000000000
          00C003400B53697A652E4865696768740500000000000000C003401453697A65
          2E506C6174666F726D44656661756C74080A496D616765496E64657802000649
          6D616765730719466F726D4D61696E2E53564749636F6E496D6167654C697374
          000E5446696C6C52474245666665637400095374796C654E616D65061346696C
          6C524742456666656374315374796C6505436F6C6F7207097846464439443945
          330000001654427574746F6E5374796C65546578744F626A6563740009537479
          6C654E616D6506047465787405416C69676E0706436C69656E74064C6F636B65
          64090A53697A652E57696474680500000000000000B806400B53697A652E4865
          696768740500000000000000B003401453697A652E506C6174666F726D446566
          61756C7408165465787453657474696E67732E466F6E742E53697A6505000000
          00000000E00240165465787453657474696E67732E466F6E74436F6C6F720708
          636C615768697465155465787453657474696E67732E5472696D6D696E670709
          436861726163746572155465787453657474696E67732E576F72645772617008
          165465787453657474696E67732E486F727A416C69676E07074C656164696E67
          0D536861646F7756697369626C650808486F74436F6C6F720708636C61576869
          74650C466F6375736564436F6C6F720708636C6157686974650B4E6F726D616C
          436F6C6F720708636C6157686974650C50726573736564436F6C6F720708636C
          6157686974650000005450463007544C61796F757400095374796C654E616D65
          06156C697374626F786974656D7374796C655F6368617405416C69676E070643
          656E7465720C436C69704368696C6472656E090C50616464696E672E4C656674
          0500000000000000C002400B50616464696E672E546F700500000000000000C0
          02400D50616464696E672E52696768740500000000000000C002400E50616464
          696E672E426F74746F6D0500000000000000C002400A53697A652E5769647468
          0500000000000000C406400B53697A652E4865696768740500000000000000AC
          04401453697A652E506C6174666F726D44656661756C74080756697369626C65
          08085461624F726465720203000A5452656374616E676C6500095374796C654E
          616D650602626705416C69676E0708436F6E74656E74730A46696C6C2E436F6C
          6F7207097830303241324233320748697454657374080A53697A652E57696474
          680500000000000000C406400B53697A652E4865696768740500000000000000
          AC04401453697A652E506C6174666F726D44656661756C74080B5374726F6B65
          2E4B696E6407044E6F6E6507585261646975730500000000000000C001400759
          5261646975730500000000000000C00140000F54436F6C6F72416E696D617469
          6F6E00095374796C654E616D6506046F766572084475726174696F6E05000000
          00006F1283F53F0C50726F70657274794E616D65060A46696C6C2E436F6C6F72
          0A537461727456616C756507097830303241324233320953746F7056616C7565
          07097846463241324233320754726967676572062149734D6F7573654F766572
          3D747275653B497353656C65637465643D66616C73650E54726967676572496E
          7665727365062249734D6F7573654F7665723D66616C73653B497353656C6563
          7465643D66616C736500000F54436F6C6F72416E696D6174696F6E0009537479
          6C654E616D65060873656C6563746564084475726174696F6E0500000000006F
          1283F53F0C50726F70657274794E616D65060A46696C6C2E436F6C6F720A5374
          61727456616C756507097846463241324233320953746F7056616C7565070978
          46463334333534310754726967676572060F497353656C65637465643D747275
          650E54726967676572496E7665727365062249734D6F7573654F7665723D6661
          6C73653B497353656C65637465643D66616C73650000000654476C7970680009
          5374796C654E616D65060A676C7970687374796C650B4D617267696E732E546F
          7005000000000000008000400D4D617267696E732E5269676874050000000000
          0000C002400E4D617267696E732E426F74746F6D050000000000000080004005
          416C69676E07044C6566740A506F736974696F6E2E580500000000000000C002
          400A506F736974696F6E2E590500000000000000E002400A53697A652E576964
          746805000000000000008003400B53697A652E48656967687405000000000000
          00F002401453697A652E506C6174666F726D44656661756C74080A496D616765
          496E646578020106496D616765730719466F726D4D61696E2E53564749636F6E
          496D6167654C697374000E5446696C6C52474245666665637400095374796C65
          4E616D65061346696C6C524742456666656374315374796C6505436F6C6F7207
          097846464439443945330000001654427574746F6E5374796C65546578744F62
          6A65637400095374796C654E616D6506047465787405416C69676E0706436C69
          656E74064C6F636B6564090A53697A652E576964746805000000000000009D06
          400B53697A652E48656967687405000000000000009803401453697A652E506C
          6174666F726D44656661756C7408165465787453657474696E67732E466F6E74
          2E53697A650500000000000000E00240165465787453657474696E67732E466F
          6E74436F6C6F720708636C615768697465155465787453657474696E67732E54
          72696D6D696E670709436861726163746572155465787453657474696E67732E
          576F72645772617008165465787453657474696E67732E486F727A416C69676E
          07074C656164696E670D536861646F7756697369626C650808486F74436F6C6F
          720708636C6157686974650C466F6375736564436F6C6F720708636C61576869
          74650B4E6F726D616C436F6C6F720708636C6157686974650C50726573736564
          436F6C6F720708636C615768697465000007544C61796F757400095374796C65
          4E616D6506086F7665725F6C617905416C69676E070552696768740D4D617267
          696E732E52696768740500000000000000D404C00A506F736974696F6E2E5805
          00000000000000C506400A506F736974696F6E2E590500000000000000C00240
          0A53697A652E57696474680500000000000000A004400B53697A652E48656967
          687405000000000000009803401453697A652E506C6174666F726D4465666175
          6C7408085461624F726465720200000F54466C6F6174416E696D6174696F6E00
          095374796C654E616D650609656469745F6F766572084475726174696F6E0500
          000000006F1283F53F07496E7665727365090C50726F70657274794E616D6506
          0D4D617267696E732E52696768740A537461727456616C756505000000000000
          00D404C00953746F7056616C7565050000000000000000000007547269676765
          72060F497353656C65637465643D747275650E54726967676572496E76657273
          650610497353656C65637465643D66616C736500000754427574746F6E000953
          74796C654E616D65060664656C65746505416C69676E07055269676874064375
          72736F72070B637248616E64506F696E740C50616464696E672E4C6566740500
          00000000000080FF3F0B50616464696E672E546F70050000000000000080FF3F
          0D50616464696E672E5269676874050000000000000080FF3F0E50616464696E
          672E426F74746F6D050000000000000080FF3F0C4D617267696E732E4C656674
          05000000000000008002400B4D617267696E732E546F70050000000000000080
          00400E4D617267696E732E426F74746F6D05000000000000008000400A506F73
          6974696F6E2E580500000000000000C003400A506F736974696F6E2E59050000
          00000000008000400A53697A652E576964746805000000000000008003400B53
          697A652E4865696768740500000000000000F002401453697A652E506C617466
          6F726D44656661756C74080B5374796C654C6F6F6B75700611627574746F6E73
          74796C655F636C656172085461624F7264657202010005545061746800095374
          796C654E616D65060A50617468315374796C6505416C69676E0706436C69656E
          7409446174612E506174680AF004000069000000000000000000504100000000
          01000000000030410000000002000000867D1541000000000200000000000041
          33ECAB3F02000000000000410000404001000000000000410000804001000000
          000000400000804002000000BC4EB93F00008040020000000000803FAF538E40
          020000000000803F0000A040020000000000803F51ACB14002000000BA4EB93F
          0000C04002000000FFFFFF3F0000C04001000000000040400000C04001000000
          000040400000A041020000000000404051ACB14102000000BC4E99400000C041
          020000000000E0400000C04101000000000088410000C0410200000051AC9941
          0000C041020000000000A84151ACB141020000000000A8410000A04101000000
          0000A8410000C040010000000000B0410000C04002000000146BB4410000C040
          020000000000B84151ACB140020000000000B8410000A040020000000000B841
          AF538E4002000000146BB44100008040020000000000B0410000804001000000
          0000804100008040010000000000804100004040020000000000804133ECAB3F
          020000007A826A41000000000200000000005041000000000300000000005041
          0000000000000000000020410000404002000000000020415DA71C4002000000
          D8292741FFFFFF3F020000000000304100000040010000000000504100000040
          0200000029D658410000004002000000000060415EA71C400200000000006041
          0000404001000000000060410000804001000000000020410000804003000000
          000020410000404000000000000098410000A041020000000000984129D6A841
          0200000029D690410000B04102000000000088410000B041010000000000E040
          0000B041020000005EA7BC400000B041020000000000A04029D6A84102000000
          0000A0400000A041010000000000A0400000C04001000000000098410000C040
          03000000000098410000A04100000000000040410000104102000000D7293741
          000010410200000000003041D729174102000000000030410000204101000000
          00003041000090410200000000003041146B944102000000D729374100009841
          0200000000004041000098410200000028D64841000098410200000000005041
          146B944102000000000050410000904101000000000050410000204102000000
          00005041D72917410200000029D6484100001041020000000000404100001041
          0300000000004041000010410000000000007041000090410200000000007041
          146B944102000000D72977410000984102000000000080410000984102000000
          146B8441000098410200000000008841146B9441020000000000884100009041
          0100000000008841000020410200000000008841D729174102000000146B8441
          0000104102000000000080410000104102000000D72977410000104102000000
          00007041D7291741020000000000704100002041030000000000704100009041
          00000000000000410000104102000000AF53EE4000001041020000000000E040
          D7291741020000000000E04000002041010000000000E0400000904102000000
          0000E040146B944102000000AF53EE4000009841020000000000004100009841
          0200000028D60841000098410200000000001041146B94410200000000001041
          000090410100000000001041000020410200000000001041D729174102000000
          29D6084100001041020000000000004100001041030000000000004100001041
          0A46696C6C2E436F6C6F720709784646443944394533064C6F636B6564090748
          697454657374080A53697A652E57696474680500000000000000E002400B5369
          7A652E4865696768740500000000000000D002401453697A652E506C6174666F
          726D44656661756C74080B5374726F6B652E4B696E6407044E6F6E6508577261
          704D6F64650703466974000F54436F6C6F72416E696D6174696F6E0009537479
          6C654E616D650614436F6C6F72416E696D6174696F6E315374796C6508447572
          6174696F6E0500000000006F1283F53F07496E7665727365090C50726F706572
          74794E616D65060A46696C6C2E436F6C6F720A537461727456616C7565070978
          46464439443945330953746F7056616C75650708636C61576869746507547269
          67676572061049734D6F7573654F7665723D747275650E54726967676572496E
          7665727365061149734D6F7573654F7665723D66616C73650000000007544275
          74746F6E00095374796C654E616D6506046564697405416C69676E0705526967
          687406437572736F72070B637248616E64506F696E740C50616464696E672E4C
          656674050000000000000080FF3F0B50616464696E672E546F70050000000000
          000080FF3F0D50616464696E672E5269676874050000000000000080FF3F0E50
          616464696E672E426F74746F6D050000000000000080FF3F0C4D617267696E73
          2E4C65667405000000000000008002400B4D617267696E732E546F7005000000
          000000008000400E4D617267696E732E426F74746F6D05000000000000008000
          400A506F736974696F6E2E5905000000000000008000400A53697A652E576964
          746805000000000000008003400B53697A652E48656967687405000000000000
          00F002401453697A652E506C6174666F726D44656661756C74080B5374796C65
          4C6F6F6B75700611627574746F6E7374796C655F636C656172085461624F7264
          657202020005545061746800095374796C654E616D65060A5061746831537479
          6C6505416C69676E0706436C69656E7409446174612E506174680AAC0000000E
          00000000000000000040410000A041010000000000A8410000A0410000000000
          00844100006040020000002CA18A4178FF2A4002000000EF5F9541A1062B4002
          00000000009C4100106040020000003D9FA2415E898A40020000004B9FA241E0
          7DB540020000001F009C4183FFCF40010000000000E040000098410100000000
          0040400000A04101000000000080400000804101000000000084410000604003
          00000000008441000060400946696C6C2E4B696E6407044E6F6E65064C6F636B
          6564090748697454657374080A53697A652E57696474680500000000000000E0
          02400B53697A652E4865696768740500000000000000D002401453697A652E50
          6C6174666F726D44656661756C74080C5374726F6B652E436F6C6F7207097846
          4644394439453308577261704D6F64650703466974000F54436F6C6F72416E69
          6D6174696F6E00095374796C654E616D650614436F6C6F72416E696D6174696F
          6E315374796C6507456E61626C656409084475726174696F6E0500000000006F
          1283F53F07496E7665727365090C50726F70657274794E616D65060C5374726F
          6B652E436F6C6F720A537461727456616C756507097846464439443945330953
          746F7056616C75650708636C6157686974650754726967676572061049734D6F
          7573654F7665723D747275650E54726967676572496E7665727365061149734D
          6F7573654F7665723D66616C73650000000000005450463007544C61796F7574
          00095374796C654E616D6506106D656D6F7374796C655F6E6F726D616C05416C
          69676E070643656E7465720C50616464696E672E4C6566740500000000000000
          8001400B50616464696E672E546F7005000000000000008001400D5061646469
          6E672E526967687405000000000000008001400E50616464696E672E426F7474
          6F6D05000000000000008001400A53697A652E57696474680500000000000000
          F406400B53697A652E48656967687405000000000000009908401453697A652E
          506C6174666F726D44656661756C74080756697369626C6508085461624F7264
          65720220000A5452656374616E676C6500095374796C654E616D650602626705
          416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F72070978334346
          46464646460748697454657374080A53697A652E576964746805000000000000
          00F406400B53697A652E48656967687405000000000000009908401453697A65
          2E506C6174666F726D44656661756C74080C5374726F6B652E436F6C6F720709
          78354146464646464607585261646975730500000000000000C0004007595261
          646975730500000000000000C00040000F54436F6C6F72416E696D6174696F6E
          00095374796C654E616D650614436F6C6F72416E696D6174696F6E315374796C
          65084475726174696F6E050000000000CDCCCCFC3F0C50726F70657274794E61
          6D65060C5374726F6B652E436F6C6F720A537461727456616C75650709783541
          4646464646460953746F7056616C756507097843384646464646460754726967
          676572060E4973466F63757365643D747275650E54726967676572496E766572
          7365060F4973466F63757365643D66616C73650000000C5442727573684F626A
          65637400095374796C654E616D65060A666F726567726F756E6400000C544272
          7573684F626A65637400095374796C654E616D65060973656C656374696F6E0B
          42727573682E436F6C6F72070978374632413936464600000B54466F6E744F62
          6A65637400095374796C654E616D650604666F6E7409466F6E742E53697A6505
          00000000000000E00240000007544C61796F757400095374796C654E616D6506
          07636F6E74656E7405416C69676E0706436C69656E740C4D617267696E732E4C
          65667405000000000000008001400B4D617267696E732E546F70050000000000
          00008001400D4D617267696E732E526967687405000000000000008001400E4D
          617267696E732E426F74746F6D05000000000000008001400A53697A652E5769
          6474680500000000000000DC06400B53697A652E486569676874050000000000
          00009308401453697A652E506C6174666F726D44656661756C7408085461624F
          72646572020000000A545363726F6C6C42617200095374796C654E616D65060A
          767363726F6C6C62617205416C69676E0705526967687406437572736F720707
          63724172726F770B536D616C6C4368616E676505000000000000000000000B4F
          7269656E746174696F6E0708566572746963616C0A506F736974696F6E2E5805
          00000000000000E806400A506F736974696F6E2E590500000000000000800140
          0A53697A652E576964746805000000000000008002400B53697A652E48656967
          687405000000000000009508401453697A652E506C6174666F726D4465666175
          6C7408085461624F72646572020100000A545363726F6C6C4261720009537479
          6C654E616D65060A687363726F6C6C62617205416C69676E0706426F74746F6D
          06437572736F72070763724172726F770B536D616C6C4368616E676505000000
          000000000000000B4F7269656E746174696F6E070A486F72697A6F6E74616C0A
          506F736974696F6E2E5805000000000000008001400A506F736974696F6E2E59
          05000000000000009608400A53697A652E57696474680500000000000000EC06
          400B53697A652E48656967687405000000000000008002401453697A652E506C
          6174666F726D44656661756C7408085461624F726465720202000007544C6179
          6F75740005416C69676E0706436C69656E740A53697A652E5769647468050000
          0000000000E406400B53697A652E486569676874050000000000000095084014
          53697A652E506C6174666F726D44656661756C7408085461624F726465720203
          000F54536D616C6C5363726F6C6C42617200095374796C654E616D65060F7673
          6D616C6C7363726F6C6C62617205416C69676E0705526967687406437572736F
          72070763724172726F770B536D616C6C4368616E676505000000000000000000
          000B4F7269656E746174696F6E0708566572746963616C0C4D617267696E732E
          4C65667405000000000000008000400A53697A652E5769647468050000000000
          00008002400B53697A652E48656967687405000000000000008002401453697A
          652E506C6174666F726D44656661756C74080756697369626C650800000F5453
          6D616C6C5363726F6C6C42617200095374796C654E616D65060F68736D616C6C
          7363726F6C6C62617205416C69676E0706426F74746F6D06437572736F720707
          63724172726F770B536D616C6C4368616E676505000000000000000000000B4F
          7269656E746174696F6E070A486F72697A6F6E74616C0B4D617267696E732E54
          6F7005000000000000008000400A53697A652E57696474680500000000000000
          9606400B53697A652E48656967687405000000000000008002401453697A652E
          506C6174666F726D44656661756C74080756697369626C65080000000F545365
          6C656374696F6E506F696E7400095374796C654E616D6506126C65667473656C
          656374696F6E706F696E74084772697053697A650500000000000000C000400C
          4772697043656E7465722E580500000000000000E002400C4772697043656E74
          65722E590500000000000000B003C00A506F736974696F6E2E58050000000000
          0000DC05400A506F736974696F6E2E5905000000000000009307400A53697A65
          2E57696474680500000000000000C003400B53697A652E486569676874050000
          0000000000C004401453697A652E506C6174666F726D44656661756C74080B53
          74796C654C6F6F6B757006176C65667473656C656374696F6E706F696E747374
          796C6519546F756368546172676574457870616E73696F6E2E4C656674050000
          0000000000E003401A546F756368546172676574457870616E73696F6E2E5269
          6768740500000000000000E003C000000F5453656C656374696F6E506F696E74
          00095374796C654E616D650613726967687473656C656374696F6E706F696E74
          084772697053697A650500000000000000C000400C4772697043656E7465722E
          590500000000000000B004C00A506F736974696F6E2E580500000000000000DC
          05400A506F736974696F6E2E5905000000000000009307400A53697A652E5769
          6474680500000000000000C003400B53697A652E486569676874050000000000
          0000C003401453697A652E506C6174666F726D44656661756C74080B5374796C
          654C6F6F6B75700618726967687473656C656374696F6E706F696E747374796C
          650000005450463007544C61796F757400095374796C654E616D650615627574
          746F6E7374796C655F636C6561726D696E6905416C69676E070643656E746572
          0A53697A652E576964746805000000000000008004400B53697A652E48656967
          687405000000000000008004401453697A652E506C6174666F726D4465666175
          6C74080756697369626C6508085461624F726465720207000A5452656374616E
          676C6500095374796C654E616D65060F52656374616E676C65315374796C6505
          416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F72070978303032
          30323132330748697454657374080A53697A652E576964746805000000000000
          008004400B53697A652E48656967687405000000000000008004401453697A65
          2E506C6174666F726D44656661756C74080B5374726F6B652E4B696E6407044E
          6F6E6507585261646975730500000000000000C0014007595261646975730500
          000000000000C00140000F54436F6C6F72416E696D6174696F6E00095374796C
          654E616D650614436F6C6F72416E696D6174696F6E315374796C650844757261
          74696F6E0500000000006F1283F53F0C50726F70657274794E616D65060A4669
          6C6C2E436F6C6F720A537461727456616C756507097830303230323132330953
          746F7056616C756507097846463230323132330754726967676572061049734D
          6F7573654F7665723D747275650E54726967676572496E766572736506114973
          4D6F7573654F7665723D66616C73650000000654476C79706800095374796C65
          4E616D65060A676C7970687374796C650B4D617267696E732E546F7005000000
          000000008000400D4D617267696E732E52696768740500000000000000800040
          0E4D617267696E732E426F74746F6D050000000000000080004005416C69676E
          070643656E7465720A53697A652E57696474680500000000000000C003400B53
          697A652E4865696768740500000000000000C003401453697A652E506C617466
          6F726D44656661756C74080A496D616765496E646578020206496D6167657307
          19466F726D4D61696E2E53564749636F6E496D6167654C697374000E5446696C
          6C52474245666665637400095374796C654E616D65061346696C6C5247424566
          66656374315374796C6505436F6C6F7207097846464439443945330000000054
          50463007544C61796F757400095374796C654E616D6506126C697374626F7873
          74796C655F636C65617205416C69676E070643656E7465720A53697A652E5769
          6474680500000000000000F406400B53697A652E486569676874050000000000
          00009908401453697A652E506C6174666F726D44656661756C74080756697369
          626C6508085461624F726465720218000C5442727573684F626A656374000953
          74796C654E616D650618416C7465726E6174696E67526F774261636B67726F75
          6E640B42727573682E436F6C6F720709784646454545454545000007544C6179
          6F757400095374796C654E616D650607636F6E74656E7405416C69676E070643
          6C69656E740C436C69704368696C6472656E090A53697A652E57696474680500
          000000000000EC06400B53697A652E4865696768740500000000000000970840
          1453697A652E506C6174666F726D44656661756C7408085461624F7264657202
          0000000A545363726F6C6C42617200095374796C654E616D65060A767363726F
          6C6C62617205416C69676E070552696768740B536D616C6C4368616E67650500
          0000000000000000000B4F7269656E746174696F6E0708566572746963616C0A
          506F736974696F6E2E580500000000000000EC06400A53697A652E5769647468
          05000000000000008002400B53697A652E486569676874050000000000000097
          08401453697A652E506C6174666F726D44656661756C7408085461624F726465
          72020100000A545363726F6C6C42617200095374796C654E616D65060A687363
          726F6C6C62617205416C69676E0706426F74746F6D0B536D616C6C4368616E67
          6505000000000000000000000B4F7269656E746174696F6E070A486F72697A6F
          6E74616C0A506F736974696F6E2E5905000000000000009708400A53697A652E
          57696474680500000000000000F406400B53697A652E48656967687405000000
          000000008002401453697A652E506C6174666F726D44656661756C7408085461
          624F726465720202000007544C61796F75740005416C69676E0706436C69656E
          740A53697A652E57696474680500000000000000EC06400B53697A652E486569
          67687405000000000000009708401453697A652E506C6174666F726D44656661
          756C7408085461624F726465720203000F54536D616C6C5363726F6C6C426172
          00095374796C654E616D65060F76736D616C6C7363726F6C6C62617205416C69
          676E070552696768740B536D616C6C4368616E67650500000000000000000000
          0B4F7269656E746174696F6E0708566572746963616C0C4D617267696E732E4C
          65667405000000000000008000400A53697A652E576964746805000000000000
          008002400B53697A652E48656967687405000000000000008002401453697A65
          2E506C6174666F726D44656661756C74080756697369626C650800000F54536D
          616C6C5363726F6C6C42617200095374796C654E616D65060F68736D616C6C73
          63726F6C6C62617205416C69676E0706426F74746F6D0B536D616C6C4368616E
          676505000000000000000000000B4F7269656E746174696F6E070A486F72697A
          6F6E74616C0B4D617267696E732E546F7005000000000000008000400A53697A
          652E576964746805000000000000009606400B53697A652E4865696768740500
          0000000000008002401453697A652E506C6174666F726D44656661756C740807
          56697369626C650800000007544C61796F757400095374796C654E616D650606
          68656164657205416C69676E0703546F700A53697A652E576964746805000000
          00000000C804400B53697A652E4865696768740500000000000000C804401453
          697A652E506C6174666F726D44656661756C74080756697369626C6508085461
          624F726465720204000007544C61796F757400095374796C654E616D65060666
          6F6F74657205416C69676E0706426F74746F6D0A53697A652E57696474680500
          000000000000C804400B53697A652E4865696768740500000000000000C80440
          1453697A652E506C6174666F726D44656661756C74080756697369626C650808
          5461624F7264657202050000005450463007544C61796F757400095374796C65
          4E616D650613627574746F6E7374796C655F7072696D61727905416C69676E07
          0643656E746572074F706163697479050000000000CDCCCCFE3F0A53697A652E
          57696474680500000000000000A004400B53697A652E48656967687405000000
          00000000A004401453697A652E506C6174666F726D44656661756C7408075669
          7369626C6508085461624F726465720208000654476C79706800095374796C65
          4E616D65060A676C7970687374796C6505416C69676E070643656E7465720A53
          697A652E57696474680500000000000000C003400B53697A652E486569676874
          0500000000000000C003401453697A652E506C6174666F726D44656661756C74
          080A496D616765496E646578020006496D616765730719466F726D4D61696E2E
          53564749636F6E496D6167654C697374000E5446696C6C524742456666656374
          00095374796C654E616D65061346696C6C524742456666656374315374796C65
          05436F6C6F7207097846464439443945330000000F54466C6F6174416E696D61
          74696F6E00095374796C654E616D650614466C6F6174416E696D6174696F6E31
          5374796C65084475726174696F6E050000000000CDCCCCFC3F0C50726F706572
          74794E616D6506074F7061636974790A537461727456616C7565050000000000
          CDCCCCFE3F0953746F7056616C7565050000000000000080FF3F075472696767
          6572061049734D6F7573654F7665723D747275650E54726967676572496E7665
          727365061149734D6F7573654F7665723D66616C73650000005450463007544C
          61796F757400095374796C654E616D65060F656469747374796C655F636C6561
          7205416C69676E070643656E7465720A53697A652E5769647468050000000000
          0000D606400B53697A652E48656967687405000000000000008C04401453697A
          652E506C6174666F726D44656661756C74080756697369626C6508085461624F
          726465720228000A5452656374616E676C6500095374796C654E616D65060262
          6705416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F7207097833
          434646464646460748697454657374080A53697A652E57696474680500000000
          000000D606400B53697A652E48656967687405000000000000008C0440145369
          7A652E506C6174666F726D44656661756C74080C5374726F6B652E436F6C6F72
          070978354146464646464607585261646975730500000000000000C000400759
          5261646975730500000000000000C00040000F54436F6C6F72416E696D617469
          6F6E00095374796C654E616D650614436F6C6F72416E696D6174696F6E315374
          796C65084475726174696F6E050000000000CDCCCCFC3F0C50726F7065727479
          4E616D65060C5374726F6B652E436F6C6F720A537461727456616C7565070978
          35414646464646460953746F7056616C75650709784338464646464646075472
          6967676572060E4973466F63757365643D747275650E54726967676572496E76
          65727365060F4973466F63757365643D66616C73650000000C5442727573684F
          626A65637400095374796C654E616D65060A666F726567726F756E6400000C54
          42727573684F626A65637400095374796C654E616D65060973656C656374696F
          6E0B42727573682E436F6C6F72070978374632413936464600000B54466F6E74
          4F626A65637400095374796C654E616D650604666F6E7409466F6E742E53697A
          650500000000000000E00240000007544C61796F757400095374796C654E616D
          650607636F6E74656E7405416C69676E0706436C69656E740C4D617267696E73
          2E4C6566740500000000000000C000400B4D617267696E732E546F7005000000
          00000000C000400D4D617267696E732E52696768740500000000000000C00040
          0E4D617267696E732E426F74746F6D0500000000000000C000400A53697A652E
          57696474680500000000000000CE06400B53697A652E48656967687405000000
          00000000E803401453697A652E506C6174666F726D44656661756C7408085461
          624F726465720200000007544C61796F757400095374796C654E616D65060762
          7574746F6E7305416C69676E07055269676874064C6F636B6564090B4D617267
          696E732E546F7005000000000000008000400D4D617267696E732E5269676874
          05000000000000008000400E4D617267696E732E426F74746F6D050000000000
          00008000400A506F736974696F6E2E580500000000000000D406400A506F7369
          74696F6E2E5905000000000000008000400A53697A652E576964746805000000
          000000000000000B53697A652E4865696768740500000000000000F803401453
          697A652E506C6174666F726D44656661756C7408085461624F72646572020100
          0006544C6162656C00095374796C654E616D65060670726F6D7074064C6F636B
          656409074F706163697479050000000000000080FE3F0756697369626C650808
          5461624F7264657202030000005450463007544C61796F757400095374796C65
          4E616D6506157363726F6C6C626172626F74746F6D627574746F6E05416C6967
          6E070643656E7465720A53697A652E576964746805000000000000008803400B
          53697A652E48656967687405000000000000008803401453697A652E506C6174
          666F726D44656661756C74080756697369626C6508085461624F726465720217
          000554506174680005416C69676E070643656E74657209446174612E50617468
          0A3400000004000000000000000000000000000000010000000000803F000000
          00010000000000003F0000803F0300000000000000000000000A46696C6C2E43
          6F6C6F720707636C6147726179064C6F636B6564090748697454657374080A53
          697A652E576964746805000000000000008002400B53697A652E486569676874
          0500000000000000E001401453697A652E506C6174666F726D44656661756C74
          080B5374726F6B652E4B696E6407044E6F6E65000F54436F6C6F72416E696D61
          74696F6E00084475726174696F6E050000000000CDCCCCFB3F0C50726F706572
          74794E616D65060A46696C6C2E436F6C6F720A537461727456616C7565070763
          6C61477261790953746F7056616C756507097846464343434343430754726967
          676572061049734D6F7573654F7665723D7472756500000F54436F6C6F72416E
          696D6174696F6E00084475726174696F6E050000000000CDCCCCFB3F0C50726F
          70657274794E616D65060A46696C6C2E436F6C6F720A537461727456616C7565
          07097846464343434343430953746F7056616C75650707636C61477261790754
          726967676572061149734D6F7573654F7665723D66616C736500000000545046
          3007544C61796F757400095374796C654E616D6506147363726F6C6C62617268
          747261636B7374796C6505416C69676E070643656E7465720A53697A652E5769
          64746805000000000000009803400B53697A652E486569676874050000000000
          0100FC04401453697A652E506C6174666F726D44656661756C74080756697369
          626C6508085461624F7264657202160006545468756D6200095374796C654E61
          6D6506057468756D62064C6F636B6564090A506F736974696F6E2E5805000000
          00000000A001400A506F736974696F6E2E590500000000000000A001400A5369
          7A652E57696474680500000000000000A002400B53697A652E48656967687405
          00000000000000B804401453697A652E506C6174666F726D44656661756C7408
          0000005450463007544C61796F757400095374796C654E616D6506137363726F
          6C6C6261726C656674627574746F6E05416C69676E070643656E7465720A5369
          7A652E57696474680500000000000000A803400B53697A652E48656967687405
          00000000000000A803401453697A652E506C6174666F726D44656661756C7408
          0756697369626C6508085461624F726465720219000554506174680005416C69
          676E070643656E74657209446174612E506174680A4000000005000000000000
          000000803F00000000010000000000803F0000803F0100000000000000000000
          3F010000000000803F000000000300000000000000000000000A46696C6C2E43
          6F6C6F720707636C6147726179064C6F636B6564090748697454657374080A53
          697A652E57696474680500000000000000E001400B53697A652E486569676874
          05000000000000008002401453697A652E506C6174666F726D44656661756C74
          080B5374726F6B652E4B696E6407044E6F6E65000F54436F6C6F72416E696D61
          74696F6E00084475726174696F6E050000000000CDCCCCFB3F0C50726F706572
          74794E616D65060A46696C6C2E436F6C6F720A537461727456616C7565070763
          6C61477261790953746F7056616C756507097846464343434343430754726967
          676572061049734D6F7573654F7665723D7472756500000F54436F6C6F72416E
          696D6174696F6E00084475726174696F6E050000000000CDCCCCFB3F0C50726F
          70657274794E616D65060A46696C6C2E436F6C6F720A537461727456616C7565
          07097846464343434343430953746F7056616C75650707636C61477261790754
          726967676572061149734D6F7573654F7665723D66616C736500000000545046
          3007544C61796F757400095374796C654E616D6506147363726F6C6C62617272
          69676874627574746F6E05416C69676E070643656E7465720A53697A652E5769
          6474680500000000000000B003400B53697A652E486569676874050000000000
          0000A003401453697A652E506C6174666F726D44656661756C74080756697369
          626C6508085461624F72646572021B000554506174680005416C69676E070643
          656E74657209446174612E506174680A34000000040000000000000000000000
          0000000001000000000000000000803F010000000000803F0000003F03000000
          00000000000000000A46696C6C2E436F6C6F720707636C6147726179064C6F63
          6B6564090748697454657374080A53697A652E57696474680500000000000000
          E001400B53697A652E48656967687405000000000000008002401453697A652E
          506C6174666F726D44656661756C74080B5374726F6B652E4B696E6407044E6F
          6E65000F54436F6C6F72416E696D6174696F6E00084475726174696F6E050000
          000000CDCCCCFB3F0C50726F70657274794E616D65060A46696C6C2E436F6C6F
          720A537461727456616C75650707636C61477261790953746F7056616C756507
          097846464343434343430754726967676572061049734D6F7573654F7665723D
          7472756500000F54436F6C6F72416E696D6174696F6E00084475726174696F6E
          050000000000CDCCCCFB3F0C50726F70657274794E616D65060A46696C6C2E43
          6F6C6F720A537461727456616C756507097846464343434343430953746F7056
          616C75650707636C61477261790754726967676572061149734D6F7573654F76
          65723D66616C7365000000005450463007544C61796F757400095374796C654E
          616D65060E7363726F6C6C6261727374796C6505416C69676E070643656E7465
          720A53697A652E576964746805000000000000009008400B53697A652E486569
          67687405000000000000808507401453697A652E506C6174666F726D44656661
          756C74080756697369626C6508085461624F72646572021F000A54526F756E64
          5265637400095374796C654E616D65060A6261636B67726F756E6405416C6967
          6E0708436F6E74656E74730A46696C6C2E436F6C6F7207097831453333333333
          330A53697A652E576964746805000000000000009008400B53697A652E486569
          67687405000000000000808507401453697A652E506C6174666F726D44656661
          756C74080B5374726F6B652E4B696E6407044E6F6E6500000654547261636B00
          095374796C654E616D65060668747261636B05416C69676E0706436C69656E74
          064C6F636B656409034D6178050000000000000080FF3F0B4F7269656E746174
          696F6E070A486F72697A6F6E74616C0A53697A652E5769647468050000000000
          00009008400B53697A652E48656967687405000000000000808507401453697A
          652E506C6174666F726D44656661756C74080B5374796C654C6F6F6B75700614
          7363726F6C6C62617268747261636B7374796C650C56696577706F727453697A
          65050000000000CDCCCCFB3F00000654547261636B00095374796C654E616D65
          060676747261636B05416C69676E0706436C69656E74064C6F636B656409034D
          6178050000000000000080FF3F0B4F7269656E746174696F6E070A486F72697A
          6F6E74616C0A53697A652E576964746805000000000000009008400B53697A65
          2E48656967687405000000000000808507401453697A652E506C6174666F726D
          44656661756C74080B5374796C654C6F6F6B757006147363726F6C6C62617276
          747261636B7374796C650C56696577706F727453697A65050000000000CDCCCC
          FB3F0000005450463007544C61796F757400095374796C654E616D6506127363
          726F6C6C626172746F70627574746F6E05416C69676E070643656E7465720A53
          697A652E576964746805000000000000008003400B53697A652E486569676874
          05000000000000009803401453697A652E506C6174666F726D44656661756C74
          080756697369626C6508085461624F72646572021E000554506174680005416C
          69676E070643656E74657209446174612E506174680A40000000050000000000
          0000000000000000803F010000000000803F0000803F010000000000003F0000
          000001000000000000000000803F0300000000000000000000000A46696C6C2E
          436F6C6F720707636C6147726179064C6F636B6564090748697454657374080A
          53697A652E576964746805000000000000008002400B53697A652E4865696768
          740500000000000000E001401453697A652E506C6174666F726D44656661756C
          74080B5374726F6B652E4B696E6407044E6F6E65000F54436F6C6F72416E696D
          6174696F6E00084475726174696F6E050000000000CDCCCCFB3F0C50726F7065
          7274794E616D65060A46696C6C2E436F6C6F720A537461727456616C75650707
          636C61477261790953746F7056616C7565070978464643434343434307547269
          67676572061049734D6F7573654F7665723D7472756500000F54436F6C6F7241
          6E696D6174696F6E00084475726174696F6E050000000000CDCCCCFB3F0C5072
          6F70657274794E616D65060A46696C6C2E436F6C6F720A537461727456616C75
          6507097846464343434343430953746F7056616C75650707636C614772617907
          54726967676572061149734D6F7573654F7665723D66616C7365000000005450
          463007544C61796F757400095374796C654E616D6506147363726F6C6C626172
          76747261636B7374796C6505416C69676E070643656E7465720A53697A652E57
          696474680500000000000000F605400B53697A652E4865696768740500000000
          0000009003401453697A652E506C6174666F726D44656661756C740807566973
          69626C6508085461624F7264657202110006545468756D6200095374796C654E
          616D6506057468756D6206437572736F72070B637248616E64506F696E74064C
          6F636B6564090A506F736974696F6E2E5805000000000000008001400A506F73
          6974696F6E2E5905000000000000008001400A53697A652E5769647468050000
          0000000000BC04400B53697A652E486569676874050000000000000090024014
          53697A652E506C6174666F726D44656661756C74080756697369626C65080000
          00545046300A54526F756E645265637400095374796C654E616D650619736D61
          6C6C7363726F6C6C62617268747261636B7374796C6505416C69676E07064365
          6E7465720A46696C6C2E436F6C6F7207097831453333333333330A53697A652E
          57696474680500000000000040A408400B53697A652E48656967687405000000
          000000009003401453697A652E506C6174666F726D44656661756C74080B5374
          726F6B652E4B696E6407044E6F6E650756697369626C65080006545468756D62
          00095374796C654E616D6506057468756D62064C6F636B6564090C4D61726769
          6E732E4C656674050000000000000080FF3F0B4D617267696E732E546F700500
          00000000000080FF3F0D4D617267696E732E5269676874050000000000000080
          FF3F0E4D617267696E732E426F74746F6D050000000000000080FF3F0A506F73
          6974696F6E2E580500000000000000C000400A506F736974696F6E2E59050000
          0000000000C002C00A53697A652E57696474680500000000000000A002400B53
          697A652E4865696768740500000000000000B804401453697A652E506C617466
          6F726D44656661756C74080000005450463007544C61796F757400095374796C
          654E616D650613736D616C6C7363726F6C6C6261727374796C6505416C69676E
          070643656E7465720A53697A652E57696474680500000000000000FA05400B53
          697A652E4865696768740500000000000040B408401453697A652E506C617466
          6F726D44656661756C74080756697369626C6508085461624F72646572021500
          0654547261636B00095374796C654E616D65060668747261636B05416C69676E
          0706436C69656E74064C6F636B656409034D6178050000000000000080FF3F0B
          4F7269656E746174696F6E070A486F72697A6F6E74616C0A53697A652E576964
          74680500000000000000FA05400B53697A652E48656967687405000000000000
          40B408401453697A652E506C6174666F726D44656661756C74080B5374796C65
          4C6F6F6B75700619736D616C6C7363726F6C6C62617268747261636B7374796C
          650C56696577706F727453697A65050000000000CDCCCCFB3F00000654547261
          636B00095374796C654E616D65060676747261636B05416C69676E0706436C69
          656E74064C6F636B656409034D6178050000000000000080FF3F0B4F7269656E
          746174696F6E070A486F72697A6F6E74616C0A53697A652E5769647468050000
          0000000000FA05400B53697A652E4865696768740500000000000040B4084014
          53697A652E506C6174666F726D44656661756C74080B5374796C654C6F6F6B75
          700619736D616C6C7363726F6C6C62617276747261636B7374796C650C566965
          77706F727453697A65050000000000CDCCCCFB3F000000545046300A54526F75
          6E645265637400095374796C654E616D650619736D616C6C7363726F6C6C6261
          7276747261636B7374796C6505416C69676E070643656E7465720A46696C6C2E
          436F6C6F7207097831453333333333330A53697A652E57696474680500000000
          000000A003400B53697A652E4865696768740500000000000000FC0740145369
          7A652E506C6174666F726D44656661756C74080B5374726F6B652E4B696E6407
          044E6F6E650756697369626C65080006545468756D6200095374796C654E616D
          6506057468756D62064C6F636B6564090C4D617267696E732E4C656674050000
          000000000080FF3F0B4D617267696E732E546F70050000000000000080FF3F0D
          4D617267696E732E5269676874050000000000000080FF3F0E4D617267696E73
          2E426F74746F6D050000000000000080FF3F0A506F736974696F6E2E58050000
          00000000009002C00A506F736974696F6E2E590500000000000000C002400A53
          697A652E57696474680500000000000000BC04400B53697A652E486569676874
          05000000000000009002401453697A652E506C6174666F726D44656661756C74
          080000005450463007544C61796F757400095374796C654E616D65060A746875
          6D627374796C6505416C69676E070643656E74657206437572736F72070B6372
          48616E64506F696E740A53697A652E576964746805000000000000009003400B
          53697A652E48656967687405000000000000008803401453697A652E506C6174
          666F726D44656661756C74080756697369626C6508085461624F726465720214
          000A54526F756E645265637400095374796C654E616D65060A6261636B67726F
          756E6405416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F720709
          784646353635383639064C6F636B6564090748697454657374080A53697A652E
          576964746805000000000000009003400B53697A652E48656967687405000000
          000000008803401453697A652E506C6174666F726D44656661756C74080B5374
          726F6B652E4B696E6407044E6F6E65000F54436F6C6F72416E696D6174696F6E
          00095374796C654E616D650614436F6C6F72416E696D6174696F6E315374796C
          65084475726174696F6E0500000000000AD7A3F83F0C50726F70657274794E61
          6D65060A46696C6C2E436F6C6F720A537461727456616C756507097846463536
          353836390953746F7056616C7565070978464641434143424507547269676765
          72061049734D6F7573654F7665723D747275650E54726967676572496E766572
          7365061149734D6F7573654F7665723D66616C7365000000005450463007544C
          61796F757400095374796C654E616D65060A747261636B7374796C6505416C69
          676E070643656E7465720A53697A652E576964746805000000000000009D0640
          0B53697A652E48656967687405000000000000009003401453697A652E506C61
          74666F726D44656661756C74080756697369626C6508085461624F7264657202
          13000A5452656374616E676C6500095374796C654E616D65060A6261636B6772
          6F756E6405416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F7207
          09784646353035303530064C6F636B6564090748697454657374080A53697A65
          2E576964746805000000000000009D06400B53697A652E486569676874050000
          00000000009003401453697A652E506C6174666F726D44656661756C74080C53
          74726F6B652E436F6C6F72070978464633303330333007585261646975730500
          0000000000008001400759526164697573050000000000000080014000000654
          5468756D6200095374796C654E616D6506057468756D6206437572736F72070B
          637248616E64506F696E74064C6F636B6564090A506F736974696F6E2E580500
          000000000000C000400A506F736974696F6E2E59050000000000000080FF3F0A
          53697A652E57696474680500000000000000C404400B53697A652E4865696768
          740500000000000000F002401453697A652E506C6174666F726D44656661756C
          74080000005450463007544C61796F757400095374796C654E616D65060E7363
          726F6C6C626F787374796C6505416C69676E070643656E7465720A53697A652E
          57696474680500000000000000CD07400B53697A652E48656967687405000000
          00000000BE07401453697A652E506C6174666F726D44656661756C7408075669
          7369626C6508085461624F7264657202400007544C61796F757400095374796C
          654E616D65060A6261636B67726F756E6405416C69676E0708436F6E74656E74
          73064C6F636B6564090A53697A652E57696474680500000000000000CD07400B
          53697A652E4865696768740500000000000000BE07401453697A652E506C6174
          666F726D44656661756C74080007544C61796F757400095374796C654E616D65
          0607636F6E74656E7405416C69676E0708436F6E74656E74730D4D617267696E
          732E52696768740500000000000000C002400A53697A652E5769647468050000
          0000000000C707400B53697A652E4865696768740500000000000000BE074014
          53697A652E506C6174666F726D44656661756C7408000007544C61796F757400
          05416C69676E0706436C69656E740A53697A652E576964746805000000000000
          00C607400B53697A652E4865696768740500000000000000B707401453697A65
          2E506C6174666F726D44656661756C7408000F54536D616C6C5363726F6C6C42
          617200095374796C654E616D65060F76736D616C6C7363726F6C6C6261720541
          6C69676E070552696768740B536D616C6C4368616E6765050000000000000000
          00000B4F7269656E746174696F6E0708566572746963616C0C4D617267696E73
          2E4C65667405000000000000008000400A53697A652E57696474680500000000
          0000008002400B53697A652E4865696768740500000000000000800240145369
          7A652E506C6174666F726D44656661756C74080B5374796C654C6F6F6B757006
          227363726F6C6C626F787374796C65536D616C6C5363726F6C6C426172537479
          6C65310756697369626C650800000F54536D616C6C5363726F6C6C4261720009
          5374796C654E616D65060F68736D616C6C7363726F6C6C62617205416C69676E
          0706426F74746F6D0B536D616C6C4368616E676505000000000000000000000B
          4F7269656E746174696F6E070A486F72697A6F6E74616C0B4D617267696E732E
          546F7005000000000000008000400A53697A652E576964746805000000000000
          009606400B53697A652E48656967687405000000000000008002401453697A65
          2E506C6174666F726D44656661756C74080756697369626C650800000007544C
          61796F75740005416C69676E0708436F6E74656E74730A53697A652E57696474
          680500000000000000CD07400B53697A652E4865696768740500000000000000
          BE07401453697A652E506C6174666F726D44656661756C74080007544C61796F
          75740005416C69676E0706426F74746F6D0A506F736974696F6E2E5905000000
          00000000A507400A53697A652E57696474680500000000000000CD07400B5369
          7A652E4865696768740500000000000000C804401453697A652E506C6174666F
          726D44656661756C740800095453697A654772697000095374796C654E616D65
          060873697A656772697005416C69676E07055269676874064C6F636B6564090A
          506F736974696F6E2E580500000000000000C307400A53697A652E5769647468
          0500000000000000A003400B53697A652E4865696768740500000000000000C8
          04401453697A652E506C6174666F726D44656661756C74080B5374796C654C6F
          6F6B7570061C7363726F6C6C626F787374796C6553697A65477269705374796C
          6531000000000A545363726F6C6C42617200095374796C654E616D65060A7673
          63726F6C6C62617205416C69676E070552696768740B536D616C6C4368616E67
          6505000000000000000000000B4F7269656E746174696F6E0708566572746963
          616C0C4D617267696E732E4C6566740500000000000000C000400B4D61726769
          6E732E546F700500000000000000C000400D4D617267696E732E526967687405
          00000000000000C000400E4D617267696E732E426F74746F6D05000000000000
          00C000400A506F736974696F6E2E580500000000000080C707400A506F736974
          696F6E2E590500000000000000C000400A53697A652E57696474680500000000
          0000008002400B53697A652E4865696768740500000000000000B40740145369
          7A652E506C6174666F726D44656661756C74080B5374796C654C6F6F6B757006
          1D7363726F6C6C626F787374796C655363726F6C6C4261725374796C65310000
          0A545363726F6C6C42617200095374796C654E616D65060A687363726F6C6C62
          617205416C69676E0706426F74746F6D0B536D616C6C4368616E676505000000
          000000000000000B4F7269656E746174696F6E070A486F72697A6F6E74616C0C
          4D617267696E732E4C6566740500000000000000C000400B4D617267696E732E
          546F700500000000000000C000400D4D617267696E732E526967687405000000
          00000000C000400E4D617267696E732E426F74746F6D0500000000000000C000
          400A506F736974696F6E2E580500000000000000C000400A506F736974696F6E
          2E590500000000000080B807400A53697A652E57696474680500000000000000
          CA07400B53697A652E48656967687405000000000000008002401453697A652E
          506C6174666F726D44656661756C7408000000005450463007544C61796F7574
          00095374796C654E616D650610627574746F6E7374796C655F6D656E7505416C
          69676E070643656E7465720C50616464696E672E4C6566740500000000000000
          C002400B50616464696E672E546F700500000000000000C002400D5061646469
          6E672E52696768740500000000000000C002400E50616464696E672E426F7474
          6F6D0500000000000000C002400A53697A652E57696474680500000000000000
          F406400B53697A652E4865696768740500000000000000B004401453697A652E
          506C6174666F726D44656661756C74080756697369626C6508085461624F7264
          65720202000A5452656374616E676C6500095374796C654E616D65060F526563
          74616E676C65315374796C6505416C69676E0708436F6E74656E74730A46696C
          6C2E436F6C6F7207097830303241324233320748697454657374080A53697A65
          2E57696474680500000000000000F406400B53697A652E486569676874050000
          0000000000B004401453697A652E506C6174666F726D44656661756C74080B53
          74726F6B652E4B696E6407044E6F6E6507585261646975730500000000000000
          C0014007595261646975730500000000000000C00140000F54436F6C6F72416E
          696D6174696F6E00095374796C654E616D6506046F766572084475726174696F
          6E0500000000006F1283F53F0C50726F70657274794E616D65060A46696C6C2E
          436F6C6F720A537461727456616C756507097830303241324233320953746F70
          56616C756507097846463241324233320754726967676572061049734D6F7573
          654F7665723D747275650E54726967676572496E7665727365061149734D6F75
          73654F7665723D66616C73650000000654476C79706800095374796C654E616D
          65060A676C7970687374796C650B4D617267696E732E546F7005000000000000
          008000400D4D617267696E732E52696768740500000000000000C002400E4D61
          7267696E732E426F74746F6D050000000000000080004005416C69676E07044C
          6566740A506F736974696F6E2E580500000000000000C002400A506F73697469
          6F6E2E590500000000000000E002400A53697A652E5769647468050000000000
          00008003400B53697A652E48656967687405000000000000008003401453697A
          652E506C6174666F726D44656661756C74080A496D616765496E646578020100
          0E5446696C6C52474245666665637400095374796C654E616D65061346696C6C
          524742456666656374315374796C6505436F6C6F720709784646443944394533
          0000001654427574746F6E5374796C65546578744F626A65637400095374796C
          654E616D6506047465787405416C69676E0706436C69656E74064C6F636B6564
          090A53697A652E57696474680500000000000000DC06400B53697A652E486569
          6768740500000000000000A003401453697A652E506C6174666F726D44656661
          756C7408165465787453657474696E67732E466F6E742E53697A650500000000
          000000E00240165465787453657474696E67732E466F6E74436F6C6F72070863
          6C615768697465155465787453657474696E67732E5472696D6D696E67070943
          6861726163746572155465787453657474696E67732E576F7264577261700816
          5465787453657474696E67732E486F727A416C69676E07074C656164696E670D
          536861646F7756697369626C650808486F74436F6C6F720708636C6157686974
          650C466F6375736564436F6C6F720708636C6157686974650B4E6F726D616C43
          6F6C6F720708636C6157686974650C50726573736564436F6C6F720708636C61
          57686974650000005450463007544C61796F757400095374796C654E616D6506
          13627574746F6E7374796C655F636F6E6669726D05416C69676E070643656E74
          65720A53697A652E576964746805000000000000008004400B53697A652E4865
          6967687405000000000000008004401453697A652E506C6174666F726D446566
          61756C74080756697369626C6508085461624F726465720204000A5452656374
          616E676C6500095374796C654E616D65060F52656374616E676C65315374796C
          6505416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F7207097830
          304646464646460748697454657374080A53697A652E57696474680500000000
          0000008004400B53697A652E4865696768740500000000000000800440145369
          7A652E506C6174666F726D44656661756C74080B5374726F6B652E4B696E6407
          044E6F6E6507585261646975730500000000000000C001400759526164697573
          0500000000000000C00140000F54436F6C6F72416E696D6174696F6E00095374
          796C654E616D650614436F6C6F72416E696D6174696F6E315374796C65084475
          726174696F6E0500000000006F1283F53F0C50726F70657274794E616D65060A
          46696C6C2E436F6C6F720A537461727456616C75650709783030464646464646
          0953746F7056616C756507097831344646464646460754726967676572061049
          734D6F7573654F7665723D747275650E54726967676572496E76657273650611
          49734D6F7573654F7665723D66616C73650000000654476C7970680009537479
          6C654E616D65060A676C7970687374796C650B4D617267696E732E546F700500
          0000000000008000400D4D617267696E732E5269676874050000000000000080
          00400E4D617267696E732E426F74746F6D050000000000000080004005416C69
          676E070643656E7465720A53697A652E57696474680500000000000000C00340
          0B53697A652E4865696768740500000000000000C003401453697A652E506C61
          74666F726D44656661756C74080A496D616765496E6465780202000E5446696C
          6C52474245666665637400095374796C654E616D65061346696C6C5247424566
          66656374315374796C6505436F6C6F7207097846464439443945330000000054
          50463007544C61796F757400095374796C654E616D65060E6D656D6F7374796C
          655F636F646505416C69676E070643656E7465720A53697A652E576964746805
          00000000000000C806400B53697A652E4865696768740500000000000000C806
          401453697A652E506C6174666F726D44656661756C74080756697369626C6508
          085461624F72646572023F000A5452656374616E676C6500095374796C654E61
          6D65060F52656374616E676C65315374796C6505416C69676E0708436F6E7465
          6E74730A46696C6C2E436F6C6F72070978333230303030303007486974546573
          74080A53697A652E57696474680500000000000000C806400B53697A652E4865
          696768740500000000000000C806401453697A652E506C6174666F726D446566
          61756C74080B5374726F6B652E4B696E6407044E6F6E65075852616469757305
          00000000000000C0014007595261646975730500000000000000C0014000000C
          5442727573684F626A65637400095374796C654E616D65060A666F726567726F
          756E640B42727573682E436F6C6F720708636C61426C61636B00000C54427275
          73684F626A65637400095374796C654E616D65060973656C656374696F6E0B42
          727573682E436F6C6F72070978464643374337433700000B54466F6E744F626A
          65637400095374796C654E616D650604666F6E74000007544C61796F75740009
          5374796C654E616D650607636F6E74656E7405416C69676E0706436C69656E74
          0C4D617267696E732E4C6566740500000000000000A001400B4D617267696E73
          2E546F700500000000000000A001400D4D617267696E732E5269676874050000
          0000000000A001400E4D617267696E732E426F74746F6D0500000000000000A0
          01400A53697A652E57696474680500000000000000B606400B53697A652E4865
          696768740500000000000000B606401453697A652E506C6174666F726D446566
          61756C7408085461624F72646572020000000A545363726F6C6C426172000953
          74796C654E616D65060A767363726F6C6C62617205416C69676E070552696768
          7406437572736F72070763724172726F770B536D616C6C4368616E6765050000
          00000000000000000B4F7269656E746174696F6E0708566572746963616C0A50
          6F736974696F6E2E580500000000000000C006400A53697A652E576964746805
          000000000000008002400B53697A652E4865696768740500000000000000C006
          401453697A652E506C6174666F726D44656661756C7408085461624F72646572
          020100000A545363726F6C6C42617200095374796C654E616D65060A68736372
          6F6C6C62617205416C69676E0706426F74746F6D06437572736F720707637241
          72726F770B536D616C6C4368616E676505000000000000000000000B4F726965
          6E746174696F6E070A486F72697A6F6E74616C0A506F736974696F6E2E590500
          000000000000C006400A53697A652E57696474680500000000000000C806400B
          53697A652E48656967687405000000000000008002401453697A652E506C6174
          666F726D44656661756C7408085461624F726465720202000007544C61796F75
          740005416C69676E0706436C69656E740A53697A652E57696474680500000000
          000000C006400B53697A652E4865696768740500000000000000C00640145369
          7A652E506C6174666F726D44656661756C7408085461624F726465720203000F
          54536D616C6C5363726F6C6C42617200095374796C654E616D65060F76736D61
          6C6C7363726F6C6C62617205416C69676E0705526967687406437572736F7207
          0763724172726F770B536D616C6C4368616E676505000000000000000000000B
          4F7269656E746174696F6E0708566572746963616C0C4D617267696E732E4C65
          667405000000000000008000400A53697A652E57696474680500000000000000
          8002400B53697A652E48656967687405000000000000008002401453697A652E
          506C6174666F726D44656661756C74080756697369626C650800000F54536D61
          6C6C5363726F6C6C42617200095374796C654E616D65060F68736D616C6C7363
          726F6C6C62617205416C69676E0706426F74746F6D06437572736F7207076372
          4172726F770B536D616C6C4368616E676505000000000000000000000B4F7269
          656E746174696F6E070A486F72697A6F6E74616C0B4D617267696E732E546F70
          05000000000000008000400A53697A652E576964746805000000000000009606
          400B53697A652E48656967687405000000000000008002401453697A652E506C
          6174666F726D44656661756C74080756697369626C65080000000F5453656C65
          6374696F6E506F696E7400095374796C654E616D6506136C65667473656C6563
          74696F6E706F696E7431084772697053697A650500000000000000C000400C47
          72697043656E7465722E580500000000000000E002400C4772697043656E7465
          722E590500000000000000B003C00A506F736974696F6E2E5805000000000000
          00B005400A506F736974696F6E2E590500000000000000B005400A53697A652E
          57696474680500000000000000C003400B53697A652E48656967687405000000
          00000000C004401453697A652E506C6174666F726D44656661756C74080B5374
          796C654C6F6F6B757006176C65667473656C656374696F6E706F696E74737479
          6C6519546F756368546172676574457870616E73696F6E2E4C65667405000000
          00000000E003401A546F756368546172676574457870616E73696F6E2E526967
          68740500000000000000E003C000000F5453656C656374696F6E506F696E7400
          095374796C654E616D650614726967687473656C656374696F6E706F696E7431
          084772697053697A650500000000000000C000400C4772697043656E7465722E
          590500000000000000B004C00A506F736974696F6E2E580500000000000000B0
          05400A506F736974696F6E2E590500000000000000B005400A53697A652E5769
          6474680500000000000000C003400B53697A652E486569676874050000000000
          0000C003401453697A652E506C6174666F726D44656661756C74080B5374796C
          654C6F6F6B75700618726967687473656C656374696F6E706F696E747374796C
          650000005450463007544C61796F757400095374796C654E616D650611627574
          746F6E7374796C655F636C65617205416C69676E070643656E74657207566973
          69626C6508085461624F72646572024500005450463007544C61796F75740009
          5374796C654E616D65060D747261636B6261727374796C6505416C69676E0706
          43656E7465720C50616464696E672E4C65667405000000000000008001400D50
          616464696E672E526967687405000000000000008001400A53697A652E576964
          746805000000000000809507400B53697A652E48656967687405000000000000
          009803401453697A652E506C6174666F726D44656661756C7408075669736962
          6C6508085461624F72646572024A0B46697865644865696768740213000A5452
          6F756E645265637400095374796C654E616D65060668747261636B05416C6967
          6E070A5665727443656E746572074869745465737408074F7061636974790500
          000000009A9999FE3F0A506F736974696F6E2E5805000000000000008001400A
          506F736974696F6E2E5905000000000000008001400A53697A652E5769647468
          05000000000000809107400B53697A652E4865696768740500000000000000B0
          02401453697A652E506C6174666F726D44656661756C74080C5374726F6B652E
          436F6C6F720709784646443644364436000009545374796C6554616700035461
          670214095374796C654E616D6506095468756D6253697A6500000C545374796C
          654F626A65637400095374796C654E616D65060676747261636B05416C69676E
          070A486F727A43656E746572074361704D6F6465070454696C65064C6F636B65
          64090C536F757263654C6F6F6B7570061B57696E646F7773203130204465736B
          746F707374796C652E706E670A506F736974696F6E2E58050000000000000090
          06400A53697A652E57696474680500000000000000B002400B53697A652E4865
          6967687405000000000000009803401453697A652E506C6174666F726D446566
          61756C74080A536F757263654C696E6B0E010D436170496E736574732E546F70
          050000000000000080014010436170496E736574732E426F74746F6D05000000
          000000008001400F536F75726365526563742E4C65667405000000000000808F
          07400E536F75726365526563742E546F700500000000000000B1064010536F75
          726365526563742E5269676874050000000000000095074011536F7572636552
          6563742E426F74746F6D0500000000000000ED064000010D436170496E736574
          732E546F700500000000000000C0014010436170496E736574732E426F74746F
          6D0500000000000000C00140055363616C650500000000000000C0FF3F0F536F
          75726365526563742E4C6566740500000000000000D707400E536F7572636552
          6563742E546F70050000000000008084074010536F75726365526563742E5269
          6768740500000000000000DF074011536F75726365526563742E426F74746F6D
          0500000000000000B2074000010D436170496E736574732E546F700500000000
          00000080024010436170496E736574732E426F74746F6D050000000000000080
          0240055363616C6505000000000000008000400F536F75726365526563742E4C
          65667405000000000000808F08400E536F75726365526563742E546F70050000
          0000000000B1074010536F75726365526563742E526967687405000000000000
          0095084011536F75726365526563742E426F74746F6D0500000000000000ED07
          400000000A5452656374616E676C6500095374796C654E616D65060A6261636B
          67726F756E6405416C69676E0708436F6E74656E74730946696C6C2E4B696E64
          07044E6F6E65064C6F636B6564090748697454657374080C4D617267696E732E
          4C656674050000000000000080FF3F0B4D617267696E732E546F700500000000
          0000008000400D4D617267696E732E5269676874050000000000000080FF3F0E
          4D617267696E732E426F74746F6D05000000000000008000400A53697A652E57
          6964746805000000000000009002400B53697A652E4865696768740500000000
          000000F002401453697A652E506C6174666F726D44656661756C74080B537472
          6F6B652E4B696E6407044E6F6E6500000006545468756D6200095374796C654E
          616D650606767468756D62064C6F636B6564090C4D617267696E732E4C656674
          05000000000000008000C00B4D617267696E732E546F70050000000000000080
          00C00D4D617267696E732E526967687405000000000000008000C00E4D617267
          696E732E426F74746F6D05000000000000008000C00B5374796C654C6F6F6B75
          70060D7468756D626261727374796C65000006545468756D6200095374796C65
          4E616D650606687468756D62064C6F636B6564090C4D617267696E732E4C6566
          7405000000000000008000C00B4D617267696E732E546F700500000000000000
          8000C00D4D617267696E732E526967687405000000000000008000C00E4D6172
          67696E732E426F74746F6D05000000000000008000C00B5374796C654C6F6F6B
          7570060D7468756D626261727374796C65085461624F72646572020100000054
          50463007544C61796F757400095374796C654E616D65060D7468756D62626172
          7374796C6505416C69676E070643656E7465720A53697A652E57696474680500
          000000000000A003400B53697A652E4865696768740500000000000000A00340
          1453697A652E506C6174666F726D44656661756C74080756697369626C650808
          5461624F726465720250000754436972636C6500095374796C654E616D65060C
          436972636C65315374796C6505416C69676E0706436C69656E740A46696C6C2E
          436F6C6F720708636C6157686974650748697454657374080A53697A652E5769
          6474680500000000000000A003400B53697A652E486569676874050000000000
          0000A003401453697A652E506C6174666F726D44656661756C74080C5374726F
          6B652E436F6C6F7207097846464444444444440000005450463007544C61796F
          757400095374796C654E616D650613627574746F6E7374796C655F77656C636F
          6D6505416C69676E070643656E7465720C50616464696E672E4C656674050000
          0000000000A002400B50616464696E672E546F700500000000000000A002400D
          50616464696E672E52696768740500000000000000A002400E50616464696E67
          2E426F74746F6D0500000000000000A002400A53697A652E5769647468050000
          0000000000F406400B53697A652E4865696768740500000000000000B8044014
          53697A652E506C6174666F726D44656661756C74080756697369626C65080854
          61624F72646572020D000A5452656374616E676C6500095374796C654E616D65
          060F52656374616E676C65315374796C6505416C69676E0708436F6E74656E74
          730A46696C6C2E436F6C6F720709784646334533463442074869745465737408
          0A53697A652E57696474680500000000000000F406400B53697A652E48656967
          68740500000000000000B804401453697A652E506C6174666F726D4465666175
          6C74080B5374726F6B652E4B696E6407044E6F6E650758526164697573050000
          0000000000C0014007595261646975730500000000000000C00140000F54436F
          6C6F72416E696D6174696F6E00095374796C654E616D650614436F6C6F72416E
          696D6174696F6E315374796C65084475726174696F6E0500000000000AD7A3F8
          3F0C50726F70657274794E616D65060A46696C6C2E436F6C6F720A5374617274
          56616C756507097846463345334634420953746F7056616C7565070978464632
          30323132330754726967676572061049734D6F7573654F7665723D747275650E
          54726967676572496E7665727365061149734D6F7573654F7665723D66616C73
          650000001654427574746F6E5374796C65546578744F626A6563740009537479
          6C654E616D6506047465787405416C69676E0706436C69656E74064C6F636B65
          64090A53697A652E57696474680500000000000000E006400B53697A652E4865
          696768740500000000000000D003401453697A652E506C6174666F726D446566
          61756C7408165465787453657474696E67732E466F6E742E53697A6505000000
          00000000E00240165465787453657474696E67732E466F6E74436F6C6F720708
          636C615768697465155465787453657474696E67732E5472696D6D696E670709
          436861726163746572155465787453657474696E67732E576F72645772617008
          165465787453657474696E67732E486F727A416C69676E07074C656164696E67
          0D536861646F7756697369626C650808486F74436F6C6F720708636C61576869
          74650C466F6375736564436F6C6F720708636C6157686974650B4E6F726D616C
          436F6C6F720708636C6157686974650C50726573736564436F6C6F720708636C
          6157686974650000005450463007544C61796F757400095374796C654E616D65
          0611627574746F6E7374796C655F726574727905416C69676E070643656E7465
          720C50616464696E672E4C6566740500000000000000C002400B50616464696E
          672E546F7005000000000000008002400D50616464696E672E52696768740500
          000000000000C002400E50616464696E672E426F74746F6D0500000000000000
          8002400A53697A652E57696474680500000000000000F406400B53697A652E48
          656967687405000000000000009804401453697A652E506C6174666F726D4465
          6661756C74080756697369626C6508085461624F726465720209000A54526563
          74616E676C6500095374796C654E616D65060F52656374616E676C6531537479
          6C6505416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F72070978
          46463334333534310748697454657374080A53697A652E576964746805000000
          00000000F406400B53697A652E48656967687405000000000000009804401453
          697A652E506C6174666F726D44656661756C74080C5374726F6B652E436F6C6F
          72070978464635363538363907585261646975730500000000000000C0014007
          595261646975730500000000000000C00140000F54436F6C6F72416E696D6174
          696F6E00095374796C654E616D650614436F6C6F72416E696D6174696F6E3153
          74796C65084475726174696F6E0500000000000AD7A3F83F0C50726F70657274
          794E616D65060A46696C6C2E436F6C6F720A537461727456616C756507097846
          463334333534310953746F7056616C7565070978464634313430344507547269
          67676572061049734D6F7573654F7665723D747275650E54726967676572496E
          7665727365061149734D6F7573654F7665723D66616C73650000001654427574
          746F6E5374796C65546578744F626A65637400095374796C654E616D65060474
          65787405416C69676E0706436C69656E74064C6F636B6564090A53697A652E57
          696474680500000000000000CA06400B53697A652E4865696768740500000000
          000000B003401453697A652E506C6174666F726D44656661756C740816546578
          7453657474696E67732E466F6E742E53697A650500000000000000E002401654
          65787453657474696E67732E466F6E74436F6C6F720708636C61576869746515
          5465787453657474696E67732E5472696D6D696E670709436861726163746572
          155465787453657474696E67732E576F72645772617008165465787453657474
          696E67732E486F727A416C69676E07074C656164696E670D536861646F775669
          7369626C650808486F74436F6C6F720708636C6157686974650C466F63757365
          64436F6C6F720708636C6157686974650B4E6F726D616C436F6C6F720708636C
          6157686974650C50726573736564436F6C6F720708636C615768697465000005
          545061746800095374796C654E616D65060A50617468315374796C6505416C69
          676E07044C65667409446174612E506174680A0C04000056000000000000007E
          466F415A8BFF40010000003A2371414DDBFF4002000000EBE27941282C014102
          00000038F87F41EB45094102000000F5B97E419205124102000000EEEB7A41D6
          C52C4102000000B1BF6E419CA2454102000000B6F35B41E10B59410200000052
          274941BC746C41020000002DB23041BA6B79410200000070141641E4147E4102
          00000091EDF640075F814102000000971CC0405DDC7E4102000000DA8F8F40F4
          FD724102000000917E71407F6A6D410200000084BB4740A83566410200000053
          052340C1A85D41010000009582DA3FCE196B4102000000B9DF893F492E754102
          00000000008027A60A6E41020000000000802786C95F410100000000008027EB
          FF1F410100000096267F40EBFF1F41020000008C159C40EBFF1F410200000092
          5CAA40CD3B314102000000DB33964048503B41010000003D9B7D404703474102
          00000074298C40F0164D4102000000BC3F9B40FB3A52410200000008ACAB40AB
          3E564102000000A015D04046255F41020000004D32F940560E62410200000067
          8F1041C58F5E410200000088852441CB105B410200000098DD3641A857514102
          00000094F64441B4C8424102000000F90F5341C13934410200000027315C41AF
          94214102000000780B5F4123840D4102000000234A604187C4044102000000F1
          6368414A5EFD40020000003A2371414DDBFF40010000007E466F415A8BFF4003
          0000007E466F415A8BFF40000000001D383841321F503F020000007AA5434155
          C1943F02000000371A4E41D786CE3F02000000F54A5741098A094001000000B8
          AF644152EDA73F0200000033C46E41FF942E3F02000000000080419066903F02
          00000000008041F437014001000000000080411500C04001000000D34D404115
          00C04002000000B30C32411500C0400200000010E92A4127889D40020000008B
          FD3441855F8940010000007AA540414B1F64400200000088F43941CFBD4B4002
          0000002C653241B81E374002000000302A2A41D10527400200000030F517413C
          6B034002000000DA660341008CEF3F0200000033E1DE4094C1054002000000B2
          F4B640FDBC134002000000BB4492408CA13A400200000007256C4005DD744002
          0000006EC033402A8C974002000000B83B0F400AD7BC4002000000F6D10340BA
          F7E44002000000E2AFFD3FF376F64002000000C6E1BC3FDB50014102000000A3
          C96D3F5A12004102000000569FC33EB1A7FD4002000000FE3FF33A2A74ED4002
          000000FB0CA33DDCF4DB4002000000F180A23E0074A64002000000CD018A3FE2
          75694002000000A53110404ED11B400200000063625B4075599C3F02000000D0
          9B9E40098BD23E020000001FD7D3408596F53D02000000378904414A7F2FBE02
          000000B4F11F41A3DA913D020000001D383841321F503F030000001D38384132
          1F503F0A46696C6C2E436F6C6F72070978464644394439453307486974546573
          74080D4D617267696E732E52696768740500000000000000C001400A506F7369
          74696F6E2E580500000000000000C002400A506F736974696F6E2E5905000000
          000000008002400A53697A652E57696474680500000000000000C002400B5369
          7A652E4865696768740500000000000000B003401453697A652E506C6174666F
          726D44656661756C74080B5374726F6B652E4B696E6407044E6F6E6508577261
          704D6F646507034669740000005450463007544C61796F757400095374796C65
          4E616D65060B636F6D626F5F7374796C6505416C69676E070643656E7465720A
          53697A652E57696474680500000000000000FA06400B53697A652E4865696768
          7405000000000000008404401453697A652E506C6174666F726D44656661756C
          74080756697369626C6508085461624F726465720256000A5452656374616E67
          6C6500095374796C654E616D650602626705416C69676E0708436F6E74656E74
          730A46696C6C2E436F6C6F720709783343464646464646074869745465737408
          0A53697A652E57696474680500000000000000FA06400B53697A652E48656967
          687405000000000000008404401453697A652E506C6174666F726D4465666175
          6C74080C5374726F6B652E436F6C6F7207097835414646464646460758526164
          6975730500000000000000C0004007595261646975730500000000000000C000
          40000F54436F6C6F72416E696D6174696F6E00095374796C654E616D65061443
          6F6C6F72416E696D6174696F6E315374796C65084475726174696F6E05000000
          0000CDCCCCFC3F0C50726F70657274794E616D65060C5374726F6B652E436F6C
          6F720A537461727456616C756507097835414646464646460953746F7056616C
          756507097843384646464646460754726967676572060E4973466F6375736564
          3D747275650E54726967676572496E7665727365060F4973466F63757365643D
          66616C736500000A5452656374616E676C6500095374796C654E616D65060561
          72726F7705416C69676E0708466974526967687407436F726E6572730B08546F
          7052696768740B426F74746F6D5269676874000A46696C6C2E436F6C6F720709
          7833434646464646460748697454657374080C4D617267696E732E4C65667405
          0000000000000080FF3F0B4D617267696E732E546F70050000000000000080FF
          3F0D4D617267696E732E5269676874050000000000000080FF3F0E4D61726769
          6E732E426F74746F6D050000000000000080FF3F0A506F736974696F6E2E5805
          0000000000B0F8D906400A506F736974696F6E2E59050000000000000080FF3F
          0A53697A652E5769647468050000000000803AF803400B53697A652E48656967
          68740500000000000000F803401453697A652E506C6174666F726D4465666175
          6C74080B5374726F6B652E4B696E6407044E6F6E650758526164697573050000
          0000000000C0004007595261646975730500000000000000C00040000F54436F
          6C6F72416E696D6174696F6E00095374796C654E616D650614436F6C6F72416E
          696D6174696F6E315374796C65084475726174696F6E050000000000CDCCCCFC
          3F07496E7665727365090C50726F70657274794E616D65060A46696C6C2E436F
          6C6F720A537461727456616C756507097833434646464646460953746F705661
          6C756507097837384646464646460754726967676572061049734D6F7573654F
          7665723D747275650E54726967676572496E7665727365061149734D6F757365
          4F7665723D66616C7365000005545061746800095374796C654E616D65060A50
          617468315374796C6505416C69676E070643656E74657209446174612E506174
          680A580000000700000000000000AE476D41295C8341010000000000C04152B8
          CC410100000014AE0442295C8341010000000000104200009A41010000000000
          C0410000FA41010000000000404100009A4103000000AE476D41295C83410A46
          696C6C2E436F6C6F7207097846464439443945330748697454657374080A5369
          7A652E57696474680500000000000000C002400B53697A652E48656967687405
          00000000000000F803401453697A652E506C6174666F726D44656661756C7408
          0B5374726F6B652E4B696E6407044E6F6E6508577261704D6F64650703466974
          0000000007544C61796F757400095374796C654E616D650607636F6E74656E74
          05416C69676E0708436F6E74656E7473064C6F636B6564090C4D617267696E73
          2E4C6566740500000000000000C000400B4D617267696E732E546F7005000000
          00000000C000400D4D617267696E732E52696768740500000000000000B80340
          0E4D617267696E732E426F74746F6D0500000000000000C000400A53697A652E
          57696474680500000000000000E006400B53697A652E48656967687405000000
          00000000D803401453697A652E506C6174666F726D44656661756C740800000B
          54466F6E744F626A65637400095374796C654E616D650604666F6E7409466F6E
          742E53697A650500000000000000E0024000000C5442727573684F626A656374
          00095374796C654E616D65060A666F726567726F756E6400000C544272757368
          4F626A65637400095374796C654E616D65060973656C656374696F6E0B427275
          73682E436F6C6F720709783746324139364646000000545046300A5452656374
          616E676C6500095374796C654E616D65060D64726F70646F776E70616E656C05
          416C69676E070643656E7465720A46696C6C2E436F6C6F720709784646333433
          3534310A53697A652E57696474680500000000000000B807400B53697A652E48
          65696768740500000000000080BD07401453697A652E506C6174666F726D4465
          6661756C74080B5374726F6B652E4B696E6407044E6F6E650756697369626C65
          0800005450463007544C61796F757400095374796C654E616D65060C706F706F
          7665727374796C6505416C69676E070643656E7465720A53697A652E57696474
          6805000000000000809D07400B53697A652E4865696768740500000000000080
          8507401453697A652E506C6174666F726D44656661756C74080756697369626C
          6508085461624F72646572020A000A5452656374616E676C6500095374796C65
          4E616D650602626705416C69676E0706436C69656E740A46696C6C2E436F6C6F
          7207097846463334333534310A53697A652E576964746805000000000000809D
          07400B53697A652E48656967687405000000000000808507401453697A652E50
          6C6174666F726D44656661756C74080C5374726F6B652E436F6C6F7207097846
          4636363637373007585261646975730500000000000000A00140075952616469
          75730500000000000000A00140000D54536861646F7745666665637400084469
          7374616E63650500000000006F1283F53F09446972656374696F6E0500000000
          000000B4044008536F66746E657373050000000000CECCCCFC3F074F70616369
          7479050000000000CDCCCCFD3F0B536861646F77436F6C6F720708636C61426C
          61636B000007544C61796F757400095374796C654E616D650607636F6E74656E
          7405416C69676E0706436C69656E740A53697A652E5769647468050000000000
          00809D07400B53697A652E48656967687405000000000000808507401453697A
          652E506C6174666F726D44656661756C7408085461624F726465720200000000
          005450463007544C61796F757400095374796C654E616D65060C6C697374626F
          787374796C6505416C69676E070643656E7465720A53697A652E576964746805
          00000000000000E907400B53697A652E4865696768740500000000000040D607
          401453697A652E506C6174666F726D44656661756C74080756697369626C6508
          085461624F726465720210000C5442727573684F626A65637400095374796C65
          4E616D650618416C7465726E6174696E67526F774261636B67726F756E640B42
          727573682E436F6C6F72070978464645424542454200000A5452656374616E67
          6C6500095374796C654E616D65060A6261636B67726F756E6405416C69676E07
          08436F6E74656E74730A46696C6C2E436F6C6F72070978464633343335343107
          48697454657374080A53697A652E57696474680500000000000000E907400B53
          697A652E4865696768740500000000000040D607401453697A652E506C617466
          6F726D44656661756C74080C5374726F6B652E436F6C6F720709784646394139
          41413007585261646975730500000000000000C0004007595261646975730500
          000000000000C000400007544C61796F757400095374796C654E616D65060763
          6F6E74656E7405416C69676E0706436C69656E740C436C69704368696C647265
          6E090C4D617267696E732E4C65667405000000000000008000400B4D61726769
          6E732E546F7005000000000000008000400D4D617267696E732E526967687405
          000000000000008000400E4D617267696E732E426F74746F6D05000000000000
          008000400A53697A652E57696474680500000000000000E307400B53697A652E
          4865696768740500000000000040D007401453697A652E506C6174666F726D44
          656661756C7408085461624F72646572020000000A545363726F6C6C42617200
          095374796C654E616D65060A767363726F6C6C62617205416C69676E07055269
          6768740B536D616C6C4368616E676505000000000000000000000B4F7269656E
          746174696F6E0708566572746963616C0A506F736974696F6E2E580500000000
          000000E507400A53697A652E576964746805000000000000008002400B53697A
          652E4865696768740500000000000040D207401453697A652E506C6174666F72
          6D44656661756C7408085461624F72646572020100000A545363726F6C6C4261
          7200095374796C654E616D65060A687363726F6C6C62617205416C69676E0706
          426F74746F6D0B536D616C6C4368616E676505000000000000000000000B4F72
          69656E746174696F6E070A486F72697A6F6E74616C0A506F736974696F6E2E59
          0500000000000040D207400A53697A652E57696474680500000000000000E907
          400B53697A652E48656967687405000000000000008002401453697A652E506C
          6174666F726D44656661756C7408085461624F726465720202000007544C6179
          6F75740005416C69676E0706436C69656E740A53697A652E5769647468050000
          0000000000E507400B53697A652E4865696768740500000000000040D2074014
          53697A652E506C6174666F726D44656661756C7408085461624F726465720203
          000F54536D616C6C5363726F6C6C42617200095374796C654E616D65060F7673
          6D616C6C7363726F6C6C62617205416C69676E070552696768740B536D616C6C
          4368616E676505000000000000000000000B4F7269656E746174696F6E070856
          6572746963616C0C4D617267696E732E4C65667405000000000000008000400A
          53697A652E576964746805000000000000008002400B53697A652E4865696768
          7405000000000000008002401453697A652E506C6174666F726D44656661756C
          74080756697369626C650800000F54536D616C6C5363726F6C6C426172000953
          74796C654E616D65060F68736D616C6C7363726F6C6C62617205416C69676E07
          06426F74746F6D0B536D616C6C4368616E676505000000000000000000000B4F
          7269656E746174696F6E070A486F72697A6F6E74616C0B4D617267696E732E54
          6F7005000000000000008000400A53697A652E57696474680500000000000000
          9606400B53697A652E48656967687405000000000000008002401453697A652E
          506C6174666F726D44656661756C74080756697369626C650800000007544C61
          796F757400095374796C654E616D65060668656164657205416C69676E070354
          6F700A53697A652E57696474680500000000000000C804400B53697A652E4865
          696768740500000000000000C804401453697A652E506C6174666F726D446566
          61756C74080756697369626C6508085461624F726465720204000007544C6179
          6F757400095374796C654E616D650606666F6F74657205416C69676E0706426F
          74746F6D0A53697A652E57696474680500000000000000C804400B53697A652E
          4865696768740500000000000000C804401453697A652E506C6174666F726D44
          656661756C74080756697369626C6508085461624F7264657202050000000054
          50463007544C61796F757400095374796C654E616D6506106C697374626F7869
          74656D7374796C6505416C69676E070643656E7465720A53697A652E57696474
          680500000000000000BB07400B53697A652E4865696768740500000000000000
          9004401453697A652E506C6174666F726D44656661756C74080756697369626C
          6508085461624F7264657202120B4669786564486569676874021E000A545265
          6374616E676C6500095374796C654E616D65060F6261636B67726F756E645F6F
          76657205416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F720709
          7830303437383646460748697454657374080A53697A652E5769647468050000
          0000000000BB07400B53697A652E486569676874050000000000000090044014
          53697A652E506C6174666F726D44656661756C74080C5374726F6B652E436F6C
          6F720709783030343738364646000F54436F6C6F72416E696D6174696F6E0009
          5374796C654E616D6506046F766572084475726174696F6E0500000000000000
          0000000C50726F70657274794E616D65060A46696C6C2E436F6C6F720A537461
          727456616C756507097830303639364136440953746F7056616C756507097842
          343639364136440754726967676572060F497353656C65637465643D74727565
          0E54726967676572496E76657273650610497353656C65637465643D66616C73
          650000000654476C79706800095374796C654E616D65060A676C797068737479
          6C650C4D617267696E732E4C65667405000000000000008000400B4D61726769
          6E732E546F70050000000000000080FF3F0D4D617267696E732E526967687405
          000000000000008000400E4D617267696E732E426F74746F6D05000000000000
          0080FF3F05416C69676E07044C6566740A506F736974696F6E2E580500000000
          0000008000400A506F736974696F6E2E59050000000000000080FF3F0A53697A
          652E576964746805000000000000008003400B53697A652E4865696768740500
          0000000000008804401453697A652E506C6174666F726D44656661756C740800
          0016544163746976655374796C65546578744F626A65637400095374796C654E
          616D6506047465787405416C69676E0706436C69656E740C4D617267696E732E
          4C6566740500000000000000C000400B4D617267696E732E546F700500000000
          00000080FF3F0D4D617267696E732E52696768740500000000000000C000400E
          4D617267696E732E426F74746F6D050000000000000080FF3F0A53697A652E57
          696474680500000000000000B807400B53697A652E4865696768740500000000
          0000008804401453697A652E506C6174666F726D44656661756C740816546578
          7453657474696E67732E466F6E742E53697A6505000000000000008003401654
          65787453657474696E67732E466F6E74436F6C6F720709783936464646464646
          155465787453657474696E67732E576F72645772617008165465787453657474
          696E67732E486F727A416C69676E07074C656164696E670D536861646F775669
          7369626C65080D41637469766554726967676572070853656C65637465640B41
          6374697665436F6C6F720708636C61576869746500000954436865636B426F78
          00095374796C654E616D650605636865636B05416C69676E07044C6566740843
          616E466F637573081244697361626C65466F637573456666656374090C4D6172
          67696E732E4C65667405000000000000008001400A506F736974696F6E2E5805
          000000000000008001400A53697A652E57696474680500000000000000A00340
          0B53697A652E48656967687405000000000000009004401453697A652E506C61
          74666F726D44656661756C74080756697369626C6508000007544C61796F7574
          00095374796C654E616D65060D6163636573736F72796D6F726505416C69676E
          07094D6F737452696768740A53697A652E57696474680500000000000000B003
          400B53697A652E4865696768740500000000000000B004401453697A652E506C
          6174666F726D44656661756C74080756697369626C6508001254416374697665
          5374796C654F626A6563740005416C69676E070643656E7465720C536F757263
          654C6F6F6B7570061A57696E646F7773203130204D6F6465726E7374796C652E
          706E670A53697A652E57696474680500000000000000C002400B53697A652E48
          656967687405000000000000008003401453697A652E506C6174666F726D4465
          6661756C740808577261704D6F6465070643656E7465720D4163746976655472
          6967676572070853656C65637465640A4163746976654C696E6B0E010F536F75
          726365526563742E4C65667405000000000000008B06400E536F757263655265
          63742E546F700500000000000000D4054010536F75726365526563742E526967
          6874050000000000000097064011536F75726365526563742E426F74746F6D05
          00000000000000F405400001055363616C650500000000000000C0FF3F0F536F
          75726365526563742E4C6566740500000000000000D006400E536F7572636552
          6563742E546F7005000000000000009F064010536F75726365526563742E5269
          6768740500000000000000E2064011536F75726365526563742E426F74746F6D
          0500000000000000B706400001055363616C6505000000000000008000400F53
          6F75726365526563742E4C65667405000000000000008B07400E536F75726365
          526563742E546F700500000000000000D4064010536F75726365526563742E52
          69676874050000000000000097074011536F75726365526563742E426F74746F
          6D0500000000000000F406400001055363616C650500000000000000C000400F
          536F75726365526563742E4C6566740500000000000080D007400E536F757263
          65526563742E546F7005000000000000009F074010536F75726365526563742E
          52696768740500000000000080E2074011536F75726365526563742E426F7474
          6F6D0500000000000000B7074000000A536F757263654C696E6B0E010F536F75
          726365526563742E4C65667405000000000000008B06400E536F757263655265
          63742E546F700500000000000000D4054010536F75726365526563742E526967
          6874050000000000000097064011536F75726365526563742E426F74746F6D05
          00000000000000F405400001055363616C650500000000000000C0FF3F0F536F
          75726365526563742E4C6566740500000000000000D006400E536F7572636552
          6563742E546F7005000000000000009F064010536F75726365526563742E5269
          6768740500000000000000E2064011536F75726365526563742E426F74746F6D
          0500000000000000B706400001055363616C6505000000000000008000400F53
          6F75726365526563742E4C65667405000000000000008B07400E536F75726365
          526563742E546F700500000000000000D4064010536F75726365526563742E52
          69676874050000000000000097074011536F75726365526563742E426F74746F
          6D0500000000000000F406400001055363616C650500000000000000C000400F
          536F75726365526563742E4C6566740500000000000080D007400E536F757263
          65526563742E546F7005000000000000009F074010536F75726365526563742E
          52696768740500000000000080E2074011536F75726365526563742E426F7474
          6F6D0500000000000000B70740000013546F756368416E696D6174696F6E2E4C
          696E6B0E0000000007544C61796F757400095374796C654E616D650612616363
          6573736F7279636865636B6D61726B05416C69676E07094D6F73745269676874
          0A53697A652E57696474680500000000000000B003400B53697A652E48656967
          68740500000000000000B004401453697A652E506C6174666F726D4465666175
          6C74080756697369626C65080012544163746976655374796C654F626A656374
          0005416C69676E070643656E7465720C536F757263654C6F6F6B7570061A5769
          6E646F7773203130204D6F6465726E7374796C652E706E670A53697A652E5769
          64746805000000000000009003400B53697A652E486569676874050000000000
          00009003401453697A652E506C6174666F726D44656661756C74080857726170
          4D6F6465070643656E7465720D41637469766554726967676572070853656C65
          637465640A4163746976654C696E6B0E010F536F75726365526563742E4C6566
          7405000000000000009B06400E536F75726365526563742E546F700500000000
          000000D2054010536F75726365526563742E52696768740500000000000000AD
          064011536F75726365526563742E426F74746F6D0500000000000000F6054000
          01055363616C650500000000000000C0FF3F0F536F75726365526563742E4C65
          66740500000000000000E806400E536F75726365526563742E546F7005000000
          000000009D064010536F75726365526563742E52696768740500000000000080
          81074011536F75726365526563742E426F74746F6D0500000000000000B80640
          0001055363616C6505000000000000008000400F536F75726365526563742E4C
          65667405000000000000009B07400E536F75726365526563742E546F70050000
          0000000000D2064010536F75726365526563742E526967687405000000000000
          00AD074011536F75726365526563742E426F74746F6D0500000000000000F606
          400001055363616C650500000000000000C000400F536F75726365526563742E
          4C6566740500000000000080E807400E536F75726365526563742E546F700500
          0000000000809D074010536F75726365526563742E5269676874050000000000
          00C081084011536F75726365526563742E426F74746F6D0500000000000080B8
          074000000A536F757263654C696E6B0E010F536F75726365526563742E4C6566
          7405000000000000009B06400E536F75726365526563742E546F700500000000
          000000D2054010536F75726365526563742E52696768740500000000000000AD
          064011536F75726365526563742E426F74746F6D0500000000000000F6054000
          01055363616C650500000000000000C0FF3F0F536F75726365526563742E4C65
          66740500000000000000E806400E536F75726365526563742E546F7005000000
          000000009D064010536F75726365526563742E52696768740500000000000080
          81074011536F75726365526563742E426F74746F6D0500000000000000B80640
          0001055363616C6505000000000000008000400F536F75726365526563742E4C
          65667405000000000000009B07400E536F75726365526563742E546F70050000
          0000000000D2064010536F75726365526563742E526967687405000000000000
          00AD074011536F75726365526563742E426F74746F6D0500000000000000F606
          400001055363616C650500000000000000C000400F536F75726365526563742E
          4C6566740500000000000080E807400E536F75726365526563742E546F700500
          0000000000809D074010536F75726365526563742E5269676874050000000000
          00C081084011536F75726365526563742E426F74746F6D0500000000000080B8
          0740000013546F756368416E696D6174696F6E2E4C696E6B0E0000000007544C
          61796F757400095374796C654E616D65060F6163636573736F72796465746169
          6C05416C69676E07094D6F737452696768740A53697A652E5769647468050000
          0000000000B003400B53697A652E4865696768740500000000000000B0044014
          53697A652E506C6174666F726D44656661756C74080756697369626C65080012
          544163746976655374796C654F626A6563740005416C69676E070643656E7465
          720C536F757263654C6F6F6B7570061A57696E646F7773203130204D6F646572
          6E7374796C652E706E670A53697A652E57696474680500000000000000800340
          0B53697A652E48656967687405000000000000008003401453697A652E506C61
          74666F726D44656661756C740808577261704D6F6465070643656E7465720D41
          637469766554726967676572070853656C65637465640A4163746976654C696E
          6B0E010F536F75726365526563742E4C65667405000000000000808707400E53
          6F75726365526563742E546F700500000000000000D4054010536F7572636552
          6563742E526967687405000000000000808F074011536F75726365526563742E
          426F74746F6D0500000000000000F405400001055363616C6505000000000000
          00C0FF3F0F536F75726365526563742E4C6566740500000000000000CB07400E
          536F75726365526563742E546F7005000000000000009F064010536F75726365
          526563742E52696768740500000000000000D7074011536F7572636552656374
          2E426F74746F6D0500000000000000B706400001055363616C65050000000000
          00008000400F536F75726365526563742E4C6566740500000000000080870840
          0E536F75726365526563742E546F700500000000000000D4064010536F757263
          65526563742E526967687405000000000000808F084011536F75726365526563
          742E426F74746F6D0500000000000000F406400001055363616C650500000000
          000000C000400F536F75726365526563742E4C6566740500000000000040CB08
          400E536F75726365526563742E546F7005000000000000009F074010536F7572
          6365526563742E52696768740500000000000040D7084011536F757263655265
          63742E426F74746F6D0500000000000000B7074000000A536F757263654C696E
          6B0E010F536F75726365526563742E4C65667405000000000000808707400E53
          6F75726365526563742E546F700500000000000000D4054010536F7572636552
          6563742E526967687405000000000000808F074011536F75726365526563742E
          426F74746F6D0500000000000000F405400001055363616C6505000000000000
          00C0FF3F0F536F75726365526563742E4C6566740500000000000000CB07400E
          536F75726365526563742E546F7005000000000000009F064010536F75726365
          526563742E52696768740500000000000000D7074011536F7572636552656374
          2E426F74746F6D0500000000000000B706400001055363616C65050000000000
          00008000400F536F75726365526563742E4C6566740500000000000080870840
          0E536F75726365526563742E546F700500000000000000D4064010536F757263
          65526563742E526967687405000000000000808F084011536F75726365526563
          742E426F74746F6D0500000000000000F406400001055363616C650500000000
          000000C000400F536F75726365526563742E4C6566740500000000000040CB08
          400E536F75726365526563742E546F7005000000000000009F074010536F7572
          6365526563742E52696768740500000000000040D7084011536F757263655265
          63742E426F74746F6D0500000000000000B70740000013546F756368416E696D
          6174696F6E2E4C696E6B0E00000000005450463007544C61796F757400035461
          67021E095374796C654E616D65060D6D656E756974656D7374796C6505416C69
          676E070643656E7465720A53697A652E57696474680500000000000080900740
          0B53697A652E4865696768740500000000000000CC04401453697A652E506C61
          74666F726D44656661756C74080756697369626C6508085461624F7264657202
          0F000A5452656374616E676C6500095374796C654E616D65060A6261636B6772
          6F756E6405416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F7207
          09784646343434353530074869745465737408074F7061636974790500000000
          0000000000000A53697A652E576964746805000000000000809007400B53697A
          652E4865696768740500000000000000CC04401453697A652E506C6174666F72
          6D44656661756C74080B5374726F6B652E4B696E6407044E6F6E650758526164
          6975730500000000000000800140075952616469757305000000000000008001
          40000F54466C6F6174416E696D6174696F6E00084475726174696F6E05000000
          000018B7D1F23F0C50726F70657274794E616D6506074F7061636974790A5374
          61727456616C756505000000000000000000000953746F7056616C7565050000
          000000000080FF3F0754726967676572061049734D6F7573654F7665723D7472
          75650E54726967676572496E7665727365061149734D6F7573654F7665723D66
          616C736500000007544C61796F757400095374796C654E616D650605676C7970
          6805416C69676E07044C6566740A53697A652E57696474680500000000000000
          C803400B53697A652E4865696768740500000000000000CC04401453697A652E
          506C6174666F726D44656661756C74080007544C61796F757400095374796C65
          4E616D650609636865636B6D61726B05416C69676E0708436F6E74656E747307
          4F7061636974790500000000006F1283F53F0A53697A652E5769647468050000
          0000000000C803400B53697A652E4865696768740500000000000000CC044014
          53697A652E506C6174666F726D44656661756C74080005545061746800095374
          796C654E616D65060E636865636B6D61726B7374796C6505416C69676E070643
          656E74657209446174612E506174680A58000000070000000000000056D95243
          91AE2C43010000009276664365021643010000009F3983432B7C3C4301000000
          9E9AA64382D2B442010000006F1CB04375A4D1420100000026DF8243263F6743
          0300000056D9524391AE2C430A46696C6C2E436F6C6F720708636C61426C6163
          6B0748697454657374080A53697A652E57696474680500000000000000B00240
          0B53697A652E4865696768740500000000000000B002401453697A652E506C61
          74666F726D44656661756C74080B5374726F6B652E4B696E6407044E6F6E6500
          0F54436F6C6F72416E696D6174696F6E00084475726174696F6E050000000000
          18B7D1F23F0C50726F70657274794E616D65060A46696C6C2E436F6C6F720A53
          7461727456616C75650708636C61426C61636B0953746F7056616C7565070863
          6C61426C61636B0754726967676572060F497353656C65637465643D74727565
          0E54726967676572496E76657273650610497353656C65637465643D66616C73
          6500000F54436F6C6F72416E696D6174696F6E00084475726174696F6E050000
          00000018B7D1F23F0C50726F70657274794E616D65060A46696C6C2E436F6C6F
          720A537461727456616C75650708636C61426C61636B0953746F7056616C7565
          0708636C61426C61636B0754726967676572062149734D6F7573654F7665723D
          747275653B497353656C65637465643D66616C73650E54726967676572496E76
          65727365062249734D6F7573654F7665723D66616C73653B497353656C656374
          65643D66616C73650000000F54466C6F6174416E696D6174696F6E0008447572
          6174696F6E050000000000CDCCCCFB3F0C50726F70657274794E616D6506074F
          7061636974790A537461727456616C756505000000000000000000000953746F
          7056616C7565050000000000000080FF3F0754726967676572060E4973436865
          636B65643D747275650E54726967676572496E7665727365060F497343686563
          6B65643D66616C73650000000654496D61676500095374796C654E616D650606
          6269746D61700E4D756C74695265734269746D61700E01000005416C69676E07
          0A486F727A43656E7465720C4D617267696E732E4C6566740500000000000000
          8000400B4D617267696E732E546F7005000000000000008000400D4D61726769
          6E732E526967687405000000000000008000400E4D617267696E732E426F7474
          6F6D05000000000000008000400A506F736974696F6E2E580500000000000000
          8000400A506F736974696F6E2E5905000000000000008000400A53697A652E57
          696474680500000000000000A803400B53697A652E4865696768740500000000
          000000BC04401453697A652E506C6174666F726D44656661756C740800000654
          476C79706800095374796C654E616D65060A676C7970687374796C650C4D6172
          67696E732E4C656674050000000000000080FF3F0B4D617267696E732E546F70
          05000000000000008000400D4D617267696E732E526967687405000000000000
          00C000400E4D617267696E732E426F74746F6D050000000000000080FF3F0541
          6C69676E070A486F727A43656E7465720A53697A652E57696474680500000000
          0000008003400B53697A652E4865696768740500000000000000800340145369
          7A652E506C6174666F726D44656661756C740800000005545465787400095374
          796C654E616D6506047465787405416C69676E07044C656674064C6F636B6564
          090748697454657374080C4D617267696E732E4C656674050000000000000080
          02400D4D617267696E732E526967687405000000000000008002400A506F7369
          74696F6E2E5805000000000000008404400A53697A652E576964746805000000
          00000000C804400B53697A652E4865696768740500000000000000CC04401453
          697A652E506C6174666F726D44656661756C7408165465787453657474696E67
          732E466F6E742E53697A65050000000000000080034016546578745365747469
          6E67732E466F6E74436F6C6F7207097839364646464646461654657874536574
          74696E67732E486F727A416C69676E07074C656164696E67000F54436F6C6F72
          416E696D6174696F6E00095374796C654E616D650608616E696D5F73656C0844
          75726174696F6E05000000000018B7D1F23F0C50726F70657274794E616D6506
          05436F6C6F720A537461727456616C756507097839364646464646460953746F
          7056616C756507097839364646464646460754726967676572060F497353656C
          65637465643D747275650E54726967676572496E76657273650610497353656C
          65637465643D66616C736500000F54436F6C6F72416E696D6174696F6E000953
          74796C654E616D650609616E696D5F6F766572084475726174696F6E05000000
          000018B7D1F23F0C50726F70657274794E616D650605436F6C6F720A53746172
          7456616C756507097839364646464646460953746F7056616C75650708636C61
          57686974650754726967676572062149734D6F7573654F7665723D747275653B
          497353656C65637465643D66616C73650E54726967676572496E766572736506
          2249734D6F7573654F7665723D66616C73653B497353656C65637465643D6661
          6C736500000005545465787400095374796C654E616D65060873686F72746375
          7405416C69676E07055269676874064C6F636B6564090748697454657374080C
          4D617267696E732E4C6566740500000000000000C002400D4D617267696E732E
          52696768740500000000000000C001400A506F736974696F6E2E580500000000
          000000D506400A53697A652E57696474680500000000000000C804400B53697A
          652E4865696768740500000000000000CC04401453697A652E506C6174666F72
          6D44656661756C7408165465787453657474696E67732E486F727A416C69676E
          07074C656164696E67000F54436F6C6F72416E696D6174696F6E000844757261
          74696F6E05000000000018B7D1F23F0C50726F70657274794E616D650605436F
          6C6F720A537461727456616C75650708636C61426C61636B0953746F7056616C
          75650708636C61426C61636B0754726967676572062149734D6F7573654F7665
          723D747275653B497353656C65637465643D66616C73650E5472696767657249
          6E7665727365062249734D6F7573654F7665723D66616C73653B497353656C65
          637465643D66616C736500000F54436F6C6F72416E696D6174696F6E00084475
          726174696F6E05000000000018B7D1F23F0C50726F70657274794E616D650605
          436F6C6F720A537461727456616C75650708636C61426C61636B0953746F7056
          616C75650708636C61426C61636B0754726967676572060F497353656C656374
          65643D747275650E54726967676572496E76657273650610497353656C656374
          65643D66616C736500000007544C61796F757400095374796C654E616D650607
          7375626D61726B05416C69676E070552696768740A506F736974696F6E2E5805
          000000000000808607400A53697A652E57696474680500000000000000A00340
          0B53697A652E4865696768740500000000000000CC04401453697A652E506C61
          74666F726D44656661756C7408000554506174680005416C69676E070643656E
          74657209446174612E506174680A340000000400000000000000000000000000
          000001000000000000000000803F010000000000803F0000003F030000000000
          0000000000000A46696C6C2E436F6C6F720709784646454445444544064C6F63
          6B6564090748697454657374080A53697A652E57696474680500000000000000
          E001400B53697A652E48656967687405000000000000008002401453697A652E
          506C6174666F726D44656661756C74080B5374726F6B652E4B696E6407044E6F
          6E65000F54436F6C6F72416E696D6174696F6E00084475726174696F6E050000
          00000018B7D1F23F0C50726F70657274794E616D65060A46696C6C2E436F6C6F
          720A537461727456616C75650708636C61426C61636B0953746F7056616C7565
          0708636C61426C61636B0754726967676572062149734D6F7573654F7665723D
          747275653B497353656C65637465643D66616C73650E54726967676572496E76
          65727365062249734D6F7573654F7665723D66616C73653B497353656C656374
          65643D66616C736500000F54436F6C6F72416E696D6174696F6E000844757261
          74696F6E05000000000018B7D1F23F0C50726F70657274794E616D65060A4669
          6C6C2E436F6C6F720A537461727456616C75650708636C61426C61636B095374
          6F7056616C75650708636C61426C61636B0754726967676572060F497353656C
          65637465643D747275650E54726967676572496E76657273650610497353656C
          65637465643D66616C736500000000005450463007544C61796F757400095374
          796C654E616D6506146D656E756974656D7374796C655F627574746F6E05416C
          69676E070643656E7465720A53697A652E576964746805000000000000809007
          400B53697A652E4865696768740500000000000000CC04401453697A652E506C
          6174666F726D44656661756C74080756697369626C6508085461624F72646572
          020B000A5452656374616E676C6500095374796C654E616D65060A6261636B67
          726F756E6405416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F72
          0709784646343434353530074869745465737408074F70616369747905000000
          000000000000000A53697A652E576964746805000000000000809007400B5369
          7A652E4865696768740500000000000000CC04401453697A652E506C6174666F
          726D44656661756C74080B5374726F6B652E4B696E6407044E6F6E6507585261
          6469757305000000000000008001400759526164697573050000000000000080
          0140000F54466C6F6174416E696D6174696F6E00084475726174696F6E050000
          00000018B7D1F23F0C50726F70657274794E616D6506074F7061636974790A53
          7461727456616C756505000000000000000000000953746F7056616C75650500
          00000000000080FF3F0754726967676572061049734D6F7573654F7665723D74
          7275650E54726967676572496E7665727365061149734D6F7573654F7665723D
          66616C736500000007544C61796F757400095374796C654E616D650605676C79
          706805416C69676E07044C6566740A53697A652E576964746805000000000000
          00C803400B53697A652E4865696768740500000000000000CC04401453697A65
          2E506C6174666F726D44656661756C74080007544C61796F757400095374796C
          654E616D650609636865636B6D61726B05416C69676E0708436F6E74656E7473
          074F7061636974790500000000006F1283F53F0A53697A652E57696474680500
          000000000000C803400B53697A652E4865696768740500000000000000CC0440
          1453697A652E506C6174666F726D44656661756C740800055450617468000953
          74796C654E616D65060E636865636B6D61726B7374796C6505416C69676E0706
          43656E74657209446174612E506174680A58000000070000000000000056D952
          4391AE2C43010000009276664365021643010000009F3983432B7C3C43010000
          009E9AA64382D2B442010000006F1CB04375A4D1420100000026DF8243263F67
          430300000056D9524391AE2C430A46696C6C2E436F6C6F720708636C61426C61
          636B0748697454657374080A53697A652E57696474680500000000000000B002
          400B53697A652E4865696768740500000000000000B002401453697A652E506C
          6174666F726D44656661756C74080B5374726F6B652E4B696E6407044E6F6E65
          000F54436F6C6F72416E696D6174696F6E00084475726174696F6E0500000000
          0018B7D1F23F0C50726F70657274794E616D65060A46696C6C2E436F6C6F720A
          537461727456616C75650708636C61426C61636B0953746F7056616C75650708
          636C61426C61636B0754726967676572060F497353656C65637465643D747275
          650E54726967676572496E76657273650610497353656C65637465643D66616C
          736500000F54436F6C6F72416E696D6174696F6E00084475726174696F6E0500
          0000000018B7D1F23F0C50726F70657274794E616D65060A46696C6C2E436F6C
          6F720A537461727456616C75650708636C61426C61636B0953746F7056616C75
          650708636C61426C61636B0754726967676572062149734D6F7573654F766572
          3D747275653B497353656C65637465643D66616C73650E54726967676572496E
          7665727365062249734D6F7573654F7665723D66616C73653B497353656C6563
          7465643D66616C73650000000F54466C6F6174416E696D6174696F6E00084475
          726174696F6E050000000000CDCCCCFB3F0C50726F70657274794E616D650607
          4F7061636974790A537461727456616C75650500000000000000000000095374
          6F7056616C7565050000000000000080FF3F0754726967676572060E49734368
          65636B65643D747275650E54726967676572496E7665727365060F4973436865
          636B65643D66616C73650000000654496D61676500095374796C654E616D6506
          066269746D61700E4D756C74695265734269746D61700E01000005416C69676E
          070A486F727A43656E7465720C4D617267696E732E4C65667405000000000000
          008000400B4D617267696E732E546F7005000000000000008000400D4D617267
          696E732E526967687405000000000000008000400E4D617267696E732E426F74
          746F6D05000000000000008000400A506F736974696F6E2E5805000000000000
          008000400A506F736974696F6E2E5905000000000000008000400A53697A652E
          57696474680500000000000000A803400B53697A652E48656967687405000000
          00000000BC04401453697A652E506C6174666F726D44656661756C7408000006
          54476C79706800095374796C654E616D65060A676C7970687374796C650C4D61
          7267696E732E4C656674050000000000000080FF3F0B4D617267696E732E546F
          7005000000000000008000400D4D617267696E732E5269676874050000000000
          0000C000400E4D617267696E732E426F74746F6D050000000000000080FF3F05
          416C69676E070A486F727A43656E7465720A53697A652E576964746805000000
          000000008003400B53697A652E48656967687405000000000000008003401453
          697A652E506C6174666F726D44656661756C74080000001654427574746F6E53
          74796C65546578744F626A65637400095374796C654E616D6506047465787405
          416C69676E0706436C69656E74064C6F636B6564090C4D617267696E732E4C65
          6674050000000000000080FF3F0B4D617267696E732E546F7005000000000000
          008000400D4D617267696E732E5269676874050000000000000080FF3F0E4D61
          7267696E732E426F74746F6D05000000000000008000400A53697A652E576964
          746805000000000000008307400B53697A652E48656967687405000000000000
          00BC04401453697A652E506C6174666F726D44656661756C7408185465787453
          657474696E67732E466F6E742E46616D696C790606526F626F746F1654657874
          53657474696E67732E466F6E742E53697A650500000000000000800340165465
          787453657474696E67732E466F6E74436F6C6F72070978393646464646464616
          5465787453657474696E67732E486F727A416C69676E07074C656164696E670D
          536861646F7756697369626C650808486F74436F6C6F720708636C6157686974
          650C466F6375736564436F6C6F7207097839364646464646460B4E6F726D616C
          436F6C6F7207097839364646464646460C50726573736564436F6C6F72070863
          6C6157686974650000005450463007544C61796F757400095374796C654E616D
          65060D6D656E75766965777374796C6505416C69676E070643656E7465720A53
          697A652E57696474680500000000000000E406400B53697A652E486569676874
          0500000000000000A907401453697A652E506C6174666F726D44656661756C74
          080756697369626C6508085461624F72646572020C0007544C61796F75740009
          5374796C654E616D650607636F6E74656E7405416C69676E0706436C69656E74
          0C4D617267696E732E4C65667405000000000000008000400B4D617267696E73
          2E546F7005000000000000008000400D4D617267696E732E5269676874050000
          00000000008000400E4D617267696E732E426F74746F6D050000000000000080
          00400A53697A652E57696474680500000000000000E006400B53697A652E4865
          696768740500000000000000A707401453697A652E506C6174666F726D446566
          61756C740800000A5452656374616E676C6500095374796C654E616D65060262
          6705416C69676E0706436C69656E740A46696C6C2E436F6C6F72070978464633
          34333534310A53697A652E57696474680500000000000000E406400B53697A65
          2E4865696768740500000000000000A907401453697A652E506C6174666F726D
          44656661756C74080C5374726F6B652E436F6C6F720709784646344234343534
          07585261646975730500000000000000A0014007595261646975730500000000
          000000A00140000D54536861646F77456666656374000844697374616E636505
          00000000006F1283F53F09446972656374696F6E0500000000000000B4044008
          536F66746E657373050000000000CECCCCFC3F074F7061636974790500000000
          00CDCCCCFD3F0B536861646F77436F6C6F720708636C61426C61636B00000000
          5450463007544C61796F757400095374796C654E616D6506126D656E75736570
          617261746F727374796C6505416C69676E070643656E7465720A53697A652E57
          696474680500000000000000C805400B53697A652E4865696768740500000000
          0000008002401453697A652E506C6174666F726D44656661756C740807566973
          69626C6508085461624F72646572025A00005450463007544C61796F75740009
          5374796C654E616D6506176C65667473656C656374696F6E706F696E74737479
          6C6505416C69676E070643656E7465720A53697A652E57696474680500000000
          000000C003400B53697A652E4865696768740500000000000000C00440145369
          7A652E506C6174666F726D44656661756C74080756697369626C650808546162
          4F72646572025F0A4669786564576964746802180B4669786564486569676874
          0230000A5452656374616E676C6500095374796C654E616D65060A6261636B67
          726F756E6405416C69676E0706426F74746F6D07436F726E6572730B07546F70
          4C6566740A426F74746F6D4C6566740B426F74746F6D5269676874000A46696C
          6C2E436F6C6F7207097846464143414342450748697454657374080C4D617267
          696E732E4C6566740500000000000000B003C00D4D617267696E732E52696768
          740500000000000000D003400A506F736974696F6E2E580500000000000000B0
          03C00A506F736974696F6E2E590500000000000000E003400A53697A652E5769
          6474680500000000000000A003400B53697A652E486569676874050000000000
          0000A003401453697A652E506C6174666F726D44656661756C74080C5374726F
          6B652E436F6C6F72070978464636383638364207585261646975730500000000
          000000A0024007595261646975730500000000000000A0024000000054504630
          07544C61796F757400095374796C654E616D650618726967687473656C656374
          696F6E706F696E747374796C6505416C69676E070643656E7465720A53697A65
          2E57696474680500000000000000C003400B53697A652E486569676874050000
          0000000000C003401453697A652E506C6174666F726D44656661756C74080756
          697369626C6508085461624F7264657202640A4669786564576964746802180B
          46697865644865696768740218000A5452656374616E676C6500095374796C65
          4E616D65060A6261636B67726F756E6405416C69676E0706436C69656E740743
          6F726E6572730B08546F7052696768740A426F74746F6D4C6566740B426F7474
          6F6D5269676874000A46696C6C2E436F6C6F7207097846464143414342450748
          697454657374080C4D617267696E732E4C65667405000000000000008000400B
          4D617267696E732E546F7005000000000000008000C00D4D617267696E732E52
          6967687405000000000000008000400E4D617267696E732E426F74746F6D0500
          000000000000C001400A53697A652E57696474680500000000000000A003400B
          53697A652E4865696768740500000000000000A003401453697A652E506C6174
          666F726D44656661756C74080C5374726F6B652E436F6C6F7207097846463638
          3638364207585261646975730500000000000000A00240075952616469757305
          00000000000000A002400000005450463007544C61796F757400095374796C65
          4E616D650611627574746F6E5F7363726F6C6C646F776E05416C69676E070643
          656E7465720A53697A652E57696474680500000000000000F003400B53697A65
          2E4865696768740500000000000000F003401453697A652E506C6174666F726D
          44656661756C74080756697369626C6508085461624F72646572026900075443
          6972636C6500095374796C654E616D650602626705416C69676E0706436C6965
          6E740A46696C6C2E436F6C6F7207097833324646464646460748697454657374
          080A53697A652E57696474680500000000000000F003400B53697A652E486569
          6768740500000000000000F003401453697A652E506C6174666F726D44656661
          756C74080C5374726F6B652E436F6C6F72070978314546464646464600055450
          61746800095374796C654E616D65060A50617468315374796C6505416C69676E
          070643656E74657209446174612E506174680AD801000027000000000000001E
          6ACF42E790C94502000000F631D042C58DC94502000000F631D042B488C94502
          0000001E6ACF429485C9450200000045A2CE427382C94502000000BC5ECD4273
          82C945020000006697CC429485C9450100000038B7BF4225B9C9450200000037
          16BF42AABBC9450200000026FFBD42E1B9C9450200000026FFBD4251B6C94501
          00000026FFBD42DF3FC9450200000026FFBD42733BC94502000000421EBD4200
          38C945020000001F04BC420038C945010000001402BC420038C94502000000F1
          E7BA420038C94502000000EB00BA42733BC94502000000EB00BA42DF3FC94501
          000000EB00BA4251B6C94502000000EB00BA42E1B9C9450200000084F1B842AA
          BBC945020000008350B84225B9C945010000009F66AB425585C9450200000049
          9FAA423382C94502000000C65CA9423382C94502000000ED94A8425585C94501
          0000007095A8425585C945020000001ACEA7427488C945020000001ACEA74286
          8DC94502000000F395A842A790C94501000000FB34B9424FD3C94501000000FB
          34B9424FD3C945020000002AC4BA4290D9C94502000000BF4BBD4290D9C94502
          000000EDDABE424FD3C94502000000ED36BF42DCD1C94502000000A1C6CF4274
          8FC945020000001E6ACF42E790C9450A46696C6C2E436F6C6F72070978414146
          46464646460748697454657374080A53697A652E576964746805000000000000
          008003400B53697A652E48656967687405000000000000008003401453697A65
          2E506C6174666F726D44656661756C74080B5374726F6B652E4B696E6407044E
          6F6E6508577261704D6F6465070346697400000F54436F6C6F72416E696D6174
          696F6E00095374796C654E616D650614436F6C6F72416E696D6174696F6E3153
          74796C65084475726174696F6E050000000000CDCCCCFC3F0C50726F70657274
          794E616D65060A46696C6C2E436F6C6F720A537461727456616C756507097833
          324646464646460953746F7056616C7565070978353046464646464607547269
          67676572061049734D6F7573654F7665723D747275650E54726967676572496E
          7665727365061149734D6F7573654F7665723D66616C73650000000054504630
          0D545377697463684F626A65637400095374796C654E616D65060B7377697463
          687374796C6505416C69676E070643656E7465720A53697A652E576964746805
          000000000000409408400B53697A652E48656967687405000000000000808207
          401453697A652E506C6174666F726D44656661756C7408085461624F72646572
          024F12547261636B696E675468756D625363616C65050000000000000080FF3F
          0756697369626C65080A46696C6C2E436F6C6F7207097846463133313331330B
          5374726F6B652E4B696E6407044E6F6E650B5468756D622E436F6C6F72070978
          46463734373437340D5468756D624F6E2E436F6C6F7207097846464143414342
          450C5468756D624F6E2E4B696E640705536F6C6964115468756D625374726F6B
          652E436F6C6F72070978464637413741374105536861706507044F76616C0000
          5450463007544C61796F757400095374796C654E616D65061A627574746F6E73
          74796C655F636C6561726D696E695F6C65667405416C69676E070643656E7465
          720A53697A652E576964746805000000000000008004400B53697A652E486569
          67687405000000000000008004401453697A652E506C6174666F726D44656661
          756C74080756697369626C6508085461624F726465720206000A545265637461
          6E676C6500095374796C654E616D65060F52656374616E676C65315374796C65
          05416C69676E0708436F6E74656E747307436F726E6572730B07546F704C6566
          740A426F74746F6D4C656674000A46696C6C2E436F6C6F720709784646323032
          3132330748697454657374080A53697A652E5769647468050000000000000080
          04400B53697A652E48656967687405000000000000008004401453697A652E50
          6C6174666F726D44656661756C74080B5374726F6B652E4B696E6407044E6F6E
          6507585261646975730500000000000000C00140075952616469757305000000
          00000000C00140000F54436F6C6F72416E696D6174696F6E00095374796C654E
          616D650614436F6C6F72416E696D6174696F6E315374796C6508447572617469
          6F6E0500000000006F1283F53F0C50726F70657274794E616D65060A46696C6C
          2E436F6C6F720A537461727456616C756507097846463230323132330953746F
          7056616C756507097846463532353435380754726967676572061049734D6F75
          73654F7665723D747275650E54726967676572496E7665727365061149734D6F
          7573654F7665723D66616C73650000000654476C79706800095374796C654E61
          6D65060A676C7970687374796C650B4D617267696E732E546F70050000000000
          00008000400D4D617267696E732E526967687405000000000000008000400E4D
          617267696E732E426F74746F6D050000000000000080004005416C69676E0706
          43656E7465720A53697A652E57696474680500000000000000C003400B53697A
          652E4865696768740500000000000000C003401453697A652E506C6174666F72
          6D44656661756C74080A496D616765496E6465780202000E5446696C6C524742
          45666665637400095374796C654E616D65061346696C6C524742456666656374
          315374796C6505436F6C6F720709784646443944394533000000005450463007
          544C61796F757400095374796C654E616D65061B627574746F6E7374796C655F
          636C6561726D696E695F726967687405416C69676E070643656E7465720A5369
          7A652E576964746805000000000000008004400B53697A652E48656967687405
          000000000000008004401453697A652E506C6174666F726D44656661756C7408
          0756697369626C6508085461624F726465720205000654476C79706800095374
          796C654E616D65060A676C7970687374796C650B4D617267696E732E546F7005
          000000000000008000400D4D617267696E732E52696768740500000000000000
          8000400E4D617267696E732E426F74746F6D050000000000000080004005416C
          69676E070643656E7465720A53697A652E57696474680500000000000000C003
          400B53697A652E4865696768740500000000000000C003401453697A652E506C
          6174666F726D44656661756C74080A496D616765496E6465780202000E544669
          6C6C52474245666665637400095374796C654E616D65061346696C6C52474245
          6666656374315374796C6505436F6C6F7207097846464439443945330000000A
          5452656374616E676C6500095374796C654E616D65060F52656374616E676C65
          315374796C6505416C69676E0708436F6E74656E747307436F726E6572730B08
          546F7052696768740B426F74746F6D5269676874000A46696C6C2E436F6C6F72
          07097846463230323132330748697454657374080A53697A652E576964746805
          000000000000008004400B53697A652E48656967687405000000000000008004
          401453697A652E506C6174666F726D44656661756C74080B5374726F6B652E4B
          696E6407044E6F6E6507585261646975730500000000000000C0014007595261
          646975730500000000000000C00140000F54436F6C6F72416E696D6174696F6E
          00095374796C654E616D650614436F6C6F72416E696D6174696F6E315374796C
          65084475726174696F6E0500000000006F1283F53F0C50726F70657274794E61
          6D65060A46696C6C2E436F6C6F720A537461727456616C756507097846463230
          323132330953746F7056616C7565070978464635323534353807547269676765
          72061049734D6F7573654F7665723D747275650E54726967676572496E766572
          7365061149734D6F7573654F7665723D66616C7365000000005450463007544C
          61796F757400095374796C654E616D65060F6D656D6F7374796C655F636C6561
          7205416C69676E070643656E7465720A53697A652E5769647468050000000000
          0000F406400B53697A652E48656967687405000000000000009908401453697A
          652E506C6174666F726D44656661756C7408085461624F726465720226000C54
          42727573684F626A65637400095374796C654E616D65060A666F726567726F75
          6E640B42727573682E436F6C6F720708636C61426C61636B00000C5442727573
          684F626A65637400095374796C654E616D65060973656C656374696F6E0B4272
          7573682E436F6C6F72070978464635423542354200000B54466F6E744F626A65
          637400095374796C654E616D650604666F6E74000007544C61796F7574000953
          74796C654E616D650607636F6E74656E7405416C69676E0706436C69656E740C
          4D617267696E732E4C6566740500000000000000B404400A53697A652E576964
          74680500000000000000BF06400B53697A652E48656967687405000000000000
          009708401453697A652E506C6174666F726D44656661756C7408085461624F72
          646572020000000A545363726F6C6C42617200095374796C654E616D65060A76
          7363726F6C6C62617205416C69676E0705526967687406437572736F72070763
          724172726F770B536D616C6C4368616E676505000000000000000000000B4F72
          69656E746174696F6E0708566572746963616C0A506F736974696F6E2E580500
          000000000000EC06400A53697A652E576964746805000000000000008002400B
          53697A652E48656967687405000000000000009708401453697A652E506C6174
          666F726D44656661756C7408085461624F72646572020100000A545363726F6C
          6C42617200095374796C654E616D65060A687363726F6C6C62617205416C6967
          6E0706426F74746F6D06437572736F72070763724172726F770B536D616C6C43
          68616E676505000000000000000000000B4F7269656E746174696F6E070A486F
          72697A6F6E74616C0A506F736974696F6E2E5905000000000000009708400A53
          697A652E57696474680500000000000000F406400B53697A652E486569676874
          05000000000000008002401453697A652E506C6174666F726D44656661756C74
          08085461624F726465720202000007544C61796F75740005416C69676E070643
          6C69656E740A53697A652E57696474680500000000000000EC06400B53697A65
          2E48656967687405000000000000009708401453697A652E506C6174666F726D
          44656661756C7408085461624F726465720203000F54536D616C6C5363726F6C
          6C42617200095374796C654E616D65060F76736D616C6C7363726F6C6C626172
          05416C69676E0705526967687406437572736F72070763724172726F770B536D
          616C6C4368616E676505000000000000000000000B4F7269656E746174696F6E
          0708566572746963616C0C4D617267696E732E4C656674050000000000000080
          00400A53697A652E576964746805000000000000008002400B53697A652E4865
          6967687405000000000000008002401453697A652E506C6174666F726D446566
          61756C74080756697369626C650800000F54536D616C6C5363726F6C6C426172
          00095374796C654E616D65060F68736D616C6C7363726F6C6C62617205416C69
          676E0706426F74746F6D06437572736F72070763724172726F770B536D616C6C
          4368616E676505000000000000000000000B4F7269656E746174696F6E070A48
          6F72697A6F6E74616C0B4D617267696E732E546F700500000000000000800040
          0A53697A652E576964746805000000000000009606400B53697A652E48656967
          687405000000000000008002401453697A652E506C6174666F726D4465666175
          6C74080756697369626C65080000000F5453656C656374696F6E506F696E7400
          095374796C654E616D6506136C65667473656C656374696F6E706F696E743108
          4772697053697A650500000000000000C000400C4772697043656E7465722E58
          0500000000000000E002400C4772697043656E7465722E590500000000000000
          B003C00A506F736974696F6E2E580500000000000000DC05400A506F73697469
          6F6E2E5905000000000000009307400A53697A652E5769647468050000000000
          0000C003400B53697A652E4865696768740500000000000000C004401453697A
          652E506C6174666F726D44656661756C74080B5374796C654C6F6F6B75700617
          6C65667473656C656374696F6E706F696E747374796C6519546F756368546172
          676574457870616E73696F6E2E4C6566740500000000000000E003401A546F75
          6368546172676574457870616E73696F6E2E52696768740500000000000000E0
          03C00756697369626C650800000F5453656C656374696F6E506F696E74000953
          74796C654E616D650614726967687473656C656374696F6E706F696E74310847
          72697053697A650500000000000000C000400C4772697043656E7465722E5905
          00000000000000B004C00A506F736974696F6E2E580500000000000000DC0540
          0A506F736974696F6E2E5905000000000000009307400A53697A652E57696474
          680500000000000000C003400B53697A652E4865696768740500000000000000
          C003401453697A652E506C6174666F726D44656661756C74080B5374796C654C
          6F6F6B75700618726967687473656C656374696F6E706F696E747374796C6507
          56697369626C65080000005450463007544C61796F757400095374796C654E61
          6D650610627574746F6E7374796C655F69636F6E05416C69676E070643656E74
          65720C50616464696E672E4C65667405000000000000008001400B5061646469
          6E672E546F7005000000000000008001400D50616464696E672E526967687405
          000000000000008001400E50616464696E672E426F74746F6D05000000000000
          008001400A53697A652E57696474680500000000000000B804400B53697A652E
          4865696768740500000000000000B804401453697A652E506C6174666F726D44
          656661756C74080756697369626C6508085461624F726465720201000A545265
          6374616E676C6500095374796C654E616D65060F52656374616E676C65315374
          796C6505416C69676E0708436F6E74656E74730A46696C6C2E436F6C6F720709
          7830303241324233320748697454657374080A53697A652E5769647468050000
          0000000000B804400B53697A652E4865696768740500000000000000B8044014
          53697A652E506C6174666F726D44656661756C74080B5374726F6B652E4B696E
          6407044E6F6E6507585261646975730500000000000000C00140075952616469
          75730500000000000000C00140000F54436F6C6F72416E696D6174696F6E0009
          5374796C654E616D6506046F766572084475726174696F6E0500000000006F12
          83F53F0C50726F70657274794E616D65060A46696C6C2E436F6C6F720A537461
          727456616C756507097830303241324233320953746F7056616C756507097846
          463241324233320754726967676572061049734D6F7573654F7665723D747275
          650E54726967676572496E7665727365061149734D6F7573654F7665723D6661
          6C73650000000654476C79706800095374796C654E616D65060A676C79706873
          74796C6505416C69676E070643656E7465720A53697A652E5769647468050000
          0000000000A003400B53697A652E4865696768740500000000000000A0034014
          53697A652E506C6174666F726D44656661756C74080A496D616765496E646578
          020E06496D616765730719466F726D4D61696E2E53564749636F6E496D616765
          4C697374000E5446696C6C52474245666665637400095374796C654E616D6506
          1346696C6C524742456666656374315374796C6505436F6C6F72070978464644
          394439453300000000}
      end>
    Left = 160
    Top = 178
  end
end
